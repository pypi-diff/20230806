# Comparing `tmp/fluxwallet-0.0.6.tar.gz` & `tmp/fluxwallet-0.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "fluxwallet-0.0.6.tar", max compression
+gzip compressed data, was "fluxwallet-0.1.0.tar", max compression
```

## Comparing `fluxwallet-0.0.6.tar` & `fluxwallet-0.1.0.tar`

### file list

```diff
@@ -1,68 +1,77 @@
--rw-r--r--   0        0        0    35141 2023-02-23 22:29:07.369080 fluxwallet-0.0.6/LICENSE
--rw-r--r--   0        0        0     1142 2023-02-23 22:29:07.338794 fluxwallet-0.0.6/fluxwallet/__init__.py
--rw-r--r--   0        0        0    28570 2023-02-23 22:29:07.344328 fluxwallet-0.0.6/fluxwallet/blocks.py
--rw-r--r--   0        0        0        5 2023-02-23 22:29:07.337076 fluxwallet-0.0.6/fluxwallet/config/VERSION
--rw-r--r--   0        0        0      976 2023-02-23 22:29:07.335521 fluxwallet-0.0.6/fluxwallet/config/__init__.py
--rw-r--r--   0        0        0    12954 2023-02-23 22:29:07.335002 fluxwallet-0.0.6/fluxwallet/config/config.py
--rw-r--r--   0        0        0     2773 2023-02-23 22:29:07.335272 fluxwallet-0.0.6/fluxwallet/config/opcodes.py
--rw-r--r--   0        0        0     1501 2023-02-23 22:29:07.337318 fluxwallet-0.0.6/fluxwallet/config/secp256k1.py
--rw-r--r--   0        0        0     2267 2023-02-23 22:29:07.347801 fluxwallet-0.0.6/fluxwallet/data/config.ini
--rw-r--r--   0        0        0     1821 2023-02-23 22:29:07.345332 fluxwallet-0.0.6/fluxwallet/data/config.ini.unittest
--rw-r--r--   0        0        0    18913 2023-02-23 22:29:07.346897 fluxwallet-0.0.6/fluxwallet/data/networks.json
--rw-r--r--   0        0        0    11174 2023-02-23 22:29:07.348271 fluxwallet-0.0.6/fluxwallet/data/providers.examples.json
--rw-r--r--   0        0        0    11938 2023-02-23 22:29:07.346345 fluxwallet-0.0.6/fluxwallet/data/providers.json
--rw-r--r--   0        0        0    12858 2023-02-23 22:29:07.347348 fluxwallet-0.0.6/fluxwallet/data/providers.old.json
--rw-r--r--   0        0        0    24436 2023-02-23 22:29:07.328134 fluxwallet-0.0.6/fluxwallet/db.py
--rw-r--r--   0        0        0     9685 2023-02-23 22:29:07.334155 fluxwallet-0.0.6/fluxwallet/db_cache.py
--rw-r--r--   0        0        0    34282 2023-02-23 22:29:07.334429 fluxwallet-0.0.6/fluxwallet/encoding.py
--rw-r--r--   0        0        0    12169 2023-02-23 22:29:07.338537 fluxwallet-0.0.6/fluxwallet/flux_transaction.py
--rw-r--r--   0        0        0   102154 2023-02-23 22:29:07.339059 fluxwallet-0.0.6/fluxwallet/keys.py
--rw-r--r--   0        0        0     4529 2023-02-23 22:29:07.344595 fluxwallet-0.0.6/fluxwallet/main.py
--rw-r--r--   0        0        0     9601 2023-02-23 22:29:07.343662 fluxwallet-0.0.6/fluxwallet/mnemonic.py
--rw-r--r--   0        0        0    13274 2023-02-23 22:29:07.343398 fluxwallet-0.0.6/fluxwallet/networks.py
--rw-r--r--   0        0        0      657 2023-02-23 22:29:07.338292 fluxwallet-0.0.6/fluxwallet/pyproject.toml
--rw-r--r--   0        0        0    42380 2023-02-23 22:29:07.344038 fluxwallet-0.0.6/fluxwallet/scripts.py
--rw-r--r--   0        0        0     1688 2023-02-23 22:29:07.352259 fluxwallet-0.0.6/fluxwallet/services/__init__.py
--rw-r--r--   0        0        0     7465 2023-02-23 22:29:07.363317 fluxwallet-0.0.6/fluxwallet/services/authproxy.py
--rw-r--r--   0        0        0     5312 2023-02-23 22:29:07.363607 fluxwallet-0.0.6/fluxwallet/services/baseclient.py
--rw-r--r--   0        0        0     8861 2023-02-23 22:29:07.361540 fluxwallet-0.0.6/fluxwallet/services/bcoin.py
--rw-r--r--   0        0        0     9742 2023-02-23 22:29:07.350347 fluxwallet-0.0.6/fluxwallet/services/bitaps.py
--rw-r--r--   0        0        0    13905 2023-02-23 22:29:07.351201 fluxwallet-0.0.6/fluxwallet/services/bitcoind.py
--rw-r--r--   0        0        0     4290 2023-02-23 22:29:07.349018 fluxwallet-0.0.6/fluxwallet/services/bitcoinlibtest.py
--rw-r--r--   0        0        0     3836 2023-02-23 22:29:07.362769 fluxwallet-0.0.6/fluxwallet/services/bitflyer.py
--rw-r--r--   0        0        0     8359 2023-02-23 22:29:07.351962 fluxwallet-0.0.6/fluxwallet/services/bitgo.py
--rw-r--r--   0        0        0     7856 2023-02-23 22:29:07.349699 fluxwallet-0.0.6/fluxwallet/services/blockchaininfo.py
--rw-r--r--   0        0        0    10674 2023-02-23 22:29:07.362173 fluxwallet-0.0.6/fluxwallet/services/blockchair.py
--rw-r--r--   0        0        0     9297 2023-02-23 22:29:07.361249 fluxwallet-0.0.6/fluxwallet/services/blockcypher.py
--rw-r--r--   0        0        0     9205 2023-02-23 22:29:07.362516 fluxwallet-0.0.6/fluxwallet/services/blocksmurfer.py
--rw-r--r--   0        0        0    10353 2023-02-23 22:29:07.364406 fluxwallet-0.0.6/fluxwallet/services/blockstream.py
--rw-r--r--   0        0        0     7721 2023-02-23 22:29:07.363992 fluxwallet-0.0.6/fluxwallet/services/chainso.py
--rw-r--r--   0        0        0     6389 2023-02-23 22:29:07.364802 fluxwallet-0.0.6/fluxwallet/services/cryptoid.py
--rw-r--r--   0        0        0    10730 2023-02-23 22:29:07.351554 fluxwallet-0.0.6/fluxwallet/services/dashd.py
--rw-r--r--   0        0        0     9573 2023-02-23 22:29:07.352563 fluxwallet-0.0.6/fluxwallet/services/dogecoind.py
--rw-r--r--   0        0        0     7897 2023-02-23 22:29:07.361870 fluxwallet-0.0.6/fluxwallet/services/insightdash.py
--rw-r--r--   0        0        0     8171 2023-02-23 22:29:07.360972 fluxwallet-0.0.6/fluxwallet/services/litecoinblockexplorer.py
--rw-r--r--   0        0        0    13955 2023-02-23 22:29:07.350744 fluxwallet-0.0.6/fluxwallet/services/litecoind.py
--rw-r--r--   0        0        0     7944 2023-02-23 22:29:07.349309 fluxwallet-0.0.6/fluxwallet/services/litecoreio.py
--rw-r--r--   0        0        0     9089 2023-02-23 22:29:07.363016 fluxwallet-0.0.6/fluxwallet/services/mempool.py
--rw-r--r--   0        0        0     6627 2023-02-23 22:29:07.360721 fluxwallet-0.0.6/fluxwallet/services/runonflux.py
--rw-r--r--   0        0        0    50883 2023-02-23 22:29:07.350031 fluxwallet-0.0.6/fluxwallet/services/services.py
--rw-r--r--   0        0        0      860 2023-02-23 22:29:07.332236 fluxwallet-0.0.6/fluxwallet/tools/__init__.py
--rw-r--r--   0        0        0    19762 2023-02-23 22:29:07.331982 fluxwallet-0.0.6/fluxwallet/tools/clw.py
--rw-r--r--   0        0        0      912 2023-02-23 22:29:07.331711 fluxwallet-0.0.6/fluxwallet/tools/mnemonic_key_create.py
--rw-r--r--   0        0        0     1790 2023-02-23 22:29:07.332486 fluxwallet-0.0.6/fluxwallet/tools/sign_raw.py
--rw-r--r--   0        0        0     5346 2023-02-23 22:29:07.333618 fluxwallet-0.0.6/fluxwallet/tools/wallet_multisig_2of3.py
--rw-r--r--   0        0        0    99087 2023-02-23 22:29:07.338043 fluxwallet-0.0.6/fluxwallet/transactions.py
--rw-r--r--   0        0        0    17352 2023-02-23 22:29:07.333893 fluxwallet-0.0.6/fluxwallet/values.py
--rw-r--r--   0        0        0   202558 2023-02-23 22:29:07.337716 fluxwallet-0.0.6/fluxwallet/wallets.py
--rw-r--r--   0        0        0     8192 2023-02-23 22:29:07.329820 fluxwallet-0.0.6/fluxwallet/wordlist/chinese_simplified.txt
--rw-r--r--   0        0        0     8192 2023-02-23 22:29:07.328782 fluxwallet-0.0.6/fluxwallet/wordlist/chinese_traditional.txt
--rw-r--r--   0        0        0    16254 2023-02-23 22:29:07.331114 fluxwallet-0.0.6/fluxwallet/wordlist/dutch.txt
--rw-r--r--   0        0        0    13116 2023-02-23 22:29:07.330170 fluxwallet-0.0.6/fluxwallet/wordlist/english.txt
--rw-r--r--   0        0        0    16777 2023-02-23 22:29:07.329539 fluxwallet-0.0.6/fluxwallet/wordlist/french.txt
--rw-r--r--   0        0        0    16033 2023-02-23 22:29:07.330837 fluxwallet-0.0.6/fluxwallet/wordlist/italian.txt
--rw-r--r--   0        0        0    26423 2023-02-23 22:29:07.329237 fluxwallet-0.0.6/fluxwallet/wordlist/japanese.txt
--rw-r--r--   0        0        0    13996 2023-02-23 22:29:07.330546 fluxwallet-0.0.6/fluxwallet/wordlist/spanish.txt
--rw-r--r--   0        0        0      657 2023-02-23 22:35:02.124249 fluxwallet-0.0.6/pyproject.toml
--rw-r--r--   0        0        0     1110 1970-01-01 00:00:00.000000 fluxwallet-0.0.6/setup.py
--rw-r--r--   0        0        0      682 1970-01-01 00:00:00.000000 fluxwallet-0.0.6/PKG-INFO
+-rw-r--r--   0        0        0     1488 2023-08-06 19:16:07.377691 fluxwallet-0.1.0/LICENSE
+-rw-r--r--   0        0        0      122 2023-08-06 19:16:46.490951 fluxwallet-0.1.0/README.md
+-rw-r--r--   0        0        0     1178 2023-07-15 06:48:47.681778 fluxwallet-0.1.0/fluxwallet/__init__.py
+-rw-r--r--   0        0        0    26527 2023-08-06 19:22:11.578367 fluxwallet-0.1.0/fluxwallet/blocks.py
+-rw-r--r--   0        0        0        5 2023-02-23 22:29:07.337076 fluxwallet-0.1.0/fluxwallet/config/VERSION
+-rw-r--r--   0        0        0      976 2023-02-23 22:29:07.335521 fluxwallet-0.1.0/fluxwallet/config/__init__.py
+-rw-r--r--   0        0        0    13610 2023-07-15 06:48:47.683549 fluxwallet-0.1.0/fluxwallet/config/config.py
+-rw-r--r--   0        0        0     2773 2023-02-23 22:29:07.335272 fluxwallet-0.1.0/fluxwallet/config/opcodes.py
+-rw-r--r--   0        0        0     1501 2023-02-23 22:29:07.337318 fluxwallet-0.1.0/fluxwallet/config/secp256k1.py
+-rw-r--r--   0        0        0     2268 2023-07-15 06:48:47.684240 fluxwallet-0.1.0/fluxwallet/data/config.ini
+-rw-r--r--   0        0        0     1821 2023-02-23 22:29:07.345332 fluxwallet-0.1.0/fluxwallet/data/config.ini.unittest
+-rw-r--r--   0        0        0    18913 2023-02-23 22:29:07.346897 fluxwallet-0.1.0/fluxwallet/data/networks.json
+-rw-r--r--   0        0        0    11174 2023-02-23 22:29:07.348271 fluxwallet-0.1.0/fluxwallet/data/providers.examples.json
+-rw-r--r--   0        0        0    11938 2023-02-23 22:29:07.346345 fluxwallet-0.1.0/fluxwallet/data/providers.json
+-rw-r--r--   0        0        0    12858 2023-02-23 22:29:07.347348 fluxwallet-0.1.0/fluxwallet/data/providers.old.json
+-rw-r--r--   0        0        0    26648 2023-07-15 06:48:47.684740 fluxwallet-0.1.0/fluxwallet/db.py
+-rw-r--r--   0        0        0    11102 2023-08-06 19:22:11.458158 fluxwallet-0.1.0/fluxwallet/db_cache.py
+-rw-r--r--   0        0        0    31155 2023-08-06 19:22:11.435664 fluxwallet-0.1.0/fluxwallet/db_new.py
+-rw-r--r--   0        0        0    36470 2023-07-18 09:52:07.945700 fluxwallet-0.1.0/fluxwallet/encoding.py
+-rw-r--r--   0        0        0    12246 2023-07-15 06:48:47.687032 fluxwallet-0.1.0/fluxwallet/flux_transaction.py
+-rw-r--r--   0        0        0   104013 2023-07-15 06:48:47.688171 fluxwallet-0.1.0/fluxwallet/keys.py
+-rw-r--r--   0        0        0     4181 2023-07-15 06:48:47.688896 fluxwallet-0.1.0/fluxwallet/main.py
+-rw-r--r--   0        0        0    10073 2023-07-15 06:48:47.689606 fluxwallet-0.1.0/fluxwallet/mnemonic.py
+-rw-r--r--   0        0        0    10870 2023-07-15 06:48:47.690030 fluxwallet-0.1.0/fluxwallet/networks.py
+-rw-r--r--   0        0        0      657 2023-02-23 22:29:07.338292 fluxwallet-0.1.0/fluxwallet/pyproject.toml
+-rw-r--r--   0        0        0    42380 2023-02-23 22:29:07.344038 fluxwallet-0.1.0/fluxwallet/scripts.py
+-rw-r--r--   0        0        0     1688 2023-02-23 22:29:07.352259 fluxwallet-0.1.0/fluxwallet/services/__init__.py
+-rw-r--r--   0        0        0     7465 2023-02-23 22:29:07.363317 fluxwallet-0.1.0/fluxwallet/services/authproxy.py
+-rw-r--r--   0        0        0     5544 2023-07-15 06:48:47.690785 fluxwallet-0.1.0/fluxwallet/services/baseclient.py
+-rw-r--r--   0        0        0     8956 2023-07-15 06:48:47.691571 fluxwallet-0.1.0/fluxwallet/services/bcoin.py
+-rw-r--r--   0        0        0    10124 2023-07-15 06:48:47.692183 fluxwallet-0.1.0/fluxwallet/services/bitaps.py
+-rw-r--r--   0        0        0    14566 2023-07-15 06:48:47.692700 fluxwallet-0.1.0/fluxwallet/services/bitcoind.py
+-rw-r--r--   0        0        0     4276 2023-07-15 06:48:47.693408 fluxwallet-0.1.0/fluxwallet/services/bitcoinlibtest.py
+-rw-r--r--   0        0        0     3871 2023-07-15 06:48:47.693828 fluxwallet-0.1.0/fluxwallet/services/bitflyer.py
+-rw-r--r--   0        0        0     8548 2023-07-15 06:48:47.694517 fluxwallet-0.1.0/fluxwallet/services/bitgo.py
+-rw-r--r--   0        0        0     8305 2023-07-15 06:48:47.695190 fluxwallet-0.1.0/fluxwallet/services/blockchaininfo.py
+-rw-r--r--   0        0        0    11632 2023-07-15 06:48:47.695980 fluxwallet-0.1.0/fluxwallet/services/blockchair.py
+-rw-r--r--   0        0        0     9697 2023-07-15 06:48:47.696430 fluxwallet-0.1.0/fluxwallet/services/blockcypher.py
+-rw-r--r--   0        0        0    10014 2023-07-15 06:48:47.697175 fluxwallet-0.1.0/fluxwallet/services/blocksmurfer.py
+-rw-r--r--   0        0        0    11214 2023-07-15 06:48:47.697596 fluxwallet-0.1.0/fluxwallet/services/blockstream.py
+-rw-r--r--   0        0        0     8038 2023-07-15 06:48:47.698276 fluxwallet-0.1.0/fluxwallet/services/chainso.py
+-rw-r--r--   0        0        0     6617 2023-07-15 06:48:47.699096 fluxwallet-0.1.0/fluxwallet/services/cryptoid.py
+-rw-r--r--   0        0        0    11149 2023-07-15 06:48:47.699788 fluxwallet-0.1.0/fluxwallet/services/dashd.py
+-rw-r--r--   0        0        0     9930 2023-07-15 06:48:47.700474 fluxwallet-0.1.0/fluxwallet/services/dogecoind.py
+-rw-r--r--   0        0        0     8440 2023-07-15 06:48:47.701139 fluxwallet-0.1.0/fluxwallet/services/insightdash.py
+-rw-r--r--   0        0        0     8757 2023-07-15 06:48:47.701506 fluxwallet-0.1.0/fluxwallet/services/litecoinblockexplorer.py
+-rw-r--r--   0        0        0    14616 2023-07-15 06:48:47.701928 fluxwallet-0.1.0/fluxwallet/services/litecoind.py
+-rw-r--r--   0        0        0     8496 2023-07-15 06:48:47.702300 fluxwallet-0.1.0/fluxwallet/services/litecoreio.py
+-rw-r--r--   0        0        0     9911 2023-07-15 06:48:47.702991 fluxwallet-0.1.0/fluxwallet/services/mempool.py
+-rw-r--r--   0        0        0    15467 2023-08-06 19:22:11.777530 fluxwallet-0.1.0/fluxwallet/services/runonflux.py
+-rw-r--r--   0        0        0    63045 2023-08-06 19:22:11.726164 fluxwallet-0.1.0/fluxwallet/services/services.py
+-rw-r--r--   0        0        0      860 2023-02-23 22:29:07.332236 fluxwallet-0.1.0/fluxwallet/tools/__init__.py
+-rw-r--r--   0        0        0    21208 2023-08-06 19:22:11.600656 fluxwallet-0.1.0/fluxwallet/tools/clw.py
+-rw-r--r--   0        0        0      912 2023-02-23 22:29:07.331711 fluxwallet-0.1.0/fluxwallet/tools/mnemonic_key_create.py
+-rw-r--r--   0        0        0     1789 2023-07-15 06:48:47.705851 fluxwallet-0.1.0/fluxwallet/tools/sign_raw.py
+-rw-r--r--   0        0        0     5581 2023-08-06 19:22:11.607966 fluxwallet-0.1.0/fluxwallet/tools/wallet_multisig_2of3.py
+-rw-r--r--   0        0        0   105100 2023-08-06 19:22:11.527807 fluxwallet-0.1.0/fluxwallet/transactions.py
+-rw-r--r--   0        0        0    18023 2023-06-19 07:46:39.603630 fluxwallet-0.1.0/fluxwallet/values.py
+-rw-r--r--   0        0        0      335 2023-08-06 19:22:11.639567 fluxwallet-0.1.0/fluxwallet/wallet/__init__.py
+-rw-r--r--   0        0        0      269 2023-07-18 13:43:47.906642 fluxwallet-0.1.0/fluxwallet/wallet/errors.py
+-rw-r--r--   0        0        0    11262 2023-08-06 19:22:11.658490 fluxwallet-0.1.0/fluxwallet/wallet/helpers.py
+-rw-r--r--   0        0        0   192780 2023-08-06 19:22:11.686653 fluxwallet-0.1.0/fluxwallet/wallet/wallet.py
+-rw-r--r--   0        0        0    15470 2023-07-15 07:25:58.876062 fluxwallet-0.1.0/fluxwallet/wallet/wallet_key.py
+-rw-r--r--   0        0        0    29547 2023-08-06 19:22:11.694119 fluxwallet-0.1.0/fluxwallet/wallet/wallet_transaction.py
+-rw-r--r--   0        0        0    34652 2023-08-06 19:22:11.649043 fluxwallet-0.1.0/fluxwallet/wallet/wallet_transaction_old.py
+-rw-r--r--   0        0        0   224929 2023-07-15 06:48:47.711692 fluxwallet-0.1.0/fluxwallet/wallets.py
+-rw-r--r--   0        0        0    12026 2023-07-15 06:48:47.712013 fluxwallet-0.1.0/fluxwallet/wallets_new.py
+-rw-r--r--   0        0        0     8192 2023-02-23 22:29:07.329820 fluxwallet-0.1.0/fluxwallet/wordlist/chinese_simplified.txt
+-rw-r--r--   0        0        0     8192 2023-02-23 22:29:07.328782 fluxwallet-0.1.0/fluxwallet/wordlist/chinese_traditional.txt
+-rw-r--r--   0        0        0    16254 2023-02-23 22:29:07.331114 fluxwallet-0.1.0/fluxwallet/wordlist/dutch.txt
+-rw-r--r--   0        0        0    13116 2023-02-23 22:29:07.330170 fluxwallet-0.1.0/fluxwallet/wordlist/english.txt
+-rw-r--r--   0        0        0    16777 2023-02-23 22:29:07.329539 fluxwallet-0.1.0/fluxwallet/wordlist/french.txt
+-rw-r--r--   0        0        0    16033 2023-02-23 22:29:07.330837 fluxwallet-0.1.0/fluxwallet/wordlist/italian.txt
+-rw-r--r--   0        0        0    26423 2023-02-23 22:29:07.329237 fluxwallet-0.1.0/fluxwallet/wordlist/japanese.txt
+-rw-r--r--   0        0        0    13996 2023-02-23 22:29:07.330546 fluxwallet-0.1.0/fluxwallet/wordlist/spanish.txt
+-rw-r--r--   0        0        0      649 2023-08-06 19:23:44.445927 fluxwallet-0.1.0/pyproject.toml
+-rw-r--r--   0        0        0      909 1970-01-01 00:00:00.000000 fluxwallet-0.1.0/PKG-INFO
```

### Comparing `fluxwallet-0.0.6/fluxwallet/__init__.py` & `fluxwallet-0.1.0/fluxwallet/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,17 +13,26 @@
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #    GNU Affero General Public License for more details.
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-import fluxwallet.blocks
+# import fluxwallet.blocks
 import fluxwallet.encoding
 import fluxwallet.keys
 import fluxwallet.mnemonic
 import fluxwallet.tools
 import fluxwallet.transactions
 import fluxwallet.values
-import fluxwallet.wallets
+import fluxwallet.wallet
 
-__all__ = ["keys", "transactions", "wallets", "encoding", "mnemonic", "tools", "blocks", "values"]
+__all__ = [
+    "keys",
+    "transactions",
+    "wallets",
+    "encoding",
+    "mnemonic",
+    "tools",
+    "blocks",
+    "values",
+]
```

### Comparing `fluxwallet-0.0.6/fluxwallet/blocks.py` & `fluxwallet-0.1.0/fluxwallet/blocks.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,21 +18,32 @@
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 from io import BytesIO
 
 from fluxwallet.encoding import *
 from fluxwallet.networks import Network
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction, FluxTransaction
 
 
 class Block:
-
-    def __init__(self, block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions=None,
-                 height=None, confirmations=None, network=DEFAULT_NETWORK):
+    def __init__(
+        self,
+        block_hash,
+        version,
+        prev_block,
+        merkle_root,
+        time,
+        bits,
+        nonce,
+        transactions=None,
+        height=None,
+        confirmations=None,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create a new Block object with provided parameters.
 
         >>> b = Block('0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709', version=0x20000000, prev_block='0000000000000000000f9578cda278ae7a2002e50d8e6079d11e2ea1f672b483', merkle_root='20e86f03c24c53c12014264d0e405e014e15a02ad02c174f017ee040750f8d9d', time=1592848036, bits=387044594, nonce=791719079)
         >>> b
         <Block(0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709, None, transactions: 0)>
 
@@ -58,36 +69,38 @@
         :type confirmations: int
         :param network: Network, leave empty for default network
         :type network: str, Network
         """
 
         self.block_hash = to_bytes(block_hash)
         if isinstance(version, int):
-            self.version = version.to_bytes(4, byteorder='big')
+            self.version = version.to_bytes(4, byteorder="big")
             self.version_int = version
         else:
             self.version = to_bytes(version)
-            self.version_int = 0 if not self.version else int.from_bytes(self.version, 'big')
+            self.version_int = (
+                0 if not self.version else int.from_bytes(self.version, "big")
+            )
         self.prev_block = to_bytes(prev_block)
         self.merkle_root = to_bytes(merkle_root)
         self.time = time
         if not isinstance(time, int):
-            self.time = int.from_bytes(time, 'big')
+            self.time = int.from_bytes(time, "big")
         if isinstance(bits, int):
-            self.bits = bits.to_bytes(4, 'big')
+            self.bits = bits.to_bytes(4, "big")
             self.bits_int = bits
         else:
             self.bits = to_bytes(bits)
-            self.bits_int = 0 if not self.bits else int.from_bytes(self.bits, 'big')
+            self.bits_int = 0 if not self.bits else int.from_bytes(self.bits, "big")
         if isinstance(nonce, int):
-            self.nonce = nonce.to_bytes(4, 'big')
+            self.nonce = nonce.to_bytes(4, "big")
             self.nonce_int = nonce
         else:
             self.nonce = to_bytes(nonce)
-            self.nonce_int = 0 if not self.nonce else int.from_bytes(self.nonce, 'big')
+            self.nonce_int = 0 if not self.nonce else int.from_bytes(self.nonce, "big")
         self.transactions = transactions
         self.transactions_dict = []
         if self.transactions is None:
             self.transactions = []
         self.txs_data = None
         self.confirmations = confirmations
         self.network = network
@@ -96,22 +109,34 @@
         self.tx_count = 0
         self.page = 1
         self.limit = 0
         self.height = height
         self.total_in = 0
         self.total_out = 0
         self.size = 0
-        if self.transactions and len(self.transactions) and isinstance(self.transactions[0], Transaction) \
-                and self.version_int > 1:
+        if (
+            self.transactions
+            and len(self.transactions)
+            and isinstance(self.transactions[0], Transaction)
+            and self.version_int > 1
+        ):
             # first bytes of unlocking script of coinbase transaction contains block height (BIP0034)
-            if self.transactions[0].coinbase and self.transactions[0].inputs[0].unlocking_script:
-                calc_height = int.from_bytes(self.transactions[0].inputs[0].unlocking_script[1:4] + b'\x00', 'little')
+            if (
+                self.transactions[0].coinbase
+                and self.transactions[0].inputs[0].unlocking_script
+            ):
+                calc_height = int.from_bytes(
+                    self.transactions[0].inputs[0].unlocking_script[1:4] + b"\x00",
+                    "little",
+                )
                 if height and calc_height != height and height > 227835:
-                    raise ValueError("Specified block height %d is different than calculated block height according to "
-                                     "BIP0034" % height)
+                    raise ValueError(
+                        "Specified block height %d is different than calculated block height according to "
+                        "BIP0034" % height
+                    )
                 self.height = calc_height
 
     def check_proof_of_work(self):
         """
         Check proof of work for this block. Block hash must be below target.
 
         This library is not optimised for mining, but you can use this for testing or learning purposes.
@@ -120,23 +145,35 @@
         >>> b.check_proof_of_work()
         True
 
         :return bool:
         """
         if not self.block_hash or not self.bits:
             return False
-        if int.from_bytes(self.block_hash, 'big') < self.target:
+        if int.from_bytes(self.block_hash, "big") < self.target:
             return True
         return False
 
     def __repr__(self):
-        return "<Block(%s, %s, transactions: %s)>" % (self.block_hash.hex(), self.height, self.tx_count)
+        return "<Block(%s, %s, transactions: %s)>" % (
+            self.block_hash.hex(),
+            self.height,
+            self.tx_count,
+        )
 
     @classmethod
-    def parse(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):
+    def parse(
+        cls,
+        raw,
+        block_hash=None,
+        height=None,
+        parse_transactions=False,
+        limit=0,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`
 
         Get genesis block:
 
         >>> from fluxwallet.services.services import Service
         >>> srv = Service()
@@ -157,23 +194,34 @@
         :param network: Name of network
         :type network: str
 
         :return Block:
         """
 
         if isinstance(raw, bytes):
-            b = cls.parse_bytesio(BytesIO(raw), block_hash, height, parse_transactions, limit, network)
+            b = cls.parse_bytesio(
+                BytesIO(raw), block_hash, height, parse_transactions, limit, network
+            )
             b.size = len(raw)
             return b
         else:
-            return cls.parse_bytesio(raw, block_hash, height, parse_transactions, limit, network)
+            return cls.parse_bytesio(
+                raw, block_hash, height, parse_transactions, limit, network
+            )
 
     @classmethod
-    def parse_bytes(cls, raw_bytes, block_hash=None, height=None, parse_transactions=False, limit=0,
-                    network=DEFAULT_NETWORK):
+    def parse_bytes(
+        cls,
+        raw_bytes,
+        block_hash=None,
+        height=None,
+        parse_transactions=False,
+        limit=0,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`
 
         Get genesis block:
 
         >>> from fluxwallet.services.services import Service
         >>> srv = Service()
@@ -194,21 +242,30 @@
         :param network: Name of network
         :type network: str
 
         :return Block:
         """
 
         raw_bytesio = BytesIO(raw_bytes)
-        b = cls.parse_bytesio(raw_bytesio, block_hash, height, parse_transactions, limit, network)
+        b = cls.parse_bytesio(
+            raw_bytesio, block_hash, height, parse_transactions, limit, network
+        )
         b.size = len(raw_bytes)
         return b
 
     @classmethod
-    def parse_bytesio(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0,
-                      network=DEFAULT_NETWORK):
+    def parse_bytesio(
+        cls,
+        raw,
+        block_hash=None,
+        height=None,
+        parse_transactions=False,
+        limit=0,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create Block object from raw serialized block in BytesIO format
 
         Get genesis block:
 
         >>> from fluxwallet.services.services import Service
         >>> srv = Service()
@@ -232,16 +289,18 @@
         :return Block:
         """
         block_header = raw.read(80)
         block_hash_calc = double_sha256(block_header)[::-1]
         if not block_hash:
             block_hash = block_hash_calc
         elif block_hash != block_hash_calc:
-            raise ValueError("Provided block hash does not correspond to calculated block hash %s" %
-                             block_hash_calc.hex())
+            raise ValueError(
+                "Provided block hash does not correspond to calculated block hash %s"
+                % block_hash_calc.hex()
+            )
 
         raw.seek(0)
         version = raw.read(4)[::-1]
         prev_block = raw.read(32)[::-1]
         merkle_root = raw.read(32)[::-1]
         time = raw.read(4)[::-1]
         bits = raw.read(4)[::-1]
@@ -258,111 +317,54 @@
             t = Transaction.parse_bytesio(raw, strict=False)
             transactions.append(t)
             # TODO: verify transactions, need input value from previous txs
             # if verify and not t.verify():
             #     raise ValueError("Could not verify transaction %s in block %s" % (t.txid, block_hash))
 
         if parse_transactions and limit == 0 and tx_count != len(transactions):
-            raise ValueError("Number of found transactions %d is not equal to expected number %d" %
-                             (len(transactions), tx_count))
-
-        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,
-                    network=network)
+            raise ValueError(
+                "Number of found transactions %d is not equal to expected number %d"
+                % (len(transactions), tx_count)
+            )
+
+        block = cls(
+            block_hash,
+            version,
+            prev_block,
+            merkle_root,
+            time,
+            bits,
+            nonce,
+            transactions,
+            height,
+            network=network,
+        )
         block.txs_data = raw
         block.tx_count = tx_count
         return block
 
-    @classmethod
-    @deprecated
-    def from_raw(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):  # pragma: no cover
-        """
-        Create Block object from raw serialized block in bytes.
-
-        Get genesis block:
-
-        >>> from fluxwallet.services.services import Service
-        >>> srv = Service()
-        >>> b = srv.getblock(0)
-        >>> b.block_hash.hex()
-        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'
-
-        :param raw: Raw serialize block
-        :type raw: bytes
-        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.
-        :type block_hash: bytes
-        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.
-        :type height: int
-        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False
-        :type parse_transactions: bool
-        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True
-        :type limit: int
-        :param network: Name of network
-        :type network: str
-
-        :return Block:
-        """
-        block_hash_calc = double_sha256(raw[:80])[::-1]
-        if not block_hash:
-            block_hash = block_hash_calc
-        elif block_hash != block_hash_calc:
-            raise ValueError("Provided block hash does not correspond to calculated block hash %s" %
-                             block_hash_calc.hex())
-
-        version = raw[0:4][::-1]
-        prev_block = raw[4:36][::-1]
-        merkle_root = raw[36:68][::-1]
-        time = raw[68:72][::-1]
-        bits = raw[72:76][::-1]
-        nonce = raw[76:80][::-1]
-        tx_count, size = varbyteint_to_int(raw[80:89])
-        txs_data = BytesIO(raw[80+size:])
-
-        # Parse coinbase transaction so we can extract extra information
-        # transactions = [Transaction.parse(txs_data, network=network)]
-        # txs_data = BytesIO(txs_data[transactions[0].size:])
-        # block_txs_data = txs_data.read()
-        txs_data_size = txs_data.seek(0, 2)
-        txs_data.seek(0)
-        transactions = []
-
-        while parse_transactions and txs_data and txs_data.tell() < txs_data_size:
-            if limit != 0 and len(transactions) >= limit:
-                break
-            t = Transaction.parse_bytesio(txs_data, strict=False)
-            transactions.append(t)
-            # t = transaction_deserialize(txs_data, network=network, check_size=False)
-            # transactions.append(t)
-            # txs_data = txs_data[t.size:]
-            # TODO: verify transactions, need input value from previous txs
-            # if verify and not t.verify():
-            #     raise ValueError("Could not verify transaction %s in block %s" % (t.txid, block_hash))
-
-        if parse_transactions and limit == 0 and tx_count != len(transactions):
-            raise ValueError("Number of found transactions %d is not equal to expected number %d" %
-                             (len(transactions), tx_count))
-
-        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,
-                    network=network)
-        block.txs_data = txs_data
-        block.tx_count = tx_count
-        return block
-
     def parse_transactions(self, limit=0):
         """
         Parse raw transactions from Block, if transaction data is available in txs_data attribute. Creates
         Transaction objects in Block.
 
         :param limit: Maximum number of transactions to parse
         :type limit: int
 
         :return:
         """
         n = 0
-        while self.txs_data and (limit == 0 or n < limit) and len(self.transactions) < self.tx_count:
-            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False
+        while (
+            self.txs_data
+            and (limit == 0 or n < limit)
+            and len(self.transactions) < self.tx_count
+        ):
+            t = Transaction.parse_bytesio(
+                self.txs_data, strict=False, network=self.network
+            )  # , check_size=False
             self.transactions.append(t)
             n += 1
 
     def parse_transactions_dict(self):
         """
         Parse raw transactions from Block, if transaction data is available in txs_data attribute. Returns a list of
         transactions dictionaries.
@@ -386,154 +388,186 @@
         """
         Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add
         Transaction object in Block and return the transaction
 
         :return Tranasaction:
         """
         if self.txs_data and len(self.transactions) < self.tx_count:
-            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False
+            t = Transaction.parse_bytesio(
+                self.txs_data, strict=False, network=self.network
+            )  # , check_size=False
             self.transactions.append(t)
             return t
         return False
 
     def parse_transaction_dict(self):
         """
         Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add
         Transaction object in Block and return the transaction
 
         :return Transaction:
         """
         if self.txs_data and len(self.transactions) < self.tx_count:
-            tx = {'height': self.height, 'coinbase': False, 'flag': None, 'witness_type': 'legacy',
-                  'version': self.txs_data.read(4)[::-1]}
-            if not tx['version']:
+            tx = {
+                "height": self.height,
+                "coinbase": False,
+                "flag": None,
+                "witness_type": "legacy",
+                "version": self.txs_data.read(4)[::-1],
+            }
+            if not tx["version"]:
                 return False
-            raw_flag = b''
-            if self.txs_data.read(1) == b'\0':
+            raw_flag = b""
+            if self.txs_data.read(1) == b"\0":
                 flag = self.txs_data.read(1)
-                if flag == b'\1':
-                    tx['witness_type'] = 'segwit'
-                raw_flag += b'\0\1'
+                if flag == b"\1":
+                    tx["witness_type"] = "segwit"
+                raw_flag += b"\0\1"
             else:
                 self.txs_data.seek(-1, 1)
 
             n_inputs, raw_n_inputs = read_varbyteint_return(self.txs_data)
 
             inputs = []
-            inputs_raw = b''
+            inputs_raw = b""
             for n in range(0, n_inputs):
-                inp = {'prev_txid': self.txs_data.read(32)[::-1]}
-                if len(inp['prev_txid']) != 32:
-                    raise Exception("Input transaction hash not found. Probably malformed self.txs_data transaction")
-                inp['output_n'] = self.txs_data.read(4)[::-1]
-                unlocking_script_size, unlocking_script_size_raw = read_varbyteint_return(self.txs_data)
-                inp['unlocking_script'] = self.txs_data.read(unlocking_script_size)
-                inp['inp_type'] = 'legacy'
-                if tx['witness_type'] == 'segwit' and not unlocking_script_size:
-                    inp['inp_type'] = 'segwit'
-                inp['sequence_number'] = self.txs_data.read(4)
-                tx['coinbase'] = False
-                if inp['prev_txid'] == 32 * b'\0':
-                    tx['coinbase'] = True
+                inp = {"prev_txid": self.txs_data.read(32)[::-1]}
+                if len(inp["prev_txid"]) != 32:
+                    raise Exception(
+                        "Input transaction hash not found. Probably malformed self.txs_data transaction"
+                    )
+                inp["output_n"] = self.txs_data.read(4)[::-1]
+                (
+                    unlocking_script_size,
+                    unlocking_script_size_raw,
+                ) = read_varbyteint_return(self.txs_data)
+                inp["unlocking_script"] = self.txs_data.read(unlocking_script_size)
+                inp["inp_type"] = "legacy"
+                if tx["witness_type"] == "segwit" and not unlocking_script_size:
+                    inp["inp_type"] = "segwit"
+                inp["sequence_number"] = self.txs_data.read(4)
+                tx["coinbase"] = False
+                if inp["prev_txid"] == 32 * b"\0":
+                    tx["coinbase"] = True
                 inputs.append(inp)
-                inputs_raw += \
-                    inp['prev_txid'][::-1] + inp['output_n'][::-1] + unlocking_script_size_raw + \
-                    inp['unlocking_script'] + inp['sequence_number']
-            tx['inputs'] = inputs
+                inputs_raw += (
+                    inp["prev_txid"][::-1]
+                    + inp["output_n"][::-1]
+                    + unlocking_script_size_raw
+                    + inp["unlocking_script"]
+                    + inp["sequence_number"]
+                )
+            tx["inputs"] = inputs
 
             outputs = []
-            outputs_raw = b''
+            outputs_raw = b""
             n_outputs, raw_n_outputs = read_varbyteint_return(self.txs_data)
-            tx['output_total'] = 0
+            tx["output_total"] = 0
             for n in range(0, n_outputs):
                 outp = {}
                 outp_value = self.txs_data.read(8)
-                outp['value'] = int.from_bytes(outp_value[::-1], 'big')
-                lock_script_size, lock_script_size_raw = read_varbyteint_return(self.txs_data)
-                outp['lock_script'] = self.txs_data.read(lock_script_size)
+                outp["value"] = int.from_bytes(outp_value[::-1], "big")
+                lock_script_size, lock_script_size_raw = read_varbyteint_return(
+                    self.txs_data
+                )
+                outp["lock_script"] = self.txs_data.read(lock_script_size)
                 outputs.append(outp)
-                outp['output_n'] = n
-                tx['output_total'] += outp['value']
-                outputs_raw += outp_value + lock_script_size_raw + outp['lock_script']
+                outp["output_n"] = n
+                tx["output_total"] += outp["value"]
+                outputs_raw += outp_value + lock_script_size_raw + outp["lock_script"]
             if not outputs:
                 raise Exception("Error no outputs found in this transaction")
-            tx['outputs'] = outputs
+            tx["outputs"] = outputs
 
-            witnesses_raw = b''
-            if tx['witness_type'] == 'segwit':
+            witnesses_raw = b""
+            if tx["witness_type"] == "segwit":
                 for n in range(0, len(inputs)):
                     n_items, raw_n_items = read_varbyteint_return(self.txs_data)
                     witnesses_raw += raw_n_items
                     if not n_items:
                         continue
                     # script = Script()
-                    inputs[n]['witnesses'] = []
+                    inputs[n]["witnesses"] = []
                     for m in range(0, n_items):
                         item_size, raw_item_size = read_varbyteint_return(self.txs_data)
                         witnesses_raw += raw_item_size
                         witness = self.txs_data.read(item_size)
                         witnesses_raw += witness
-                        inputs[n]['witnesses'].append(witness)
+                        inputs[n]["witnesses"].append(witness)
 
             tx_locktime = self.txs_data.read(4)
-            tx['locktime'] = int.from_bytes(tx_locktime[::-1], 'big')
-            tx['rawtx'] = tx['version'][::-1] + raw_flag + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw + \
-                          witnesses_raw + tx_locktime
-            tx['txid'] = double_sha256(tx['version'][::-1] + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw
-                                       + tx_locktime)[::-1]
-            tx['size'] = len(tx['rawtx'])
+            tx["locktime"] = int.from_bytes(tx_locktime[::-1], "big")
+            tx["rawtx"] = (
+                tx["version"][::-1]
+                + raw_flag
+                + raw_n_inputs
+                + inputs_raw
+                + raw_n_outputs
+                + outputs_raw
+                + witnesses_raw
+                + tx_locktime
+            )
+            tx["txid"] = double_sha256(
+                tx["version"][::-1]
+                + raw_n_inputs
+                + inputs_raw
+                + raw_n_outputs
+                + outputs_raw
+                + tx_locktime
+            )[::-1]
+            tx["size"] = len(tx["rawtx"])
             # TODO: tx['vsize'] = len(tx['rawtx'])
             return tx
         return False
 
     def as_dict(self):
         """
         Get representation of current Block as dictionary.
 
         :return dict:
         """
         return {
-            'block_hash': self.block_hash.hex(),
-            'height': self.height,
-            'version': self.version_int,
-            'prev_block': None if not self.prev_block else self.prev_block.hex(),
-            'merkle_root': self.merkle_root.hex(),
-            'timestamp': self.time,
-            'bits': self.bits_int,
-            'nonce': self.nonce_int,
-            'target': self.target_hex,
-            'difficulty': self.difficulty,
-            'tx_count': self.tx_count,
-            'transactions': self.transactions,
-            'confirmations': self.confirmations
+            "block_hash": self.block_hash.hex(),
+            "height": self.height,
+            "version": self.version_int,
+            "prev_block": None if not self.prev_block else self.prev_block.hex(),
+            "merkle_root": self.merkle_root.hex(),
+            "timestamp": self.time,
+            "bits": self.bits_int,
+            "nonce": self.nonce_int,
+            "target": self.target_hex,
+            "difficulty": self.difficulty,
+            "tx_count": self.tx_count,
+            "transactions": self.transactions,
+            "confirmations": self.confirmations,
         }
 
     @property
     def target(self):
         """
         Block target calculated from block's bits. Block hash must be below this target. Used to calculate
         block difficulty.
 
         :return int:
         """
         if not self.bits:
             return 0
         exponent = self.bits[0]
-        coefficient = int.from_bytes(b'\x00' + self.bits[1:], 'big')
+        coefficient = int.from_bytes(b"\x00" + self.bits[1:], "big")
         return coefficient * 256 ** (exponent - 3)
 
     @property
     def target_hex(self):
         """
         Block target in hexadecimal string of 64 characters.
 
         :return str:
         """
         if not self.bits:
-            return ''
+            return ""
         return hex(int(self.target))[2:].zfill(64)
 
     @property
     def difficulty(self):
         """
         Block difficulty calculated from bits / target. Human readable representation of block's target.
 
@@ -545,15 +579,15 @@
         >>> b.difficulty
         1.0
 
         :return float:
         """
         if not self.bits:
             return 0
-        return 0xffff * 256 ** (0x1d - 3) / self.target
+        return 0xFFFF * 256 ** (0x1D - 3) / self.target
 
     def serialize(self):
         """
         Serialize raw block in bytes.
 
         A block consists of a 80 bytes header:
         * version - 4 bytes
@@ -566,24 +600,28 @@
         Followed by a list of raw serialized transactions.
 
         Method will raise an error if one of the header fields is missing or has an incorrect size.
 
         :return bytes:
         """
         if len(self.transactions) != self.tx_count or len(self.transactions) < 1:
-            raise ValueError("Block contains incorrect number of transactions, can not serialize")
+            raise ValueError(
+                "Block contains incorrect number of transactions, can not serialize"
+            )
         rb = self.version[::-1]
         rb += self.prev_block[::-1]
         rb += self.merkle_root[::-1]
-        rb += self.time.to_bytes(4, 'little')
+        rb += self.time.to_bytes(4, "little")
         rb += self.bits[::-1]
         rb += self.nonce[::-1]
         if len(rb) != 80:
-            raise ValueError("Missing or incorrect length of 1 of the block header variables: version, prev_block, "
-                             "merkle_root, time, bits or nonce.")
+            raise ValueError(
+                "Missing or incorrect length of 1 of the block header variables: version, prev_block, "
+                "merkle_root, time, bits or nonce."
+            )
         rb += int_to_varbyteint(len(self.transactions))
         for t in self.transactions:
             rb += t.raw()
         return rb
 
     @property
     def version_bin(self):
@@ -618,37 +656,39 @@
         >>> print(b.version_bips())
         ['BIP9', 'BIP141']
 
         :return list of str:
         """
         bips = []
         if self.version_int >> 29 == 0b001 and self.height >= 407021:
-            bips.append('BIP9')
+            bips.append("BIP9")
             if self.version_int >> 0 & 1 == 1:
-                bips.append('BIP68')   # BIP112 (CHECKSEQUENCEVERIFY), BIP113 - Relative lock-time using consensus-enforced sequence numbers
+                bips.append(
+                    "BIP68"
+                )  # BIP112 (CHECKSEQUENCEVERIFY), BIP113 - Relative lock-time using consensus-enforced sequence numbers
             if self.version_int >> 1 & 1 == 1:
-                bips.append('BIP141')  # BIP143, BIP147 (Segwit)
+                bips.append("BIP141")  # BIP143, BIP147 (Segwit)
             if self.version_int >> 4 & 1 == 1:
-                bips.append('BIP91')   # Segwit?
+                bips.append("BIP91")  # Segwit?
             if self.version_int == 0x30000000:
-                bips.append('BIP109')  # Increase block size 2MB (rejected)
-            mask = 0x1fffe000
+                bips.append("BIP109")  # Increase block size 2MB (rejected)
+            mask = 0x1FFFE000
             if self.version_int & mask and self.height >= 500000:
-                bips.append('BIP310')   # version-rolling
+                bips.append("BIP310")  # version-rolling
         elif self.height < 500000:
             if self.version_int == 2:
-                bips.append('BIP34')    # Version 2: Block Height in Coinbase
+                bips.append("BIP34")  # Version 2: Block Height in Coinbase
             if self.version_int == 3:
-                bips.append('BIP66')    # Version 3: Strict DER signatures
+                bips.append("BIP66")  # Version 3: Strict DER signatures
             if self.version_int == 4:
-                bips.append('BIP65')    # Version 4: Introduce CHECKLOCKTIMEVERIFY
+                bips.append("BIP65")  # Version 4: Introduce CHECKLOCKTIMEVERIFY
             if self.version_int == 0x30000000:
-                bips.append('BIP109')   # Increase block size 2MB (rejected)
+                bips.append("BIP109")  # Increase block size 2MB (rejected)
             if self.version_int == 0x20000007:
-                bips.append('BIP101')   # Increase block size 8MB (rejected)
+                bips.append("BIP101")  # Increase block size 8MB (rejected)
 
         return bips
 
     def update_totals(self):
         self.total_in = 0
         self.total_out = 0
         for t in self.transactions:
```

### Comparing `fluxwallet-0.0.6/fluxwallet/config/__init__.py` & `fluxwallet-0.1.0/fluxwallet/config/__init__.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/config/opcodes.py` & `fluxwallet-0.1.0/fluxwallet/config/opcodes.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/config/secp256k1.py` & `fluxwallet-0.1.0/fluxwallet/config/secp256k1.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/data/config.ini` & `fluxwallet-0.1.0/fluxwallet/data/config.ini`

 * *Files 4% similar despite different names*

```diff
@@ -37,15 +37,15 @@
 # Default network when creating wallets, transaction, keys, etc.
 ;default_network=bitcoin
 
 # Default witness_type for new wallets and keys
 ;default_witness_type=legacy
 
 # Use caching for service providers
-;service_caching_enabled=True
+;service_caching_enabled=False
 
 # Maximum number of errors before service request fails
 ;service_max_errors=3
 
 # Maximum number of transactions per service request
 ;max_transactions=20
```

### Comparing `fluxwallet-0.0.6/fluxwallet/data/config.ini.unittest` & `fluxwallet-0.1.0/fluxwallet/data/config.ini.unittest`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/data/networks.json` & `fluxwallet-0.1.0/fluxwallet/data/networks.json`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/data/providers.examples.json` & `fluxwallet-0.1.0/fluxwallet/data/providers.examples.json`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/data/providers.json` & `fluxwallet-0.1.0/fluxwallet/data/providers.json`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/data/providers.old.json` & `fluxwallet-0.1.0/fluxwallet/data/providers.old.json`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/db.py` & `fluxwallet-0.1.0/fluxwallet/db.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,23 +13,40 @@
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #    GNU Affero General Public License for more details.
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
+from __future__ import annotations
 
 from urllib.parse import urlparse
 
-from sqlalchemy import (BigInteger, Boolean, CheckConstraint, Column, DateTime,
-                        ForeignKey, Integer, LargeBinary, Sequence, String,
-                        UniqueConstraint, create_engine)
+from sqlalchemy import (
+    BigInteger,
+    Boolean,
+    CheckConstraint,
+    Column,
+    DateTime,
+    ForeignKey,
+    Integer,
+    LargeBinary,
+    Sequence,
+    String,
+    UniqueConstraint,
+    create_engine,
+)
 from sqlalchemy.ext.compiler import compiles
-from sqlalchemy.ext.declarative import declarative_base
-from sqlalchemy.orm import close_all_sessions, relationship, sessionmaker
+from sqlalchemy.orm import (
+    Mapped,
+    close_all_sessions,
+    declarative_base,
+    relationship,
+    sessionmaker,
+)
 
 from fluxwallet.main import *
 
 _logger = logging.getLogger(__name__)
 Base = declarative_base()
 
 
@@ -44,78 +61,108 @@
     """
     fluxwallet Database object used by Service() and HDWallet() class. Initialize database and open session when
     creating database object.
 
     Create new database if is doesn't exist yet
 
     """
+
+    def __enter__(self):
+        return self.session
+
+    def __exit__(self, exception_type, exception_value, exception_traceback):
+        self.session.close()
+
     def __init__(self, db_uri=None, password=None):
         if db_uri is None:
             db_uri = DEFAULT_DATABASE
         self.o = urlparse(db_uri)
-        if not self.o.scheme or \
-                len(self.o.scheme) < 2:  # Dirty hack to avoid issues with urlparse on Windows confusing drive with scheme
+        if (
+            not self.o.scheme or len(self.o.scheme) < 2
+        ):  # Dirty hack to avoid issues with urlparse on Windows confusing drive with scheme
             if password:
                 # Warning: This requires the pysqlcipher3 module
-                db_uri = 'sqlite+pysqlcipher://:%s@/%s?cipher=aes-256-cfb&kdf_iter=64000' % (password, db_uri)
+                db_uri = (
+                    "sqlite+pysqlcipher://:%s@/%s?cipher=aes-256-cfb&kdf_iter=64000"
+                    % (password, db_uri)
+                )
             else:
-                db_uri = 'sqlite:///%s' % db_uri
+                db_uri = "sqlite:///%s" % db_uri
 
         if db_uri.startswith("sqlite://") and ALLOW_DATABASE_THREADS:
             db_uri += "&" if "?" in db_uri else "?"
             db_uri += "check_same_thread=False"
-        if self.o.scheme == 'mysql':
+        if self.o.scheme == "mysql":
             db_uri += "&" if "?" in db_uri else "?"
-            db_uri += 'binary_prefix=true'
-        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')
+            db_uri += "binary_prefix=true"
+        self.engine = create_engine(db_uri, isolation_level="READ UNCOMMITTED")
 
         Session = sessionmaker(bind=self.engine)
         Base.metadata.create_all(self.engine)
         self._import_config_data(Session)
         self.session = Session()
 
-        _logger.info("Using database: %s://%s:%s/%s" % (self.o.scheme or '', self.o.hostname or '',
-                                                        self.o.port or '', self.o.path or ''))
+        _logger.info(
+            "Using database: %s://%s:%s/%s"
+            % (
+                self.o.scheme or "",
+                self.o.hostname or "",
+                self.o.port or "",
+                self.o.path or "",
+            )
+        )
         self.db_uri = db_uri
 
         # VERIFY AND UPDATE DATABASE
         # Just a very simple database update script, without any external libraries for now
         #
-        version_db = self.session.query(DbConfig.value).filter_by(variable='version').scalar()
-        if version_db[:3] == '0.4' and FLUXWALLET_VERSION[:3] >= '0.5':
-            raise ValueError("Old database version found (<0.4.19). Can not convert to >0.5 version database "
-                             "automatically, use updatedb.py tool to update")
+        version_db = (
+            self.session.query(DbConfig.value).filter_by(variable="version").scalar()
+        )
+        if version_db[:3] == "0.4" and FLUXWALLET_VERSION[:3] >= "0.5":
+            raise ValueError(
+                "Old database version found (<0.4.19). Can not convert to >0.5 version database "
+                "automatically, use updatedb.py tool to update"
+            )
         try:
             if FLUXWALLET_VERSION != version_db:
-                _logger.warning("fluxwallet database (%s) is from different version then library code (%s). "
-                                "Let's try to update database." % (version_db, FLUXWALLET_VERSION))
+                _logger.warning(
+                    "fluxwallet database (%s) is from different version then library code (%s). "
+                    "Let's try to update database." % (version_db, FLUXWALLET_VERSION)
+                )
                 db_update(self, version_db, FLUXWALLET_VERSION)
         except Exception as e:
             _logger.warning("Error when verifying version or updating database: %s" % e)
 
     def drop_db(self, yes_i_am_sure=False):
         if yes_i_am_sure:
             self.session.commit()
             self.session.close_all()
             close_all_sessions()
             Base.metadata.drop_all(self.engine)
 
     @staticmethod
     def _import_config_data(ses):
         session = ses()
-        installation_date = session.query(DbConfig.value).filter_by(variable='installation_date').scalar()
+        installation_date = (
+            session.query(DbConfig.value)
+            .filter_by(variable="installation_date")
+            .scalar()
+        )
         if not installation_date:
-            session.merge(DbConfig(variable='version', value=FLUXWALLET_VERSION))
-            session.merge(DbConfig(variable='installation_date', value=str(datetime.now())))
-            url = ''
+            session.merge(DbConfig(variable="version", value=FLUXWALLET_VERSION))
+            session.merge(
+                DbConfig(variable="installation_date", value=str(datetime.now()))
+            )
+            url = ""
             try:
                 url = str(session.bind.url)
             except Exception:
                 pass
-            session.merge(DbConfig(variable='installation_url', value=url))
+            session.merge(DbConfig(variable="installation_url", value=url))
             session.commit()
         session.close()
 
 
 def add_column(engine, table_name, column):
     """
     Used to add new column to database with migration and update scripts
@@ -123,168 +170,324 @@
     :param engine:
     :param table_name:
     :param column:
     :return:
     """
     column_name = column.compile(dialect=engine.dialect)
     column_type = column.type.compile(engine.dialect)
-    engine.execute("ALTER TABLE %s ADD COLUMN %s %s" % (table_name, column_name, column_type))
+    engine.execute(
+        "ALTER TABLE %s ADD COLUMN %s %s" % (table_name, column_name, column_type)
+    )
+
+
+class DbAddressBook(Base):
+    """
+    Fluxwallet address book mapping
+    """
+
+    __tablename__ = "address_book"
+    id = Column(
+        Integer,
+        Sequence("addressbook_id_seq"),
+        primary_key=True,
+        doc="Unique addressbook ID",
+    )
+    name = Column(String(80), unique=True, doc="Unique address nickname")
+    address = Column(
+        String(255),
+        index=True,
+        doc="Address representation of key. A cryptocurrency address is a hash of the public key",
+    )
 
 
 class DbConfig(Base):
     """
     fluxwallet configuration variables
 
     """
-    __tablename__ = 'config'
+
+    __tablename__ = "config"
     variable = Column(String(30), primary_key=True)
     value = Column(String(255))
 
 
 class DbWallet(Base):
     """
     Database definitions for wallets in Sqlalchemy format
 
     Contains one or more keys.
 
     """
-    __tablename__ = 'wallets'
-    id = Column(Integer, Sequence('wallet_id_seq'), primary_key=True, doc="Unique wallet ID")
+
+    __tablename__ = "wallets"
+    id = Column(
+        Integer, Sequence("wallet_id_seq"), primary_key=True, doc="Unique wallet ID"
+    )
     name = Column(String(80), unique=True, doc="Unique wallet name")
     owner = Column(String(50), doc="Wallet owner")
-    network_name = Column(String(20), ForeignKey('networks.name'), doc="Name of network, i.e.: bitcoin, litecoin")
-    network = relationship("DbNetwork", doc="Link to DbNetwork object")
-    purpose = Column(Integer,
-                     doc="Wallet purpose ID. BIP-44 purpose field, indicating which key-scheme is used default is 44")
+    network_name = Column(
+        String(20),
+        ForeignKey("networks.name"),
+        doc="Name of network, i.e.: bitcoin, litecoin",
+    )
+    network: Mapped[DbNetwork] = relationship(doc="Link to DbNetwork object")
+    purpose = Column(
+        Integer,
+        doc="Wallet purpose ID. BIP-44 purpose field, indicating which key-scheme is used default is 44",
+    )
     scheme = Column(String(25), doc="Key structure type, can be BIP-32 or single")
-    witness_type = Column(String(20), default='legacy',
-                          doc="Wallet witness type. Can be 'legacy', 'segwit' or 'p2sh-segwit'. Default is legacy.")
-    encoding = Column(String(15), default='base58',
-                      doc="Default encoding to use for address generation, i.e. base58 or bech32. Default is base58.")
-    main_key_id = Column(Integer,
-                         doc="Masterkey ID for this wallet. All other keys are derived from the masterkey in a "
-                             "HD wallet bip32 wallet")
-    keys = relationship("DbKey", back_populates="wallet", doc="Link to keys (DbKeys objects) in this wallet")
-    transactions = relationship("DbTransaction", back_populates="wallet",
-                                doc="Link to transaction (DbTransactions) in this wallet")
-    multisig_n_required = Column(Integer, default=1, doc="Number of required signature for multisig, "
-                                                         "only used for multisignature master key")
+    witness_type = Column(
+        String(20),
+        default="legacy",
+        doc="Wallet witness type. Can be 'legacy', 'segwit' or 'p2sh-segwit'. Default is legacy.",
+    )
+    encoding = Column(
+        String(15),
+        default="base58",
+        doc="Default encoding to use for address generation, i.e. base58 or bech32. Default is base58.",
+    )
+    main_key_id = Column(
+        Integer,
+        doc="Masterkey ID for this wallet. All other keys are derived from the masterkey in a "
+        "HD wallet bip32 wallet",
+    )
+    keys: Mapped[DbKey] = relationship(
+        back_populates="wallet",
+        doc="Link to keys (DbKeys objects) in this wallet",
+    )
+    transactions: Mapped[DbTransaction] = relationship(
+        back_populates="wallet",
+        doc="Link to transaction (DbTransactions) in this wallet",
+    )
+    multisig_n_required = Column(
+        Integer,
+        default=1,
+        doc="Number of required signature for multisig, "
+        "only used for multisignature master key",
+    )
     sort_keys = Column(Boolean, default=False, doc="Sort keys in multisig wallet")
-    parent_id = Column(Integer, ForeignKey('wallets.id'), doc="Wallet ID of parent wallet, used in multisig wallets")
-    children = relationship("DbWallet", lazy="joined", join_depth=2,
-                            doc="Wallet IDs of children wallets, used in multisig wallets")
-    multisig = Column(Boolean, default=True, doc="Indicates if wallet is a multisig wallet. Default is True")
-    cosigner_id = Column(Integer,
-                         doc="ID of cosigner of this wallet. Used in multisig wallets to differentiate between "
-                             "different wallets")
-    key_path = Column(String(100),
-                      doc="Key path structure used in this wallet. Key path for multisig wallet, use to create "
-                          "your own non-standard key path. Key path must follow the following rules: "
-                          "* Path start with masterkey (m) and end with change / address_index "
-                          "* If accounts are used, the account level must be 3. I.e.: m/purpose/coin_type/account/ "
-                          "* All keys must be hardened, except for change, address_index or cosigner_id "
-                          " Max length of path is 8 levels")
-    default_account_id = Column(Integer, doc="ID of default account for this wallet if multiple accounts are used")
+    parent_id = Column(
+        Integer,
+        ForeignKey("wallets.id"),
+        doc="Wallet ID of parent wallet, used in multisig wallets",
+    )
+    children: Mapped[DbWallet] = relationship(
+        # lazy="joined",
+        # join_depth=2,
+        doc="Wallet IDs of children wallets, used in multisig wallets",
+    )
+    multisig = Column(
+        Boolean,
+        default=True,
+        doc="Indicates if wallet is a multisig wallet. Default is True",
+    )
+    cosigner_id = Column(
+        Integer,
+        doc="ID of cosigner of this wallet. Used in multisig wallets to differentiate between "
+        "different wallets",
+    )
+    key_path = Column(
+        String(100),
+        doc="Key path structure used in this wallet. Key path for multisig wallet, use to create "
+        "your own non-standard key path. Key path must follow the following rules: "
+        "* Path start with masterkey (m) and end with change / address_index "
+        "* If accounts are used, the account level must be 3. I.e.: m/purpose/coin_type/account/ "
+        "* All keys must be hardened, except for change, address_index or cosigner_id "
+        " Max length of path is 8 levels",
+    )
+    default_account_id = Column(
+        Integer,
+        doc="ID of default account for this wallet if multiple accounts are used",
+    )
 
     __table_args__ = (
-        CheckConstraint(scheme.in_(['single', 'bip32']), name='constraint_allowed_schemes'),
-        CheckConstraint(encoding.in_(['base58', 'bech32']), name='constraint_default_address_encodings_allowed'),
-        CheckConstraint(witness_type.in_(['legacy', 'segwit', 'p2sh-segwit']), name='wallet_constraint_allowed_types'),
+        CheckConstraint(
+            scheme.in_(["single", "bip32"]), name="constraint_allowed_schemes"
+        ),
+        CheckConstraint(
+            encoding.in_(["base58", "bech32"]),
+            name="constraint_default_address_encodings_allowed",
+        ),
+        CheckConstraint(
+            witness_type.in_(["legacy", "segwit", "p2sh-segwit"]),
+            name="wallet_constraint_allowed_types",
+        ),
     )
 
     def __repr__(self):
         return "<DbWallet(name='%s', network='%s'>" % (self.name, self.network_name)
 
 
 class DbKeyMultisigChildren(Base):
     """
     Use many-to-many relationship for multisig keys. A multisig keys contains 2 or more child keys
     and a child key can be used in more then one multisig key.
 
     """
-    __tablename__ = 'key_multisig_children'
 
-    parent_id = Column(Integer, ForeignKey('keys.id'), primary_key=True)
-    child_id = Column(Integer, ForeignKey('keys.id'), primary_key=True)
-    key_order = Column(Integer, Sequence('key_multisig_children_id_seq'))
+    __tablename__ = "key_multisig_children"
+
+    parent_id = Column(Integer, ForeignKey("keys.id"), primary_key=True)
+    child_id = Column(Integer, ForeignKey("keys.id"), primary_key=True)
+    key_order = Column(Integer, Sequence("key_multisig_children_id_seq"))
 
 
 class DbKey(Base):
     """
     Database definitions for keys in Sqlalchemy format
 
     Part of a wallet, and used by transactions
 
     """
-    __tablename__ = 'keys'
-    id = Column(Integer, Sequence('key_id_seq'), primary_key=True, doc="Unique Key ID")
-    parent_id = Column(Integer, Sequence('parent_id_seq'), doc="Parent Key ID. Used in HD wallets")
+
+    __tablename__ = "keys"
+    id = Column(Integer, Sequence("key_id_seq"), primary_key=True, doc="Unique Key ID")
+    parent_id = Column(
+        Integer, Sequence("parent_id_seq"), doc="Parent Key ID. Used in HD wallets"
+    )
     name = Column(String(80), index=True, doc="Key name string")
-    account_id = Column(Integer, index=True, doc="ID of account if key is part of a HD structure")
-    depth = Column(Integer,
-                   doc="Depth of key if it is part of a HD structure. Depth=0 means masterkey, "
-                       "depth=1 are the masterkeys children.")
+    account_id = Column(
+        Integer, index=True, doc="ID of account if key is part of a HD structure"
+    )
+    depth = Column(
+        Integer,
+        doc="Depth of key if it is part of a HD structure. Depth=0 means masterkey, "
+        "depth=1 are the masterkeys children.",
+    )
     change = Column(Integer, doc="Change or normal address: Normal=0, Change=1")
-    address_index = Column(BigInteger, doc="Index of address in HD key structure address level")
-    public = Column(LargeBinary(128), index=True, doc="Bytes representation of public key")
-    private = Column(LargeBinary(128), index=True, doc="Bytes representation of private key")
-    wif = Column(String(255), index=True, doc="Public or private WIF (Wallet Import Format) representation")
-    compressed = Column(Boolean, default=True, doc="Is key compressed or not. Default is True")
-    key_type = Column(String(10), default='bip32', doc="Type of key: single, bip32 or multisig. Default is bip32")
-    address = Column(String(255), index=True,
-                     doc="Address representation of key. An cryptocurrency address is a hash of the public key")
-    cosigner_id = Column(Integer, doc="ID of cosigner, used if key is part of HD Wallet")
-    encoding = Column(String(15), default='base58', doc='Encoding used to represent address: base58 or bech32')
+    address_index = Column(
+        BigInteger, doc="Index of address in HD key structure address level"
+    )
+    public = Column(
+        LargeBinary(128), index=True, doc="Bytes representation of public key"
+    )
+    private = Column(
+        LargeBinary(128), index=True, doc="Bytes representation of private key"
+    )
+    wif = Column(
+        String(255),
+        index=True,
+        doc="Public or private WIF (Wallet Import Format) representation",
+    )
+    compressed = Column(
+        Boolean, default=True, doc="Is key compressed or not. Default is True"
+    )
+    key_type = Column(
+        String(10),
+        default="bip32",
+        doc="Type of key: single, bip32 or multisig. Default is bip32",
+    )
+    address = Column(
+        String(255),
+        index=True,
+        doc="Address representation of key. An cryptocurrency address is a hash of the public key",
+    )
+    cosigner_id = Column(
+        Integer, doc="ID of cosigner, used if key is part of HD Wallet"
+    )
+    encoding = Column(
+        String(15),
+        default="base58",
+        doc="Encoding used to represent address: base58 or bech32",
+    )
     purpose = Column(Integer, default=44, doc="Purpose ID, default is 44")
     is_private = Column(Boolean, doc="Is key private or not?")
     path = Column(String(100), doc="String of BIP-32 key path")
-    wallet_id = Column(Integer, ForeignKey('wallets.id'), index=True, doc="Wallet ID which contains this key")
-    wallet = relationship("DbWallet", back_populates="keys", doc="Related Wallet object")
-    transaction_inputs = relationship("DbTransactionInput", cascade="all,delete", back_populates="key",
-                                      doc="All DbTransactionInput objects this key is part of")
-    transaction_outputs = relationship("DbTransactionOutput", cascade="all,delete", back_populates="key",
-                                       doc="All DbTransactionOutput objects this key is part of")
-    balance = Column(BigInteger, default=0, doc="Total balance of UTXO's linked to this key")
-    used = Column(Boolean, default=False, doc="Has key already been used on the blockchain in as input or output? "
-                                              "Default is False")
-    network_name = Column(String(20), ForeignKey('networks.name'),
-                          doc="Name of key network, i.e. bitcoin, litecoin, dash")
-    latest_txid = Column(LargeBinary(32), doc="TxId of latest transaction downloaded from the blockchain")
+    wallet_id = Column(
+        Integer,
+        ForeignKey("wallets.id"),
+        index=True,
+        doc="Wallet ID which contains this key",
+    )
+    wallet = relationship(
+        "DbWallet", back_populates="keys", doc="Related Wallet object"
+    )
+    transaction_inputs = relationship(
+        "DbTransactionInput",
+        cascade="all,delete",
+        back_populates="key",
+        doc="All DbTransactionInput objects this key is part of",
+    )
+    transaction_outputs = relationship(
+        "DbTransactionOutput",
+        cascade="all,delete",
+        back_populates="key",
+        doc="All DbTransactionOutput objects this key is part of",
+    )
+    balance = Column(
+        BigInteger, default=0, doc="Total balance of UTXO's linked to this key"
+    )
+    used = Column(
+        Boolean,
+        default=False,
+        doc="Has key already been used on the blockchain in as input or output? "
+        "Default is False",
+    )
+    network_name = Column(
+        String(20),
+        ForeignKey("networks.name"),
+        doc="Name of key network, i.e. bitcoin, litecoin, dash",
+    )
+    latest_txid = Column(
+        LargeBinary(32), doc="TxId of latest transaction downloaded from the blockchain"
+    )
     network = relationship("DbNetwork", doc="DbNetwork object for this key")
-    multisig_parents = relationship("DbKeyMultisigChildren", backref='child_key',
-                                    primaryjoin=id == DbKeyMultisigChildren.child_id,
-                                    doc="List of parent keys")
-    multisig_children = relationship("DbKeyMultisigChildren", backref='parent_key',
-                                     order_by="DbKeyMultisigChildren.key_order",
-                                     primaryjoin=id == DbKeyMultisigChildren.parent_id,
-                                     doc="List of children keys")
+    multisig_parents = relationship(
+        "DbKeyMultisigChildren",
+        backref="child_key",
+        primaryjoin=id == DbKeyMultisigChildren.child_id,
+        doc="List of parent keys",
+    )
+    multisig_children = relationship(
+        "DbKeyMultisigChildren",
+        backref="parent_key",
+        order_by="DbKeyMultisigChildren.key_order",
+        primaryjoin=id == DbKeyMultisigChildren.parent_id,
+        doc="List of children keys",
+    )
 
     __table_args__ = (
-        CheckConstraint(key_type.in_(['single', 'bip32', 'multisig']), name='constraint_key_types_allowed'),
-        CheckConstraint(encoding.in_(['base58', 'bech32']), name='constraint_address_encodings_allowed'),
-        UniqueConstraint('wallet_id', 'public', name='constraint_wallet_pubkey_unique'),
-        UniqueConstraint('wallet_id', 'private', name='constraint_wallet_privkey_unique'),
-        UniqueConstraint('wallet_id', 'wif', name='constraint_wallet_wif_unique'),
-        UniqueConstraint('wallet_id', 'address', name='constraint_wallet_address_unique'),
+        CheckConstraint(
+            key_type.in_(["single", "bip32", "multisig"]),
+            name="constraint_key_types_allowed",
+        ),
+        CheckConstraint(
+            encoding.in_(["base58", "bech32"]),
+            name="constraint_address_encodings_allowed",
+        ),
+        UniqueConstraint("wallet_id", "public", name="constraint_wallet_pubkey_unique"),
+        UniqueConstraint(
+            "wallet_id", "private", name="constraint_wallet_privkey_unique"
+        ),
+        UniqueConstraint("wallet_id", "wif", name="constraint_wallet_wif_unique"),
+        UniqueConstraint(
+            "wallet_id", "address", name="constraint_wallet_address_unique"
+        ),
     )
 
     def __repr__(self):
         return "<DbKey(id='%s', name='%s', wif='%s'>" % (self.id, self.name, self.wif)
 
 
 class DbNetwork(Base):
     """
     Database definitions for networks in Sqlalchemy format
 
     Most network settings and variables can be found outside the database in the libraries configurations settings.
     Use the fluxwallet/data/networks.json file to view and manage settings.
 
     """
-    __tablename__ = 'networks'
-    name = Column(String(20), unique=True, primary_key=True, doc="Network name, i.e.: bitcoin, litecoin, dash")
+
+    __tablename__ = "networks"
+    name = Column(
+        String(20),
+        unique=True,
+        primary_key=True,
+        doc="Network name, i.e.: bitcoin, litecoin, dash",
+    )
     description = Column(String(50))
 
     def __repr__(self):
         return "<DbNetwork(name='%s', description='%s'>" % (self.name, self.description)
 
 
 # class TransactionType(enum.Enum):
@@ -298,152 +501,308 @@
 class DbTransaction(Base):
     """
     Database definitions for transactions in Sqlalchemy format
 
     Refers to 1 or more keys which can be part of a wallet
 
     """
-    __tablename__ = 'transactions'
-    id = Column(Integer, Sequence('transaction_id_seq'), primary_key=True,
-                doc="Unique transaction index for internal usage")
-    txid = Column(LargeBinary(32), index=True, doc="Bytes representation of transaction ID")
-    wallet_id = Column(Integer, ForeignKey('wallets.id'), index=True,
-                       doc="ID of wallet which contains this transaction")
+
+    __tablename__ = "transactions"
+    id = Column(
+        Integer,
+        Sequence("transaction_id_seq"),
+        primary_key=True,
+        doc="Unique transaction index for internal usage",
+    )
+    txid = Column(
+        LargeBinary(32), index=True, doc="Bytes representation of transaction ID"
+    )
+    wallet_id = Column(
+        Integer,
+        ForeignKey("wallets.id"),
+        index=True,
+        doc="ID of wallet which contains this transaction",
+    )
     account_id = Column(Integer, index=True, doc="ID of account")
-    wallet = relationship("DbWallet", back_populates="transactions",
-                          doc="Link to Wallet object which contains this transaction")
-    witness_type = Column(String(20), default='legacy', doc="Is this a legacy or segwit transaction?")
-    version = Column(BigInteger, default=1,
-                     doc="Tranaction version. Default is 1 but some wallets use another version number")
-    locktime = Column(BigInteger, default=0,
-                      doc="Transaction level locktime. Locks the transaction until a specified block "
-                          "(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970)."
-                          " Default value is 0 for transactions without locktime")
-    date = Column(DateTime, default=datetime.utcnow,
-                  doc="Date when transaction was confirmed and included in a block. "
-                      "Or when it was created when transaction is not send or confirmed")
-    coinbase = Column(Boolean, default=False, doc="Is True when this is a coinbase transaction, default is False")
-    confirmations = Column(Integer, default=0,
-                           doc="Number of confirmation when this transaction is included in a block. "
-                               "Default is 0: unconfirmed")
-    block_height = Column(Integer, index=True, doc="Number of block this transaction is included in")
+    wallet = relationship(
+        "DbWallet",
+        back_populates="transactions",
+        doc="Link to Wallet object which contains this transaction",
+    )
+    witness_type = Column(
+        String(20), default="legacy", doc="Is this a legacy or segwit transaction?"
+    )
+    version = Column(
+        BigInteger,
+        default=1,
+        doc="Tranaction version. Default is 1 but some wallets use another version number",
+    )
+    locktime = Column(
+        BigInteger,
+        default=0,
+        doc="Transaction level locktime. Locks the transaction until a specified block "
+        "(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970)."
+        " Default value is 0 for transactions without locktime",
+    )
+    date = Column(
+        DateTime,
+        default=datetime.utcnow,
+        doc="Date when transaction was confirmed and included in a block. "
+        "Or when it was created when transaction is not send or confirmed",
+    )
+    coinbase = Column(
+        Boolean,
+        default=False,
+        doc="Is True when this is a coinbase transaction, default is False",
+    )
+    expiry_height = Column(
+        Integer,
+        default=0,
+        doc="Expiry height (in blocktime) for this transactions. I.e, must be confirmed before this block height."
+        "Default is 0: no expiry (not version 4 transaction)",
+    )
+    confirmations = Column(
+        Integer,
+        default=0,
+        doc="Number of confirmation when this transaction is included in a block. "
+        "Default is 0: unconfirmed",
+    )
+    block_height = Column(
+        Integer, index=True, doc="Number of block this transaction is included in"
+    )
     size = Column(Integer, doc="Size of the raw transaction in bytes")
     fee = Column(BigInteger, doc="Transaction fee")
-    inputs = relationship("DbTransactionInput", cascade="all,delete",
-                          doc="List of all inputs as DbTransactionInput objects")
-    outputs = relationship("DbTransactionOutput", cascade="all,delete",
-                           doc="List of all outputs as DbTransactionOutput objects")
-    status = Column(String(20), default='new',
-                    doc="Current status of transaction, can be one of the following: new', "
-                        "'unconfirmed', 'confirmed'. Default is 'new'")
-    is_complete = Column(Boolean, default=True, doc="Allow to store incomplete transactions, for instance if not all "
-                                                    "inputs are known when retrieving UTXO's")
-    input_total = Column(BigInteger, default=0,
-                         doc="Total value of the inputs of this transaction. Input total = Output total + fee. "
-                             "Default is 0")
-    output_total = Column(BigInteger, default=0,
-                          doc="Total value of the outputs of this transaction. Output total = Input total - fee")
-    network_name = Column(String(20), ForeignKey('networks.name'), doc="Blockchain network name of this transaction")
+    inputs = relationship(
+        "DbTransactionInput",
+        cascade="all,delete",
+        doc="List of all inputs as DbTransactionInput objects",
+    )
+    outputs = relationship(
+        "DbTransactionOutput",
+        cascade="all,delete",
+        doc="List of all outputs as DbTransactionOutput objects",
+    )
+    status = Column(
+        String(20),
+        default="new",
+        doc="Current status of transaction, can be one of the following: new', "
+        "'unconfirmed', 'confirmed'. Default is 'new'",
+    )
+    is_complete = Column(
+        Boolean,
+        default=True,
+        doc="Allow to store incomplete transactions, for instance if not all "
+        "inputs are known when retrieving UTXO's",
+    )
+    input_total = Column(
+        BigInteger,
+        default=0,
+        doc="Total value of the inputs of this transaction. Input total = Output total + fee. "
+        "Default is 0",
+    )
+    output_total = Column(
+        BigInteger,
+        default=0,
+        doc="Total value of the outputs of this transaction. Output total = Input total - fee",
+    )
+    network_name = Column(
+        String(20),
+        ForeignKey("networks.name"),
+        doc="Blockchain network name of this transaction",
+    )
     network = relationship("DbNetwork", doc="Link to DbNetwork object")
-    raw = Column(LargeBinary,
-                 doc="Raw transaction hexadecimal string. Transaction is included in raw format on the blockchain")
-    verified = Column(Boolean, default=False, doc="Is transaction verified. Default is False")
+    raw = Column(
+        LargeBinary,
+        doc="Raw transaction hexadecimal string. Transaction is included in raw format on the blockchain",
+    )
+    verified = Column(
+        Boolean, default=False, doc="Is transaction verified. Default is False"
+    )
 
     __table_args__ = (
-        UniqueConstraint('wallet_id', 'txid', name='constraint_wallet_transaction_hash_unique'),
-        CheckConstraint(status.in_(['new', 'unconfirmed', 'confirmed']),
-                        name='constraint_status_allowed'),
-        CheckConstraint(witness_type.in_(['legacy', 'segwit']), name='transaction_constraint_allowed_types'),
+        UniqueConstraint(
+            "wallet_id", "txid", name="constraint_wallet_transaction_hash_unique"
+        ),
+        CheckConstraint(
+            status.in_(["new", "unconfirmed", "confirmed"]),
+            name="constraint_status_allowed",
+        ),
+        CheckConstraint(
+            witness_type.in_(["legacy", "segwit"]),
+            name="transaction_constraint_allowed_types",
+        ),
     )
 
     def __repr__(self):
-        return "<DbTransaction(txid='%s', confirmations='%s')>" % (self.txid, self.confirmations)
+        return "<DbTransaction(txid='%s', confirmations='%s')>" % (
+            self.txid,
+            self.confirmations,
+        )
 
 
 class DbTransactionInput(Base):
     """
     Transaction Input Table
 
     Relates to Transaction table and Key table
 
     """
-    __tablename__ = 'transaction_inputs'
-    transaction_id = Column(Integer, ForeignKey('transactions.id'), primary_key=True,
-                            doc="Input is part of transaction with this ID")
-    transaction = relationship("DbTransaction", back_populates='inputs', doc="Related DbTransaction object")
+
+    __tablename__ = "transaction_inputs"
+    transaction_id = Column(
+        Integer,
+        ForeignKey("transactions.id"),
+        primary_key=True,
+        doc="Input is part of transaction with this ID",
+    )
+    transaction = relationship(
+        "DbTransaction", back_populates="inputs", doc="Related DbTransaction object"
+    )
     index_n = Column(Integer, primary_key=True, doc="Index number of transaction input")
-    key_id = Column(Integer, ForeignKey('keys.id'), index=True, doc="ID of key used in this input")
-    key = relationship("DbKey", back_populates="transaction_inputs", doc="Related DbKey object")
-    address = Column(String(255),
-                     doc="Address string of input, used if no key is associated. "
-                         "An cryptocurrency address is a hash of the public key or a redeemscript")
-    witnesses = Column(LargeBinary, doc="Witnesses (signatures) used in Segwit transaction inputs")
-    witness_type = Column(String(20), default='legacy',
-                          doc="Type of transaction, can be legacy, segwit or p2sh-segwit. Default is legacy")
-    prev_txid = Column(LargeBinary(32),
-                       doc="Transaction hash of previous transaction. Previous unspent outputs (UTXO) is spent "
-                           "in this input")
-    output_n = Column(BigInteger, doc="Output_n of previous transaction output that is spent in this input")
-    script = Column(LargeBinary, doc="Unlocking script to unlock previous locked output")
-    script_type = Column(String(20), default='sig_pubkey',
-                         doc="Unlocking script type. Can be 'coinbase', 'sig_pubkey', 'p2sh_multisig', 'signature', "
-                             "'unknown', 'p2sh_p2wpkh' or 'p2sh_p2wsh'. Default is sig_pubkey")
-    sequence = Column(BigInteger, doc="Transaction sequence number. Used for timelock transaction inputs")
+    key_id = Column(
+        Integer, ForeignKey("keys.id"), index=True, doc="ID of key used in this input"
+    )
+    key = relationship(
+        "DbKey", back_populates="transaction_inputs", doc="Related DbKey object"
+    )
+    address = Column(
+        String(255),
+        doc="Address string of input, used if no key is associated. "
+        "An cryptocurrency address is a hash of the public key or a redeemscript",
+    )
+    witnesses = Column(
+        LargeBinary, doc="Witnesses (signatures) used in Segwit transaction inputs"
+    )
+    witness_type = Column(
+        String(20),
+        default="legacy",
+        doc="Type of transaction, can be legacy, segwit or p2sh-segwit. Default is legacy",
+    )
+    prev_txid = Column(
+        LargeBinary(32),
+        doc="Transaction hash of previous transaction. Previous unspent outputs (UTXO) is spent "
+        "in this input",
+    )
+    output_n = Column(
+        BigInteger,
+        doc="Output_n of previous transaction output that is spent in this input",
+    )
+    script = Column(
+        LargeBinary, doc="Unlocking script to unlock previous locked output"
+    )
+    script_type = Column(
+        String(20),
+        default="sig_pubkey",
+        doc="Unlocking script type. Can be 'coinbase', 'sig_pubkey', 'p2sh_multisig', 'signature', "
+        "'unknown', 'p2sh_p2wpkh' or 'p2sh_p2wsh'. Default is sig_pubkey",
+    )
+    sequence = Column(
+        BigInteger,
+        doc="Transaction sequence number. Used for timelock transaction inputs",
+    )
     value = Column(BigInteger, default=0, doc="Value of transaction input")
-    double_spend = Column(Boolean, default=False,
-                          doc="Indicates if a service provider tagged this transaction as double spend")
+    double_spend = Column(
+        Boolean,
+        default=False,
+        doc="Indicates if a service provider tagged this transaction as double spend",
+    )
 
-    __table_args__ = (CheckConstraint(witness_type.in_(['legacy', 'segwit', 'p2sh-segwit']),
-                                      name='transactioninput_constraint_allowed_types'),
-                      UniqueConstraint('transaction_id', 'index_n', name='constraint_transaction_input_unique'))
+    __table_args__ = (
+        CheckConstraint(
+            witness_type.in_(["legacy", "segwit", "p2sh-segwit"]),
+            name="transactioninput_constraint_allowed_types",
+        ),
+        UniqueConstraint(
+            "transaction_id", "index_n", name="constraint_transaction_input_unique"
+        ),
+    )
 
 
 class DbTransactionOutput(Base):
     """
     Transaction Output Table
 
     Relates to Transaction and Key table
 
     When spent is False output is considered an UTXO
 
     """
-    __tablename__ = 'transaction_outputs'
-    transaction_id = Column(Integer, ForeignKey('transactions.id'), primary_key=True,
-                            doc="Transaction ID of parent transaction")
-    transaction = relationship("DbTransaction", back_populates='outputs',
-                               doc="Link to transaction object")
-    output_n = Column(Integer, primary_key=True, doc="Sequence number of transaction output")
-    key_id = Column(Integer, ForeignKey('keys.id'), index=True, doc="ID of key used in this transaction output")
-    key = relationship("DbKey", back_populates="transaction_outputs", doc="List of DbKey object used in this output")
-    address = Column(String(255),
-                     doc="Address string of output, used if no key is associated. "
-                         "An cryptocurrency address is a hash of the public key or a redeemscript")
+
+    __tablename__ = "transaction_outputs"
+    transaction_id = Column(
+        Integer,
+        ForeignKey("transactions.id"),
+        primary_key=True,
+        doc="Transaction ID of parent transaction",
+    )
+    transaction = relationship(
+        "DbTransaction", back_populates="outputs", doc="Link to transaction object"
+    )
+    output_n = Column(
+        Integer, primary_key=True, doc="Sequence number of transaction output"
+    )
+    key_id = Column(
+        Integer,
+        ForeignKey("keys.id"),
+        index=True,
+        doc="ID of key used in this transaction output",
+    )
+    key = relationship(
+        "DbKey",
+        back_populates="transaction_outputs",
+        doc="List of DbKey object used in this output",
+    )
+    address = Column(
+        String(255),
+        doc="Address string of output, used if no key is associated. "
+        "An cryptocurrency address is a hash of the public key or a redeemscript",
+    )
     script = Column(LargeBinary, doc="Locking script which locks transaction output")
-    script_type = Column(String(20), default='p2pkh',
-                         doc="Locking script type. Can be one of these values: 'p2pkh', 'multisig', 'p2sh', 'p2pk', "
-                             "'nulldata', 'unknown', 'p2wpkh', 'p2wsh', 'p2tr'. Default is p2pkh")
+    script_type = Column(
+        String(20),
+        default="p2pkh",
+        doc="Locking script type. Can be one of these values: 'p2pkh', 'multisig', 'p2sh', 'p2pk', "
+        "'nulldata', 'unknown', 'p2wpkh', 'p2wsh', 'p2tr'. Default is p2pkh",
+    )
     value = Column(BigInteger, default=0, doc="Total transaction output value")
-    spent = Column(Boolean, default=False, doc="Indicated if output is already spent in another transaction")
-    spending_txid = Column(LargeBinary(32), doc="Transaction hash of input which spends this output")
-    spending_index_n = Column(Integer, doc="Index number of transaction input which spends this output")
+    spent = Column(
+        Boolean,
+        default=False,
+        doc="Indicated if output is already spent in another transaction",
+    )
+    spending_txid = Column(
+        LargeBinary(32), doc="Transaction hash of input which spends this output"
+    )
+    spending_index_n = Column(
+        Integer, doc="Index number of transaction input which spends this output"
+    )
 
-    __table_args__ = (UniqueConstraint('transaction_id', 'output_n', name='constraint_transaction_output_unique'),)
+    __table_args__ = (
+        UniqueConstraint(
+            "transaction_id", "output_n", name="constraint_transaction_output_unique"
+        ),
+    )
 
 
 def db_update_version_id(db, version):
     _logger.info("Updated fluxwallet database to version %s" % version)
-    db.session.query(DbConfig).filter(DbConfig.variable == 'version').update(
-        {DbConfig.value: version})
+    db.session.query(DbConfig).filter(DbConfig.variable == "version").update(
+        {DbConfig.value: version}
+    )
     db.session.commit()
     return version
 
 
 def db_update(db, version_db, code_version=FLUXWALLET_VERSION):
     # Database changes from version 0.5+
     #
-    if version_db <= '0.6.3' and code_version > '0.6.3':
+    if version_db <= "0.6.3" and code_version > "0.6.3":
         # Example: column = Column('latest_txid', String(32))
-        column = Column('witnesses', LargeBinary, doc="Witnesses (signatures) used in Segwit transaction inputs")
-        add_column(db.engine, 'transaction_inputs', column)
+        column = Column(
+            "witnesses",
+            LargeBinary,
+            doc="Witnesses (signatures) used in Segwit transaction inputs",
+        )
+        add_column(db.engine, "transaction_inputs", column)
         # version_db = db_update_version_id(db, '0.6.4')
     version_db = db_update_version_id(db, code_version)
     return version_db
```

### Comparing `fluxwallet-0.0.6/fluxwallet/db_cache.py` & `fluxwallet-0.1.0/fluxwallet/db_cache.py`

 * *Files 20% similar despite different names*

```diff
@@ -25,104 +25,186 @@
 #     from psycopg2 import sql
 #     from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
 # except ImportError as e:
 #     print("Could not import all modules. Error: %s" % e)
 #     # from psycopg2cffi import compat  # Use for PyPy support
 #     # compat.register()
 #     pass  # Only necessary when mysql or postgres is used
+from __future__ import annotations
+
 from urllib.parse import urlparse
 
-from sqlalchemy import (BigInteger, Boolean, Column, DateTime, Enum,
-                        ForeignKey, Integer, LargeBinary, String,
-                        create_engine)
-from sqlalchemy.ext.declarative import declarative_base
-from sqlalchemy.orm import close_all_sessions, relationship, sessionmaker
+from sqlalchemy import (
+    BigInteger,
+    Boolean,
+    Column,
+    DateTime,
+    Enum,
+    ForeignKey,
+    Integer,
+    LargeBinary,
+    String,
+    text,
+)
+from sqlalchemy.event import listen
+from sqlalchemy.ext.asyncio import (
+    AsyncAttrs,
+    AsyncSession,
+    async_sessionmaker,
+    create_async_engine,
+)
+from sqlalchemy.ext.asyncio.engine import AsyncEngine
+
+# from sqlalchemy.ext.compiler import compiles
+from sqlalchemy.orm import (
+    DeclarativeBase,
+    Mapped,
+    WriteOnlyMapped,
+    mapped_column,
+    relationship,
+)
 
 from fluxwallet.main import *
 
-_logger = logging.getLogger(__name__)
-try:
-    dbcacheurl_obj = urlparse(DEFAULT_DATABASE_CACHE)
-    if dbcacheurl_obj.netloc:
-        dbcacheurl = dbcacheurl_obj.netloc.replace(dbcacheurl_obj.password, 'xxx')
-    else:
-        dbcacheurl = dbcacheurl_obj.path
-    _logger.info("Default Cache Database %s" % dbcacheurl)
-except Exception:
-    _logger.warning("Default Cache Database: unable to parse URL")
-Base = declarative_base()
+# _logger = logging.getLogger(__name__)
 
 
 class WitnessTypeTransactions(enum.Enum):
     legacy = "legacy"
     segwit = "segwit"
 
 
+class Base(AsyncAttrs, DeclarativeBase):
+    pass
+
+
 class DbCache:
     """
     Cache Database object. Initialize database and open session when creating database object.
 
     Create new database if is doesn't exist yet
 
     """
-    def __init__(self, db_uri=None):
-        self.engine = None
-        self.session = None
+
+    _built = False
+
+    @classmethod
+    async def start(cls, db_uri: str | None = None) -> DbCache:
+        self = DbCache()
+
+        async with self.engine.begin() as conn:
+            await conn.run_sync(Base.metadata.create_all)
+
+        await self.test_connection()
+        DbCache._built = True
+
+        return self
+
+    async def __aenter__(self) -> AsyncSession:
+        if not DbCache._built:
+            async with self.engine.begin() as conn:
+                await conn.run_sync(Base.metadata.create_all)
+
+            await self.test_connection()
+            DbCache._built = True
+
+        return self._session
+
+    async def __aexit__(self, exception_type, exception_value, exception_traceback):
+        # await self._session.close()
+        # return None / False will reraise
+        # print("Exiting DbCache Context")
+        ...
+
+    def __init__(
+        self,
+        db_uri: str | None = None,
+        *,
+        sessionmaker: async_sessionmaker | None = None,
+    ):
         if db_uri is None:
             db_uri = DEFAULT_DATABASE_CACHE
-        elif not db_uri:
-            return
-        self.o = urlparse(db_uri)
-
-        # if self.o.scheme == 'mysql':
-        #     raise Warning("Could not connect to cache database. MySQL databases not supported at the moment, "
-        #                   "because bytes strings are not supported as primary keys")
-
-        if not self.o.scheme or len(self.o.scheme) < 2:
-            db_uri = 'sqlite:///%s' % db_uri
-        if db_uri.startswith("sqlite://") and ALLOW_DATABASE_THREADS:
-            db_uri += "&" if "?" in db_uri else "?"
-            db_uri += "check_same_thread=False"
-        if self.o.scheme == 'mysql':
-            db_uri += "&" if "?" in db_uri else "?"
-            db_uri += 'binary_prefix=true'
-        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')
 
-        Session = sessionmaker(bind=self.engine)
-        Base.metadata.create_all(self.engine)
+        db_uri = f"sqlite+aiosqlite:///{db_uri}"
+
+        self.connection_possible = False
+        self.engine = create_async_engine(db_uri, isolation_level="READ UNCOMMITTED")
+        self.sessionmaker = async_sessionmaker(self.engine, expire_on_commit=False)
+
+        listen(self.engine.sync_engine, "connect", self.set_sqlite_pragma)
         self.db_uri = db_uri
-        _logger.info("Using cache database: %s://%s:%s/%s" % (self.o.scheme or '', self.o.hostname or '',
-                                                              self.o.port or '', self.o.path or ''))
-        self.session = Session()
-
-    def drop_db(self):
-        self.session.commit()
-        # self.session.close_all()
-        close_all_sessions()
-        Base.metadata.drop_all(self.engine)
+        self._session = self.sessionmaker()
+
+    def get_session(self):
+        return self.sessionmaker()
+
+    def set_sqlite_pragma(self, dbapi_connection, connection_record):
+        cursor = dbapi_connection.cursor()
+        cursor.execute("PRAGMA journal_mode=WAL")
+        cursor.close()
+
+        # print("Cache Engine connected")
+
+    async def test_connection(self) -> None:
+        async with self.get_session() as session:
+            try:
+                await session.execute(text("SELECT 1"))
+                self.connection_possible = True
+            except Exception:
+                self.connection_possible = False
+
+    @property
+    def session(self) -> AsyncSession:
+        return self._session
+
+    # def drop_db(self):
+    #     self.session.commit()
+    #     # self.session.close_all()
+    #     close_all_sessions()
+    #     Base.metadata.drop_all(self.engine)
 
 
 class DbCacheTransactionNode(Base):
     """
     Link table for cache transactions and addresses
     """
-    __tablename__ = 'cache_transactions_node'
-    txid = Column(LargeBinary(32), ForeignKey('cache_transactions.txid'), primary_key=True)
-    transaction = relationship("DbCacheTransaction", back_populates='nodes', doc="Related transaction object")
-    index_n = Column(Integer, primary_key=True, doc="Order of input/output in this transaction")
+
+    __tablename__ = "cache_transactions_node"
+    txid = Column(
+        LargeBinary(32), ForeignKey("cache_transactions.txid"), primary_key=True
+    )
+    transaction = relationship(
+        "DbCacheTransaction", back_populates="nodes", doc="Related transaction object"
+    )
+    index_n = Column(
+        Integer, primary_key=True, doc="Order of input/output in this transaction"
+    )
     value = Column(BigInteger, default=0, doc="Value of transaction input")
-    address = Column(String(255), index=True, doc="Address string base32 or base58 encoded")
+    address = Column(
+        String(255), index=True, doc="Address string base32 or base58 encoded"
+    )
     script = Column(LargeBinary, doc="Locking or unlocking script")
-    witnesses = Column(LargeBinary, doc="Witnesses (signatures) used in Segwit transaction inputs")
-    sequence = Column(BigInteger, default=0xffffffff,
-                      doc="Transaction sequence number. Used for timelock transaction inputs")
+    witnesses = Column(
+        LargeBinary, doc="Witnesses (signatures) used in Segwit transaction inputs"
+    )
+    sequence = Column(
+        BigInteger,
+        default=0xFFFFFFFF,
+        doc="Transaction sequence number. Used for timelock transaction inputs",
+    )
     is_input = Column(Boolean, primary_key=True, doc="True if input, False if output")
     spent = Column(Boolean, default=None, doc="Is output spent?")
-    ref_txid = Column(LargeBinary(32), index=True, doc="Transaction hash of input which spends this output")
-    ref_index_n = Column(BigInteger, doc="Index number of transaction input which spends this output")
+    ref_txid = Column(
+        LargeBinary(32),
+        index=True,
+        doc="Transaction hash of input which spends this output",
+    )
+    ref_index_n = Column(
+        BigInteger, doc="Index number of transaction input which spends this output"
+    )
 
     def prev_txid(self):
         if self.is_input:
             return self.ref_txid
 
     def output_n(self):
         if self.is_input:
@@ -140,75 +222,131 @@
 class DbCacheTransaction(Base):
     """
     Transaction Cache Table
 
     Database which stores transactions received from service providers as cache
 
     """
-    __tablename__ = 'cache_transactions'
-    txid = Column(LargeBinary(32), primary_key=True, doc="Hexadecimal representation of transaction hash or transaction ID")
-    date = Column(DateTime, doc="Date when transaction was confirmed and included in a block")
-    version = Column(BigInteger, default=1,
-                     doc="Tranaction version. Default is 1 but some wallets use another version number")
-    locktime = Column(BigInteger, default=0,
-                      doc="Transaction level locktime. Locks the transaction until a specified block "
-                          "(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970)."
-                          " Default value is 0 for transactions without locktime")
-    confirmations = Column(Integer, default=0,
-                           doc="Number of confirmation when this transaction is included in a block. "
-                               "Default is 0: unconfirmed")
-    block_height = Column(Integer, index=True, doc="Height of block this transaction is included in")
+
+    __tablename__ = "cache_transactions"
+    txid = Column(
+        LargeBinary(32),
+        primary_key=True,
+        doc="Hexadecimal representation of transaction hash or transaction ID",
+    )
+    date = Column(
+        DateTime, doc="Date when transaction was confirmed and included in a block"
+    )
+    version = Column(
+        BigInteger,
+        default=1,
+        doc="Tranaction version. Default is 1 but some wallets use another version number",
+    )
+    locktime = Column(
+        BigInteger,
+        default=0,
+        doc="Transaction level locktime. Locks the transaction until a specified block "
+        "(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970)."
+        " Default value is 0 for transactions without locktime",
+    )
+    expiry_height = Column(
+        Integer,
+        default=0,
+        doc="Expiry height (in blocktime) for this transactions. I.e, must be confirmed before this block height."
+        "Default is 0: no expiry (not version 4 transaction)",
+    )
+    confirmations = Column(
+        Integer,
+        default=0,
+        doc="Number of confirmation when this transaction is included in a block. "
+        "Default is 0: unconfirmed",
+    )
+    block_height = Column(
+        Integer, index=True, doc="Height of block this transaction is included in"
+    )
     network_name = Column(String(20), doc="Blockchain network name of this transaction")
     fee = Column(BigInteger, doc="Transaction fee")
-    nodes = relationship("DbCacheTransactionNode", cascade="all,delete",
-                         doc="List of all inputs and outputs as DbCacheTransactionNode objects")
+    nodes = relationship(
+        "DbCacheTransactionNode",
+        cascade="all,delete",
+        doc="List of all inputs and outputs as DbCacheTransactionNode objects",
+    )
     order_n = Column(Integer, doc="Order of transaction in block")
-    witness_type = Column(Enum(WitnessTypeTransactions), default=WitnessTypeTransactions.legacy,
-                          doc="Transaction type enum: legacy or segwit")
+    witness_type = Column(
+        Enum(WitnessTypeTransactions),
+        default=WitnessTypeTransactions.legacy,
+        doc="Transaction type enum: legacy or segwit",
+    )
 
 
 class DbCacheAddress(Base):
     """
     Address Cache Table
 
     Stores transactions and unspent outputs (UTXO's) per address
 
     """
-    __tablename__ = 'cache_address'
-    address = Column(String(255), primary_key=True, doc="Address string base32 or base58 encoded")
+
+    __tablename__ = "cache_address"
+    address = Column(
+        String(255), primary_key=True, doc="Address string base32 or base58 encoded"
+    )
     network_name = Column(String(20), doc="Blockchain network name of this transaction")
-    balance = Column(BigInteger, default=0, doc="Total balance of UTXO's linked to this key")
+    balance = Column(
+        BigInteger, default=0, doc="Total balance of UTXO's linked to this key"
+    )
     last_block = Column(Integer, doc="Number of last updated block")
-    last_txid = Column(LargeBinary(32), doc="Transaction ID of latest transaction in cache")
+    last_txid = Column(
+        LargeBinary(32), doc="Transaction ID of latest transaction in cache"
+    )
+    last_tx_index = Column(
+        Integer, doc="Transaction index of latest transaction in cache"
+    )
     n_utxos = Column(Integer, doc="Total number of UTXO's for this address")
     n_txs = Column(Integer, doc="Total number of transactions for this address")
 
 
 class DbCacheBlock(Base):
     """
     Block Cache Table
 
     Stores block headers
     """
-    __tablename__ = 'cache_blocks'
-    height = Column(Integer, primary_key=True, doc="Height or sequence number for this block")
+
+    __tablename__ = "cache_blocks"
+    height = Column(
+        Integer, primary_key=True, doc="Height or sequence number for this block"
+    )
     block_hash = Column(LargeBinary(32), index=True, doc="Hash of this block")
     network_name = Column(String(20), doc="Blockchain network name")
-    version = Column(BigInteger, doc="Block version to specify which features are used (hex)")
+    version = Column(
+        BigInteger, doc="Block version to specify which features are used (hex)"
+    )
     prev_block = Column(LargeBinary(32), doc="Block hash of previous block")
-    merkle_root = Column(LargeBinary(32), doc="Merkle root used to validate transaction in block")
+    merkle_root = Column(
+        LargeBinary(32), doc="Merkle root used to validate transaction in block"
+    )
     time = Column(BigInteger, doc="Timestamp to indicated when block was created")
-    bits = Column(BigInteger, doc="Encoding for proof-of-work, used to determine target and difficulty")
-    nonce = Column(BigInteger, doc="Nonce (number used only once or n-once) is used to create different block hashes")
+    bits = Column(
+        BigInteger,
+        doc="Encoding for proof-of-work, used to determine target and difficulty",
+    )
+    nonce = Column(
+        BigInteger,
+        doc="Nonce (number used only once or n-once) is used to create different block hashes",
+    )
     tx_count = Column(Integer, doc="Number of transactions included in this block")
 
 
 class DbCacheVars(Base):
     """
     Table to store various blockchain related variables
     """
-    __tablename__ = 'cache_variables'
+
+    __tablename__ = "cache_variables"
     varname = Column(String(50), primary_key=True, doc="Variable unique name")
-    network_name = Column(String(20), primary_key=True, doc="Blockchain network name of this transaction")
+    network_name = Column(
+        String(20), primary_key=True, doc="Blockchain network name of this transaction"
+    )
     value = Column(String(255), doc="Value of variable")
     type = Column(String(20), doc="Type of variable: int, string or float")
     expires = Column(DateTime, doc="Datetime value when variable expires")
```

### Comparing `fluxwallet-0.0.6/fluxwallet/encoding.py` & `fluxwallet-0.1.0/fluxwallet/encoding.py`

 * *Files 4% similar despite different names*

```diff
@@ -26,85 +26,104 @@
 
 from fluxwallet.main import *
 
 _logger = logging.getLogger(__name__)
 
 
 SCRYPT_ERROR = None
-USING_MODULE_SCRYPT = os.getenv("USING_MODULE_SCRYPT") not in ["false", "False", "0", "FALSE"]
+USING_MODULE_SCRYPT = os.getenv("USING_MODULE_SCRYPT") not in [
+    "false",
+    "False",
+    "0",
+    "FALSE",
+]
 
 try:
     from Crypto.Hash import RIPEMD160
 except ImportError as err:
-    _logger.warning("Could not import RIPEMD160 from cryptodome, will try do use hashlib but this could lead to errors")
+    _logger.warning(
+        "Could not import RIPEMD160 from cryptodome, will try do use hashlib but this could lead to errors"
+    )
 
 try:
     from Crypto.Cipher import AES
 except ImportError as PYAES_ERROR:
     _logger.warning("MISSING MODULES! Please install pycryptodome")
-    _logger.warning("The bip38_decrypt and bip38_encrypt methods need the pycryptodome library to work!")
+    _logger.warning(
+        "The bip38_decrypt and bip38_encrypt methods need the pycryptodome library to work!"
+    )
 
 try:
     if USING_MODULE_SCRYPT is not False:
         import scrypt
+
         USING_MODULE_SCRYPT = True
 except ImportError as SCRYPT_ERROR:
     try:
         from Crypto.Protocol.KDF import scrypt
+
         _logger.info("Using scrypt method from pycryptodome")
     except ImportError as err:
         _logger.info("Could not import scrypt from pycryptodome: %s" % str(err))
         pass
 
-if 'scrypt' not in sys.modules and 'Crypto.Protocol.KDF' not in sys.modules:
+if "scrypt" not in sys.modules and "Crypto.Protocol.KDF" not in sys.modules:
     try:
         import pyscrypt as scrypt
     except ImportError:
-        _logger.warning("MISSING MODULES! Please install scrypt, pycryptodome or pyscrypt")
-        _logger.warning("The bip38_decrypt and bip38_encrypt methods need a scrypt library to work!")
+        _logger.warning(
+            "MISSING MODULES! Please install scrypt, pycryptodome or pyscrypt"
+        )
+        _logger.warning(
+            "The bip38_decrypt and bip38_encrypt methods need a scrypt library to work!"
+        )
     USING_MODULE_SCRYPT = False
 
 USE_FASTECDSA = os.getenv("USE_FASTECDSA") not in ["false", "False", "0", "FALSE"]
 try:
     if USE_FASTECDSA is not False:
         from fastecdsa.encoding.der import DEREncoder
+
         USE_FASTECDSA = True
 except ImportError:
     pass
-if 'fastecdsa' not in sys.modules:
+if "fastecdsa" not in sys.modules:
     _logger.warning("Could not include fastecdsa library, using slower ecdsa instead.")
     USE_FASTECDSA = False
     try:
         import ecdsa
     except ImportError:
-        raise ImportError("Could not include ecdsa library. Please install fastecdsa or ecdsa library.")
+        raise ImportError(
+            "Could not include ecdsa library. Please install fastecdsa or ecdsa library."
+        )
 
 
 class EncodingError(Exception):
-    """ Log and raise encoding errors """
-    def __init__(self, msg=''):
+    """Log and raise encoding errors"""
+
+    def __init__(self, msg=""):
         self.msg = msg
 
     def __str__(self):
         return self.msg
 
 
-bytesascii = b''
+bytesascii = b""
 for bxn in range(256):
     bytesascii += bytes((bxn,))
 
 code_strings = {
-    2: b'01',
-    3: b' ,.',
-    10: b'0123456789',
-    16: b'0123456789abcdef',
-    32: b'abcdefghijklmnopqrstuvwxyz234567',
-    58: b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
-    256: b''.join([bytes((csx,)) for csx in range(256)]),
-    'bech32': b'qpzry9x8gf2tvdw0s3jn54khce6mua7l'
+    2: b"01",
+    3: b" ,.",
+    10: b"0123456789",
+    16: b"0123456789abcdef",
+    32: b"abcdefghijklmnopqrstuvwxyz234567",
+    58: b"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
+    256: b"".join([bytes((csx,)) for csx in range(256)]),
+    "bech32": b"qpzry9x8gf2tvdw0s3jn54khce6mua7l",
 }
 
 
 def _get_code_string(base):
     if base in code_strings:
         return code_strings[base]
     else:
@@ -116,15 +135,15 @@
     codestring = ""
     for i in array:
         codestring += chr(codebase[i])
     return codestring
 
 
 def _codestring_to_array(codestring, base):
-    codestring = bytes(codestring, 'utf8')
+    codestring = bytes(codestring, "utf8")
     codebase = code_strings[base]
     array = []
     for s in codestring:
         try:
             array.append(codebase.index(s))
         except ValueError:
             raise EncodingError("Character '%s' not found in codebase" % s)
@@ -144,30 +163,32 @@
     :param base: specify variable format, i.e. 10 for decimal, 16 for hex
     :type base: int
 
     :return: Normalized var in string for Python 2, bytes for Python 3, decimal for base10
     """
     try:
         if isinstance(var, str):
-            var = var.encode('ISO-8859-1')
+            var = var.encode("ISO-8859-1")
     except ValueError:
         try:
-            var = var.encode('utf-8')
+            var = var.encode("utf-8")
         except ValueError:
             raise EncodingError("Unknown character '%s' in input format" % var)
 
     if base == 10:
         return int(var)
     elif isinstance(var, list):
         return deepcopy(var)
     else:
         return var
 
 
-def change_base(chars, base_from, base_to, min_length=0, output_even=None, output_as_list=None):
+def change_base(
+    chars, base_from, base_to, min_length=0, output_even=None, output_as_list=None
+):
     """
     Convert input chars from one numeric base to another. For instance from hexadecimal (base-16) to decimal (base-10)
 
     From and to numeric base can be any base. If base is not found in definitions an array of index numbers will be returned
 
     Examples:
 
@@ -230,17 +251,17 @@
             return bytes.fromhex(chars)
     if base_from == 16 and base_to == 10:
         return int(inp, 16)
     if base_from == 10 and base_to == 16:
         hex_outp = hex(inp)[2:]
         return hex_outp.zfill(min_length) if min_length else hex_outp
     if base_from == 256 and base_to == 10:
-        return int.from_bytes(inp, 'big')
+        return int.from_bytes(inp, "big")
     if base_from == 10 and base_to == 256:
-        return inp.to_bytes(min_length, byteorder='big')
+        return inp.to_bytes(min_length, byteorder="big")
     if base_from == 256 and base_to == 58:
         return base58encode(inp)
     if base_from == 16 and base_to == 58:
         return base58encode(bytes.fromhex(chars))
 
     if output_even is None and base_to == 16:
         output_even = True
@@ -257,19 +278,21 @@
                 inp = inp[:-1]
             try:
                 pos = code_str_from.index(item)
             except ValueError:
                 try:
                     pos = code_str_from.index(item.lower())
                 except ValueError:
-                    raise EncodingError("Unknown character %s found in input string" % item)
+                    raise EncodingError(
+                        "Unknown character %s found in input string" % item
+                    )
             input_dec += pos * factor
 
             # Add leading zero if there are leading zero's in input
-            firstchar = chr(code_str_from[0]).encode('utf-8')
+            firstchar = chr(code_str_from[0]).encode("utf-8")
             if not pos * factor:
                 if isinstance(inp, list):
                     if not len([x for x in inp if x != firstchar]):
                         addzeros += 1
                 elif not len(inp.strip(firstchar)):
                     addzeros += 1
             factor *= base_from
@@ -305,43 +328,43 @@
             output = [code_str[0]] + output
 
         # Add leading zero's
         while len(output) < min_length:
             output = [code_str[0]] + output
 
     if not output_as_list and isinstance(output, list):
-        output = 0 if not len(output) else ''.join([chr(c) for c in output])
+        output = 0 if not len(output) else "".join([chr(c) for c in output])
     if base_to == 10:
-        return int(0) or (output != '' and int(output))
+        return int(0) or (output != "" and int(output))
     if base_to == 256 and not output_as_list:
-        return output.encode('ISO-8859-1')
+        return output.encode("ISO-8859-1")
     else:
         return output
 
 
 def base58encode(inp):
     """
     Convert bytes to base58 encode string
 
     :param inp: Input string
     :type inp: bytes
 
     :return str:
     """
     origlen = len(inp)
-    inp = inp.lstrip(b'\0')
+    inp = inp.lstrip(b"\0")
     padding_zeros = origlen - len(inp)
-    code_str = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
-    acc = int.from_bytes(inp, 'big')
+    code_str = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
+    acc = int.from_bytes(inp, "big")
 
-    string = ''
+    string = ""
     while acc:
         acc, idx = divmod(acc, 58)
-        string = code_str[idx:idx + 1] + string
-    return '1' * padding_zeros + string
+        string = code_str[idx : idx + 1] + string
+    return "1" * padding_zeros + string
 
 
 def varbyteint_to_int(byteint):
     """
     Convert CompactSize Variable length integer in byte format to integer.
 
     See https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer for specification
@@ -352,26 +375,26 @@
     :param byteint: 1-9 byte representation
     :type byteint: bytes, list
 
     :return (int, int): tuple wit converted integer and size
     """
     if not isinstance(byteint, (bytes, list)):
         raise EncodingError("Byteint must be a list or defined as bytes")
-    if byteint == b'':
+    if byteint == b"":
         return 0, 0
     ni = byteint[0]
     if ni < 253:
         return ni, 1
     if ni == 253:  # integer of 2 bytes
         size = 2
     elif ni == 254:  # integer of 4 bytes
         size = 4
     else:  # integer of 8 bytes
         size = 8
-    return int.from_bytes(byteint[1:1+size][::-1], 'big'), size + 1
+    return int.from_bytes(byteint[1 : 1 + size][::-1], "big"), size + 1
 
 
 def read_varbyteint(s):
     """
     Read variable length integer from BytesIO stream. Wrapper for the varbyteint_to_int method
 
     :param s: A binary stream
@@ -394,29 +417,29 @@
     :type s: BytesIO
 
     :return (int, bytes):
     """
     pos = s.tell()
     byteint = s.read(9)
     if not byteint:
-        return 0, b''
+        return 0, b""
 
     ni = byteint[0]
     if ni < 253:
         s.seek(pos + 1)
         return ni, byteint[0:1]
     if ni == 253:  # integer of 2 bytes
         size = 2
     elif ni == 254:  # integer of 4 bytes
         size = 4
     else:  # integer of 8 bytes
         size = 8
-    varbytes = byteint[1:1+size]
+    varbytes = byteint[1 : 1 + size]
     s.seek(pos + size + 1)
-    return int.from_bytes(varbytes[::-1], 'big'), byteint[0:1] + varbytes
+    return int.from_bytes(varbytes[::-1], "big"), byteint[0:1] + varbytes
 
 
 def int_to_varbyteint(inp):
     """
     Convert integer to CompactSize Variable length integer in byte format.
 
     See https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer for specification
@@ -427,22 +450,22 @@
     :param inp: Integer to convert
     :type inp: int
 
     :return: byteint: 1-9 byte representation as integer
     """
     if not isinstance(inp, numbers.Number):
         raise EncodingError("Input must be a number type")
-    if inp < 0xfd:
-        return inp.to_bytes(1, 'little')
-    elif inp < 0xffff:
-        return b'\xfd' + inp.to_bytes(2, 'little')
-    elif inp < 0xffffffff:
-        return b'\xfe' + inp.to_bytes(4, 'little')
+    if inp < 0xFD:
+        return inp.to_bytes(1, "little")
+    elif inp < 0xFFFF:
+        return b"\xfd" + inp.to_bytes(2, "little")
+    elif inp < 0xFFFFFFFF:
+        return b"\xfe" + inp.to_bytes(4, "little")
     else:
-        return b'\xff' + inp.to_bytes(8, 'little')
+        return b"\xff" + inp.to_bytes(8, "little")
 
 
 def convert_der_sig(signature, as_hex=True):
     """
     Extract content from DER encoded string: Convert DER encoded signature to signature string.
 
     :param signature: DER signature
@@ -455,19 +478,19 @@
 
     if not signature:
         return ""
     if USE_FASTECDSA:
         r, s = DEREncoder.decode_signature(bytes(signature))
     else:
         sg, junk = ecdsa.der.remove_sequence(signature)
-        if junk != b'':
+        if junk != b"":
             raise EncodingError("Junk found in encoding sequence %s" % junk)
         r, sg = ecdsa.der.remove_integer(sg)
         s, sg = ecdsa.der.remove_integer(sg)
-    sig = '%064x%064x' % (r, s)
+    sig = "%064x%064x" % (r, s)
     if as_hex:
         return sig
     else:
         return bytes.fromhex(sig)
 
 
 def der_encode_sig(r, s):
@@ -501,22 +524,22 @@
     :type as_hex: bool
     :param encoding: Address encoding used: base58 or bech32. Default is base58. Try to derive from address if encoding=None is provided
     :type encoding: str
 
     :return bytes, str: public key hash
     """
 
-    if encoding == 'base58' or encoding is None:
+    if encoding == "base58" or encoding is None:
         try:
             pkh = addr_base58_to_pubkeyhash(address, as_hex)
         except EncodingError:
             pkh = None
         if pkh is not None:
             return pkh
-    if encoding == 'bech32' or encoding is None:
+    if encoding == "bech32" or encoding is None:
         return addr_bech32_to_pubkeyhash(address, as_hex=as_hex)
 
 
 def addr_base58_to_pubkeyhash(address, as_hex=False):
     """
     Convert Base58 encoded address to public key hash
 
@@ -532,19 +555,22 @@
     """
 
     try:
         address = change_base(address, 58, 256, 25)
     except EncodingError as err:
         raise EncodingError("Invalid address %s: %s" % (address, err))
     if len(address) != 25:
-        raise EncodingError("Invalid address hash160 length, should be 25 characters not %d" % len(address))
+        raise EncodingError(
+            "Invalid address hash160 length, should be 25 characters not %d"
+            % len(address)
+        )
     check = address[-4:]
     pkh = address[:-4]
     checksum = double_sha256(pkh)[0:4]
-    assert (check == checksum), "Invalid address, checksum incorrect"
+    assert check == checksum, "Invalid address, checksum incorrect"
     if as_hex:
         return pkh.hex()[2:]
     else:
         return pkh[1:]
 
 
 def addr_bech32_to_pubkeyhash(bech, prefix=None, include_witver=False, as_hex=False):
@@ -563,24 +589,29 @@
     :param include_witver: Include witness version in output? Default is False
     :type include_witver: bool
     :param as_hex: Output public key hash as hex or bytes. Default is False
     :type as_hex: bool
 
     :return str: Public Key Hash
     """
-    if (any(ord(x) < 33 or ord(x) > 126 for x in bech)) or (bech.lower() != bech and bech.upper() != bech):
+    if (any(ord(x) < 33 or ord(x) > 126 for x in bech)) or (
+        bech.lower() != bech and bech.upper() != bech
+    ):
         raise EncodingError("Invalid bech32 character in bech string")
     bech = bech.lower()
-    pos = bech.rfind('1')
+    pos = bech.rfind("1")
     if pos < 1 or pos + 7 > len(bech) or len(bech) > 90:
         raise EncodingError("Invalid bech32 string length")
     if prefix and prefix != bech[:pos]:
-        raise EncodingError("Invalid bech32 address. Prefix '%s', prefix expected is '%s'" % (bech[:pos], prefix))
+        raise EncodingError(
+            "Invalid bech32 address. Prefix '%s', prefix expected is '%s'"
+            % (bech[:pos], prefix)
+        )
     hrp = bech[:pos]
-    data = _codestring_to_array(bech[pos + 1:], 'bech32')
+    data = _codestring_to_array(bech[pos + 1 :], "bech32")
     hrp_expanded = [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]
     check = _bech32_polymod(hrp_expanded + data)
     if not (check == 1 or check == BECH32M_CONST):
         raise EncodingError("Bech polymod check failed")
     if data[0] == 0 and check != 1:
         raise EncodingError("Invalid checksum (Bech32m instead of Bech32)")
     if data[0] != 0 and check != BECH32M_CONST:
@@ -589,15 +620,15 @@
     decoded = bytes(convertbits(data[1:], 5, 8, pad=False))
     if decoded is None or len(decoded) < 2 or len(decoded) > 40:
         raise EncodingError("Invalid decoded data length, must be between 2 and 40")
     if data[0] > 16:
         raise EncodingError("Invalid witness version")
     if data[0] == 0 and len(decoded) not in [20, 32]:
         raise EncodingError("Invalid decoded data length, must be 20 or 32 bytes")
-    prefix = b''
+    prefix = b""
     if include_witver:
         datalen = len(decoded)
         prefix = bytes([data[0] + 0x50 if data[0] else 0, datalen])
     if as_hex:
         return (prefix + decoded).hex()
     return prefix + decoded
 
@@ -613,22 +644,22 @@
     :param bech: Bech32 address to convert
     :type bech: str
 
     :return bool: Bech32 checksum
     """
 
     bech = bech.lower()
-    pos = bech.rfind('1')
+    pos = bech.rfind("1")
     hrp = bech[:pos]
-    data = _codestring_to_array(bech[pos + 1:], 'bech32')
+    data = _codestring_to_array(bech[pos + 1 :], "bech32")
     hrp_expanded = [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]
     return _bech32_polymod(hrp_expanded + data)
 
 
-def pubkeyhash_to_addr(pubkeyhash, prefix=None, encoding='base58', witver=0):
+def pubkeyhash_to_addr(pubkeyhash, prefix=None, encoding="base58", witver=0):
     """
     Convert public key hash to base58 encoded address
 
     Wrapper for the :func:`pubkeyhash_to_addr_base58` and :func:`pubkeyhash_to_addr_bech32` method
 
     :param pubkeyhash: Public key hash
     :type pubkeyhash: bytes, str
@@ -638,27 +669,27 @@
     :type encoding: str
     :param witver: Witness version used. Currently used for Taproot addresses with witver=1. Ignored for base58 addresses
     :type witver: int
 
     :return str: Base58 or bech32 encoded address
 
     """
-    if encoding == 'base58':
+    if encoding == "base58":
         if prefix is None:
-            prefix = b'\x00'
+            prefix = b"\x00"
         return pubkeyhash_to_addr_base58(pubkeyhash, prefix)
-    elif encoding == 'bech32':
+    elif encoding == "bech32":
         if prefix is None:
-            prefix = 'bc'
+            prefix = "bc"
         return pubkeyhash_to_addr_bech32(pubkeyhash, prefix, witver)
     else:
         raise EncodingError("Encoding %s not supported" % encoding)
 
 
-def pubkeyhash_to_addr_base58(pubkeyhash, prefix=b'\x00'):
+def pubkeyhash_to_addr_base58(pubkeyhash, prefix=b"\x00"):
     """
     Convert public key hash to base58 encoded address
 
     >>> pubkeyhash_to_addr_base58('21342f229392d7c9ed82c932916cee6517fbc9a2')
     '142Zp9WZn9Fh4MV8F3H5Dv4Rbg7Ja1sPWZ'
 
     :param pubkeyhash: Public key hash
@@ -669,15 +700,17 @@
     :return str: Base-58 encoded address
     """
     key = to_bytes(prefix) + to_bytes(pubkeyhash)
     addr256 = key + double_sha256(key)[:4]
     return base58encode(addr256)
 
 
-def pubkeyhash_to_addr_bech32(pubkeyhash, prefix='bc', witver=0, separator='1', checksum_xor=1):
+def pubkeyhash_to_addr_bech32(
+    pubkeyhash, prefix="bc", witver=0, separator="1", checksum_xor=1
+):
     """
     Encode public key hash as bech32 encoded (segwit) address
 
     >>> pubkeyhash_to_addr_bech32('21c1bc695a56f47991e95ff26856e50f78d3c118')
     'bc1qy8qmc6262m68ny0ftlexs4h9paud8sgce3sf84'
 
     Format of address is prefix/hrp + seperator + bech32 address + checksum
@@ -719,26 +752,31 @@
     data = [witver] + convertbits(pubkeyhash, 8, 5)
 
     # Expand the HRP into values for checksum computation
     hrp_expanded = [ord(x) >> 5 for x in prefix] + [0] + [ord(x) & 31 for x in prefix]
     polymod = _bech32_polymod(hrp_expanded + data + [0, 0, 0, 0, 0, 0]) ^ checksum_xor
     checksum = [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]
 
-    return prefix + separator + _array_to_codestring(data, 'bech32') + _array_to_codestring(checksum, 'bech32')
+    return (
+        prefix
+        + separator
+        + _array_to_codestring(data, "bech32")
+        + _array_to_codestring(checksum, "bech32")
+    )
 
 
 def _bech32_polymod(values):
     """
     Internal function that computes the Bech32 checksum
     """
-    generator = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
+    generator = [0x3B6A57B2, 0x26508E6D, 0x1EA119FA, 0x3D4233DD, 0x2A1462B3]
     chk = 1
     for value in values:
         top = chk >> 25
-        chk = (chk & 0x1ffffff) << 5 ^ value
+        chk = (chk & 0x1FFFFFF) << 5 ^ value
         for i in range(5):
             chk ^= generator[i] if ((top >> i) & 1) else 0
     return chk
 
 
 def convertbits(data, frombits, tobits, pad=True):
     """
@@ -787,15 +825,15 @@
 
     :param string: String input
     :type string: bytes, str
 
     :return bytes: varstring
     """
     s = normalize_var(string)
-    if s == b'\0':
+    if s == b"\0":
         return s
     return int_to_varbyteint(len(s)) + s
 
 
 def to_bytes(string, unhexlify=True):
     """
     Convert string, hexadecimal string to bytes
@@ -804,27 +842,27 @@
     :type string: str, bytes
     :param unhexlify: Try to unhexlify hexstring
     :type unhexlify: bool
 
     :return: Bytes var
     """
     if not string:
-        return b''
+        return b""
     if unhexlify:
         try:
             if isinstance(string, bytes):
                 string = string.decode()
             s = bytes.fromhex(string)
             return s
         except (TypeError, ValueError):
             pass
     if isinstance(string, bytes):
         return string
     else:
-        return bytes(string, 'utf8')
+        return bytes(string, "utf8")
 
 
 def to_hexstring(string):
     """
     Convert bytes, string to a hexadecimal string. Use instead of built-in hex() method if format
     of input string is not known.
 
@@ -833,44 +871,44 @@
 
     :param string: Variable to convert to hex string
     :type string: bytes, str
 
     :return: hexstring
     """
     if not string:
-        return ''
+        return ""
     try:
         bytes.fromhex(string)
         return string
     except (ValueError, TypeError):
         pass
 
     if not isinstance(string, bytes):
-        string = bytes(string, 'utf8')
+        string = bytes(string, "utf8")
     return string.hex()
 
 
 def normalize_string(string):
     """
     Normalize a string to the default NFKD unicode format
     See https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization
 
     :param string: string value
     :type string: bytes, str
 
     :return: string
     """
     if isinstance(string, bytes):
-        utxt = string.decode('utf8')
+        utxt = string.decode("utf8")
     elif isinstance(string, TYPE_TEXT):
         utxt = string
     else:
         raise TypeError("String value expected")
 
-    return unicodedata.normalize('NFKD', utxt)
+    return unicodedata.normalize("NFKD", utxt)
 
 
 def double_sha256(string, as_hex=False):
     """
     Get double SHA256 hash of string
 
     :param string: String to be hashed
@@ -886,29 +924,75 @@
         return hashlib.sha256(hashlib.sha256(string).digest()).hexdigest()
 
 
 def ripemd160(string):
     try:
         return RIPEMD160.new(string).digest()
     except Exception:
-        return hashlib.new('ripemd160', string).digest()
+        return hashlib.new("ripemd160", string).digest()
 
 
 def hash160(string):
     """
     Creates a RIPEMD-160 + SHA256 hash of the input string
 
     :param string: Script
     :type string: bytes
 
     :return bytes: RIPEMD-160 hash of script
     """
     return ripemd160(hashlib.sha256(string).digest())
 
 
+def aes_encrypt(data, key):
+    """
+    Encrypt data using AES Symmetric Block cipher Encryption in SIV mode (see
+    https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#siv-mode)
+
+    A nonce is not used so data is encrypted deterministic, in SIV mode this doesn't reduce security.
+
+    Method returns a byte string with ciphertext and a 16-byte tag. The ciphertext has the same length as the data.
+
+    Data can be decrypted with the :func:`aes_decrypt` method
+
+    :param data: Data to encrypt
+    :type data: bytes
+    :param key: The cryptographic key, size must be 32 bytes because AES-128 is used as cipher
+    :type key: bytes
+
+    :return bytes: Ciphertext and 16 bytes tag
+
+    """
+    cipher = AES.new(key, AES.MODE_SIV)
+    ct, tag = cipher.encrypt_and_digest(data)
+    return ct + tag
+
+
+def aes_decrypt(encrypted_data, key):
+    """
+    Decrypt encrypted data using AES Symmetric Block cipher Encryption in SIV mode. Use to decrypt data encrypted
+    with the :func:`aes_encrypt` method. The encrypted data attribute must contain a Ciphertext and 16-byte tag.
+
+    A nonce is not used so data is encrypted deterministic, in SIV mode this doesn't reduce security.
+    (see https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#siv-mode)
+
+    :param encrypted_data: Data to decrypt. Must consist of a ciphertext and 16 byte tag.
+    :type encrypted_data: bytes
+    :param key: The cryptographic key, size must be 32 bytes because AES-128 is used as cipher
+    :type key: bytes
+
+    :return bytes: Ciphertext and 16 bytes tag
+
+    """
+    ct = encrypted_data[:-16]
+    tag = encrypted_data[-16:]
+    cipher2 = AES.new(key, AES.MODE_SIV)
+    return cipher2.decrypt_and_verify(ct, tag)
+
+
 def bip38_decrypt(encrypted_privkey, password):
     """
     BIP0038 non-ec-multiply decryption. Returns WIF private key.
     Based on code from https://github.com/nomorecoin/python-bip38-testing
     This method is called by Key class init function when importing BIP0038 key.
 
     :param encrypted_privkey: Encrypted private key using WIF protected key format
@@ -917,22 +1001,24 @@
     :type password: str
 
     :return tupple (bytes, bytes): (Private Key bytes, 4 byte address hash for verification)
     """
     d = change_base(encrypted_privkey, 58, 256)[2:]
     flagbyte = d[0:1]
     d = d[1:]
-    if flagbyte == b'\xc0':
+    if flagbyte == b"\xc0":
         compressed = False
-    elif flagbyte == b'\xe0':
+    elif flagbyte == b"\xe0":
         compressed = True
     else:
-        raise EncodingError("Unrecognised password protected key format. Flagbyte incorrect.")
+        raise EncodingError(
+            "Unrecognised password protected key format. Flagbyte incorrect."
+        )
     if isinstance(password, str):
-        password = password.encode('utf-8')
+        password = password.encode("utf-8")
     addresshash = d[0:4]
     d = d[4:-4]
     try:
         key = scrypt(password, addresshash, 64, 16384, 8, 8)
     except Exception:
         key = scrypt.hash(password, addresshash, 16384, 8, 8, 64)
     derivedhalf1 = key[0:32]
@@ -940,22 +1026,24 @@
     encryptedhalf1 = d[0:16]
     encryptedhalf2 = d[16:32]
     # aes = pyaes.AESModeOfOperationECB(derivedhalf2)
     aes = AES.new(derivedhalf2, AES.MODE_ECB)
     decryptedhalf2 = aes.decrypt(encryptedhalf2)
     decryptedhalf1 = aes.decrypt(encryptedhalf1)
     priv = decryptedhalf1 + decryptedhalf2
-    priv = (int.from_bytes(priv, 'big') ^ int.from_bytes(derivedhalf1, 'big')).to_bytes(32, 'big')
+    priv = (int.from_bytes(priv, "big") ^ int.from_bytes(derivedhalf1, "big")).to_bytes(
+        32, "big"
+    )
     # if compressed:
     #     # FIXME: This works but does probably not follow the BIP38 standards (was before: priv = b'\0' + priv)
     #     priv += b'\1'
     return priv, addresshash, compressed
 
 
-def bip38_encrypt(private_hex, address, password, flagbyte=b'\xe0'):
+def bip38_encrypt(private_hex, address, password, flagbyte=b"\xe0"):
     """
     BIP0038 non-ec-multiply encryption. Returns BIP0038 encrypted private key
     Based on code from https://github.com/nomorecoin/python-bip38-testing
 
     :param private_hex: Private key in hex format
     :type private_hex: str
     :param address: Address string
@@ -964,31 +1052,39 @@
     :type password: str
     :param flagbyte: Flagbyte prefix for WIF
     :type flagbyte: bytes
 
     :return str: BIP38 password encrypted private key
     """
     if isinstance(address, str):
-        address = address.encode('utf-8')
+        address = address.encode("utf-8")
     if isinstance(password, str):
-        password = password.encode('utf-8')
+        password = password.encode("utf-8")
     addresshash = double_sha256(address)[0:4]
     try:
         key = scrypt(password, addresshash, 64, 16384, 8, 8)
     except Exception:
         key = scrypt.hash(password, addresshash, 16384, 8, 8, 64)
     derivedhalf1 = key[0:32]
     derivedhalf2 = key[32:64]
     aes = AES.new(derivedhalf2, AES.MODE_ECB)
     # aes = pyaes.AESModeOfOperationECB(derivedhalf2)
-    encryptedhalf1 = \
-        aes.encrypt((int(private_hex[0:32], 16) ^ int.from_bytes(derivedhalf1[0:16], 'big')).to_bytes(16, 'big'))
-    encryptedhalf2 = \
-        aes.encrypt((int(private_hex[32:64], 16) ^ int.from_bytes(derivedhalf1[16:32], 'big')).to_bytes(16, 'big'))
-    encrypted_privkey = b'\x01\x42' + flagbyte + addresshash + encryptedhalf1 + encryptedhalf2
+    encryptedhalf1 = aes.encrypt(
+        (
+            int(private_hex[0:32], 16) ^ int.from_bytes(derivedhalf1[0:16], "big")
+        ).to_bytes(16, "big")
+    )
+    encryptedhalf2 = aes.encrypt(
+        (
+            int(private_hex[32:64], 16) ^ int.from_bytes(derivedhalf1[16:32], "big")
+        ).to_bytes(16, "big")
+    )
+    encrypted_privkey = (
+        b"\x01\x42" + flagbyte + addresshash + encryptedhalf1 + encryptedhalf2
+    )
     encrypted_privkey += double_sha256(encrypted_privkey)[:4]
     return base58encode(encrypted_privkey)
 
 
 class Quantity:
     """
     Class to convert very large or very small numbers to a readable format.
@@ -997,42 +1093,46 @@
 
     >>> # Example - the Hashrate on 10th July 2020
     >>> str(Quantity(122972532877979100000, 'H/s'))
     '122.973 EH/s'
 
     """
 
-    def __init__(self, value, units='', precision=3):
+    def __init__(self, value, units="", precision=3):
         """
         Convert given value to number between 0 and 1000 and determine metric prefix
 
         :param value: Value as integer in base 0
         :type value: int, float
         :param units: Base units, so 'g' for grams for instance
         :type units: str
         :param precision: Number of digits after the comma
         :type precision: int
 
         """
         # Metric prefixes according to BIPM, the International System of Units (SI) in 10**3 steps
-        self.prefix_list = list('yzafpnm1kMGTPEZY')
-        self.base = self.prefix_list.index('1')
+        self.prefix_list = list("yzafpnm1kMGTPEZY")
+        self.base = self.prefix_list.index("1")
         assert value >= 0
 
         self.absolute = value
         self.units = units
         self.precision = precision
-        while value != 0 and (value < 1 or value > 1000) and 0 < self.base < len(self.prefix_list)-1:
+        while (
+            value != 0
+            and (value < 1 or value > 1000)
+            and 0 < self.base < len(self.prefix_list) - 1
+        ):
             if value > 1000:
                 self.base += 1
                 value /= 1000.0
             elif value < 1000:
                 self.base -= 1
                 value *= 1000.0
         self.value = value
 
     def __str__(self):
         # > Python 3.6: return f"{self.value:4.{self.precision}f} {self.prefix_list[self.base]}{self.units}"
         prefix = self.prefix_list[self.base]
-        if prefix == '1':
-            prefix = ''
-        return ('%4.*f %s%s' % (self.precision, self.value, prefix, self.units)).strip()
+        if prefix == "1":
+            prefix = ""
+        return ("%4.*f %s%s" % (self.precision, self.value, prefix, self.units)).strip()
```

### Comparing `fluxwallet-0.0.6/fluxwallet/flux_transaction.py` & `fluxwallet-0.1.0/fluxwallet/flux_transaction.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import struct
 from dataclasses import dataclass
 from hashlib import blake2b
 from io import BytesIO
 from typing import BinaryIO
+
 from fluxwallet.encoding import read_varbyteint
 
 MAX_MONEY = 21000000 * 100000000
 TX_EXPIRY_HEIGHT_THRESHOLD = 500000000
 
 OVERWINTER_VERSION_GROUP_ID = 0x03C4827
 OVERWINTER_TX_VERSION = 3
@@ -25,17 +26,14 @@
 
 SIGHASH_ALL = 1
 SIGHASH_NONE = 2
 SIGHASH_SINGLE = 3
 SIGHASH_ANYONECANPAY = 0x80
 
 
-
-
-
 def write_compact_size(n, allow_u64=False):
     assert allow_u64 or n <= MAX_COMPACT_SIZE
     if n < 253:
         return struct.pack("B", n)
     elif n <= 0xFFFF:
         return struct.pack("B", 253) + struct.pack("<H", n)
     elif n <= 0xFFFFFFFF:
@@ -51,15 +49,15 @@
     def __bool__(self):
         return bool(self._script)
 
     def __bytes__(self):
         return write_compact_size(len(self._script)) + self._script
 
     @staticmethod
-    def encode(operations: list):
+    def encode(operations: list) -> bytes:
         encoded = b""
         for op in operations:
             if isinstance(op, int):
                 encoded += op.to_bytes(1, "big")
             else:
                 encoded += write_compact_size(len(op)) + op
         return encoded
@@ -155,15 +153,15 @@
     nValue: int
     script: Script
 
     def __bytes__(self):
         return struct.pack("<Q", self.nValue) + bytes(self.script)
 
 
-class SaplingTx(object):
+class SaplingTx:
     def __init__(
         self,
         version,
         vin: list[TxIn] = [],
         vout: list[TxOut] = [],
         nLockTime: int = 0,
         nExpiryHeight: int = 0,
@@ -176,15 +174,15 @@
             self.nVersionGroupId = OVERWINTER_VERSION_GROUP_ID
             self.nVersion = OVERWINTER_TX_VERSION
         elif version == SAPLING_TX_VERSION:
             self.fOverwintered = True
             self.nVersionGroupId = SAPLING_VERSION_GROUP_ID
             self.nVersion = SAPLING_TX_VERSION
         else:
-            raise Exception("Unsupported version")
+            raise Exception(f"Version: {version} not supported for SaplingTx")
 
         self.vin = []
         for tx in vin:
             self.vin.append(tx)
 
         self.vout = []
         for tx in vout:
@@ -261,74 +259,73 @@
 
     def __repr__(self):
         resp = ""
         for k, v in self.__dict__.items():
             resp += f"{k}: {v}\n"
         return resp
 
-
     def version_bytes(self):
         return self.nVersion | (1 << 31 if self.fOverwintered else 0)
 
     def getHashPrevouts(self, person=b"ZcashPrevoutHash"):
         digest = blake2b(digest_size=32, person=person)
 
         for x in self.vin:
             digest.update(bytes(x.prevout))
         return digest.digest()
 
-
     def getHashSequence(self, person=b"ZcashSequencHash"):
         digest = blake2b(digest_size=32, person=person)
 
         for x in self.vin:
             digest.update(struct.pack("<I", x.nSequence))
         return digest.digest()
 
-
     def getHashOutputs(self, person=b"ZcashOutputsHash"):
         digest = blake2b(digest_size=32, person=person)
         for x in self.vout:
             digest.update(bytes(x))
         return digest.digest()
 
-
     def getHashJoinSplits(self):
         digest = blake2b(digest_size=32, person=b"ZcashJSplitsHash")
         for jsdesc in self.vJoinSplit:
             digest.update(bytes(jsdesc))
         digest.update(self.joinSplitPubKey)
         return digest.digest()
 
-
     def getHashShieldedSpends(self):
         digest = blake2b(digest_size=32, person=b"ZcashSSpendsHash")
         for desc in self.vShieldedSpends:
             # We don't pass in serialized form of desc as spendAuthSig is not part of the hash
             digest.update(bytes(desc.cv))
             digest.update(bytes(desc.anchor))
             digest.update(desc.nullifier)
             digest.update(bytes(desc.rk))
             digest.update(bytes(desc.proof))
         return digest.digest()
 
-
     def getHashShieldedOutputs(self):
         digest = blake2b(digest_size=32, person=b"ZcashSOutputHash")
         for desc in self.vShieldedOutputs:
             digest.update(bytes(desc))
         return digest.digest()
 
-
-    def signature_hash(self, script_code: bytes, value: int, input_n: int, nIn: int, hash_type: str=SIGHASH_ALL) -> bytes:
+    def signature_hash(
+        self,
+        script_code: bytes,
+        value: int,
+        input_n: int,
+        nIn: int,
+        hash_type: str = SIGHASH_ALL,
+    ) -> bytes:
         consensusBranchId = 0x76B809BB  # Sapling
         if input_n == None:
             return b""
 
-
         # this is zip243
         hashPrevouts = b"\x00" * 32
         hashSequence = b"\x00" * 32
         hashOutputs = b"\x00" * 32
         hashJoinSplits = b"\x00" * 32
         hashShieldedSpends = b"\x00" * 32
         hashShieldedOutputs = b"\x00" * 32
@@ -387,8 +384,8 @@
 
         digest.update(bytes(self.vin[input_n].prevout))
         digest.update(write_compact_size(len(script_code)) + script_code)
         digest.update(struct.pack("<Q", value))
 
         digest.update(struct.pack("<I", self.vin[input_n].nSequence))
 
-        return digest.digest()
+        return digest.digest()
```

### Comparing `fluxwallet-0.0.6/fluxwallet/keys.py` & `fluxwallet-0.1.0/fluxwallet/keys.py`

 * *Files 10% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import collections
 import hmac
 import json
 import random
+import time
 
 from fluxwallet.config.secp256k1 import *
 from fluxwallet.encoding import *
 from fluxwallet.mnemonic import Mnemonic
 from fluxwallet.networks import Network, network_by_value, wif_prefix_search
 
 rfc6979_warning_given = False
@@ -35,34 +36,38 @@
     from fastecdsa import point as fastecdsa_point
     from fastecdsa.curve import secp256k1 as fastecdsa_secp256k1
     from fastecdsa.util import RFC6979
 else:
     import ecdsa
 
     secp256k1_curve = ecdsa.ellipticcurve.CurveFp(secp256k1_p, secp256k1_a, secp256k1_b)
-    secp256k1_generator = ecdsa.ellipticcurve.Point(secp256k1_curve, secp256k1_Gx, secp256k1_Gy, secp256k1_n)
+    secp256k1_generator = ecdsa.ellipticcurve.Point(
+        secp256k1_curve, secp256k1_Gx, secp256k1_Gy, secp256k1_n
+    )
 
 _logger = logging.getLogger(__name__)
 
 
 class BKeyError(Exception):
     """
     Handle Key class Exceptions
 
     """
 
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.error(msg)
 
     def __str__(self):
         return self.msg
 
 
-def check_network_and_key(key, network=None, kf_networks=None, default_network=DEFAULT_NETWORK):
+def check_network_and_key(
+    key, network=None, kf_networks=None, default_network=DEFAULT_NETWORK
+):
     """
     Check if given key corresponds with given network and return network if it does. If no network is specified
     this method tries to extract the network from the key. If no network can be extracted from the key the
     default network will be returned.
 
     >>> check_network_and_key('L4dTuJf2ceEdWDvCPsLhYf8GiiuYqXtqfbcKdC21BPDvEM1ykJRC')
     'bitcoin'
@@ -78,27 +83,33 @@
     :param default_network: Specify different default network, leave empty for default (bitcoin)
     :type default_network: str, None
 
     :return str: Network name
     """
     if not kf_networks:
         kf = get_key_format(key)
-        if kf['networks']:
-            kf_networks = kf['networks']
+        if kf["networks"]:
+            kf_networks = kf["networks"]
     if kf_networks:
         if network is not None and network not in kf_networks:
-            raise BKeyError("Specified key %s is from different network then specified: %s" % (kf_networks, network))
+            raise BKeyError(
+                "Specified key %s is from different network then specified: %s"
+                % (kf_networks, network)
+            )
         elif network is None and len(kf_networks) == 1:
             return kf_networks[0]
         elif network is None and len(kf_networks) > 1:
             if default_network in kf_networks:
                 return default_network
-            elif 'testnet' in kf_networks:
-                return 'testnet'
-            raise BKeyError("Could not determine network of specified key, multiple networks found: %s" % kf_networks)
+            elif "testnet" in kf_networks:
+                return "testnet"
+            raise BKeyError(
+                "Could not determine network of specified key, multiple networks found: %s"
+                % kf_networks
+            )
     if network is None:
         return default_network
     else:
         return network
 
 
 def get_key_format(key, is_private=None):
@@ -124,112 +135,121 @@
     :return dict: Dictionary with format, network and is_private
     """
     if not key:
         raise BKeyError("Key empty, please specify a valid key")
     key_format = ""
     networks = None
     script_types = []
-    witness_types = ['legacy']
+    witness_types = ["legacy"]
     multisig = [False]
 
     # if isinstance(key, bytes) and len(key) in [128, 130]:
     #     key = to_hexstring(key)
     if not (is_private is None or isinstance(is_private, bool)):
         raise BKeyError("Attribute 'is_private' must be False or True")
     elif isinstance(key, numbers.Number):
-        key_format = 'decimal'
+        key_format = "decimal"
         is_private = True
-    elif isinstance(key, bytes) and len(key) in [33, 65] and key[:1] in [b'\2', b'\3']:
-        key_format = 'bin_compressed'
+    elif isinstance(key, bytes) and len(key) in [33, 65] and key[:1] in [b"\2", b"\3"]:
+        key_format = "bin_compressed"
         is_private = False
-    elif isinstance(key, bytes) and (len(key) in [33, 65] and key[:1] == b'\4'):
-        key_format = 'bin'
+    elif isinstance(key, bytes) and (len(key) in [33, 65] and key[:1] == b"\4"):
+        key_format = "bin"
         is_private = False
-    elif isinstance(key, bytes) and len(key) == 33 and key[-1:] == b'\1':
-        key_format = 'bin_compressed'
+    elif isinstance(key, bytes) and len(key) == 33 and key[-1:] == b"\1":
+        key_format = "bin_compressed"
         is_private = True
     elif isinstance(key, bytes) and len(key) == 32:
-        key_format = 'bin'
+        key_format = "bin"
         is_private = True
-    elif len(key) == 130 and key[:2] == '04' and not is_private:
-        key_format = 'public_uncompressed'
+    elif len(key) == 130 and key[:2] == "04" and not is_private:
+        key_format = "public_uncompressed"
         is_private = False
     elif len(key) == 128:
-        key_format = 'hex'
+        key_format = "hex"
         if is_private is None:
             is_private = True
-    elif len(key) == 66 and key[:2] in ['02', '03'] and not is_private:
-        key_format = 'public'
+    elif len(key) == 66 and key[:2] in ["02", "03"] and not is_private:
+        key_format = "public"
         is_private = False
     elif len(key) == 64:
-        key_format = 'hex'
+        key_format = "hex"
         if is_private is None:
             is_private = True
-    elif len(key) == 66 and key[-2:] in ['01'] and not (is_private is False):
-        key_format = 'hex_compressed'
+    elif len(key) == 66 and key[-2:] in ["01"] and not (is_private is False):
+        key_format = "hex_compressed"
         is_private = True
-    elif len(key) == 58 and key[:2] == '6P':
-        key_format = 'wif_protected'
+    elif len(key) == 58 and key[:2] == "6P":
+        key_format = "wif_protected"
         is_private = True
-    elif isinstance(key, TYPE_TEXT) and len(key.split(' ')) > 1:
-        key_format = 'mnemonic'
+    elif isinstance(key, TYPE_TEXT) and len(key.split(" ")) > 1:
+        key_format = "mnemonic"
         is_private = True
     else:
         try:
             key_hex = change_base(key, 58, 16)
             prefix_data = wif_prefix_search(key_hex[:8])
             if prefix_data:
-                networks = list(dict.fromkeys([n['network'] for n in prefix_data]))
-                if is_private is None and len(set([n['is_private'] for n in prefix_data])) > 1:
-                    raise BKeyError("Cannot determine if key is private or public, please specify is_private "
-                                    "attribute")
-                is_private = prefix_data[0]['is_private']
-                script_types = list(dict.fromkeys([n['script_type'] for n in prefix_data]))
-                witness_types = list(dict.fromkeys([n['witness_type'] for n in prefix_data]))
-                multisig = list(dict.fromkeys([n['multisig'] for n in prefix_data]))
-                key_format = 'hdkey_public'
+                networks = list(dict.fromkeys([n["network"] for n in prefix_data]))
+                if (
+                    is_private is None
+                    and len(set([n["is_private"] for n in prefix_data])) > 1
+                ):
+                    raise BKeyError(
+                        "Cannot determine if key is private or public, please specify is_private "
+                        "attribute"
+                    )
+                is_private = prefix_data[0]["is_private"]
+                script_types = list(
+                    dict.fromkeys([n["script_type"] for n in prefix_data])
+                )
+                witness_types = list(
+                    dict.fromkeys([n["witness_type"] for n in prefix_data])
+                )
+                multisig = list(dict.fromkeys([n["multisig"] for n in prefix_data]))
+                key_format = "hdkey_public"
                 if is_private:
-                    key_format = 'hdkey_private'
+                    key_format = "hdkey_private"
             else:
-                networks = network_by_value('prefix_wif', key_hex[:2])
+                networks = network_by_value("prefix_wif", key_hex[:2])
                 if networks:
-                    if key_hex[-10:-8] == '01':
-                        key_format = 'wif_compressed'
+                    if key_hex[-10:-8] == "01":
+                        key_format = "wif_compressed"
                     else:
-                        key_format = 'wif'
+                        key_format = "wif"
                     is_private = True
         except (TypeError, EncodingError):
             pass
     if not key_format:
         try:
             int(key)
             if 70 < len(key) < 78:
-                key_format = 'decimal'
+                key_format = "decimal"
                 is_private = True
         except (TypeError, ValueError):
             pass
     if not key_format:
         try:
             da = deserialize_address(key)
-            key_format = 'address'
-            networks = da['network']
+            key_format = "address"
+            networks = da["network"]
             is_private = False
-            script_types = da['script_type']
+            script_types = da["script_type"]
         except (EncodingError, TypeError):
             pass
     if not key_format:
         raise BKeyError("Unrecognised key format")
     else:
         return {
             "format": key_format,
             "networks": networks,
             "is_private": is_private,
             "script_types": script_types,
             "witness_types": witness_types,
-            "multisig": multisig
+            "multisig": multisig,
         }
 
 
 def deserialize_address(address, encoding=None, network=None):
     """
     Deserialize address. Calculate public key hash and try to determine script type and network.
 
@@ -247,85 +267,96 @@
     :param encoding: Encoding scheme used for address encoding. Attempts to guess encoding if not specified.
     :type encoding: str
     :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network
     :type network: str
 
     :return dict: with information about this address
     """
-    if encoding is None or encoding == 'base58':
+    if encoding is None or encoding == "base58":
         try:
             address_bytes = change_base(address, 58, 256, 25)
         except EncodingError:
             pass
         else:
             check = address_bytes[-4:]
             key_hash = address_bytes[:-4]
             checksum = double_sha256(key_hash)[0:4]
-            if check != checksum and encoding == 'base58':
+            if check != checksum and encoding == "base58":
                 raise BKeyError("Invalid address %s, checksum incorrect" % address)
             elif check == checksum:
                 address_prefix = key_hash[0:2]
-                networks_p2pkh = network_by_value('prefix_address', address_prefix.hex())
-                networks_p2sh = network_by_value('prefix_address_p2sh', address_prefix.hex())
+                networks_p2pkh = network_by_value(
+                    "prefix_address", address_prefix.hex()
+                )
+                networks_p2sh = network_by_value(
+                    "prefix_address_p2sh", address_prefix.hex()
+                )
                 public_key_hash = key_hash[2:]
-                script_type = ''
-                witness_type = ''
+                script_type = ""
+                witness_type = ""
                 networks = []
                 if networks_p2pkh and not networks_p2sh:
-                    script_type = 'p2pkh'
-                    witness_type = 'legacy'
+                    script_type = "p2pkh"
+                    witness_type = "legacy"
                     networks = networks_p2pkh
                 elif networks_p2sh:
-                    script_type = 'p2sh'
+                    script_type = "p2sh"
                     networks = networks_p2sh
                 if network:
                     if network not in networks:
-                        raise BKeyError("Network %s not found in extracted networks: %s" % (network, networks))
+                        raise BKeyError(
+                            "Network %s not found in extracted networks: %s"
+                            % (network, networks)
+                        )
                 elif len(networks) >= 1:
                     network = networks[0]
                 return {
-                    'address': address,
-                    'encoding': 'base58',
-                    'public_key_hash': '' if not public_key_hash else public_key_hash.hex(),
-                    'public_key_hash_bytes': public_key_hash,
-                    'prefix': address_prefix,
-                    'network': network,
-                    'script_type': script_type,
-                    'witness_type': witness_type,
-                    'networks': networks,
-                    'witver': None,
+                    "address": address,
+                    "encoding": "base58",
+                    "public_key_hash": ""
+                    if not public_key_hash
+                    else public_key_hash.hex(),
+                    "public_key_hash_bytes": public_key_hash,
+                    "prefix": address_prefix,
+                    "network": network,
+                    "script_type": script_type,
+                    "witness_type": witness_type,
+                    "networks": networks,
+                    "witver": None,
                 }
-    if encoding == 'bech32' or encoding is None:
+    if encoding == "bech32" or encoding is None:
         try:
             pkh_incl = addr_bech32_to_pubkeyhash(address, include_witver=True)
             public_key_hash = pkh_incl[2:]
             witver = pkh_incl[0] - 0x50 if pkh_incl[0] else 0
-            prefix = address[:address.rfind('1')]
-            networks = network_by_value('prefix_bech32', prefix)
-            witness_type = 'segwit' if not witver else 'taproot'
+            prefix = address[: address.rfind("1")]
+            networks = network_by_value("prefix_bech32", prefix)
+            witness_type = "segwit" if not witver else "taproot"
             if len(public_key_hash) == 20:
-                script_type = 'p2wpkh'
+                script_type = "p2wpkh"
             else:
-                script_type = 'p2wsh' if not witver else 'p2tr'
+                script_type = "p2wsh" if not witver else "p2tr"
             return {
-                'address': address,
-                'encoding': 'bech32',
-                'public_key_hash': '' if not public_key_hash else public_key_hash.hex(),
-                'public_key_hash_bytes': public_key_hash,
-                'prefix': prefix,
-                'network': '' if not networks else networks[0],
-                'script_type': script_type,
-                'witness_type': witness_type,
-                'networks': networks,
-                'witver': witver,
+                "address": address,
+                "encoding": "bech32",
+                "public_key_hash": "" if not public_key_hash else public_key_hash.hex(),
+                "public_key_hash_bytes": public_key_hash,
+                "prefix": prefix,
+                "network": "" if not networks else networks[0],
+                "script_type": script_type,
+                "witness_type": witness_type,
+                "networks": networks,
+                "witver": witver,
             }
         except EncodingError as err:
             raise EncodingError("Invalid address %s: %s" % (address, err))
     else:
-        raise EncodingError("Address %s is not in specified encoding %s" % (address, encoding))
+        raise EncodingError(
+            "Address %s is not in specified encoding %s" % (address, encoding)
+        )
 
 
 def addr_convert(addr, prefix, encoding=None, to_encoding=None):
     """
     Convert address to another encoding and/or address with another prefix.
 
     >>> addr_convert('1GMDUKLom6bJuY37RuFNc6PHv1rv2Hziuo', prefix='bc', to_encoding='bech32')
@@ -341,25 +372,36 @@
     :type to_encoding: str
 
     :return str: New converted address
     """
 
     if encoding is None:
         da = deserialize_address(addr)
-        encoding = da['encoding']
+        encoding = da["encoding"]
     pkh = addr_to_pubkeyhash(addr, encoding=encoding)
     if to_encoding is None:
         to_encoding = encoding
-    if isinstance(prefix, TYPE_TEXT) and to_encoding == 'base58':
+    if isinstance(prefix, TYPE_TEXT) and to_encoding == "base58":
         prefix = to_hexstring(prefix)
     return pubkeyhash_to_addr(pkh, prefix=prefix, encoding=to_encoding)
 
 
-def path_expand(path, path_template=None, level_offset=None, account_id=0, cosigner_id=0, purpose=44,
-                address_index=0, change=0, witness_type=DEFAULT_WITNESS_TYPE, multisig=False, network=DEFAULT_NETWORK):
+def path_expand(
+    path,
+    path_template=None,
+    level_offset=None,
+    account_id=0,
+    cosigner_id=0,
+    purpose=44,
+    address_index=0,
+    change=0,
+    witness_type=DEFAULT_WITNESS_TYPE,
+    multisig=False,
+    network=DEFAULT_NETWORK,
+):
     """
     Create key path. Specify part of key path and path settings
 
     >>> path_expand([10, 20], witness_type='segwit')
     ['m', "84'", "0'", "0'", '10', '20']
 
     :param path: Part of path, for example [0, 2] for change=0 and address_index=2
@@ -384,31 +426,40 @@
     :type multisig: bool
     :param network: Network name. Leave empty for default network
     :type network: str
 
     :return list:
     """
     if isinstance(path, TYPE_TEXT):
-        path = path.split('/')
+        path = path.split("/")
     if not path_template:
-        ks = [k for k in WALLET_KEY_STRUCTURES if
-              k['witness_type'] == witness_type and k['multisig'] == multisig and k['purpose'] is not None]
+        ks = [
+            k
+            for k in WALLET_KEY_STRUCTURES
+            if k["witness_type"] == witness_type
+            and k["multisig"] == multisig
+            and k["purpose"] is not None
+        ]
         if ks:
-            purpose = ks[0]['purpose']
-            path_template = ks[0]['key_path']
+            purpose = ks[0]["purpose"]
+            path_template = ks[0]["key_path"]
     if not isinstance(path, list):
-        raise BKeyError("Please provide path as list with at least 1 item. Wallet key path format is %s" %
-                        path_template)
+        raise BKeyError(
+            "Please provide path as list with at least 1 item. Wallet key path format is %s"
+            % path_template
+        )
     if len(path) > len(path_template):
-        raise BKeyError("Invalid path provided. Path should be shorter than %d items. "
-                        "Wallet key path format is %s" % (len(path_template), path_template))
+        raise BKeyError(
+            "Invalid path provided. Path should be shorter than %d items. "
+            "Wallet key path format is %s" % (len(path_template), path_template)
+        )
 
     # If path doesn't start with m/M complement path
     poppath = deepcopy(path)
-    if path == [] or path[0] not in ['m', 'M']:
+    if path == [] or path[0] not in ["m", "M"]:
         wallet_key_path = path_template
         if level_offset:
             wallet_key_path = wallet_key_path[:level_offset]
         new_path = []
         for pi in wallet_key_path[::-1]:
             if not len(poppath):
                 new_path.append(pi)
@@ -416,86 +467,69 @@
                 new_path.append(poppath.pop())
         new_path = new_path[::-1]
     else:
         new_path = deepcopy(path)
 
     # Replace variable names in path with corresponding values
     # network, account_id, _ = self._get_account_defaults(network, account_id)
-    script_type_id = 1 if witness_type == 'p2sh-segwit' else 2
+    script_type_id = 1 if witness_type == "p2sh-segwit" else 2
     var_defaults = {
-        'network': network,
-        'account': account_id,
-        'purpose': purpose,
-        'coin_type': Network(network).bip44_cointype,
-        'script_type': script_type_id,
-        'cosigner_index': cosigner_id,
-        'change': change,
-        'address_index': address_index
+        "network": network,
+        "account": account_id,
+        "purpose": purpose,
+        "coin_type": Network(network).bip44_cointype,
+        "script_type": script_type_id,
+        "cosigner_index": cosigner_id,
+        "change": change,
+        "address_index": address_index,
     }
     npath = new_path
     for i, pi in enumerate(new_path):
         if not isinstance(pi, TYPE_TEXT):
             pi = str(pi)
         if pi in "mM":
             continue
         hardened = False
         varname = pi
         if pi[-1:] == "'" or (pi[-1:] in "HhPp" and pi[:-1].isdigit()):
             varname = pi[:-1]
             hardened = True
         if path_template[i][-1:] == "'":
             hardened = True
-        new_varname = (str(var_defaults[varname]) if varname in var_defaults else varname)
+        new_varname = str(var_defaults[varname]) if varname in var_defaults else varname
         if new_varname == varname and not new_varname.isdigit():
-            raise BKeyError("Variable %s not found in Key structure definitions in main.py" % varname)
-        if varname == 'address_index' and address_index is None:
+            raise BKeyError(
+                "Variable %s not found in Key structure definitions in main.py"
+                % varname
+            )
+        if varname == "address_index" and address_index is None:
             raise BKeyError("Please provide value for 'address_index' or 'path'")
-        npath[i] = new_varname + ("'" if hardened else '')
+        npath[i] = new_varname + ("'" if hardened else "")
     if "None'" in npath or "None" in npath:
         raise BKeyError("Could not parse all variables in path %s" % npath)
     return npath
 
 
 class Address(object):
     """
     Class to store, convert and analyse various address types as representation of public keys or scripts hashes
     """
 
     @classmethod
-    @deprecated
-    def import_address(cls, address, compressed=None, encoding=None, depth=None, change=None,
-                       address_index=None, network=None, network_overrides=None):
-        """
-        Import an address to the Address class. Specify network if available, otherwise it will be
-        derived form the address.
-
-        :param address: Address to import
-        :type address: str
-        :param compressed: Is key compressed or not, default is None
-        :type compressed: bool
-        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding. Leave empty to derive from address
-        :type encoding: str
-        :param depth: Level of depth in BIP32 key path
-        :type depth: int
-        :param change: Use 0 for normal address/key, and 1 for change address (for returned/change payments)
-        :type change: int
-        :param address_index: Index of address. Used in BIP32 key paths
-        :type address_index: int
-        :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network
-        :type network: str
-        :param network_overrides: Override network settings for specific prefixes, i.e.: {"prefix_address_p2sh": "32"}. Used by settings in providers.json
-        :type network_overrides: dict
-
-        :return Address:
-        """
-        return cls.parse(address, compressed, encoding, depth, change, address_index, network, network_overrides)
-
-    @classmethod
-    def parse(cls, address, compressed=None, encoding=None, depth=None, change=None,
-              address_index=None, network=None, network_overrides=None):
+    def parse(
+        cls,
+        address,
+        compressed=None,
+        encoding=None,
+        depth=None,
+        change=None,
+        address_index=None,
+        network=None,
+        network_overrides=None,
+    ):
         """
         Import an address to the Address class. Specify network if available, otherwise it will be
         derived form the address.
 
         >>> addr = Address.parse('bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3')
         >>> addr.as_dict()
         {'network': 'bitcoin', '_data': None, 'script_type': 'p2wsh', 'encoding': 'bech32', 'compressed': None, 'witver': 0, 'witness_type': 'segwit', 'depth': None, 'change': None, 'address_index': None, 'prefix': 'bc', 'redeemscript': '', '_hashed_data': None, 'address': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3', 'address_orig': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3'}
@@ -516,28 +550,49 @@
         :type network: str
         :param network_overrides: Override network settings for specific prefixes, i.e.: {"prefix_address_p2sh": "32"}. Used by settings in providers.json
         :type network_overrides: dict
 
         :return Address:
         """
         if encoding is None and address[:3].split("1")[0] in ENCODING_BECH32_PREFIXES:
-            encoding = 'bech32'
+            encoding = "bech32"
         addr_dict = deserialize_address(address, encoding=encoding, network=network)
-        public_key_hash_bytes = addr_dict['public_key_hash_bytes']
-        prefix = addr_dict['prefix']
+        public_key_hash_bytes = addr_dict["public_key_hash_bytes"]
+        prefix = addr_dict["prefix"]
         if network is None:
-            network = addr_dict['network']
-        script_type = addr_dict['script_type']
-        return Address(hashed_data=public_key_hash_bytes, prefix=prefix, script_type=script_type,
-                       compressed=compressed, encoding=addr_dict['encoding'], depth=depth, change=change,
-                       address_index=address_index, network=network, network_overrides=network_overrides)
-
-    def __init__(self, data='', hashed_data='', prefix=None, script_type=None,
-                 compressed=None, encoding=None, witness_type=None, depth=None, change=None,
-                 address_index=None, network=DEFAULT_NETWORK, network_overrides=None):
+            network = addr_dict["network"]
+        script_type = addr_dict["script_type"]
+        return Address(
+            hashed_data=public_key_hash_bytes,
+            prefix=prefix,
+            script_type=script_type,
+            compressed=compressed,
+            encoding=addr_dict["encoding"],
+            depth=depth,
+            change=change,
+            address_index=address_index,
+            network=network,
+            network_overrides=network_overrides,
+        )
+
+    def __init__(
+        self,
+        data="",
+        hashed_data="",
+        prefix=None,
+        script_type=None,
+        compressed=None,
+        encoding=None,
+        witness_type=None,
+        depth=None,
+        change=None,
+        address_index=None,
+        network=DEFAULT_NETWORK,
+        network_overrides=None,
+    ):
         """
         Initialize an Address object. Specify a public key, redeemscript or a hash.
 
         >>> addr = Address('03715219f51a2681b7642d1e0e35f61e5288ff59b87d275be9eaf1a5f481dcdeb6', encoding='bech32', script_type='p2wsh')
         >>> addr.address
         'bc1qaehsuffn0stxmugx3z69z9hm6gnjd9qzeqlfv92cpf5adw63x4tsfl7vwl'
 
@@ -557,79 +612,97 @@
         :type network: str, Network
         :param network_overrides: Override network settings for specific prefixes, i.e.: {"prefix_address_p2sh": "32"}. Used by settings in providers.json
         :type network_overrides: dict
 
         """
         self.network = network
         if not (data or hashed_data):
-            raise BKeyError("Please specify data (public key or script) or hashed_data argument")
+            raise BKeyError(
+                "Please specify data (public key or script) or hashed_data argument"
+            )
         if not isinstance(network, Network):
             self.network = Network(network)
         self.data_bytes = to_bytes(data)
         self._data = None
         self.script_type = script_type
         self.encoding = encoding
         self.compressed = compressed
         self.witver = 0
         if witness_type is None:
-            if self.script_type in ['p2wpkh', 'p2wsh']:
-                witness_type = 'segwit'
-            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:
-                witness_type = 'p2sh-segwit'
-            elif self.script_type == 'p2tr':
-                witness_type = 'taproot'
+            if self.script_type in ["p2wpkh", "p2wsh"]:
+                witness_type = "segwit"
+            elif self.script_type in ["p2sh_p2wpkh", "p2sh_p2wsh"]:
+                witness_type = "p2sh-segwit"
+            elif self.script_type == "p2tr":
+                witness_type = "taproot"
                 self.witver = 1
         self.witness_type = witness_type
         self.depth = depth
         self.change = change
         self.address_index = address_index
 
         if self.encoding is None:
-            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr'] or self.witness_type == 'segwit':
-                self.encoding = 'bech32'
+            if (
+                self.script_type in ["p2wpkh", "p2wsh", "p2tr"]
+                or self.witness_type == "segwit"
+            ):
+                self.encoding = "bech32"
             else:
-                self.encoding = 'base58'
+                self.encoding = "base58"
         self.hash_bytes = to_bytes(hashed_data)
         self.prefix = prefix
-        self.redeemscript = b''
+        self.redeemscript = b""
         if not self.hash_bytes:
-            if (self.encoding == 'bech32' and self.script_type in ['p2sh', 'p2sh_multisig', 'p2tr']) or \
-                    self.script_type in ['p2wsh', 'p2sh_p2wsh']:
+            if (
+                self.encoding == "bech32"
+                and self.script_type in ["p2sh", "p2sh_multisig", "p2tr"]
+            ) or self.script_type in ["p2wsh", "p2sh_p2wsh"]:
                 self.hash_bytes = hashlib.sha256(self.data_bytes).digest()
             else:
                 self.hash_bytes = hash160(self.data_bytes)
         self._hashed_data = None
-        if self.encoding == 'base58':
+        if self.encoding == "base58":
             if self.script_type is None:
-                self.script_type = 'p2pkh'
-            if self.witness_type == 'p2sh-segwit':
-                self.redeemscript = b'\0' + varstr(self.hash_bytes)
+                self.script_type = "p2pkh"
+            if self.witness_type == "p2sh-segwit":
+                self.redeemscript = b"\0" + varstr(self.hash_bytes)
                 # overwrite hash_bytes with hash of redeemscript
                 self.hash_bytes = hash160(self.redeemscript)
             if self.prefix is None:
-                if self.script_type in ['p2sh', 'p2sh_p2wpkh', 'p2sh_p2wsh', 'p2sh_multisig'] or \
-                        self.witness_type == 'p2sh-segwit':
+                if (
+                    self.script_type
+                    in ["p2sh", "p2sh_p2wpkh", "p2sh_p2wsh", "p2sh_multisig"]
+                    or self.witness_type == "p2sh-segwit"
+                ):
                     self.prefix = self.network.prefix_address_p2sh
                 else:
                     self.prefix = self.network.prefix_address
             else:
                 self.prefix = to_bytes(prefix)
-        elif self.encoding == 'bech32':
+        elif self.encoding == "bech32":
             if self.script_type is None:
-                self.script_type = 'p2wpkh'
+                self.script_type = "p2wpkh"
             if self.prefix is None:
                 self.prefix = self.network.prefix_bech32
         else:
             raise BKeyError("Encoding %s not supported" % self.encoding)
-        self.address = pubkeyhash_to_addr(self.hash_bytes, prefix=self.prefix, encoding=self.encoding,
-                                          witver=self.witver)
+        self.address = pubkeyhash_to_addr(
+            self.hash_bytes,
+            prefix=self.prefix,
+            encoding=self.encoding,
+            witver=self.witver,
+        )
         self.address_orig = None
         provider_prefix = None
-        if network_overrides and 'prefix_address_p2sh' in network_overrides and self.script_type == 'p2sh':
-            provider_prefix = network_overrides['prefix_address_p2sh']
+        if (
+            network_overrides
+            and "prefix_address_p2sh" in network_overrides
+            and self.script_type == "p2sh"
+        ):
+            provider_prefix = network_overrides["prefix_address_p2sh"]
         self.address_orig = self.address
         if provider_prefix:
             self.address = addr_convert(self.address, provider_prefix)
 
     def __repr__(self):
         return "<Address(address=%s)>" % self.address
 
@@ -648,20 +721,20 @@
     def as_dict(self):
         """
         Get current Address class as dictionary. Byte values are represented by hexadecimal strings
 
         :return dict:
         """
         addr_dict = deepcopy(self.__dict__)
-        del (addr_dict['data_bytes'])
-        del (addr_dict['hash_bytes'])
-        if isinstance(addr_dict['network'], Network):
-            addr_dict['network'] = addr_dict['network'].name
-        addr_dict['redeemscript'] = addr_dict['redeemscript'].hex()
-        addr_dict['prefix'] = addr_dict['prefix']
+        del addr_dict["data_bytes"]
+        del addr_dict["hash_bytes"]
+        if isinstance(addr_dict["network"], Network):
+            addr_dict["network"] = addr_dict["network"].name
+        addr_dict["redeemscript"] = addr_dict["redeemscript"].hex()
+        addr_dict["prefix"] = addr_dict["prefix"]
         return addr_dict
 
     def as_json(self):
         """
         Get current key as json formatted string
 
         :return str:
@@ -698,25 +771,33 @@
         :type wif: str
         :param network: Bitcoin, testnet, litecoin or other network
         :type network: str, Network
 
         :return Key:
         """
         key_hex = change_base(wif, 58, 16)
-        networks = network_by_value('prefix_wif', key_hex[:2])
+        networks = network_by_value("prefix_wif", key_hex[:2])
         compressed = False
         if networks:
-            if key_hex[-10:-8] == '01':
+            if key_hex[-10:-8] == "01":
                 compressed = True
             network = network or next(iter(networks), DEFAULT_NETWORK)
         else:
             raise BKeyError("Could not create key, wif format not recognised")
         return Key(wif, network, compressed, is_private=True)
 
-    def __init__(self, import_key=None, network=None, compressed=True, password='', is_private=None, strict=True):
+    def __init__(
+        self,
+        import_key=None,
+        network=None,
+        compressed=True,
+        password="",
+        is_private=None,
+        strict=True,
+    ):
         """
         Initialize a Key object. Import key can be in WIF, bytes, hexstring, etc. If import_key is empty a new
         private key will be generated.
 
         If a private key is imported a public key will be derived. If a public is imported the private key data will
         be empty.
 
@@ -764,118 +845,127 @@
         self.compressed = compressed
         self._hash160 = None
         self.key_format = None
         self.is_private = None
 
         if not import_key:
             import_key = random.SystemRandom().randint(1, secp256k1_n - 1)
-            self.key_format = 'decimal'
+            self.key_format = "decimal"
             networks_extracted = network
             assert is_private is True or is_private is None
             self.is_private = True  # Ignore provided attribute
         else:
             try:
                 kf = get_key_format(import_key)
             except BKeyError:
                 if strict:
                     raise BKeyError("Unrecognised key format")
                 else:
                     networks_extracted = []
             else:
-                if kf['format'] == 'address':
+                if kf["format"] == "address":
                     raise BKeyError("Can not create Key object from address")
                 self.key_format = kf["format"]
                 networks_extracted = kf["networks"]
-                self.is_private = is_private if is_private else kf['is_private']
+                self.is_private = is_private if is_private else kf["is_private"]
                 if self.is_private is None:
                     raise BKeyError("Could not determine if key is private or public")
 
         if network is not None:
             self.network = network
             if not isinstance(network, Network):
                 self.network = Network(network)
         elif networks_extracted:
-            self.network = Network(check_network_and_key(import_key, None, networks_extracted))
+            self.network = Network(
+                check_network_and_key(import_key, None, networks_extracted)
+            )
         else:
             self.network = Network(DEFAULT_NETWORK)
 
         if self.key_format == "wif_protected":
-            import_key, self.compressed = self._bip38_decrypt(import_key, password, network)
-            self.key_format = 'bin_compressed' if self.compressed else 'bin'
+            import_key, self.compressed = self._bip38_decrypt(
+                import_key, password, network
+            )
+            self.key_format = "bin_compressed" if self.compressed else "bin"
 
         if not self.is_private:
             self.secret = None
             pub_key = to_hexstring(import_key)
             if len(pub_key) == 130:
                 self._public_uncompressed_hex = pub_key
                 self.x_hex = pub_key[2:66]
                 self.y_hex = pub_key[66:130]
                 self._y = int(self.y_hex, 16)
                 self.compressed = False
                 if self._y % 2:
-                    prefix = '03'
+                    prefix = "03"
                 else:
-                    prefix = '02'
+                    prefix = "02"
                 self.public_hex = pub_key
                 self.public_compressed_hex = prefix + self.x_hex
             else:
                 self.public_hex = pub_key
                 self.x_hex = pub_key[2:66]
                 self.compressed = True
                 self._x = int(self.x_hex, 16)
                 self.public_compressed_hex = pub_key
             self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)
             if self._public_uncompressed_hex:
-                self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)
+                self._public_uncompressed_byte = bytes.fromhex(
+                    self._public_uncompressed_hex
+                )
             if self.compressed:
                 self.public_byte = self.public_compressed_byte
             else:
                 self.public_byte = self.public_uncompressed_byte
-        elif self.is_private and self.key_format == 'decimal':
+        elif self.is_private and self.key_format == "decimal":
             self.secret = int(import_key)
             self.private_hex = change_base(self.secret, 10, 16, 64)
             self.private_byte = bytes.fromhex(self.private_hex)
         elif self.is_private:
-            if self.key_format == 'hex':
+            if self.key_format == "hex":
                 key_hex = import_key
                 key_byte = bytes.fromhex(key_hex)
-            elif self.key_format == 'hex_compressed':
+            elif self.key_format == "hex_compressed":
                 key_hex = import_key[:-2]
                 key_byte = bytes.fromhex(key_hex)
                 self.compressed = True
-            elif self.key_format == 'bin':
+            elif self.key_format == "bin":
                 key_byte = import_key
                 key_hex = key_byte.hex()
-            elif self.key_format == 'bin_compressed':
+            elif self.key_format == "bin_compressed":
                 key_byte = import_key
-                if len(import_key) in [33, 65, 129] and import_key[-1:] == b'\1':
+                if len(import_key) in [33, 65, 129] and import_key[-1:] == b"\1":
                     key_byte = import_key[:-1]
                 key_hex = key_byte.hex()
                 self.compressed = True
-            elif self.is_private and self.key_format in ['wif', 'wif_compressed']:
+            elif self.is_private and self.key_format in ["wif", "wif_compressed"]:
                 # Check and remove Checksum, prefix and postfix tags
                 key = change_base(import_key, 58, 256)
                 checksum = key[-4:]
                 key = key[:-4]
                 if checksum != double_sha256(key)[:4]:
                     raise BKeyError("Invalid checksum, not a valid WIF key")
-                found_networks = network_by_value('prefix_wif', key[0:1].hex())
+                found_networks = network_by_value("prefix_wif", key[0:1].hex())
                 if not len(found_networks):
-                    raise BKeyError("Unrecognised WIF private key, version byte unknown. Versionbyte: %s" % key[0:1])
+                    raise BKeyError(
+                        "Unrecognised WIF private key, version byte unknown. Versionbyte: %s"
+                        % key[0:1]
+                    )
                 self._wif = import_key
                 self._wif_prefix = key[0:1]
                 # if self.network.name not in found_networks:
                 #     if len(found_networks) > 1:
                 #         raise BKeyError("More then one network found with this versionbyte, please specify network. "
                 #                         "Networks found: %s" % found_networks)
                 #     else:
                 #         _logger.warning("Current network %s is different then the one found in key: %s" %
                 #                         (network, found_networks[0]))
                 #         self.network = Network(found_networks[0])
-                if key[-1:] == b'\x01':
+                if key[-1:] == b"\x01":
                     self.compressed = True
                     key = key[:-1]
                 else:
                     self.compressed = False
                 key_byte = key[1:]
                 key_hex = key_byte.hex()
             else:
@@ -898,25 +988,35 @@
                 self._y = p.y
             else:
                 self._x = p.x()
                 self._y = p.y()
             self.x_hex = change_base(self._x, 10, 16, 64)
             self.y_hex = change_base(self._y, 10, 16, 64)
             if self._y % 2:
-                prefix = '03'
+                prefix = "03"
             else:
-                prefix = '02'
+                prefix = "02"
 
             self.public_compressed_hex = prefix + self.x_hex
-            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex
-            self.public_hex = self.public_compressed_hex if self.compressed else self.public_uncompressed_hex
+            self._public_uncompressed_hex = "04" + self.x_hex + self.y_hex
+            self.public_hex = (
+                self.public_compressed_hex
+                if self.compressed
+                else self.public_uncompressed_hex
+            )
 
             self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)
-            self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)
-            self.public_byte = self.public_compressed_byte if self.compressed else self.public_uncompressed_byte
+            self._public_uncompressed_byte = bytes.fromhex(
+                self._public_uncompressed_hex
+            )
+            self.public_byte = (
+                self.public_compressed_byte
+                if self.compressed
+                else self.public_uncompressed_byte
+            )
         self._address_obj = None
         self._wif = None
         self._wif_prefix = None
 
     def __repr__(self):
         return "<Key(public_hex=%s, network=%s)>" % (self.public_hex, self.network.name)
 
@@ -969,21 +1069,21 @@
             self._y = int(self.y_hex, 16)
         return self._y
 
     @property
     def public_uncompressed_hex(self):
         if not self._public_uncompressed_hex:
             # Calculate y from x with y=x^3 + 7 function
-            sign = self.public_hex[:2] == '03'
+            sign = self.public_hex[:2] == "03"
             ys = pow(self._x, 3, secp256k1_p) + 7 % secp256k1_p
             self._y = mod_sqrt(ys)
             if self._y & 1 != sign:
                 self._y = secp256k1_p - self._y
             self.y_hex = change_base(self._y, 10, 16, 64)
-            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex
+            self._public_uncompressed_hex = "04" + self.x_hex + self.y_hex
         return self._public_uncompressed_hex
 
     @property
     def public_uncompressed_byte(self):
         if not self._public_uncompressed_byte:
             self._public_uncompressed_byte = bytes.fromhex(self.public_uncompressed_hex)
         return self._public_uncompressed_byte
@@ -998,29 +1098,29 @@
         :param include_private: Include private key information in dictionary
         :type include_private: bool
 
         :return collections.OrderedDict:
         """
 
         key_dict = collections.OrderedDict()
-        key_dict['network'] = self.network.name
-        key_dict['key_format'] = self.key_format
-        key_dict['compressed'] = self.compressed
-        key_dict['is_private'] = self.is_private
+        key_dict["network"] = self.network.name
+        key_dict["key_format"] = self.key_format
+        key_dict["compressed"] = self.compressed
+        key_dict["is_private"] = self.is_private
         if include_private:
-            key_dict['private_hex'] = self.private_hex
-            key_dict['secret'] = self.secret
-            key_dict['wif'] = self.wif()
-        key_dict['public_hex'] = self.public_hex
-        key_dict['public_uncompressed_hex'] = self.public_uncompressed_hex
-        key_dict['hash160'] = self.hash160.hex()
-        key_dict['address'] = self.address()
+            key_dict["private_hex"] = self.private_hex
+            key_dict["secret"] = self.secret
+            key_dict["wif"] = self.wif()
+        key_dict["public_hex"] = self.public_hex
+        key_dict["public_uncompressed_hex"] = self.public_uncompressed_hex
+        key_dict["hash160"] = self.hash160.hex()
+        key_dict["address"] = self.address()
         x, y = self.public_point()
-        key_dict['point_x'] = x
-        key_dict['point_y'] = y
+        key_dict["point_x"] = x
+        key_dict["point_y"] = y
         return key_dict
 
     def as_json(self, include_private=False):
         """
         Get current key as json formatted string
 
         :param include_private: Include private key information in dictionary
@@ -1046,18 +1146,20 @@
         """
         priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)
 
         # Verify addresshash
         k = Key(priv, compressed=compressed, network=network)
         addr = k.address()
         if isinstance(addr, str):
-            addr = addr.encode('utf-8')
+            addr = addr.encode("utf-8")
         if double_sha256(addr)[0:4] != addresshash:
-            raise BKeyError('Addresshash verification failed! Password or '
-                            'specified network %s might be incorrect' % network)
+            raise BKeyError(
+                "Addresshash verification failed! Password or "
+                "specified network %s might be incorrect" % network
+            )
         return priv, compressed
 
     def encrypt(self, password):
         """
         BIP0038 non-ec-multiply encryption. Returns BIP0038 encrypted private key
         Based on code from https://github.com/nomorecoin/python-bip38-testing
 
@@ -1066,21 +1168,17 @@
         '6PYM8wAnnmAK5mHYoF7zqj88y5HtK7eiPeqPdu4WnYEFkYKEEoMFEVfuDg'
 
         :param password: Required password for encryption
         :type password: str
 
         :return str: BIP38 password encrypted private key
         """
-        flagbyte = b'\xe0' if self.compressed else b'\xc0'
+        flagbyte = b"\xe0" if self.compressed else b"\xc0"
         return bip38_encrypt(self.private_hex, self.address(), password, flagbyte)
 
-    @deprecated
-    def bip38_encrypt(self, password):
-        return self.encrypt(password)
-
     def wif(self, prefix=None):
         """
         Get private Key in Wallet Import Format, steps:
         # Convert to Binary and add 0x80 hex
         # Calculate Double SHA256 and add as checksum to end of key
 
         :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings
@@ -1097,17 +1195,17 @@
                 versionbyte = bytes.fromhex(prefix)
             else:
                 versionbyte = prefix
 
         if self._wif and self._wif_prefix == versionbyte:
             return self._wif
 
-        key = versionbyte + self.secret.to_bytes(32, byteorder='big')
+        key = versionbyte + self.secret.to_bytes(32, byteorder="big")
         if self.compressed:
-            key += b'\1'
+            key += b"\1"
         key += double_sha256(key)[:4]
         self._wif = base58encode(key)
         self._wif_prefix = versionbyte
         return self._wif
 
     def public(self):
         """
@@ -1134,15 +1232,17 @@
     def hash160(self):
         """
         Get public key in RIPEMD-160 + SHA256 format
 
         :return bytes:
         """
         if not self._hash160:
-            self._hash160 = hash160(self.public_byte if self.compressed else self.public_uncompressed_byte)
+            self._hash160 = hash160(
+                self.public_byte if self.compressed else self.public_uncompressed_byte
+            )
         return self._hash160
 
     @property
     def address_obj(self):
         """
         Get address object property. Create standard address object if not defined already.
 
@@ -1173,22 +1273,34 @@
         else:
             data = self.public_uncompressed_byte
             self.compressed = False
         if encoding is None:
             if self._address_obj:
                 encoding = self._address_obj.encoding
             else:
-                encoding = 'base58'
-        if not self.compressed and encoding == 'bech32':
-            raise BKeyError("Uncompressed keys are non-standard for segwit/bech32 encoded addresses")
+                encoding = "base58"
+        if not self.compressed and encoding == "bech32":
+            raise BKeyError(
+                "Uncompressed keys are non-standard for segwit/bech32 encoded addresses"
+            )
         if self._address_obj and script_type is None:
             script_type = self._address_obj.script_type
-        if not (self._address_obj and self._address_obj.prefix == prefix and self._address_obj.encoding == encoding):
-            self._address_obj = Address(data, prefix=prefix, network=self.network, script_type=script_type,
-                                        encoding=encoding, compressed=compressed)
+        if not (
+            self._address_obj
+            and self._address_obj.prefix == prefix
+            and self._address_obj.encoding == encoding
+        ):
+            self._address_obj = Address(
+                data,
+                prefix=prefix,
+                network=self.network,
+                script_type=script_type,
+                encoding=encoding,
+                compressed=compressed,
+            )
         return self._address_obj.address
 
     def address_uncompressed(self, prefix=None, script_type=None, encoding=None):
         """
         Get uncompressed address from public key
 
         :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings
@@ -1196,15 +1308,17 @@
         :param script_type: Type of script, i.e. p2sh or p2pkh.
         :type script_type: str
         :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding
         :type encoding: str
 
         :return str: Base58 encoded address
         """
-        return self.address(compressed=False, prefix=prefix, script_type=script_type, encoding=encoding)
+        return self.address(
+            compressed=False, prefix=prefix, script_type=script_type, encoding=encoding
+        )
 
     def info(self):
         """
         Prints key information to standard output
 
         """
 
@@ -1238,16 +1352,23 @@
     Besides a private or public key a HD Key has a chain code, allowing to create
     a structure of related keys.
 
     The structure and key-path are defined in BIP0043 and BIP0044.
     """
 
     @staticmethod
-    def from_seed(import_seed, key_type='bip32', network=DEFAULT_NETWORK, compressed=True,
-                  encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):
+    def from_seed(
+        import_seed,
+        key_type="bip32",
+        network=DEFAULT_NETWORK,
+        compressed=True,
+        encoding=None,
+        witness_type=DEFAULT_WITNESS_TYPE,
+        multisig=False,
+    ):
         """
         Used by class init function, import key from seed
 
         :param import_seed: Private key seed as bytes or hexstring
         :type import_seed: str, bytes
         :param key_type: Specify type of key, default is BIP32
         :type key_type: str
@@ -1264,23 +1385,41 @@
 
         :return HDKey:
         """
         seed = to_bytes(import_seed)
         i = hmac.new(b"Bitcoin seed", seed, hashlib.sha512).digest()
         key = i[:32]
         chain = i[32:]
-        key_int = int.from_bytes(key, 'big')
+        key_int = int.from_bytes(key, "big")
         if key_int >= secp256k1_n:
             raise BKeyError("Key int value cannot be greater than secp256k1_n")
-        return HDKey(key=key, chain=chain, network=network, key_type=key_type, compressed=compressed,
-                     encoding=encoding, witness_type=witness_type, multisig=multisig)
+        # checking to see if this needs to be run in thread
+
+        return HDKey(
+            key=key,
+            chain=chain,
+            network=network,
+            key_type=key_type,
+            compressed=compressed,
+            encoding=encoding,
+            witness_type=witness_type,
+            multisig=multisig,
+        )
 
     @staticmethod
-    def from_passphrase(passphrase, password='', network=DEFAULT_NETWORK, key_type='bip32', compressed=True,
-                        encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):
+    def from_passphrase(
+        passphrase,
+        password="",
+        network=DEFAULT_NETWORK,
+        key_type="bip32",
+        compressed=True,
+        encoding=None,
+        witness_type=DEFAULT_WITNESS_TYPE,
+        multisig=False,
+    ):
         """
         Create key from Mnemonic passphrase
 
         :param passphrase: Mnemonic passphrase, list of words as string seperated with a space character
         :type passphrase: str
         :param password: Password to protect passphrase
         :type password: str
@@ -1295,16 +1434,23 @@
         :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.
         :type witness_type: str
         :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addreses
         :type multisig: bool
 
         :return HDKey:
         """
-        return HDKey.from_seed(Mnemonic().to_seed(passphrase, password), network=network, key_type=key_type,
-                               compressed=compressed, encoding=encoding, witness_type=witness_type, multisig=multisig)
+        return HDKey.from_seed(
+            Mnemonic().to_seed(passphrase, password),
+            network=network,
+            key_type=key_type,
+            compressed=compressed,
+            encoding=encoding,
+            witness_type=witness_type,
+            multisig=multisig,
+        )
 
     @staticmethod
     def from_wif(wif, network=None, compressed=True, multisig=None):
         """
         Create HDKey from BIP32 WIF
 
         :param wif: HDKey WIF
@@ -1326,38 +1472,70 @@
             is_private = False
             key = bkey[45:78]
         else:
             is_private = True
             key = bkey[46:78]
         depth = ord(bkey[4:5])
         parent_fingerprint = bkey[5:9]
-        child_index = int.from_bytes(bkey[9:13], 'big')
+        child_index = int.from_bytes(bkey[9:13], "big")
         chain = bkey[13:45]
 
         key_hex = bkey.hex()
         prefix_data = wif_prefix_search(key_hex[:8], network=network, multisig=multisig)
         if not prefix_data:
-            raise BKeyError("Invalid BIP32 HDkey WIF. Cannot find prefix in network definitions")
+            raise BKeyError(
+                "Invalid BIP32 HDkey WIF. Cannot find prefix in network definitions"
+            )
 
-        networks = list(dict.fromkeys([n['network'] for n in prefix_data]))
+        networks = list(dict.fromkeys([n["network"] for n in prefix_data]))
         if not network and networks:
             network = networks[0]
         elif network not in networks:
-            raise BKeyError("Network %s not found in list of derived networks %s" % (network, networks))
-
-        witness_type = next(iter(list(dict.fromkeys([n['witness_type'] for n in prefix_data]))), None)
-        multisig = multisig or next(iter(list(dict.fromkeys([n['multisig'] for n in prefix_data]))), None)
+            raise BKeyError(
+                "Network %s not found in list of derived networks %s"
+                % (network, networks)
+            )
 
-        return HDKey(key=key, chain=chain, depth=depth, parent_fingerprint=parent_fingerprint,
-                     child_index=child_index, is_private=is_private, network=network, witness_type=witness_type,
-                     multisig=multisig, compressed=compressed)
-
-    def __init__(self, import_key=None, key=None, chain=None, depth=0, parent_fingerprint=b'\0\0\0\0',
-                 child_index=0, is_private=True, network=None, key_type='bip32', password='', compressed=True,
-                 encoding=None, witness_type=None, multisig=False):
+        witness_type = next(
+            iter(list(dict.fromkeys([n["witness_type"] for n in prefix_data]))), None
+        )
+        multisig = multisig or next(
+            iter(list(dict.fromkeys([n["multisig"] for n in prefix_data]))), None
+        )
+
+        return HDKey(
+            key=key,
+            chain=chain,
+            depth=depth,
+            parent_fingerprint=parent_fingerprint,
+            child_index=child_index,
+            is_private=is_private,
+            network=network,
+            witness_type=witness_type,
+            multisig=multisig,
+            compressed=compressed,
+        )
+
+    def __init__(
+        self,
+        import_key=None,
+        key=None,
+        chain=None,
+        depth: int = 0,
+        parent_fingerprint: bytes = b"\0\0\0\0",
+        child_index: int = 0,
+        is_private: bool = True,
+        network=None,
+        key_type: str = "bip32",
+        password: str = "",
+        compressed: bool = True,
+        encoding=None,
+        witness_type=None,
+        multisig: bool = False,
+    ):
         """
         Hierarchical Deterministic Key class init function.
 
         If no import_key is specified a key will be generated with systems cryptographically random function.
         Import key can be any format normal or HD key (extended key) accepted by get_key_format.
         If a normal key with no chain part is provided, a chain with only 32 0-bytes will be used.
 
@@ -1412,82 +1590,93 @@
                 key, chain = self._key_derivation(seed)
             # If key is 64 bytes long assume a HD Key with key and chain part
             elif isinstance(import_key, bytes) and len(import_key) == 64:
                 key = import_key[:32]
                 chain = import_key[32:]
             elif isinstance(import_key, Key):
                 if not import_key.compressed:
-                    _logger.warning("Uncompressed private keys are not standard for BIP32 keys, use at your own risk!")
+                    _logger.warning(
+                        "Uncompressed private keys are not standard for BIP32 keys, use at your own risk!"
+                    )
                     compressed = False
-                chain = chain if chain else b'\0' * 32
+                chain = chain if chain else b"\0" * 32
                 if not import_key.private_byte:
-                    raise BKeyError('Cannot import public Key in HDKey')
+                    raise BKeyError("Cannot import public Key in HDKey")
                 key = import_key.private_byte
-                key_type = 'private'
+                key_type = "private"
             else:
                 kf = get_key_format(import_key)
-                if kf['format'] == 'address':
+                if kf["format"] == "address":
                     raise BKeyError("Can not create HDKey object from address")
-                if len(kf['script_types']) == 1:
-                    self.script_type = kf['script_types'][0]
-                if len(kf['witness_types']) == 1 and not witness_type:
-                    witness_type = kf['witness_types'][0]
+                if len(kf["script_types"]) == 1:
+                    self.script_type = kf["script_types"][0]
+                if len(kf["witness_types"]) == 1 and not witness_type:
+                    witness_type = kf["witness_types"][0]
                     encoding = get_encoding_from_witness(witness_type)
-                if len(kf['multisig']) == 1:
-                    multisig = kf['multisig'][0]
-                network = Network(check_network_and_key(import_key, network, kf["networks"]))
-                if kf['format'] in ['hdkey_private', 'hdkey_public']:
+                if len(kf["multisig"]) == 1:
+                    multisig = kf["multisig"][0]
+                network = Network(
+                    check_network_and_key(import_key, network, kf["networks"])
+                )
+                if kf["format"] in ["hdkey_private", "hdkey_public"]:
                     bkey = change_base(import_key, 58, 256)
                     # Derive key, chain, depth, child_index and fingerprint part from extended key WIF
                     if ord(bkey[45:46]):
                         is_private = False
                         key = bkey[45:78]
                     else:
                         key = bkey[46:78]
                     depth = ord(bkey[4:5])
                     parent_fingerprint = bkey[5:9]
-                    child_index = int.from_bytes(bkey[9:13], 'big')
+                    child_index = int.from_bytes(bkey[9:13], "big")
                     chain = bkey[13:45]
-                elif kf['format'] == 'mnemonic':
-                    raise BKeyError("Use HDKey.from_passphrase() method to parse a passphrase")
-                elif kf['format'] == 'wif_protected':
-                    key, compressed = self._bip38_decrypt(import_key, password, network.name, witness_type)
-                    chain = chain if chain else b'\0' * 32
-                    key_type = 'private'
+                elif kf["format"] == "mnemonic":
+                    raise BKeyError(
+                        "Use HDKey.from_passphrase() method to parse a passphrase"
+                    )
+                elif kf["format"] == "wif_protected":
+                    key, compressed = self._bip38_decrypt(
+                        import_key, password, network.name, witness_type
+                    )
+                    chain = chain if chain else b"\0" * 32
+                    key_type = "private"
                 else:
                     key = import_key
-                    chain = chain if chain else b'\0' * 32
-                    is_private = kf['is_private']
-                    key_type = 'private' if is_private else 'public'
+                    chain = chain if chain else b"\0" * 32
+                    is_private = kf["is_private"]
+                    key_type = "private" if is_private else "public"
 
         if witness_type is None:
             witness_type = DEFAULT_WITNESS_TYPE
 
-        Key.__init__(self, key, network, compressed, password, is_private)
+        super().__init__(key, network, compressed, password, is_private)
 
         self.encoding = encoding
         self.witness_type = witness_type
         self.multisig = multisig
 
         self.chain = chain
         self.depth = depth
         self.parent_fingerprint = parent_fingerprint
         self.child_index = child_index
         self.key_type = key_type
 
     def __repr__(self):
-        return "<HDKey(public_hex=%s, wif_public=%s, network=%s)>" % \
-               (self.public_hex, self.wif_public(), self.network.name)
+        return "<HDKey(public_hex=%s, wif_public=%s, network=%s)>" % (
+            self.public_hex,
+            self.wif_public(),
+            self.network.name,
+        )
 
     def info(self):
         """
         Prints key information to standard output
 
         """
-        super(HDKey, self).info()
+        super().info()
 
         print("EXTENDED KEY")
         print(" Key Type                    %s" % self.key_type)
         print(" Chain code (hex)            %s" % self.chain.hex())
         print(" Child Index                 %s" % self.child_index)
         print(" Parent Fingerprint (hex)    %s" % self.parent_fingerprint.hex())
         print(" Depth                       %s" % self.depth)
@@ -1507,22 +1696,22 @@
         :type include_private: bool
 
         :return collections.OrderedDict:
         """
 
         key_dict = super(HDKey, self).as_dict()
         if include_private:
-            key_dict['fingerprint'] = self.fingerprint.hex()
-            key_dict['chain_code'] = self.chain.hex()
-            key_dict['fingerprint_parent'] = self.parent_fingerprint.hex()
-        key_dict['child_index'] = self.child_index
-        key_dict['depth'] = self.depth
-        key_dict['extended_wif_public'] = self.wif_public()
+            key_dict["fingerprint"] = self.fingerprint.hex()
+            key_dict["chain_code"] = self.chain.hex()
+            key_dict["fingerprint_parent"] = self.parent_fingerprint.hex()
+        key_dict["child_index"] = self.child_index
+        key_dict["depth"] = self.depth
+        key_dict["extended_wif_public"] = self.wif_public()
         if include_private:
-            key_dict['extended_wif_private'] = self.wif(is_private=True)
+            key_dict["extended_wif_private"] = self.wif(is_private=True)
         return key_dict
 
     def as_json(self, include_private=False):
         """
         Get current key as json formatted string
 
         :param include_private: Include private key information in dictionary
@@ -1537,35 +1726,42 @@
         Derive extended private key with key and chain part from seed
 
         :param seed:
         :type seed: bytes
 
         :return tuple: key and chain bytes
         """
-        chain = hasattr(self, 'chain') and self.chain or b"Bitcoin seed"
+        chain = hasattr(self, "chain") and self.chain or b"Bitcoin seed"
         i = hmac.new(chain, seed, hashlib.sha512).digest()
         key = i[:32]
         chain = i[32:]
-        key_int = int.from_bytes(key, 'big')
+        key_int = int.from_bytes(key, "big")
         if key_int >= secp256k1_n:
-            raise BKeyError("Key cannot be greater than secp256k1_n. Try another index number.")
+            raise BKeyError(
+                "Key cannot be greater than secp256k1_n. Try another index number."
+            )
         return key, chain
 
     @property
     def fingerprint(self):
         """
         Get key fingerprint: the last for bytes of the hash160 of this key.
 
         :return bytes:
         """
 
         return self.hash160[:4]
 
     @staticmethod
-    def _bip38_decrypt(encrypted_privkey, password, network=DEFAULT_NETWORK, witness_type=DEFAULT_WITNESS_TYPE):
+    def _bip38_decrypt(
+        encrypted_privkey,
+        password,
+        network=DEFAULT_NETWORK,
+        witness_type=DEFAULT_WITNESS_TYPE,
+    ):
         """
         BIP0038 non-ec-multiply decryption. Returns WIF private key.
         Based on code from https://github.com/nomorecoin/python-bip38-testing
         This method is called by Key class init function when importing BIP0038 key.
 
         :param encrypted_privkey: Encrypted private key using WIF protected key format
         :type encrypted_privkey: str
@@ -1574,24 +1770,35 @@
 
         :return str: Private Key WIF
         """
         priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)
         # compressed = True if priv[-1:] == b'\1' else False
 
         # Verify addresshash
-        k = HDKey(priv, compressed=compressed, network=network, witness_type=witness_type)
+        k = HDKey(
+            priv, compressed=compressed, network=network, witness_type=witness_type
+        )
         addr = k.address()
         if isinstance(addr, str):
-            addr = addr.encode('utf-8')
+            addr = addr.encode("utf-8")
         if double_sha256(addr)[0:4] != addresshash:
-            raise BKeyError('Addresshash verification failed! Password or '
-                            'specified network %s might be incorrect' % network)
+            raise BKeyError(
+                "Addresshash verification failed! Password or "
+                "specified network %s might be incorrect" % network
+            )
         return priv, compressed
 
-    def wif(self, is_private=None, child_index=None, prefix=None, witness_type=None, multisig=None):
+    def wif(
+        self,
+        is_private=None,
+        child_index=None,
+        prefix=None,
+        witness_type=None,
+        multisig=None,
+    ):
         """
         Get Extended WIF of current key
 
         >>> private_hex = '221ff330268a9bb5549a02c801764cffbc79d5c26f4041b26293a425fd5b557c'
         >>> k = HDKey(private_hex)
         >>> k.wif()
         'xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6SmypHzZG2cYrwpGkWJqRxS6EAW77gd7CHFoXNpBd3LN8xjAyCW'
@@ -1607,35 +1814,48 @@
         :param multisig: Key is part of a multisignature wallet?
         :type multisig: bool
 
         :return str: Base58 encoded WIF key
         """
 
         if not witness_type:
-            witness_type = DEFAULT_WITNESS_TYPE if not self.witness_type else self.witness_type
+            witness_type = (
+                DEFAULT_WITNESS_TYPE if not self.witness_type else self.witness_type
+            )
         if not multisig:
             multisig = False if not self.multisig else self.multisig
 
         rkey = self.private_byte or self.public_compressed_byte
         if prefix and not isinstance(prefix, bytes):
             prefix = bytes.fromhex(prefix)
         if self.is_private and is_private:
             if not prefix:
-                prefix = self.network.wif_prefix(is_private=True, witness_type=witness_type, multisig=multisig)
-            typebyte = b'\x00'
+                prefix = self.network.wif_prefix(
+                    is_private=True, witness_type=witness_type, multisig=multisig
+                )
+            typebyte = b"\x00"
         else:
             if not prefix:
-                prefix = self.network.wif_prefix(witness_type=witness_type, multisig=multisig)
-            typebyte = b''
+                prefix = self.network.wif_prefix(
+                    witness_type=witness_type, multisig=multisig
+                )
+            typebyte = b""
             if not is_private:
                 rkey = self.public_byte
         if child_index:
             self.child_index = child_index
-        raw = prefix + self.depth.to_bytes(1, 'big') + self.parent_fingerprint + \
-              self.child_index.to_bytes(4, 'big') + self.chain + typebyte + rkey
+        raw = (
+            prefix
+            + self.depth.to_bytes(1, "big")
+            + self.parent_fingerprint
+            + self.child_index.to_bytes(4, "big")
+            + self.chain
+            + typebyte
+            + rkey
+        )
         chk = double_sha256(raw)[:4]
         ret = raw + chk
         return change_base(ret, 256, 58, 111)
 
     def wif_key(self, prefix=None):
         """
         Get WIF of Key object. Call to parent object Key.wif()
@@ -1655,30 +1875,37 @@
         :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.
         :type witness_type: str
         :param multisig: Key is part of a multisignature wallet?
         :type multisig: bool
 
         :return str: Base58 encoded WIF key
         """
-        return self.wif(is_private=False, prefix=prefix, witness_type=witness_type, multisig=multisig)
+        return self.wif(
+            is_private=False,
+            prefix=prefix,
+            witness_type=witness_type,
+            multisig=multisig,
+        )
 
     def wif_private(self, prefix=None, witness_type=None, multisig=None):
         """
         Get Extended WIF private key. Wrapper for the :func:`wif` method
 
         :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings
         :type prefix: str, bytes
         :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.
         :type witness_type: str
         :param multisig: Key is part of a multi signature wallet?
         :type multisig: bool
 
         :return str: Base58 encoded WIF key
         """
-        return self.wif(is_private=True, prefix=prefix, witness_type=witness_type, multisig=multisig)
+        return self.wif(
+            is_private=True, prefix=prefix, witness_type=witness_type, multisig=multisig
+        )
 
     def address(self, compressed=None, prefix=None, script_type=None, encoding=None):
         """
         Get address derived from public key
 
         >>> wif = 'xpub661MyMwAqRbcFcXi3aM3fVdd42FGDSdufhrr5tdobiPjMrPUykFMTdaFEr7yoy1xxeifDY8kh2k4h9N77MY6rk18nfgg5rPtbFDF2YHzLfA'
         >>> k = HDKey.from_wif(wif)
@@ -1722,43 +1949,58 @@
         :type network: str
 
         :return HDKey: HD Key class object of subkey
         """
 
         if isinstance(path, TYPE_TEXT):
             path = path.split("/")
-        if self.key_type == 'single':
+        if self.key_type == "single":
             raise BKeyError("Key derivation cannot be used for 'single' type keys")
         key = self
         first_public = False
-        if path[0] == 'm':  # Use Private master key
+        if path[0] == "m":  # Use Private master key
             path = path[1:]
-        elif path[0] == 'M':  # Use Public master key
+        elif path[0] == "M":  # Use Public master key
             path = path[1:]
             first_public = True
         if path:
             if len(path) > 1:
-                _logger.info("Path length > 1 can be slow for larger paths, use Wallet Class to generate keys paths")
+                _logger.info(
+                    "Path length > 1 can be slow for larger paths, use Wallet Class to generate keys paths"
+                )
             for item in path:
                 if not item:
                     raise BKeyError("Could not parse path. Index is empty.")
                 hardened = item[-1] in "'HhPp"
                 if hardened:
                     item = item[:-1]
                 index = int(item)
                 if index < 0:
-                    raise BKeyError("Could not parse path. Index must be a positive integer.")
+                    raise BKeyError(
+                        "Could not parse path. Index must be a positive integer."
+                    )
                 if first_public or not key.is_private:
-                    key = key.child_public(index=index, network=network)  # TODO hardened=hardened key?
+                    key = key.child_public(
+                        index=index, network=network
+                    )  # TODO hardened=hardened key?
                     first_public = False
                 else:
-                    key = key.child_private(index=index, hardened=hardened, network=network)
+                    key = key.child_private(
+                        index=index, hardened=hardened, network=network
+                    )
         return key
 
-    def public_master(self, account_id=0, purpose=None, multisig=None, witness_type=None, as_private=False):
+    def public_master(
+        self,
+        account_id=0,
+        purpose=None,
+        multisig=None,
+        witness_type=None,
+        as_private=False,
+    ):
         """
         Derives a public master key for current HDKey. A public master key can be shared with other software
         administration tools to create readonly wallets or can be used to create multisignature wallets.
 
         >>> private_hex = 'b66ed9778029d32ebede042c79f448da8f7ab9efba19c63b7d3cdf6925203b71'
         >>> k = HDKey(private_hex)
         >>> pm = k.public_master()
@@ -1777,33 +2019,50 @@
 
         :return HDKey:
         """
         if multisig:
             self.multisig = multisig
         if witness_type:
             self.witness_type = witness_type
-        ks = [k for k in WALLET_KEY_STRUCTURES if
-              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]
+        ks = [
+            k
+            for k in WALLET_KEY_STRUCTURES
+            if k["witness_type"] == self.witness_type
+            and k["multisig"] == self.multisig
+            and k["purpose"] is not None
+        ]
         if len(ks) > 1:
-            raise BKeyError("Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
-                            "witness_type - multisig combination")
+            raise BKeyError(
+                "Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
+                "witness_type - multisig combination"
+            )
         if ks and not purpose:
-            purpose = ks[0]['purpose']
-        path_template = ks[0]['key_path']
+            purpose = ks[0]["purpose"]
+        path_template = ks[0]["key_path"]
 
         # Use last hardened key as public master root
-        pm_depth = path_template.index([x for x in path_template if x[-1:] == "'"][-1]) + 1
-        path = path_expand(path_template[:pm_depth], path_template, account_id=account_id, purpose=purpose,
-                           witness_type=self.witness_type, network=self.network.name)
+        pm_depth = (
+            path_template.index([x for x in path_template if x[-1:] == "'"][-1]) + 1
+        )
+        path = path_expand(
+            path_template[:pm_depth],
+            path_template,
+            account_id=account_id,
+            purpose=purpose,
+            witness_type=self.witness_type,
+            network=self.network.name,
+        )
         if as_private:
             return self.subkey_for_path(path)
         else:
             return self.subkey_for_path(path).public()
 
-    def public_master_multisig(self, account_id=0, purpose=None, witness_type=None, as_private=False):
+    def public_master_multisig(
+        self, account_id=0, purpose=None, witness_type=None, as_private=False
+    ):
         """
         Derives a public master key for current HDKey for use with multi signature wallets. Wrapper for the
         :func:`public_master` method.
 
         :param account_id: Account ID. Leave empty for account 0
         :type account_id: int
         :param purpose: BIP standard used, i.e. 44 for default, 45 for multisig, 84 for segwit.
@@ -1859,30 +2118,40 @@
 
         if network is None:
             network = self.network.name
         if not self.is_private:
             raise BKeyError("Need a private key to create child private key")
         if hardened:
             index |= 0x80000000
-            data = b'\0' + self.private_byte + index.to_bytes(4, 'big')
+            data = b"\0" + self.private_byte + index.to_bytes(4, "big")
         else:
-            data = self.public_byte + index.to_bytes(4, 'big')
+            data = self.public_byte + index.to_bytes(4, "big")
         key, chain = self._key_derivation(data)
 
-        key = int.from_bytes(key, 'big')
+        key = int.from_bytes(key, "big")
         if key >= secp256k1_n:
-            raise BKeyError("Key cannot be greater than secp256k1_n. Try another index number.")
+            raise BKeyError(
+                "Key cannot be greater than secp256k1_n. Try another index number."
+            )
         newkey = (key + self.secret) % secp256k1_n
         if newkey == 0:
             raise BKeyError("Key cannot be zero. Try another index number.")
-        newkey = int.to_bytes(newkey, 32, 'big')
+        newkey = int.to_bytes(newkey, 32, "big")
 
-        return HDKey(key=newkey, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,
-                     child_index=index, witness_type=self.witness_type, multisig=self.multisig,
-                     encoding=self.encoding, network=network)
+        return HDKey(
+            key=newkey,
+            chain=chain,
+            depth=self.depth + 1,
+            parent_fingerprint=self.fingerprint,
+            child_index=index,
+            witness_type=self.witness_type,
+            multisig=self.multisig,
+            encoding=self.encoding,
+            network=network,
+        )
 
     def child_public(self, index=0, network=None):
         """
         Use Child Key Derivation to derive child public key of current HD Key object.
 
         Used by :func:`subkey_for_path` to create key paths for instance to use in HD wallets. You can use this method to create your own key structures.
 
@@ -1904,40 +2173,55 @@
         :type network: str
 
         :return HDKey: HD Key class object
         """
         if network is None:
             network = self.network.name
         if index > 0x80000000:
-            raise BKeyError("Cannot derive hardened key from public private key. Index must be less than 0x80000000")
-        data = self.public_byte + index.to_bytes(4, 'big')
+            raise BKeyError(
+                "Cannot derive hardened key from public private key. Index must be less than 0x80000000"
+            )
+        data = self.public_byte + index.to_bytes(4, "big")
         key, chain = self._key_derivation(data)
-        key = int.from_bytes(key, 'big')
+        key = int.from_bytes(key, "big")
         if key >= secp256k1_n:
-            raise BKeyError("Key cannot be greater than secp256k1_n. Try another index number.")
+            raise BKeyError(
+                "Key cannot be greater than secp256k1_n. Try another index number."
+            )
 
         x, y = self.public_point()
         if USE_FASTECDSA:
             ki = ec_point(key) + fastecdsa_point.Point(x, y, fastecdsa_secp256k1)
             ki_x = ki.x
             ki_y = ki.y
         else:
-            ki = ec_point(key) + ecdsa.ellipticcurve.Point(secp256k1_curve, x, y, secp256k1_n)
+            ki = ec_point(key) + ecdsa.ellipticcurve.Point(
+                secp256k1_curve, x, y, secp256k1_n
+            )
             ki_x = ki.x()
             ki_y = ki.y()
 
         if ki_y % 2:
-            prefix = '03'
+            prefix = "03"
         else:
-            prefix = '02'
+            prefix = "02"
         xhex = change_base(ki_x, 10, 16, 64)
         secret = bytes.fromhex(prefix + xhex)
-        return HDKey(key=secret, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,
-                     child_index=index, is_private=False, witness_type=self.witness_type, multisig=self.multisig,
-                     encoding=self.encoding, network=network)
+        return HDKey(
+            key=secret,
+            chain=chain,
+            depth=self.depth + 1,
+            parent_fingerprint=self.fingerprint,
+            child_index=index,
+            is_private=False,
+            witness_type=self.witness_type,
+            multisig=self.multisig,
+            encoding=self.encoding,
+            network=network,
+        )
 
     def public(self):
         """
         Public version of current private key. Strips all private information from HDKey object, returns deepcopy
         version of current object
 
         :return HDKey:
@@ -1988,44 +2272,34 @@
         :type signature: bytes
         :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object
         :type public_key: HDKey, Key, str, hexstring, bytes
 
         :return Signature:
         """
 
-        der_signature = ''
+        der_signature = ""
         hash_type = SIGHASH_ALL
-        if len(signature) > 64 and signature.startswith(b'\x30'):
+        if len(signature) > 64 and signature.startswith(b"\x30"):
             der_signature = signature[:-1]
-            hash_type = int.from_bytes(signature[-1:], 'big')
+            hash_type = int.from_bytes(signature[-1:], "big")
             signature = convert_der_sig(signature[:-1], as_hex=False)
         if len(signature) != 64:
-            raise BKeyError("Signature length must be 64 bytes or 128 character hexstring")
-        r = int.from_bytes(signature[:32], 'big')
-        s = int.from_bytes(signature[32:], 'big')
-        return Signature(r, s, signature=signature, der_signature=der_signature, public_key=public_key,
-                         hash_type=hash_type)
-
-    @staticmethod
-    @deprecated
-    def from_str(signature, public_key=None):
-        """
-        Create a signature from signature string with r and s part. Signature length must be 64 bytes or 128
-        character hexstring
-
-        :param signature: Signature string
-        :type signature: bytes, str
-        :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object
-        :type public_key: HDKey, Key, str, hexstring, bytes
-
-        :return Signature:
-        """
-
-        signature = to_bytes(signature)
-        return Signature(signature, public_key)
+            raise BKeyError(
+                "Signature length must be 64 bytes or 128 character hexstring"
+            )
+        r = int.from_bytes(signature[:32], "big")
+        s = int.from_bytes(signature[32:], "big")
+        return Signature(
+            r,
+            s,
+            signature=signature,
+            der_signature=der_signature,
+            public_key=public_key,
+            hash_type=hash_type,
+        )
 
     @staticmethod
     def create(txid, private, use_rfc6979=True, k=None):
         """
         Sign a transaction hash and create a signature with provided private key.
 
         >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'
@@ -2061,46 +2335,62 @@
         if not k:
             if use_rfc6979 and USE_FASTECDSA:
                 rfc6979 = RFC6979(txid, secret, secp256k1_n, hashlib.sha256)
                 k = rfc6979.gen_nonce()
             else:
                 global rfc6979_warning_given
                 if not USE_FASTECDSA and not rfc6979_warning_given:
-                    _logger.warning("RFC6979 only supported when fastecdsa library is used")
+                    _logger.warning(
+                        "RFC6979 only supported when fastecdsa library is used"
+                    )
                     rfc6979_warning_given = True
                 k = random.SystemRandom().randint(1, secp256k1_n - 1)
 
         if USE_FASTECDSA:
             r, s = _ecdsa.sign(
                 txid,
                 str(secret),
                 str(k),
                 str(secp256k1_p),
                 str(secp256k1_a),
                 str(secp256k1_b),
                 str(secp256k1_n),
                 str(secp256k1_Gx),
-                str(secp256k1_Gy)
+                str(secp256k1_Gy),
             )
             if int(s) > secp256k1_n / 2:
                 s = secp256k1_n - int(s)
             return Signature(r, s, txid, secret, public_key=pub_key, k=k)
         else:
-            sk = ecdsa.SigningKey.from_string(private.private_byte, curve=ecdsa.SECP256k1)
+            sk = ecdsa.SigningKey.from_string(
+                private.private_byte, curve=ecdsa.SECP256k1
+            )
             txid_bytes = to_bytes(txid)
-            sig_der = sk.sign_digest(txid_bytes, sigencode=ecdsa.util.sigencode_der, k=k)
+            sig_der = sk.sign_digest(
+                txid_bytes, sigencode=ecdsa.util.sigencode_der, k=k
+            )
             signature = convert_der_sig(sig_der)
             r = int(signature[:64], 16)
             s = int(signature[64:], 16)
             if s > secp256k1_n / 2:
                 s = secp256k1_n - s
             return Signature(r, s, txid, secret, public_key=pub_key, k=k)
 
-    def __init__(self, r, s, txid=None, secret=None, signature=None, der_signature=None, public_key=None, k=None,
-                 hash_type=SIGHASH_ALL):
+    def __init__(
+        self,
+        r,
+        s,
+        txid=None,
+        secret=None,
+        signature=None,
+        der_signature=None,
+        public_key=None,
+        k=None,
+        hash_type=SIGHASH_ALL,
+    ):
         """
         Initialize Signature object with provided r and r value
 
         >>> r = 32979225540043540145671192266052053680452913207619328973512110841045982813493
         >>> s = 12990793585889366641563976043319195006380846016310271470330687369836458989268
         >>> sig = Signature(r, s)
         >>> sig.hex()
@@ -2125,42 +2415,50 @@
         """
 
         self.r = int(r)
         self.s = int(s)
         self.x = None
         self.y = None
         if self.r < 1 or self.r >= secp256k1_n:
-            raise BKeyError('Invalid Signature: r is not a positive integer smaller than the curve order')
+            raise BKeyError(
+                "Invalid Signature: r is not a positive integer smaller than the curve order"
+            )
         elif self.s < 1 or self.s >= secp256k1_n:
-            raise BKeyError('Invalid Signature: s is not a positive integer smaller than the curve order')
+            raise BKeyError(
+                "Invalid Signature: s is not a positive integer smaller than the curve order"
+            )
         self._txid = None
         self.txid = txid
         self.secret = None if not secret else int(secret)
         if isinstance(signature, bytes):
             self._signature = signature
             signature = signature.hex()
         else:
             self._signature = to_bytes(signature)
         if signature and len(signature) != 128:
-            raise BKeyError('Invalid Signature: length must be 64 bytes')
+            raise BKeyError("Invalid Signature: length must be 64 bytes")
         self._public_key = None
         self.public_key = public_key
         self.k = k
         self.hash_type = hash_type
-        self.hash_type_byte = self.hash_type.to_bytes(1, 'big')
+        self.hash_type_byte = self.hash_type.to_bytes(1, "big")
         self.der_signature = der_signature
         if not der_signature:
             self.der_signature = der_encode_sig(self.r, self.s)
 
         self._der_encoded = to_bytes(der_signature) + self.hash_type_byte
 
     def __repr__(self):
-        der_sig = '' if not self._der_encoded else self._der_encoded.hex()
-        return "<Signature(r=%d, s=%d, signature=%s, der_signature=%s)>" % \
-               (self.r, self.s, self.hex(), der_sig)
+        der_sig = "" if not self._der_encoded else self._der_encoded.hex()
+        return "<Signature(r=%d, s=%d, signature=%s, der_signature=%s)>" % (
+            self.r,
+            self.s,
+            self.hex(),
+            der_sig,
+        )
 
     def __str__(self):
         return self.as_der_encoded(as_hex=True)
 
     def __bytes__(self):
         return self.as_der_encoded()
 
@@ -2201,15 +2499,15 @@
             value = HDKey(value)
         if value.is_private:
             value = value.public()
         self.x, self.y = value.public_point()
 
         if USE_FASTECDSA:
             if not fastecdsa_secp256k1.is_point_on_curve((self.x, self.y)):
-                raise BKeyError('Invalid public key, point is not on secp256k1 curve')
+                raise BKeyError("Invalid public key, point is not on secp256k1 curve")
         self._public_key = value
 
     def hex(self):
         """
         Signature r and s value as single hexadecimal string
 
         :return hexstring:
@@ -2223,15 +2521,15 @@
         """
         Signature r and s value as single bytes string
 
         :return bytes:
         """
 
         if not self._signature:
-            self._signature = self.r.to_bytes(32, 'big') + self.s.to_bytes(32, 'big')
+            self._signature = self.r.to_bytes(32, "big") + self.s.to_bytes(32, "big")
         return self._signature
 
     def as_der_encoded(self, as_hex=False, include_hash_type=True):
         """
         Get DER encoded signature
 
         :param as_hex: Output as hexstring
@@ -2243,15 +2541,19 @@
         """
         if not self._der_encoded or len(self._der_encoded) < 2:
             self._der_encoded = der_encode_sig(self.r, self.s) + self.hash_type_byte
 
         if include_hash_type:
             return self._der_encoded.hex() if as_hex else self._der_encoded
         else:
-            return der_encode_sig(self.r, self.s).hex() if as_hex else der_encode_sig(self.r, self.s)
+            return (
+                der_encode_sig(self.r, self.s).hex()
+                if as_hex
+                else der_encode_sig(self.r, self.s)
+            )
 
     def verify(self, txid=None, public_key=None):
         """
         Verify this signature. Provide txid or public_key if not already known
 
         >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'
         >>> pub_key = HDKey(k).public()
@@ -2284,25 +2586,26 @@
                 str(self.x),
                 str(self.y),
                 str(secp256k1_p),
                 str(secp256k1_a),
                 str(secp256k1_b),
                 str(secp256k1_n),
                 str(secp256k1_Gx),
-                str(secp256k1_Gy)
+                str(secp256k1_Gy),
             )
         else:
             transaction_to_sign = to_bytes(self.txid)
             signature = self.bytes()
             if len(transaction_to_sign) != 32:
                 transaction_to_sign = double_sha256(transaction_to_sign)
-            ver_key = ecdsa.VerifyingKey.from_string(self.public_key.public_uncompressed_byte[1:],
-                                                     curve=ecdsa.SECP256k1)
+            ver_key = ecdsa.VerifyingKey.from_string(
+                self.public_key.public_uncompressed_byte[1:], curve=ecdsa.SECP256k1
+            )
             try:
-                if len(signature) > 64 and signature.startswith(b'\x30'):
+                if len(signature) > 64 and signature.startswith(b"\x30"):
                     try:
                         signature = convert_der_sig(signature[:-1], as_hex=False)
                     except Exception:
                         pass
                 ver_key.verify_digest(signature, transaction_to_sign)
             except ecdsa.keys.BadSignatureError:
                 return False
```

### Comparing `fluxwallet-0.0.6/fluxwallet/main.py` & `fluxwallet-0.1.0/fluxwallet/main.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,42 +16,47 @@
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import functools
 import logging
+
 # Do not remove any of the imports below, used by other files
 import os
 import sys
 from logging.handlers import RotatingFileHandler
 
 from fluxwallet.config.config import *
 
 # Initialize logging
-logger = logging.getLogger('fluxwallet')
+logger = logging.getLogger("fluxwallet")
 logger.setLevel(LOGLEVEL)
 
 if ENABLE_fluxwallet_LOGGING:
-    handler = RotatingFileHandler(str(FW_LOG_FILE), maxBytes=100 * 1024 * 1024, backupCount=2)
-    formatter = logging.Formatter('%(asctime)s %(levelname)s %(funcName)s(%(lineno)d) %(message)s',
-                                  datefmt='%Y/%m/%d %H:%M:%S')
+    handler = RotatingFileHandler(
+        str(FW_LOG_FILE), maxBytes=100 * 1024 * 1024, backupCount=2
+    )
+    formatter = logging.Formatter(
+        "%(asctime)s %(levelname)s %(funcName)s(%(lineno)d) %(message)s",
+        datefmt="%Y/%m/%d %H:%M:%S",
+    )
     handler.setFormatter(formatter)
     handler.setLevel(LOGLEVEL)
     logger.addHandler(handler)
 
     _logger = logging.getLogger(__name__)
-    logger.info('WELCOME TO fluxwallet - CRYPTOCURRENCY LIBRARY')
-    logger.info('Version: %s' % FLUXWALLET_VERSION)
-    logger.info('Logger name: %s' % logging.__name__)
-    logger.info('Read config from: %s' % FW_CONFIG_FILE)
-    logger.info('Directory databases: %s' % FW_DATABASE_DIR)
-    logger.info('Default database: %s' % DEFAULT_DATABASE)
-    logger.info('Logging to: %s' % FW_LOG_FILE)
-    logger.info('Directory for data files: %s' % FW_DATA_DIR)
+    logger.info("WELCOME TO fluxwallet - CRYPTOCURRENCY LIBRARY")
+    logger.info("Version: %s" % FLUXWALLET_VERSION)
+    logger.info("Logger name: %s" % logging.__name__)
+    logger.info("Read config from: %s" % FW_CONFIG_FILE)
+    logger.info("Directory databases: %s" % FW_DATABASE_DIR)
+    logger.info("Default database: %s" % DEFAULT_DATABASE)
+    logger.info("Logging to: %s" % FW_LOG_FILE)
+    logger.info("Directory for data files: %s" % FW_DATA_DIR)
 
 
 def script_type_default(witness_type=None, multisig=False, locking_script=False):
     """
     Determine default script type for provided witness type and key type combination used in this library.
 
     >>> script_type_default('segwit', locking_script=True)
@@ -65,54 +70,44 @@
     :type locking_script: bool
 
     :return str: Default script type
     """
 
     if not witness_type:
         return None
-    if witness_type == 'legacy' and not multisig:
-        return 'p2pkh' if locking_script else 'sig_pubkey'
-    elif witness_type == 'legacy' and multisig:
-        return 'p2sh' if locking_script else 'p2sh_multisig'
-    elif witness_type == 'segwit' and not multisig:
-        return 'p2wpkh' if locking_script else 'sig_pubkey'
-    elif witness_type == 'segwit' and multisig:
-        return 'p2wsh' if locking_script else 'p2sh_multisig'
-    elif witness_type == 'p2sh-segwit' and not multisig:
-        return 'p2sh' if locking_script else 'p2sh_p2wpkh'
-    elif witness_type == 'p2sh-segwit' and multisig:
-        return 'p2sh' if locking_script else 'p2sh_p2wsh'
+    if witness_type == "legacy" and not multisig:
+        return "p2pkh" if locking_script else "sig_pubkey"
+    elif witness_type == "legacy" and multisig:
+        return "p2sh" if locking_script else "p2sh_multisig"
+    elif witness_type == "segwit" and not multisig:
+        return "p2wpkh" if locking_script else "sig_pubkey"
+    elif witness_type == "segwit" and multisig:
+        return "p2wsh" if locking_script else "p2sh_multisig"
+    elif witness_type == "p2sh-segwit" and not multisig:
+        return "p2sh" if locking_script else "p2sh_p2wpkh"
+    elif witness_type == "p2sh-segwit" and multisig:
+        return "p2sh" if locking_script else "p2sh_p2wsh"
     else:
-        raise ValueError("Wallet and key type combination not supported: %s / %s" % (witness_type, multisig))
+        raise ValueError(
+            "Wallet and key type combination not supported: %s / %s"
+            % (witness_type, multisig)
+        )
 
 
 def get_encoding_from_witness(witness_type=None):
     """
     Derive address encoding (base58 or bech32) from transaction witness type.
 
     Returns 'base58' for legacy and p2sh-segwit witness type and 'bech32' for segwit
 
     :param witness_type: Witness type: legacy, p2sh-segwit or segwit
     :type witness_type: str
 
     :return str:
     """
 
-    if witness_type == 'segwit':
-        return 'bech32'
-    elif witness_type in [None, 'legacy', 'p2sh-segwit']:
-        return 'base58'
+    if witness_type == "segwit":
+        return "bech32"
+    elif witness_type in [None, "legacy", "p2sh-segwit"]:
+        return "base58"
     else:
         raise ValueError("Unknown witness type %s" % witness_type)
-
-
-def deprecated(func):
-    """
-    This is a decorator which can be used to mark functions as deprecated. It will result in a warning being emitted when the function is used.
-    """
-
-    @functools.wraps(func)
-    def new_func(*args, **kwargs):
-        logging.warning("Call to deprecated function {}.".format(func.__name__))
-        return func(*args, **kwargs)
-
-    return new_func
```

### Comparing `fluxwallet-0.0.6/fluxwallet/mnemonic.py` & `fluxwallet-0.1.0/fluxwallet/mnemonic.py`

 * *Files 4% similar despite different names*

```diff
@@ -36,35 +36,44 @@
         Init Mnemonic class and read wordlist of specified language
 
         :param language: use specific wordlist, i.e. chinese, dutch (in development), english, french, italian, japanese or spanish. Leave empty for default 'english'
         :type language: str
 
         """
         self._wordlist = []
-        with Path(FW_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:
-            self._wordlist = [w.strip() for w in f.readlines()]
+        self.change_language(language)
 
     @staticmethod
     def checksum(data):
         """
         Calculates checksum for given data key
 
         :param data: key string
         :type data: bytes, hexstring
 
         :return str: Checksum of key in bits
         """
         data = to_bytes(data)
         if len(data) % 4 > 0:
-            raise ValueError('Data length in bits should be divisible by 32, but it is not (%d bytes = %d bits).' %
-                             (len(data), len(data) * 8))
+            raise ValueError(
+                "Data length in bits should be divisible by 32, but it is not (%d bytes = %d bits)."
+                % (len(data), len(data) * 8)
+            )
         key_hash = hashlib.sha256(data).digest()
-        return change_base(key_hash, 256, 2, 256)[:len(data) * 8 // 32]
+        return change_base(key_hash, 256, 2, 256)[: len(data) * 8 // 32]
 
-    def to_seed(self, words, password='', validate=True):
+    def change_language(self, language: str):
+        wordlist_path = Path(FW_INSTALL_DIR) / f"wordlist/{language}.txt"
+        self._ingest_wordlist(wordlist_path)
+
+    def _ingest_wordlist(self, wordlist_path: Path):
+        with open(wordlist_path) as stream:
+            self._wordlist = [w.strip() for w in stream.readlines()]
+
+    def to_seed(self, words, password="", validate=True):
         """
         Use Mnemonic words and optionally a password to create a PBKDF2 seed (Password-Based Key Derivation Function 2)
 
         First use 'sanitize_mnemonic' to determine language and validate and check words
 
         >>> Mnemonic().to_seed('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()
         '6969ed4666db67fc74fae7869e2acf3c766b5ef95f5e31eb2fcebd93d76069c6de971225f700042b0b513f0ad6c8562277fc4b5ee1344b720f1686dc2dccc220'
@@ -80,16 +89,20 @@
         """
         words = self.sanitize_mnemonic(words)
         # Check if passphrase is valid
         if validate:
             self.to_entropy(words)
         mnemonic = to_bytes(words)
         password = to_bytes(password)
-        return hashlib.pbkdf2_hmac(hash_name='sha512', password=mnemonic, salt=b'mnemonic' + password,
-                                   iterations=2048)
+        return hashlib.pbkdf2_hmac(
+            hash_name="sha512",
+            password=mnemonic,
+            salt=b"mnemonic" + password,
+            iterations=2048,
+        )
 
     def word(self, index):
         """
         Get word from wordlist
 
         :param index: word index ID
         :type index: int
@@ -138,23 +151,29 @@
         :type add_checksum: bool
         :param check_on_curve: Check if data integer value is on secp256k1 curve. Should be enabled when not testing and working with crypto
         :type check_on_curve: bool
 
         :return str: Mnemonic passphrase consisting of a space seperated list of words
         """
         data = to_bytes(data)
-        data_int = int.from_bytes(data, 'big')
+        data_int = int.from_bytes(data, "big")
         if check_on_curve and not 0 < data_int < secp256k1_n:
-            raise ValueError("Integer value of data should be in secp256k1 domain between 1 and secp256k1_n-1")
+            raise ValueError(
+                "Integer value of data should be in secp256k1 domain between 1 and secp256k1_n-1"
+            )
         if add_checksum:
-            binresult = change_base(data_int, 10, 2, len(data) * 8) + self.checksum(data)
+            binresult = change_base(data_int, 10, 2, len(data) * 8) + self.checksum(
+                data
+            )
             wi = change_base(binresult, 2, 2048)
         else:
-            wi = change_base(data_int, 10, 2048, len(data) // 1.375 + len(data) % 1.375 > 0)
-        return normalize_string(' '.join([self._wordlist[i] for i in wi]))
+            wi = change_base(
+                data_int, 10, 2048, len(data) // 1.375 + len(data) % 1.375 > 0
+            )
+        return normalize_string(" ".join([self._wordlist[i] for i in wi]))
 
     def to_entropy(self, words, includes_checksum=True):
         """
         Convert Mnemonic words back to key data entropy
 
         >>> Mnemonic().to_entropy('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()
         '28acfc94465fd2f6774759d6897ec122'
@@ -165,26 +184,26 @@
         :param includes_checksum: Boolean to specify if checksum is used. Default is True
         :type includes_checksum: bool
 
         :return bytes: Entropy seed
         """
         words = self.sanitize_mnemonic(words)
         if isinstance(words, TYPE_TEXT):
-            words = words.split(' ')
+            words = words.split(" ")
         wi = []
         for word in words:
             wi.append(self._wordlist.index(word))
-        ent_length = int(len(words) * 4/3)
+        ent_length = int(len(words) * 4 / 3)
         ent = change_base(wi, 2048, 256, ent_length, output_even=False)
         if includes_checksum:
             binresult = change_base(ent, 256, 2, len(ent) * 4)
-            ent = change_base(binresult[:-len(binresult) // 33], 2, 256, ent_length)
+            ent = change_base(binresult[: -len(binresult) // 33], 2, 256, ent_length)
 
             # Check checksum
-            checksum = binresult[-len(binresult) // 33:]
+            checksum = binresult[-len(binresult) // 33 :]
             if checksum != self.checksum(ent):
                 raise ValueError("Invalid checksum %s for entropy %s" % (checksum, ent))
 
         return ent
 
     @staticmethod
     def detect_language(words):
@@ -197,22 +216,24 @@
         :param words: List of space separated words
         :type words: str
 
         :return str: Language
         """
         words = normalize_string(words)
         if isinstance(words, TYPE_TEXT):
-            words = words.split(' ')
+            words = words.split(" ")
 
         wlcount = {}
-        for fn in Path(FW_INSTALL_DIR, 'wordlist').iterdir():
+        for fn in Path(FW_INSTALL_DIR, "wordlist").iterdir():
             if fn.suffix == ".txt":
-                with open(os.path.join(str(FW_INSTALL_DIR), 'wordlist', fn), encoding='utf-8') as f:
+                with open(
+                    os.path.join(str(FW_INSTALL_DIR), "wordlist", fn), encoding="utf-8"
+                ) as f:
                     wordlist = [w.strip() for w in f.readlines()]
-                    language = fn.name.split('.')[0]
+                    language = fn.name.split(".")[0]
                     wlcount[language] = 0
                     for word in words:
                         if word in wordlist:
                             wlcount[language] += 1
         detlang = max(wlcount.keys(), key=(lambda key: wlcount[key]))
         if not wlcount[detlang]:
             raise Warning("Could not detect language of Mnemonic sentence %s" % words)
@@ -228,14 +249,17 @@
         :type words: str
 
         :return str: Sanitized list of words
         """
         words = normalize_string(words)
         language = self.detect_language(words)
         if isinstance(words, TYPE_TEXT):
-            words = words.split(' ')
-        with Path(FW_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:
+            words = words.split(" ")
+        with Path(FW_INSTALL_DIR, "wordlist", "%s.txt" % language).open() as f:
             wordlist = [w.strip() for w in f.readlines()]
             for word in words:
                 if word not in wordlist:
-                    raise Warning("Unrecognised word %s in mnemonic sentence" % word.encode('utf8'))
-        return ' '.join(words)
+                    raise Warning(
+                        "Unrecognised word %s in mnemonic sentence"
+                        % word.encode("utf8")
+                    )
+        return " ".join(words)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/pyproject.toml` & `fluxwallet-0.1.0/fluxwallet/pyproject.toml`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/scripts.py` & `fluxwallet-0.1.0/fluxwallet/scripts.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/services/__init__.py` & `fluxwallet-0.1.0/fluxwallet/services/__init__.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/services/authproxy.py` & `fluxwallet-0.1.0/fluxwallet/services/authproxy.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/services/baseclient.py` & `fluxwallet-0.1.0/fluxwallet/services/baseclient.py`

 * *Files 10% similar despite different names*

```diff
@@ -27,26 +27,36 @@
 from fluxwallet.main import *
 from fluxwallet.networks import Network
 
 _logger = logging.getLogger(__name__)
 
 
 class ClientError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.info(msg)
 
     def __str__(self):
         return self.msg
 
 
 class BaseClient(object):
-
-    def __init__(self, network, provider, base_url, denominator, api_key='', provider_coin_id='',
-                 network_overrides=None, timeout=TIMEOUT_REQUESTS, latest_block=None, strict=True):
+    def __init__(
+        self,
+        network: str,
+        provider: str,
+        base_url: str,
+        denominator: int,
+        api_key: str = "",
+        provider_coin_id: str = "",
+        network_overrides=None,
+        timeout=TIMEOUT_REQUESTS,
+        latest_block=None,
+        strict=True,
+    ):
         try:
             self.network = network
             if not isinstance(network, Network):
                 self.network = Network(network)
             self.provider = provider
             self.base_url = base_url
             self.resp = None
@@ -58,26 +68,36 @@
             self.latest_block = latest_block
             if network_overrides is not None:
                 self.network_overrides = network_overrides
             self.strict = strict
         except Exception:
             raise ClientError("This Network is not supported by %s Client" % provider)
 
-    def request(self, url_path, variables={}, method="get", secure=True, post_data="", base = None):
+    def request(
+        self,
+        url_path: str,
+        variables: dict = {},
+        method: str = "get",
+        secure: bool = True,
+        post_data: str = "",
+        base: str | None = None,
+    ):
         url_vars = ""
-        url = self.base_url + url_path if base is None else base + url_path
+        url = f"{self.base_url}{url_path}" if base is None else f"{base}{url_path}"
+
         if not url or not self.base_url:
             raise ClientError("No (complete) url provided: %s" % url)
+
         headers = {
-            "User-Agent": "fluxwallet/%s" % FLUXWALLET_VERSION,
+            "User-Agent": f"fluxwallet/{FLUXWALLET_VERSION}",
             "Accept": "application/json",
             # 'Content-Type': 'application/json',
-            "Referrer": "https://www.github.com/1200wd/fluxwallet",
+            # "Referrer": "https://www.github.com/1200wd/fluxwallet",
         }
-        # ToDo: Check use 'headers = None' for some providers?
+
         if method == "get":
             if variables:
                 url_vars = "?" + urlencode(variables)
             url += url_vars
             log_url = url if "@" not in url else url.split("@")[1]
             _logger.info("Url get request %s" % log_url)
             self.resp = requests.get(
@@ -122,14 +142,18 @@
                 return self.resp.content
             return json.loads(self.resp.text)
         except ValueError or json.decoder.JSONDecodeError:
             return self.resp.text
 
     def _address_convert(self, address):
         if not isinstance(address, Address):
-            return Address.parse(address, network_overrides=self.network_overrides, network=self.network.name)
+            return Address.parse(
+                address,
+                network_overrides=self.network_overrides,
+                network=self.network.name,
+            )
 
     def _addresslist_convert(self, addresslist):
         addresslistconv = []
         for address in addresslist:
             addresslistconv.append(self._address_convert(address))
         return addresslistconv
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bcoin.py` & `fluxwallet-0.1.0/fluxwallet/services/bcoin.py`

 * *Files 9% similar despite different names*

```diff
@@ -16,224 +16,232 @@
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 from fluxwallet.main import *
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction, transaction_update_spents
+from fluxwallet.transactions import BitcoinTransaction, transaction_update_spents
 
-PROVIDERNAME = 'bcoin'
+PROVIDERNAME = "bcoin"
 
 _logger = logging.getLogger(__name__)
 
 
 class BcoinClient(BaseClient):
     """
     Class to interact with Bcoin API
     """
 
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, func, data='', parameter='', variables=None, method='get'):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, func, data="", parameter="", variables=None, method="get"
+    ):
         url_path = func
         if data:
-            url_path += '/' + str(data)
+            url_path += "/" + str(data)
         if parameter:
-            url_path += '/' + parameter
+            url_path += "/" + parameter
         if variables is None:
             variables = {}
         return self.request(url_path, variables, method, secure=False)
 
     def _parse_transaction(self, tx):
-        status = 'unconfirmed'
-        if tx['confirmations']:
-            status = 'confirmed'
-        t = Transaction.parse_hex(tx['hex'], strict=False, network=self.network)
-        t.locktime = tx['locktime']
+        status = "unconfirmed"
+        if tx["confirmations"]:
+            status = "confirmed"
+        t = BitcoinTransaction.parse_hex(tx["hex"], strict=False, network=self.network)
+        t.locktime = tx["locktime"]
         t.network = self.network
-        t.fee = tx['fee']
-        t.date = datetime.utcfromtimestamp(tx['time']) if tx['time'] else None
-        t.confirmations = tx['confirmations']
-        t.block_height = tx['height'] if tx['height'] > 0 else None
-        t.block_hash = tx['block']
+        t.fee = tx["fee"]
+        t.date = datetime.utcfromtimestamp(tx["time"]) if tx["time"] else None
+        t.confirmations = tx["confirmations"]
+        t.block_height = tx["height"] if tx["height"] > 0 else None
+        t.block_hash = tx["block"]
         t.status = status
         if not t.coinbase:
             for i in t.inputs:
-                i.value = tx['inputs'][t.inputs.index(i)]['coin']['value']
+                i.value = tx["inputs"][t.inputs.index(i)]["coin"]["value"]
         for o in t.outputs:
             o.spent = None
         t.update_totals()
         return t
 
     def getbalance(self, addresslist):
         balance = 0.0
         from fluxwallet.services.services import Service
+
         for address in addresslist:
             # First get all transactions for this address from the blockchain
-            srv = Service(network=self.network.name, providers=['bcoin'])
+            srv = Service(network=self.network.name, providers=["bcoin"])
             txs = srv.gettransactions(address, limit=25)
 
             # Fail if large number of transactions are found
             if not srv.complete:
-                raise ClientError("If not all transactions are known, we cannot determine utxo's. "
-                                  "Increase limit or use other provider.")
-
-            for a in [output for outputs in [t.outputs for t in txs] for output in outputs]:
+                raise ClientError(
+                    "If not all transactions are known, we cannot determine utxo's. "
+                    "Increase limit or use other provider."
+                )
+
+            for a in [
+                output for outputs in [t.outputs for t in txs] for output in outputs
+            ]:
                 if a.address == address:
                     balance += a.value
             for a in [i for inputs in [t.inputs for t in txs] for i in inputs]:
                 if a.address == address:
                     balance -= a.value
         return int(balance)
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         # First get all transactions for this address from the blockchain
         txs = self.gettransactions(address, limit=50)
 
         # Fail if large number of transactions are found
         if len(txs) > 50:
-            raise ClientError("If not all transactions are known, we cannot determine utxo's")
+            raise ClientError(
+                "If not all transactions are known, we cannot determine utxo's"
+            )
 
         utxos = []
         for tx in txs:
             for unspent in tx.outputs:
                 if unspent.address != address:
                     continue
                 if not self.isspent(tx.txid, unspent.output_n):
                     utxos.append(
                         {
-                            'address': unspent.address,
-                            'txid': tx.txid,
-                            'confirmations': tx.confirmations,
-                            'output_n': unspent.output_n,
-                            'input_n': 0,
-                            'block_height': tx.block_height,
-                            'fee': tx.fee,
-                            'size': tx.size,
-                            'value': unspent.value,
-                            'script': unspent.lock_script.hex(),
-                            'date': tx.date,
-                         }
+                            "address": unspent.address,
+                            "txid": tx.txid,
+                            "confirmations": tx.confirmations,
+                            "output_n": unspent.output_n,
+                            "input_n": 0,
+                            "block_height": tx.block_height,
+                            "fee": tx.fee,
+                            "size": tx.size,
+                            "value": unspent.value,
+                            "script": unspent.lock_script.hex(),
+                            "date": tx.date,
+                        }
                     )
                     if tx.txid == after_txid:
                         utxos = []
         return utxos[:limit]
 
     def gettransaction(self, txid):
-        tx = self.compose_request('tx', txid)
+        tx = self.compose_request("tx", txid)
         return self._parse_transaction(tx)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        assert(limit > 0)
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        assert limit > 0
         txs = []
         while True:
-            variables = {'limit': limit, 'after': after_txid}
-            res = self.compose_request('tx', 'address', address, variables)
+            variables = {"limit": limit, "after": after_txid}
+            res = self.compose_request("tx", "address", address, variables)
             for tx in res:
                 txs.append(self._parse_transaction(tx))
             if not txs or len(txs) >= limit:
                 break
             if len(res) == limit:
-                after_txid = res[limit-1]['hash']
+                after_txid = res[limit - 1]["hash"]
             else:
                 break
 
         # Check which outputs are spent/unspent for this address
         if not after_txid and len(txs) != limit:
             txs = transaction_update_spents(txs, address)
         return txs
 
     def getrawtransaction(self, txid):
-        return self.compose_request('tx', txid)['hex']
+        return self.compose_request("tx", txid)["hex"]
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('broadcast', variables={'tx': rawtx}, method='post')
-        txid = ''
-        if 'success' in res and res['success']:
-            t = Transaction.parse_hex(rawtx, network=self.network)
+        res = self.compose_request("broadcast", variables={"tx": rawtx}, method="post")
+        txid = ""
+        if "success" in res and res["success"]:
+            t = BitcoinTransaction.parse_hex(rawtx, network=self.network)
             txid = t.txid
-        return {
-            'txid': txid,
-            'response_dict': res
-        }
+        return {"txid": txid, "response_dict": res}
 
     def estimatefee(self, blocks):
         if blocks > 15:
             blocks = 15
-        fee = self.compose_request('fee', variables={'blocks': blocks})['rate']
+        fee = self.compose_request("fee", variables={"blocks": blocks})["rate"]
         if not fee:
             return False
         return fee
 
     def blockcount(self):
-        return self.compose_request('')['chain']['height']
+        return self.compose_request("")["chain"]["height"]
 
-    def mempool(self, txid=''):
-        txids = self.compose_request('mempool')
+    def mempool(self, txid=""):
+        txids = self.compose_request("mempool")
         if not txid:
             return txids
         elif txid in txids:
             return [txid]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        block = self.compose_request('block', str(blockid))
-        block['tx_count'] = len(block['txs'])
-        txs = block['txs']
+        block = self.compose_request("block", str(blockid))
+        block["tx_count"] = len(block["txs"])
+        txs = block["txs"]
         parsed_txs = []
         if parse_transactions:
-            txs = txs[(page-1)*limit:page*limit]
+            txs = txs[(page - 1) * limit : page * limit]
         for tx in txs:
-            tx['confirmations'] = block['depth']
-            tx['time'] = block['time']
-            tx['height'] = block['height']
-            tx['block'] = block['hash']
+            tx["confirmations"] = block["depth"]
+            tx["time"] = block["time"]
+            tx["height"] = block["height"]
+            tx["block"] = block["hash"]
             if parse_transactions:
                 t = self._parse_transaction(tx)
                 parsed_txs.append(t)
             else:
-                parsed_txs.append(tx['hash'])
+                parsed_txs.append(tx["hash"])
 
-        block['time'] = block['time']
-        block['txs'] = parsed_txs
-        block['page'] = page
-        block['pages'] = None if not limit else int(block['tx_count'] // limit) + (block['tx_count'] % limit > 0)
-        block['limit'] = limit
-        block['prev_block'] = block.pop('prevBlock')
-        block['merkle_root'] = block.pop('merkleRoot')
-        block['block_hash'] = block.pop('hash')
+        block["time"] = block["time"]
+        block["txs"] = parsed_txs
+        block["page"] = page
+        block["pages"] = (
+            None
+            if not limit
+            else int(block["tx_count"] // limit) + (block["tx_count"] % limit > 0)
+        )
+        block["limit"] = limit
+        block["prev_block"] = block.pop("prevBlock")
+        block["merkle_root"] = block.pop("merkleRoot")
+        block["block_hash"] = block.pop("hash")
         return block
 
     def getrawblock(self, blockid):
         try:
             blockid = int(blockid)
-            data = {
-                "method": "getblockbyheight",
-                "params": [blockid, 0, 0]
-            }
+            data = {"method": "getblockbyheight", "params": [blockid, 0, 0]}
         except ValueError:
-            data = {
-                "method": "getblock",
-                "params": [blockid, 0, 0]
-            }
-        res = self.compose_request('', method='post', variables=data)
-        return res['result']
+            data = {"method": "getblock", "params": [blockid, 0, 0]}
+        res = self.compose_request("", method="post", variables=data)
+        return res["result"]
 
     def isspent(self, txid, index):
         try:
-            self.compose_request('coin', txid, str(index))
+            self.compose_request("coin", txid, str(index))
         except ClientError:
             return 1
         return 0
 
     def getinfo(self):
-        res = self.compose_request('', variables={'method': 'getmininginfo'}, method='post')
-        info = res['result']
+        res = self.compose_request(
+            "", variables={"method": "getmininginfo"}, method="post"
+        )
+        info = res["result"]
         return {
-            'blockcount': info['blocks'],
-            'chain': info['chain'],
-            'difficulty': info['difficulty'],
-            'hashrate': info['networkhashps'],
-            'mempool_size': info['pooledtx']
+            "blockcount": info["blocks"],
+            "chain": info["chain"],
+            "difficulty": info["difficulty"],
+            "hashrate": info["networkhashps"],
+            "mempool_size": info["pooledtx"],
         }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bitaps.py` & `fluxwallet-0.1.0/fluxwallet/services/bitaps.py`

 * *Files 7% similar despite different names*

```diff
@@ -19,35 +19,44 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
 _logger = logging.getLogger(__name__)
 
-PROVIDERNAME = 'bitaps'
+PROVIDERNAME = "bitaps"
 # Please note: In the Bitaps API, the first couple of Bitcoin blocks are not correctly indexed,
 # so transactions from these blocks are missing.
 
 
 class BitapsClient(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, category, command='', data='', variables=None, req_type='blockchain', method='get'):
-        url_path = req_type + '/' + category
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self,
+        category,
+        command="",
+        data="",
+        variables=None,
+        req_type="blockchain",
+        method="get",
+    ):
+        url_path = req_type + "/" + category
         if command:
-            url_path += '/' + command
+            url_path += "/" + command
         if data:
-            if url_path[-1:] != '/':
-                url_path += '/'
+            if url_path[-1:] != "/":
+                url_path += "/"
             url_path += data
         return self.request(url_path, variables=variables, method=method)
 
     # def _parse_transaction(self, tx):
     #     status = 'unconfirmed'
     #     if tx['confirmations']:
     #         status = 'confirmed'
@@ -59,15 +68,15 @@
     #     block_height = None
     #     if 'blockHeight' in tx:
     #         block_height = tx['blockHeight']
     #     witness_type = 'legacy'
     #     if tx['segwit']:
     #         witness_type = 'segwit'
     #
-    #     t = Transaction(
+    #     t = BitcoinTransaction(
     #         locktime=tx['lockTime'], version=tx['version'], network=self.network, fee=tx['fee'],
     #         fee_per_kb=None if 'feeRate' not in tx else int(tx['feeRate']), size=tx['size'],
     #         txid=tx['txId'], date=date, confirmations=tx['confirmations'], block_height=block_height,
     #         input_total=tx['inputsAmount'], output_total=tx['outputsAmount'], status=status, coinbase=tx['coinbase'],
     #         verified=None if 'valid' not in tx else tx['valid'], witness_type=witness_type)
     #
     #     for n, ti in tx['vIn'].items():
@@ -89,57 +98,69 @@
     #                      strict=self.strict)
     #
     #     return t
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('address', 'state', address)
-            balance += res['data']['balance']
+            res = self.compose_request("address", "state", address)
+            balance += res["data"]["balance"]
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         utxos = []
         page = 1
         while True:
-            variables = {'mode': 'verbose', 'limit': 50, 'page': page, 'order': 'asc'}
+            variables = {"mode": "verbose", "limit": 50, "page": page, "order": "asc"}
             try:
-                res = self.compose_request('address', 'transactions', address, variables)
-                res2 = self.compose_request('address', 'unconfirmed/transactions', address, variables)
+                res = self.compose_request(
+                    "address", "transactions", address, variables
+                )
+                res2 = self.compose_request(
+                    "address", "unconfirmed/transactions", address, variables
+                )
             except ClientError as e:
                 if "address not found" in self.resp.text:
                     return []
                 else:
                     raise ClientError(e.msg)
-            txs = res['data']['list']
-            txs += res2['data']['list']
+            txs = res["data"]["list"]
+            txs += res2["data"]["list"]
             for tx in txs:
-                for outp in tx['vOut']:
-                    utxo = tx['vOut'][outp]
-                    if 'address' not in utxo or utxo['address'] != address or utxo['spent']:
+                for outp in tx["vOut"]:
+                    utxo = tx["vOut"][outp]
+                    if (
+                        "address" not in utxo
+                        or utxo["address"] != address
+                        or utxo["spent"]
+                    ):
                         continue
                     utxos.append(
                         {
-                            'address': utxo['address'],
-                            'txid': tx['txId'],
-                            'confirmations': 0 if 'confirmations' not in tx else tx['confirmations'],
-                            'output_n': int(outp),
-                            'input_n': 0,
-                            'block_height': None if 'blockHeight' not in tx else tx['blockHeight'],
-                            'fee': None,
-                            'size': 0,
-                            'value': utxo['value'],
-                            'script': utxo['scriptPubKey'],
-                            'date': datetime.utcfromtimestamp(tx['timestamp'])
-                         }
+                            "address": utxo["address"],
+                            "txid": tx["txId"],
+                            "confirmations": 0
+                            if "confirmations" not in tx
+                            else tx["confirmations"],
+                            "output_n": int(outp),
+                            "input_n": 0,
+                            "block_height": None
+                            if "blockHeight" not in tx
+                            else tx["blockHeight"],
+                            "fee": None,
+                            "size": 0,
+                            "value": utxo["value"],
+                            "script": utxo["scriptPubKey"],
+                            "date": datetime.utcfromtimestamp(tx["timestamp"]),
+                        }
                     )
-                if tx['txId'] == after_txid:
+                if tx["txId"] == after_txid:
                     utxos = []
             page += 1
-            if page > res['data']['pages']:
+            if page > res["data"]["pages"]:
                 break
         return utxos[:limit]
 
     # FIXME: Disabled results very unpredictable, seem randomized... :(
     # def gettransaction(self, txid):
     #     res = self.compose_request('transaction', txid)
     #     return self._parse_transaction(res['data'])
@@ -170,15 +191,15 @@
     #     return tx['data']['rawTx']
 
     # def sendrawtransaction
 
     # def estimatefee
 
     def blockcount(self):
-        return self.compose_request('block', 'last')['data']['height']
+        return self.compose_request("block", "last")["data"]["height"]
 
     # def mempool(self, txid):
     #     if txid:
     #         t = self.gettransaction(txid)
     #         if t and not t.confirmations:
     #             return [t.txid]
     #     else:
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bitcoind.py` & `fluxwallet-0.1.0/fluxwallet/services/litecoind.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    Client for bitcoind deamon
-#     2017 - 2020 Oct - 1200 Web Development <http://1200wd.com/>
+#    Client for litecoind deamon
+#     2018-2022 Oct - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -20,254 +20,291 @@
 
 import configparser
 
 from fluxwallet.main import *
 from fluxwallet.networks import Network
 from fluxwallet.services.authproxy import AuthServiceProxy
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'bitcoind'
+PROVIDERNAME = "litecoind"
 
 _logger = logging.getLogger(__name__)
 
 
 class ConfigError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.info(msg)
 
     def __str__(self):
         return self.msg
 
 
 def _read_from_config(configparser, section, value, fallback=None):
     try:
         return configparser.get(section, value)
     except Exception:
         return fallback
 
 
-class BitcoindClient(BaseClient):
+class LitecoindClient(BaseClient):
     """
-    Class to interact with bitcoind, the Bitcoin deamon
+    Class to interact with litecoind, the Litecoin deamon
     """
 
     @staticmethod
-    def from_config(configfile=None, network='bitcoin'):
+    def from_config(configfile=None, network="litecoin"):
         """
-        Read settings from bitcoind config file
+        Read settings from litecoind config file
 
         :param configfile: Path to config file. Leave empty to look in default places
         :type: str
-        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet
+        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet
         :type: str
 
-        :return BitcoindClient:
+        :return LitecoindClient:
         """
         try:
             config = configparser.ConfigParser(strict=False)
         except TypeError:
             config = configparser.ConfigParser()
-        config_fn = 'bitcoin.conf'
+        config_fn = "litecoin.conf"
         if isinstance(network, Network):
             network = network.name
-        if network == 'testnet':
-            config_fn = 'bitcoin-testnet.conf'
+        if network == "testnet":
+            config_fn = "litecoin-testnet.conf"
 
         cfn = None
         if not configfile:
-            config_locations = ['~/.fluxwallet', '~/.bitcoin', '~/Application Data/Bitcoin',
-                                '~/Library/Application Support/Bitcoin']
+            config_locations = [
+                "~/.fluxwallet",
+                "~/.litecoin",
+                "~/Application Data/Litecoin",
+                "~/Library/Application Support/Litecoin",
+            ]
             for location in config_locations:
                 cfn = Path(location, config_fn).expanduser()
                 if cfn.exists():
                     break
         else:
-            cfn = Path(FW_DATA_DIR, 'config', configfile)
+            cfn = Path(FW_DATA_DIR, "config", configfile)
 
         if not cfn or not cfn.is_file():
-            raise ConfigError("Config file %s not found. Please install bitcoin client and specify a path to config "
-                              "file if path is not default. Or place a config file in .fluxwallet/bitcoin.conf to "
-                              "reference to an external server." % cfn)
+            raise ConfigError(
+                "Config file %s not found. Please install Litecoin client and specify a path to config "
+                "file if path is not default. Or place a config file in .fluxwallet/litecoin.conf to "
+                "reference to an external server." % cfn
+            )
 
         try:
             config.read(cfn)
         except Exception:
             with cfn.open() as f:
-                config_string = '[rpc]\n' + f.read()
+                config_string = "[rpc]\n" + f.read()
             config.read_string(config_string)
 
-        testnet = _read_from_config(config, 'rpc', 'testnet')
+        testnet = _read_from_config(config, "rpc", "testnet")
         if testnet:
-            network = 'testnet'
-        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':
+            network = "testnet"
+        if _read_from_config(config, "rpc", "rpcpassword") == "specify_rpc_password":
             raise ConfigError("Please update config settings in %s" % cfn)
-        if network == 'testnet':
-            port = 18332
+        if network == "testnet":
+            port = 19332
         else:
-            port = 8332
-        port = _read_from_config(config, 'rpc', 'rpcport', port)
-        server = '127.0.0.1'
-        server = _read_from_config(config, 'rpc', 'rpcconnect', server)
-        server = _read_from_config(config, 'rpc', 'bind', server)
-        server = _read_from_config(config, 'rpc', 'externalip', server)
+            port = 9332
+        port = _read_from_config(config, "rpc", "rpcport", port)
+        server = "127.0.0.1"
+        server = _read_from_config(config, "rpc", "rpcconnect", server)
+        server = _read_from_config(config, "rpc", "bind", server)
+        server = _read_from_config(config, "rpc", "externalip", server)
+        url = "http://%s:%s@%s:%s" % (
+            config.get("rpc", "rpcuser"),
+            config.get("rpc", "rpcpassword"),
+            server,
+            port,
+        )
+        return LitecoindClient(network, url)
 
-        url = "http://%s:%s@%s:%s" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)
-        return BitcoindClient(network, url)
-
-    def __init__(self, network='bitcoin', base_url='', denominator=100000000, *args):
+    def __init__(self, network="litecoin", base_url="", denominator=100000000, *args):
         """
-        Open connection to bitcoin node
+        Open connection to litecoin node
 
-        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet
+        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet
         :type: str
         :param base_url: Connection URL in format http(s)://user:password@host:port.
         :type: str
-        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for bitcoin
+        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for litecoin
         :type: str
         """
         if isinstance(network, Network):
             network = network.name
         if not base_url:
-            bdc = self.from_config('', network)
+            bdc = self.from_config("", network)
             base_url = bdc.base_url
             network = bdc.network
-        if len(base_url.split(':')) != 4:
-            raise ConfigError("Bitcoind connection URL must be of format 'http(s)://user:password@host:port,"
-                              "current format is %s. Please set url in providers.json file or check bitcoin config "
-                              "file" % base_url)
-        if 'password' in base_url:
-            raise ConfigError("Invalid password in bitcoind provider settings. "
-                              "Please replace default password and set url in providers.json or bitcoin.conf file")
-        _logger.info("Connect to bitcoind")
+        if len(base_url.split(":")) != 4:
+            raise ConfigError(
+                "Litecoind connection URL must be of format 'http(s)://user:password@host:port,"
+                "current format is %s. Please set url in providers.json file or check litecoin config "
+                "file" % base_url
+            )
+        if "password" in base_url:
+            raise ConfigError(
+                "Invalid password in litecoind provider settings. "
+                "Please replace default password and set url in providers.json or litecoin.conf file"
+            )
+        _logger.info("Connect to litecoind")
         self.proxy = AuthServiceProxy(base_url)
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
             res = self.proxy.getaddressinfo(address)
-            if not (res['ismine'] or res['iswatchonly']):
+            if not (res["ismine"] or res["iswatchonly"]):
                 raise ClientError(
-                    "Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
-                    "address to wallet." % address)
+                    "Address %s not found in litceoind wallet, use 'importpubkey' or 'importaddress' to add "
+                    "address to wallet." % address
+                )
             txs_list = self.proxy.listunspent(0, 99999999, [address])
             for tx in txs_list:
-                balance += int(tx['amount'] * self.units)
+                balance += int(tx["amount"] * self.units)
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         utxos = []
         res = self.proxy.getaddressinfo(address)
-        if not (res['ismine'] or res['iswatchonly']):
-            raise ClientError("Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
-                              "address to wallet." % address)
+        if not (res["ismine"] or res["iswatchonly"]):
+            raise ClientError(
+                "Address %s not found in litecoind wallet, use 'importpubkey' or 'importaddress' to add "
+                "address to wallet." % address
+            )
 
-        txs_list = self.proxy.listunspent(0, 9999999, [address])
+        txs_list = self.proxy.listunspent(0, 99999999, [address])
         blockcount = self.blockcount()
-        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):
-            utxos.append({
-                'address': tx['address'],
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': tx['vout'],
-                'input_n': -1,
-                'block_height': blockcount - tx['confirmations'] + 1,
-                'fee': None,
-                'size': 0,
-                'value': int(tx['amount'] * self.units),
-                'script': tx['scriptPubKey'],
-                'date': None,
-            })
-            if tx['txid'] == after_txid:
+        for tx in sorted(txs_list, key=lambda x: x["confirmations"], reverse=True):
+            utxos.append(
+                {
+                    "address": tx["address"],
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": tx["vout"],
+                    "input_n": -1,
+                    "block_height": blockcount - tx["confirmations"] + 1,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(tx["amount"] * self.units),
+                    "script": tx["scriptPubKey"],
+                    "date": None,
+                }
+            )
+            if tx["txid"] == after_txid:
                 utxos = []
 
         return utxos
 
     def _parse_transaction(self, tx, block_height=None, get_input_values=True):
-        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
-        t.confirmations = tx.get('confirmations')
-        t.block_hash = tx.get('blockhash')
-        t.status = 'unconfirmed'
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        t.confirmations = tx.get("confirmations")
+        t.block_hash = tx.get("blockhash")
+        t.status = "unconfirmed"
         for i in t.inputs:
-            if i.prev_txid == b'\x00' * 32:
-                i.script_type = 'coinbase'
+            if i.prev_txid == b"\x00" * 32:
+                i.script_type = "coinbase"
                 continue
             if get_input_values:
                 txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)
-                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))
+                i.value = int(
+                    round(
+                        float(txi["vout"][i.output_n_int]["value"])
+                        / self.network.denominator
+                    )
+                )
         for o in t.outputs:
             o.spent = None
 
         if not block_height and t.block_hash:
-            block_height = self.proxy.getblock(t.block_hash, 1)['height']
+            block_height = self.proxy.getblock(t.block_hash, 1)["height"]
         t.block_height = block_height
         if not t.confirmations and block_height is not None:
             if not self.latest_block:
                 self.latest_block = self.blockcount()
             t.confirmations = (self.latest_block - block_height) + 1
         if t.confirmations or block_height:
-            t.status = 'confirmed'
+            t.status = "confirmed"
             t.verified = True
-        t.version = tx['version'].to_bytes(4, 'big')
-        t.version_int = tx['version']
-        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])
+        t.version = tx["version"].to_bytes(4, "big")
+        t.version_int = tx["version"]
+        t.date = None if "time" not in tx else datetime.utcfromtimestamp(tx["time"])
         t.update_totals()
         return t
 
     def gettransaction(self, txid):
         tx_raw = self.proxy.getrawtransaction(txid, 1)
         return self._parse_transaction(tx_raw)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         MAX_WALLET_TRANSACTIONS = 1000
         txs = []
         res = self.proxy.getaddressinfo(address)
-        if not (res['ismine'] or res['iswatchonly']):
-            raise ClientError("Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
-                              "address to wallet." % address)
+        if not (res["ismine"] or res["iswatchonly"]):
+            raise ClientError(
+                "Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
+                "address to wallet." % address
+            )
         txs_list = self.proxy.listtransactions("*", MAX_WALLET_TRANSACTIONS, 0, True)
         if len(txs_list) >= MAX_WALLET_TRANSACTIONS:
-            raise ClientError("Bitcoind wallet contains too many transactions %d, use other service provider for this "
-                              "wallet" % MAX_WALLET_TRANSACTIONS)
-        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))
-        for (txid, blockheight) in txids:
+            raise ClientError(
+                "Bitcoind wallet contains too many transactions %d, use other service provider for this "
+                "wallet" % MAX_WALLET_TRANSACTIONS
+            )
+        txids = list(
+            set(
+                [
+                    (tx["txid"], tx["blockheight"])
+                    for tx in txs_list
+                    if tx["address"] == address
+                ]
+            )
+        )
+        for txid, blockheight in txids:
             tx_raw = self.proxy.getrawtransaction(txid, 1)
             t = self._parse_transaction(tx_raw, blockheight)
             txs.append(t)
             if txid == after_txid:
                 txs = []
         return txs
 
     def getrawtransaction(self, txid):
         res = self.proxy.getrawtransaction(txid)
         return res
 
     def sendrawtransaction(self, rawtx):
         res = self.proxy.sendrawtransaction(rawtx)
-        return {
-            'txid': res,
-            'response_dict': res
-        }
+        return {"txid": res, "response_dict": res}
 
     def estimatefee(self, blocks):
-        pres = ''
+        pres = ""
         try:
             pres = self.proxy.estimatesmartfee(blocks)
-            res = pres['feerate']
+            res = pres["feerate"]
         except KeyError as e:
-            _logger.info("bitcoind error: %s, %s" % (e, pres))
+            _logger.info("litecoind error: %s, %s" % (e, pres))
             res = self.proxy.estimatefee(blocks)
         return int(res * self.units)
 
     def blockcount(self):
         return self.proxy.getblockcount()
 
-    def mempool(self, txid=''):
+    def mempool(self, txid=""):
         txids = self.proxy.getrawmempool()
         if not txid:
             return txids
         elif txid in txids:
             return [txid]
         return []
 
@@ -276,37 +313,43 @@
             blockid = self.proxy.getblockhash(int(blockid))
         if not limit:
             limit = 99999
 
         txs = []
         if parse_transactions:
             bd = self.proxy.getblock(blockid, 2)
-            for tx in bd['tx'][(page - 1) * limit:page * limit]:
-                tx['time'] = bd['time']
-                tx['blockhash'] = bd['hash']
-                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))
+            for tx in bd["tx"][(page - 1) * limit : page * limit]:
+                tx["time"] = bd["time"]
+                tx["blockhash"] = bd["hash"]
+                txs.append(
+                    self._parse_transaction(
+                        tx, block_height=bd["height"], get_input_values=True
+                    )
+                )
         else:
             bd = self.proxy.getblock(blockid, 1)
-            txs = bd['tx']
+            txs = bd["tx"]
 
         block = {
-            'bits': int(bd['bits'], 16),
-            'depth': bd['confirmations'],
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': bd['nonce'],
-            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],
-            'time': bd['time'],
-            'tx_count': bd['nTx'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None,
-            'limit': limit
+            "bits": int(bd["bits"], 16),
+            "depth": bd["confirmations"],
+            "block_hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": bd["nonce"],
+            "prev_block": None
+            if "previousblockhash" not in bd
+            else bd["previousblockhash"],
+            "time": bd["time"],
+            "tx_count": bd["nTx"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None,
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
         if isinstance(blockid, int):
             blockid = self.proxy.getblockhash(blockid)
         return self.proxy.getblock(blockid, 0)
@@ -316,50 +359,52 @@
         if not res:
             return 1
         return 0
 
     def getinfo(self):
         info = self.proxy.getmininginfo()
         return {
-            'blockcount': info['blocks'],
-            'chain': info['chain'],
-            'difficulty': int(info['difficulty']),
-            'hashrate': int(info['networkhashps']),
-            'mempool_size': int(info['pooledtx']),
+            "blockcount": info["blocks"],
+            "chain": info["chain"],
+            "difficulty": int(info["difficulty"]),
+            "hashrate": int(info["networkhashps"]),
+            "mempool_size": int(info["pooledtx"]),
         }
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     #
     # SOME EXAMPLES
     #
 
     from pprint import pprint
 
     # 1. Connect by specifying connection URL
-    # base_url = 'http://bitcoinrpc:passwd@host:8332'
-    # bdc = BitcoindClient(base_url=base_url)
+    # base_url = 'http://litecoin:passwd@host:9432'
+    # bdc = LitecoindClient(base_url=base_url)
     # 2. Or connect using default settings or settings from config file
-    bdc = BitcoindClient()
+    client = LitecoindClient()
 
     print("\n=== SERVERINFO ===")
-    pprint(bdc.proxy.getnetworkinfo())
+    pprint(client.proxy.getnetworkinfo())
 
     print("\n=== Best Block ===")
-    blockhash = bdc.proxy.getbestblockhash()
-    bestblock = bdc.proxy.getblock(blockhash)
-    bestblock['tx'] = '...' + str(len(bestblock['tx'])) + ' transactions...'
+    blockhash = client.proxy.getbestblockhash()
+    bestblock = client.proxy.getblock(blockhash)
+    bestblock["tx"] = "..." + str(len(bestblock["tx"])) + " transactions..."
     pprint(bestblock)
 
     print("\n=== Mempool ===")
-    rmp = bdc.proxy.getrawmempool()
+    rmp = client.proxy.getrawmempool()
     pprint(rmp[:25])
-    print('... truncated ...')
+    print("... truncated ...")
     print("Mempool Size %d" % len(rmp))
 
-    print("\n=== Raw Transaction by txid ===")
-    t = bdc.getrawtransaction('7eb5332699644b753cd3f5afba9562e67612ea71ef119af1ac46559adb69ea0d')
+    print("\n=== Raw BitcoinTransaction by txid ===")
+    t = client.getrawtransaction(
+        "fa3906a4219078364372d0e2715f93e822edd0b47ce146c71ba7ba57179b50f6"
+    )
     pprint(t)
 
     print("\n=== Current network fees ===")
-    t = bdc.estimatefee(5)
+    t = client.estimatefee(5)
     pprint(t)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bitcoinlibtest.py` & `fluxwallet-0.1.0/fluxwallet/services/bitcoinlibtest.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,16 +17,20 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import hashlib
 import logging
 
-from fluxwallet.encoding import (addr_bech32_to_pubkeyhash, addr_to_pubkeyhash,
-                                 double_sha256, to_bytes)
+from fluxwallet.encoding import (
+    addr_bech32_to_pubkeyhash,
+    addr_to_pubkeyhash,
+    double_sha256,
+    to_bytes,
+)
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient
 
 _logger = logging.getLogger(__name__)
 
 PROVIDERNAME = 'bitcoinlib'
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bitflyer.py` & `fluxwallet-0.1.0/fluxwallet/services/bitflyer.py`

 * *Files 10% similar despite different names*

```diff
@@ -19,49 +19,50 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.keys import Address
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'bitflyer'
+PROVIDERNAME = "bitflyer"
 
 
 _logger = logging.getLogger(__name__)
 
 
 class BitflyerClient(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
-    def compose_request(self, function, parameter='', parameter2='', method='get'):
+    def compose_request(self, function, parameter="", parameter2="", method="get"):
         url_path = function
         if parameter:
-            url_path += '/' + str(parameter)
+            url_path += "/" + str(parameter)
         if parameter2:
-            url_path += '/' + str(parameter2)
+            url_path += "/" + str(parameter2)
         return self.request(url_path, method=method)
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('address', address)
-            balance += res['unconfirmed_balance']
+            res = self.compose_request("address", address)
+            balance += res["unconfirmed_balance"]
         return balance
 
     # def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
 
     # def gettransaction(self, txid, block_count=None):
     #     tx = self.compose_request('tx', txid)
     #     # tx_date = None if not tx.get('received_date') else datetime.strptime(tx['received_date'],
     #     #                                                                      "%Y-%m-%dT%H:%M:%S.%f")
-    #     t = Transaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,
+    #     t = BitcoinTransaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,
     #                     # fee=tx['fees'], size=tx['size'], txid=tx['tx_hash'], date=tx_date,
     #                     confirmations=tx['confirmed'], block_height=tx['block_height'],
     #                     status='confirmed' if tx['confirmed'] else 'unconfirmed')
     #     for ti in tx['inputs']:
     #         a = Address.parse(ti['address'])
     #         t.add_input(prev_txid=ti['prev_hash'], output_n=ti['prev_index'], unlocking_script=ti['script'],
     #                     value=ti['value'], address=ti['address'], sequence=ti['sequence'],
@@ -78,16 +79,16 @@
     # def getrawtransaction(self, txid):
 
     # def sendrawtransaction(self, rawtx):
 
     # def estimatefee(self, blocks):
 
     def blockcount(self):
-        res = self.compose_request('block', 'latest')
-        return res['height']
+        res = self.compose_request("block", "latest")
+        return res["height"]
 
     # def mempool(self, txid):
 
     # def getblock(self, blockid, parse_transactions, page, limit):
 
     # def getrawblock(self, blockid):
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/bitgo.py` & `fluxwallet-0.1.0/fluxwallet/services/bitgo.py`

 * *Files 13% similar despite different names*

```diff
@@ -19,78 +19,85 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
 _logger = logging.getLogger(__name__)
 
-PROVIDERNAME = 'bitgo'
+PROVIDERNAME = "bitgo"
 LIMIT_TX = 49
 
 
 class BitGoClient(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
-    def compose_request(self, category, data, cmd='', variables=None, method='get'):
+    def compose_request(self, category, data, cmd="", variables=None, method="get"):
         if data:
-            data = '/' + data
+            data = "/" + data
         url_path = category + data
-        if cmd != '':
-            url_path += '/' + cmd
+        if cmd != "":
+            url_path += "/" + cmd
         return self.request(url_path, variables, method=method)
 
     # def getbalance(self, addresslist):
     #     balance = 0
     #     for address in addresslist:
     #         res = self.compose_request('address', address)
     #         balance += res['balance']
     #     return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         utxos = []
         skip = 0
         total = 1
         while total > skip:
-            variables = {'limit': 100, 'skip': skip}
-            res = self.compose_request('address', address, 'unspents', variables)
-            for utxo in res['unspents'][::-1]:
-                if utxo['tx_hash'] == after_txid:
+            variables = {"limit": 100, "skip": skip}
+            res = self.compose_request("address", address, "unspents", variables)
+            for utxo in res["unspents"][::-1]:
+                if utxo["tx_hash"] == after_txid:
                     break
                 utxos.append(
                     {
-                        'address': utxo['address'],
-                        'txid': utxo['tx_hash'],
-                        'confirmations': utxo['confirmations'],
-                        'output_n': utxo['tx_output_n'],
-                        'input_n': 0,
-                        'block_height': int(utxo['blockHeight']) if utxo['blockHeight'] else None,
-                        'fee': None,
-                        'size': 0,
-                        'value': int(round(utxo['value'] * self.units, 0)),
-                        'script': utxo['script'],
-                        'date': datetime.strptime(utxo['date'], "%Y-%m-%dT%H:%M:%S.%fZ")
-                     }
+                        "address": utxo["address"],
+                        "txid": utxo["tx_hash"],
+                        "confirmations": utxo["confirmations"],
+                        "output_n": utxo["tx_output_n"],
+                        "input_n": 0,
+                        "block_height": int(utxo["blockHeight"])
+                        if utxo["blockHeight"]
+                        else None,
+                        "fee": None,
+                        "size": 0,
+                        "value": int(round(utxo["value"] * self.units, 0)),
+                        "script": utxo["script"],
+                        "date": datetime.strptime(
+                            utxo["date"], "%Y-%m-%dT%H:%M:%S.%fZ"
+                        ),
+                    }
                 )
-            total = res['total']
-            skip = res['start'] + res['count']
+            total = res["total"]
+            skip = res["start"] + res["count"]
             if skip > 2000:
-                _logger.info("BitGoClient: UTXO's list has been truncated, list is incomplete")
+                _logger.info(
+                    "BitGoClient: UTXO's list has been truncated, list is incomplete"
+                )
                 break
         return utxos[::-1][:limit]
 
     # RAW TRANSACTION DOES NOT CONTAIN CORRECT RAW TRANSACTION (MISSING SIGS)
     # def gettransaction(self, txid):
     #     tx = self.compose_request('tx', txid)
-    #     t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
+    #     t = BitcoinTransaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
     #     t.status = 'unconfirmed'
     #     t.date = None
     #     if tx['confirmations']:
     #         t.status = 'confirmed'
     #         t.date = datetime.strptime(tx['date'], "%Y-%m-%dT%H:%M:%S.%fZ")
     #     t.confirmations = tx['confirmations']
     #     if 'height' in tx:
@@ -137,41 +144,41 @@
     #         variables = {'limit': LIMIT_TX, 'skip': skip}
     #         res = self.compose_request('address', address, 'tx', variables)
     #         for tx in res['transactions']:
     #             if tx['id'] not in txids:
     #                 txids.insert(0, tx['id'])
     #         total = res['total']
     #         # if total > 2000:
-    #         #     raise ClientError("BitGoClient: Transactions list limit exceeded > 2000")
+    #         #     raise ClientError("BitGoClient: BitcoinTransactions list limit exceeded > 2000")
     #         skip = res['start'] + res['count']
     #         if len(txids) > limit:
     #             break
     #     if after_txid:
     #         txids = txids[txids.index(after_txid) + 1:]
     #     for txid in txids[:limit]:
     #         txs.append(self.gettransaction(txid))
     #     return txs
 
     # RAW TRANSACTION DOES NOT CONTAIN CORRECT RAW TRANSACTION (MISSING SIGS)
     # def getrawtransaction(self, txid):
     #     tx = self.compose_request('tx', txid)
-    #     t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
+    #     t = BitcoinTransaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
     #     for i in t.inputs:
     #         if not i.address:
     #             raise ClientError("Address missing in input. Provider might not support segwit transactions")
     #     return tx['hex']
 
     # def sendrawtransaction
 
     def estimatefee(self, blocks):
-        res = self.compose_request('tx', 'fee', variables={'numBlocks': blocks})
-        return res['feePerKb']
+        res = self.compose_request("tx", "fee", variables={"numBlocks": blocks})
+        return res["feePerKb"]
 
     def blockcount(self):
-        return self.compose_request('block', 'latest')['height']
+        return self.compose_request("block", "latest")["height"]
 
     # def mempool
 
     # def getblock(self, blockid, parse_transactions, page, limit):
     #     bd = self.compose_request('block', str(blockid))
     #     if parse_transactions:
     #         txs = []
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/blockchaininfo.py` & `fluxwallet-0.1.0/fluxwallet/services/chainso.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    blockchain_info client
-#     2017-2019 July - 1200 Web Development <http://1200wd.com/>
+#    Chain.so client
+#     2017-2022 October - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -18,183 +18,203 @@
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
-from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
-
-PROVIDERNAME = 'blockchaininfo'
+from fluxwallet.services.baseclient import BaseClient, ClientError
+from fluxwallet.transactions import BitcoinTransaction
 
 _logger = logging.getLogger(__name__)
 
+PROVIDERNAME = "chainso"
 
-class BlockchainInfoClient(BaseClient):
 
+class ChainSo(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, cmd, parameter='', variables=None, method='get'):
-        url_path = cmd
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, function, data="", parameter="", variables=None, method="get"
+    ):
+        url_path = function
+        url_path += "/" + self.provider_coin_id
+        if data:
+            url_path += "/" + data
         if parameter:
-            url_path += '/' + parameter
-        return self.request(url_path, variables, method=method)
+            url_path += "/" + parameter
+        if variables is None:
+            variables = {}
+        if self.api_key:
+            variables.update({"api_key": self.api_key})
+        return self.request(url_path, variables, method)
+
+    def sendrawtransaction(self, rawtx):
+        res = self.compose_request(
+            "send_tx", variables={"tx_hex": rawtx}, method="post"
+        )
+        return {
+            "txid": "" if "data" not in res else res["data"]["txid"],
+            "response_dict": res,
+        }
 
     def getbalance(self, addresslist):
-        addresses = {'active': '|'.join(addresslist)}
-        res = self.compose_request('balance', variables=addresses)
-        balance = 0
-        for address in res:
-            balance += res[address]['final_balance']
-        return balance
-
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        utxos = []
-        variables = {'active': address, 'limit': 1000}
-        res = self.compose_request('unspent', variables=variables)
-        if len(res['unspent_outputs']) > 299:
-            _logger.info("BlockchainInfoClient: Large number of outputs for address %s, "
-                         "UTXO list may be incomplete" % address)
-        res['unspent_outputs'].sort(key=lambda x: x['confirmations'])
-        for utxo in res['unspent_outputs']:
-            if utxo['tx_hash_big_endian'] == after_txid:
-                break
-            utxos.append({
-                'address': address,
-                'txid': utxo['tx_hash_big_endian'],
-                'confirmations': utxo['confirmations'],
-                'output_n': utxo['tx_output_n'],
-                'input_n':  utxo['tx_index'],
-                'block_height': None,
-                'fee': None,
-                'size': 0,
-                'value': int(round(utxo['value'] * self.units, 0)),
-                'script': utxo['script'],
-                'date': None
-            })
-        return utxos[::-1][:limit]
-
-    def gettransaction(self, txid, latest_block=None):
-        self.latest_block = self.latest_block if not latest_block else latest_block
-        tx = self.compose_request('rawtx', txid)
-        rawtx = self.getrawtransaction(txid)
-        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)
+        balance = 0.0
+        for address in addresslist:
+            res = self.compose_request("get_address_balance", address)
+            balance += float(res["data"]["confirmed_balance"]) + float(
+                res["data"]["unconfirmed_balance"]
+            )
+        return int(balance * self.units)
+
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        txs = []
+        lasttx = after_txid
+        res = self.compose_request("get_tx_unspent", address, lasttx)
+        if res["status"] != "success":
+            pass
+        for tx in res["data"]["txs"][:limit]:
+            txs.append(
+                {
+                    "address": address,
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": -1 if "output_no" not in tx else tx["output_no"],
+                    "input_n": -1 if "input_no" not in tx else tx["input_no"],
+                    "block_height": None,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(round(float(tx["value"]) * self.units, 0)),
+                    "script": tx["script_hex"],
+                    "date": datetime.utcfromtimestamp(tx["time"]),
+                }
+            )
+        if len(txs) >= 1000:
+            _logger.warning(
+                "ChainSo: transaction list has been truncated, and thus is incomplete"
+            )
+        return txs
+
+    def getrawtransaction(self, txid):
+        res = self.compose_request("get_tx", txid)
+        return res["data"]["tx_hex"]
+
+    def gettransaction(self, txid, block_height=None):
+        res = self.compose_request("get_tx", txid)
+        tx = res["data"]
+        rawtx = tx["tx_hex"]
+        t = BitcoinTransaction.parse_hex(
+            rawtx, strict=self.strict, network=self.network
+        )
         input_total = 0
-        for n, i in enumerate(t.inputs):
-            if 'prev_out' in tx['inputs'][n]:
-                i.value = 0 if not tx['inputs'][n]['prev_out'] else tx['inputs'][n]['prev_out']['value']
+        output_total = 0
+        if not t.coinbase:
+            for n, i in enumerate(t.inputs):
+                i.value = int(round(float(tx["inputs"][n]["value"]) * self.units, 0))
                 input_total += i.value
-        for n, o in enumerate(t.outputs):
-            o.spent = tx['out'][n]['spent']
-        if 'block_height' in tx and tx['block_height']:
-            if not self.latest_block:
-                self.latest_block = self.blockcount()
-            t.status = 'confirmed'
-            t.date = datetime.utcfromtimestamp(tx['time'])
-            t.block_height = tx['block_height']
-            t.confirmations = 1
-            if self.latest_block > t.block_height:
-                t.confirmations = self.latest_block - t.block_height
-        else:
-            t.status = 'unconfirmed'
-            t.confirmations = 0
-            t.date = None
+        for o in t.outputs:
+            o.spent = None
+            output_total += o.value
+        if not t.block_height and tx["confirmations"]:
+            t.block_height = self.getblock(tx["blockhash"], False, 1, 1)["height"]
+        t.block_hash = tx["blockhash"]
         t.rawtx = bytes.fromhex(rawtx)
-        t.size = tx['size']
-        t.network_name = self.network
-        t.locktime = tx['lock_time']
-        t.version_int = tx['ver']
-        t.version = tx['ver'].to_bytes(4, 'big')
+        t.size = tx["size"]
+        t.network = self.network
+        t.locktime = tx["locktime"]
         t.input_total = input_total
+        t.output_total = output_total
         t.fee = 0
         if t.input_total:
             t.fee = t.input_total - t.output_total
+        t.confirmations = tx["confirmations"]
+        if tx["confirmations"]:
+            t.status = "confirmed"
+            t.date = datetime.utcfromtimestamp(tx["time"])
+        else:
+            t.status = "unconfirmed"
+            t.date = None
         return t
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         txs = []
-        txids = []
-        variables = {'limit': 100}
-        res = self.compose_request('rawaddr', address, variables=variables)
-        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-        for tx in res['txs']:
-            if tx['hash'] not in txids:
-                txids.insert(0, tx['hash'])
-        if after_txid:
-            txids = txids[txids.index(after_txid) + 1:]
-        for txid in txids[:limit]:
-            t = self.gettransaction(txid, latest_block=self.latest_block)
-            t.confirmations = 0 if not t.block_height else self.latest_block - t.block_height
+        res1 = self.compose_request("get_tx_received", address, after_txid)
+        if res1["status"] != "success":
+            raise ClientError(
+                "Chainso get_tx_received request unsuccessful, status: %s"
+                % res1["status"]
+            )
+        res2 = self.compose_request("get_tx_spent", address, after_txid)
+        if res2["status"] != "success":
+            raise ClientError(
+                "Chainso get_tx_spent request unsuccessful, status: %s" % res2["status"]
+            )
+        res = res1["data"]["txs"] + res2["data"]["txs"]
+        res = sorted(res, key=lambda x: x["time"])
+        tx_conf = []
+        for t in res:
+            tt = (t["confirmations"], t["txid"])
+            if tt not in tx_conf:
+                tx_conf.append(tt)
+        for tx in tx_conf[:limit]:
+            t = self.gettransaction(tx[1])
             txs.append(t)
         return txs
 
-    def getrawtransaction(self, txid):
-        return self.compose_request('rawtx', txid, {'format': 'hex'})
-
-    # def sendrawtransaction()
-
-    # def estimatefee()
-
     def blockcount(self):
-        return self.compose_request('latestblock')['height']
+        return self.compose_request("get_info")["data"]["blocks"]
 
-    def mempool(self, txid=''):
-        if txid:
-            tx = self.compose_request('rawtx', txid)
-            if 'block_height' not in tx:
-                return [tx['hash']]
-        else:
-            txs = self.compose_request('unconfirmed-transactions', variables={'format': 'json'})
-            return [tx['hash'] for tx in txs['txs']]
+    def mempool(self, txid):
+        res = self.compose_request("is_tx_confirmed", txid)
+        if res["status"] == "success" and res["data"]["confirmations"] == 0:
+            return [txid]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        bd = self.compose_request('rawblock', str(blockid))
+        if limit > 5:
+            limit = 5
+        bd = self.compose_request("get_block", str(blockid))["data"]
         if parse_transactions:
             txs = []
-            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-            for tx in bd['tx'][(page-1)*limit:page*limit]:
+            for txid in bd["txs"][(page - 1) * limit : page * limit]:
                 # try:
-                txs.append(self.gettransaction(tx['hash'], latest_block=self.latest_block))
+                txs.append(self.gettransaction(txid, block_height=bd["block_no"]))
                 # except Exception as e:
-                #     _logger.error("Could not parse tx %s with error %s" % (tx['hash'], e))
+                #     raise ClientError("Could not parse tx %s with error %s" % (txid, e))
         else:
-            txs = [tx['hash'] for tx in bd['tx']]
+            txs = bd["txs"]
 
+        n_txs = len(bd["txs"])
         block = {
-            'bits': bd['bits'],
-            'depth': None,
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['mrkl_root'],
-            'nonce': abs(bd['nonce']),
-            'prev_block': bd['prev_block'],
-            'time': bd['time'],
-            'tx_count': len(bd['tx']),
-            'txs': txs,
-            'version': bd['ver'],
-            'page': page,
-            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),
-            'limit': limit
+            "bits": None,
+            "depth": bd["confirmations"],
+            "block_hash": bd["blockhash"],
+            "height": bd["block_no"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": None,
+            "prev_block": bd["previous_blockhash"],
+            "time": bd["time"],
+            "tx_count": n_txs,
+            "txs": txs,
+            "version": b"",
+            "page": page,
+            "pages": None if not limit else int(n_txs // limit) + (n_txs % limit > 0),
+            "limit": limit,
         }
         return block
 
-    def getrawblock(self, blockid):
-        return self.compose_request('rawblock', str(blockid), {'format': 'hex'})
+    # def getrawblock(self, blockid):
 
-    # def isspent(self, txid, index):
+    # def isspent(self, txid, output_n):
 
     def getinfo(self):
-        import json
-
-        import requests
-        info = json.loads(requests.get('https://api.blockchain.info/stats', timeout=self.timeout).text)
-        unconfirmed = self.compose_request('q', 'unconfirmedcount')
+        info = self.compose_request("get_info")["data"]
         return {
-            'blockcount': info['n_blocks_total'],
-            'chain': '',
-            'difficulty': info['difficulty'],
-            'hashrate': int(float(info['hash_rate'] * 10**9)),
-            'mempool_size': unconfirmed,
+            "blockcount": info["blocks"],
+            "chain": info["name"],
+            "difficulty": int(float(info["mining_difficulty"])),
+            "hashrate": int(float(info["hashrate"])),
+            "mempool_size": int(info["unconfirmed_txs"]),
         }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/blockchair.py` & `fluxwallet-0.1.0/fluxwallet/services/blockchair.py`

 * *Files 13% similar despite different names*

```diff
@@ -25,230 +25,300 @@
     from datetime import timezone
 except Exception:
     pass
 from fluxwallet.encoding import EncodingError, varstr
 from fluxwallet.keys import Address, deserialize_address
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
 _logger = logging.getLogger(__name__)
 
-PROVIDERNAME = 'blockchair'
+PROVIDERNAME = "blockchair"
 REQUEST_LIMIT = 100
 
 
 class BlockChairClient(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, command, query_vars=None, variables=None, data=None, offset=0, limit=REQUEST_LIMIT,
-                        method='get'):
-        url_path = ''
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self,
+        command,
+        query_vars=None,
+        variables=None,
+        data=None,
+        offset=0,
+        limit=REQUEST_LIMIT,
+        method="get",
+    ):
+        url_path = ""
         if not variables:
             variables = {}
-        if command not in ['stats', 'mempool']:
-            variables.update({'limit': limit})
+        if command not in ["stats", "mempool"]:
+            variables.update({"limit": limit})
         if offset:
-            variables.update({'offset': offset})
+            variables.update({"offset": offset})
         if command:
             url_path += command
         if data:
-            if url_path[-1:] != '/':
-                url_path += '/'
+            if url_path[-1:] != "/":
+                url_path += "/"
             url_path += data
         if query_vars:
-            varstr = ','.join(['%s(%s)' % (qv, query_vars[qv]) for qv in query_vars])
-            variables.update({'q': varstr})
+            varstr = ",".join(["%s(%s)" % (qv, query_vars[qv]) for qv in query_vars])
+            variables.update({"q": varstr})
         return self.request(url_path, variables, method=method)
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('dashboards/address/', data=address)
-            balance += int(res['data'][address]['address']['balance'])
+            res = self.compose_request("dashboards/address/", data=address)
+            balance += int(res["data"][address]["address"]["balance"])
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         utxos = []
         offset = 0
         while True:
-            res = self.compose_request('outputs', {'recipient': address, 'is_spent': 'false'}, offset=offset)
-            if len(res['data']) == REQUEST_LIMIT:
-                raise ClientError("Blockchair returned more then maximum of %d data rows" % REQUEST_LIMIT)
-            current_block = res['context']['state']
-            for utxo in res['data'][::-1]:
-                if utxo['is_spent']:
+            res = self.compose_request(
+                "outputs", {"recipient": address, "is_spent": "false"}, offset=offset
+            )
+            if len(res["data"]) == REQUEST_LIMIT:
+                raise ClientError(
+                    "Blockchair returned more then maximum of %d data rows"
+                    % REQUEST_LIMIT
+                )
+            current_block = res["context"]["state"]
+            for utxo in res["data"][::-1]:
+                if utxo["is_spent"]:
                     continue
-                if utxo['transaction_hash'] == after_txid:
+                if utxo["transaction_hash"] == after_txid:
                     utxos = []
                     continue
-                utxos.append({
-                    'address': address,
-                    'txid': utxo['transaction_hash'],
-                    'confirmations': current_block - utxo['block_id'],
-                    'output_n': utxo['index'],
-                    'input_n': 0,
-                    'block_height': utxo['block_id'],
-                    'fee': None,
-                    'size': 0,
-                    'value': utxo['value'],
-                    'script': utxo['script_hex'],
-                    'date': datetime.strptime(utxo['time'], "%Y-%m-%d %H:%M:%S")
-                })
-            if not len(res['data']) or len(res['data']) < REQUEST_LIMIT:
+                utxos.append(
+                    {
+                        "address": address,
+                        "txid": utxo["transaction_hash"],
+                        "confirmations": current_block - utxo["block_id"],
+                        "output_n": utxo["index"],
+                        "input_n": 0,
+                        "block_height": utxo["block_id"],
+                        "fee": None,
+                        "size": 0,
+                        "value": utxo["value"],
+                        "script": utxo["script_hex"],
+                        "date": datetime.strptime(utxo["time"], "%Y-%m-%d %H:%M:%S"),
+                    }
+                )
+            if not len(res["data"]) or len(res["data"]) < REQUEST_LIMIT:
                 break
             offset += REQUEST_LIMIT
         return utxos[:limit]
 
     def gettransaction(self, tx_id):
-        res = self.compose_request('dashboards/transaction/', data=tx_id)
+        res = self.compose_request("dashboards/transaction/", data=tx_id)
 
-        tx = res['data'][tx_id]['transaction']
-        confirmations = 0 if tx['block_id'] <= 0 else res['context']['state'] - tx['block_id']
-        status = 'unconfirmed'
+        tx = res["data"][tx_id]["transaction"]
+        confirmations = (
+            0 if tx["block_id"] <= 0 else res["context"]["state"] - tx["block_id"]
+        )
+        status = "unconfirmed"
         if confirmations:
-            status = 'confirmed'
-        witness_type = 'legacy'
-        if tx['has_witness']:
-            witness_type = 'segwit'
-        input_total = tx['input_total']
-        t = Transaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,
-                        fee=tx['fee'], size=tx['size'], txid=tx['hash'],
-                        date=None if not confirmations else datetime.strptime(tx['time'], "%Y-%m-%d %H:%M:%S"),
-                        confirmations=confirmations, block_height=tx['block_id'] if tx['block_id'] > 0 else None,
-                        status=status, input_total=input_total, coinbase=tx['is_coinbase'],
-                        output_total=tx['output_total'], witness_type=witness_type)
+            status = "confirmed"
+        witness_type = "legacy"
+        if tx["has_witness"]:
+            witness_type = "segwit"
+        input_total = tx["input_total"]
+        t = BitcoinTransaction(
+            locktime=tx["lock_time"],
+            version=tx["version"],
+            network=self.network,
+            fee=tx["fee"],
+            size=tx["size"],
+            txid=tx["hash"],
+            date=None
+            if not confirmations
+            else datetime.strptime(tx["time"], "%Y-%m-%d %H:%M:%S"),
+            confirmations=confirmations,
+            block_height=tx["block_id"] if tx["block_id"] > 0 else None,
+            status=status,
+            input_total=input_total,
+            coinbase=tx["is_coinbase"],
+            output_total=tx["output_total"],
+            witness_type=witness_type,
+        )
         index_n = 0
-        if not res['data'][tx_id]['inputs']:
+        if not res["data"][tx_id]["inputs"]:
             # This is a coinbase transaction, add input
-            t.add_input(prev_txid=b'\00' * 32, output_n=0, value=0)
+            t.add_input(prev_txid=b"\00" * 32, output_n=0, value=0)
 
-        for ti in res['data'][tx_id]['inputs']:
-            if ti['spending_witness']:
+        for ti in res["data"][tx_id]["inputs"]:
+            if ti["spending_witness"]:
                 # witnesses = b"".join([varstr(bytes.fromhex(x)) for x in ti['spending_witness'].split(",")])
-                witnesses = ti['spending_witness'].split(",")
-                address = Address.parse(ti['recipient'])
-                if address.script_type == 'p2sh':
-                    witness_type = 'p2sh-segwit'
+                witnesses = ti["spending_witness"].split(",")
+                address = Address.parse(ti["recipient"])
+                if address.script_type == "p2sh":
+                    witness_type = "p2sh-segwit"
                 else:
-                    witness_type = 'segwit'
-                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],
-                            unlocking_script=ti['spending_signature_hex'],
-                            witnesses=witnesses, index_n=index_n, value=ti['value'],
-                            address=address, witness_type=witness_type, sequence=ti['spending_sequence'], strict=self.strict)
+                    witness_type = "segwit"
+                t.add_input(
+                    prev_txid=ti["transaction_hash"],
+                    output_n=ti["index"],
+                    unlocking_script=ti["spending_signature_hex"],
+                    witnesses=witnesses,
+                    index_n=index_n,
+                    value=ti["value"],
+                    address=address,
+                    witness_type=witness_type,
+                    sequence=ti["spending_sequence"],
+                    strict=self.strict,
+                )
             else:
-                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],
-                            unlocking_script=ti['spending_signature_hex'], index_n=index_n, value=ti['value'],
-                            address=ti['recipient'], unlocking_script_unsigned=ti['script_hex'],
-                            sequence=ti['spending_sequence'], strict=self.strict)
+                t.add_input(
+                    prev_txid=ti["transaction_hash"],
+                    output_n=ti["index"],
+                    unlocking_script=ti["spending_signature_hex"],
+                    index_n=index_n,
+                    value=ti["value"],
+                    address=ti["recipient"],
+                    unlocking_script_unsigned=ti["script_hex"],
+                    sequence=ti["spending_sequence"],
+                    strict=self.strict,
+                )
             index_n += 1
-        for to in res['data'][tx_id]['outputs']:
+        for to in res["data"][tx_id]["outputs"]:
             try:
-                deserialize_address(to['recipient'], network=self.network.name)
-                addr = to['recipient']
+                deserialize_address(to["recipient"], network=self.network.name)
+                addr = to["recipient"]
             except EncodingError:
-                addr = ''
-            t.add_output(value=to['value'], address=addr, lock_script=to['script_hex'],
-                         spent=to['is_spent'], output_n=to['index'], spending_txid=to['spending_transaction_hash'],
-                         spending_index_n=to['spending_index'], strict=self.strict)
+                addr = ""
+            t.add_output(
+                value=to["value"],
+                address=addr,
+                lock_script=to["script_hex"],
+                spent=to["is_spent"],
+                output_n=to["index"],
+                spending_txid=to["spending_transaction_hash"],
+                spending_index_n=to["spending_index"],
+                strict=self.strict,
+            )
         return t
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         txids = []
         offset = 0
         while True:
-            res = self.compose_request('dashboards/address/', data=address, offset=offset)
-            addr = res['data'][address]
-            if not addr['transactions']:
+            res = self.compose_request(
+                "dashboards/address/", data=address, offset=offset
+            )
+            addr = res["data"][address]
+            if not addr["transactions"]:
                 break
-            txids = addr['transactions'][::-1] + txids
+            txids = addr["transactions"][::-1] + txids
             offset += 50
             if len(txids) > limit:
                 break
         if after_txid:
-            txids = txids[txids.index(after_txid)+1:]
+            txids = txids[txids.index(after_txid) + 1 :]
         txs = []
         for txid in txids[:limit]:
             txs.append(self.gettransaction(txid))
         return txs
 
     def getrawtransaction(self, txid):
-        res = self.compose_request('raw/transaction', data=txid)
-        return res['data'][txid]['raw_transaction']
+        res = self.compose_request("raw/transaction", data=txid)
+        return res["data"][txid]["raw_transaction"]
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('push/transaction', variables={'data': rawtx}, method='post')
-        return {
-            'txid': res['data']['transaction_hash'],
-            'response_dict': res
-        }
+        res = self.compose_request(
+            "push/transaction", variables={"data": rawtx}, method="post"
+        )
+        return {"txid": res["data"]["transaction_hash"], "response_dict": res}
 
     def estimatefee(self, blocks):
-        return self.compose_request('stats')['data']['suggested_transaction_fee_per_byte_sat'] * 1000
+        return (
+            self.compose_request("stats")["data"][
+                "suggested_transaction_fee_per_byte_sat"
+            ]
+            * 1000
+        )
 
     def blockcount(self):
         """
         Get latest block number: The block number of last block in longest chain on the blockchain
 
         :return int:
         """
-        res = self.compose_request('stats')
-        return res['context']['state']
+        res = self.compose_request("stats")
+        return res["context"]["state"]
 
-    def mempool(self, txid=''):
+    def mempool(self, txid=""):
         if txid:
-            res = self.compose_request('mempool', {'hash': txid}, data='transactions')
+            res = self.compose_request("mempool", {"hash": txid}, data="transactions")
         else:
-            res = self.compose_request('mempool', data='transactions')
-        return [tx['hash'] for tx in res['data'] if 'hash' in tx]
+            res = self.compose_request("mempool", data="transactions")
+        return [tx["hash"] for tx in res["data"] if "hash" in tx]
 
     def getblock(self, blockid, parse_transactions, page, limit):
         if limit > 100:
             limit = 100
-        res = self.compose_request('dashboards/block/', data=str(blockid), offset=(page-1)*limit, limit=limit)
-        bd = res['data'][str(blockid)]['block']
-        txids = res['data'][str(blockid)]['transactions']
+        res = self.compose_request(
+            "dashboards/block/",
+            data=str(blockid),
+            offset=(page - 1) * limit,
+            limit=limit,
+        )
+        bd = res["data"][str(blockid)]["block"]
+        txids = res["data"][str(blockid)]["transactions"]
         if parse_transactions:
             txs = []
             for txid in txids:
                 txs.append(self.gettransaction(txid))
         else:
             txs = txids
 
         block = {
-            'bits': bd['bits'],
-            'depth': None,
-            'block_hash': bd['hash'],
-            'height': bd['id'],
-            'merkle_root': bd['merkle_root'],
-            'nonce': bd['nonce'],
-            'prev_block': b'',
-            'time': int(datetime.strptime(bd['time'], "%Y-%m-%d %H:%M:%S").replace(tzinfo=timezone.utc).timestamp()),
-            'tx_count': bd['transaction_count'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(bd['transaction_count'] // limit) + (bd['transaction_count'] % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": None,
+            "block_hash": bd["hash"],
+            "height": bd["id"],
+            "merkle_root": bd["merkle_root"],
+            "nonce": bd["nonce"],
+            "prev_block": b"",
+            "time": int(
+                datetime.strptime(bd["time"], "%Y-%m-%d %H:%M:%S")
+                .replace(tzinfo=timezone.utc)
+                .timestamp()
+            ),
+            "tx_count": bd["transaction_count"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(bd["transaction_count"] // limit)
+            + (bd["transaction_count"] % limit > 0),
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
-        res = self.compose_request('raw/block/', data=str(blockid))
-        rb = res['data'][str(blockid)]['raw_block']
+        res = self.compose_request("raw/block/", data=str(blockid))
+        rb = res["data"][str(blockid)]["raw_block"]
         return rb
 
     def isspent(self, txid, output_n):
         t = self.gettransaction(txid)
         return 1 if t.outputs[output_n].spent else 0
 
     def getinfo(self):
-        info = self.compose_request('stats')['data']
+        info = self.compose_request("stats")["data"]
         return {
-            'blockcount': info['best_block_height'],
-            'chain': '',
-            'difficulty': int(float(info['difficulty'])),
-            'hashrate': int(info['hashrate_24h']),
-            'mempool_size': int(info['mempool_transactions']),
+            "blockcount": info["best_block_height"],
+            "chain": "",
+            "difficulty": int(float(info["difficulty"])),
+            "hashrate": int(info["hashrate_24h"]),
+            "mempool_size": int(info["mempool_transactions"]),
         }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/blockcypher.py` & `fluxwallet-0.1.0/fluxwallet/services/blockcypher.py`

 * *Files 20% similar despite different names*

```diff
@@ -19,59 +19,62 @@
 #
 
 import logging
 from datetime import datetime, timezone
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'blockcypher'
+PROVIDERNAME = "blockcypher"
 
 _logger = logging.getLogger(__name__)
 
 
 class BlockCypher(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, function, data, parameter='', variables=None, method='get'):
-        url_path = function + '/' + data
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, function, data, parameter="", variables=None, method="get"
+    ):
+        url_path = function + "/" + data
         if parameter:
-            url_path += '/' + parameter
+            url_path += "/" + parameter
         if variables is None:
             variables = {}
         if self.api_key:
-            variables.update({'token': self.api_key})
+            variables.update({"token": self.api_key})
         return self.request(url_path, variables, method)
 
     def getbalance(self, addresslist):
         addresslist = self._addresslist_convert(addresslist)
-        addresses = ';'.join([a.address for a in addresslist])
-        res = self.compose_request('addrs', addresses, 'balance')
+        addresses = ";".join([a.address for a in addresslist])
+        res = self.compose_request("addrs", addresses, "balance")
         balance = 0.0
         if not isinstance(res, list):
             res = [res]
         for rec in res:
-            balance += float(rec['final_balance'])
+            balance += float(rec["final_balance"])
         return int(balance * self.units)
 
     # Disabled: Invalid results for https://api.blockcypher.com/v1/ltc/main/addrs/LVqLipGhyQ1nWtPPc8Xp3zn6JxcU1Hi8eG?unspentOnly=1&limit=2000
     # def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
     #     address = self._address_convert(address)
     #     res = self.compose_request('addrs', address.address, variables={'unspentOnly': 1, 'limit': 2000})
     #     transactions = []
     #     if not isinstance(res, list):
     #         res = [res]
     #     for a in res:
     #         txrefs = a.setdefault('txrefs', []) + a.get('unconfirmed_txrefs', [])
     #         if len(txrefs) > 500:
     #             _logger.warning("BlockCypher: Large number of transactions for address %s, "
-    #                             "Transaction list may be incomplete" % address)
+    #                             "BitcoinTransaction list may be incomplete" % address)
     #         for tx in txrefs:
     #             if tx['tx_hash'] == after_txid:
     #                 break
     #             tdate = None
     #             if 'confirmed' in tx:
     #                 try:
     #                     tdate = datetime.strptime(tx['confirmed'], "%Y-%m-%dT%H:%M:%SZ")
@@ -87,131 +90,158 @@
     #                 'script': '',
     #                 'block_height': None,
     #                 'date': tdate
     #             })
     #     return transactions[::-1][:limit]
 
     def gettransaction(self, txid):
-        tx = self.compose_request('txs', txid, variables={'includeHex': 'true'})
-        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
-        if tx['confirmations']:
-            t.status = 'confirmed'
-            t.date = datetime.strptime(tx['confirmed'][:19], "%Y-%m-%dT%H:%M:%S")
+        tx = self.compose_request("txs", txid, variables={"includeHex": "true"})
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        if tx["confirmations"]:
+            t.status = "confirmed"
+            t.date = datetime.strptime(tx["confirmed"][:19], "%Y-%m-%dT%H:%M:%S")
         else:
-            t.status = 'unconfirmed'
-        t.confirmations = tx['confirmations']
-        t.block_height = tx['block_height'] if tx['block_height'] > 0 else None
-        t.fee = tx['fees']
-        t.rawtx = bytes.fromhex(tx['hex'])
-        t.size = int(len(tx['hex']) / 2)
+            t.status = "unconfirmed"
+        t.confirmations = tx["confirmations"]
+        t.block_height = tx["block_height"] if tx["block_height"] > 0 else None
+        t.fee = tx["fees"]
+        t.rawtx = bytes.fromhex(tx["hex"])
+        t.size = int(len(tx["hex"]) / 2)
         t.network = self.network
         t.input_total = 0
-        if len(t.inputs) != len(tx['inputs']):
-            raise ClientError("Invalid number of inputs provided. Raw tx: %d, blockcypher: %d" %
-                              (len(t.inputs), len(tx['inputs'])))
+        if len(t.inputs) != len(tx["inputs"]):
+            raise ClientError(
+                "Invalid number of inputs provided. Raw tx: %d, blockcypher: %d"
+                % (len(t.inputs), len(tx["inputs"]))
+            )
         for n, i in enumerate(t.inputs):
-            if not t.coinbase and not (tx['inputs'][n]['output_index'] == i.output_n_int and
-                                       tx['inputs'][n]['prev_hash'] == i.prev_txid.hex()):
-                raise ClientError("Transaction inputs do not match raw transaction")
-            if 'output_value' in tx['inputs'][n]:
+            if not t.coinbase and not (
+                tx["inputs"][n]["output_index"] == i.output_n_int
+                and tx["inputs"][n]["prev_hash"] == i.prev_txid.hex()
+            ):
+                raise ClientError(
+                    "BitcoinTransaction inputs do not match raw transaction"
+                )
+            if "output_value" in tx["inputs"][n]:
                 if not t.coinbase:
-                    i.value = tx['inputs'][n]['output_value']
+                    i.value = tx["inputs"][n]["output_value"]
                 t.input_total += i.value
-        if len(t.outputs) != len(tx['outputs']):
-            raise ClientError("Invalid number of outputs provided. Raw tx: %d, blockcypher: %d" %
-                              (len(t.outputs), len(tx['outputs'])))
+        if len(t.outputs) != len(tx["outputs"]):
+            raise ClientError(
+                "Invalid number of outputs provided. Raw tx: %d, blockcypher: %d"
+                % (len(t.outputs), len(tx["outputs"]))
+            )
         for n, o in enumerate(t.outputs):
-            if 'spent_by' in tx['outputs'][n]:
+            if "spent_by" in tx["outputs"][n]:
                 o.spent = True
-                o.spending_txid = tx['outputs'][n]['spent_by']
+                o.spending_txid = tx["outputs"][n]["spent_by"]
         return t
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         txs = []
         address = self._address_convert(address)
-        res = self.compose_request('addrs', address.address, variables={'unspentOnly': 0, 'limit': 2000})
+        res = self.compose_request(
+            "addrs", address.address, variables={"unspentOnly": 0, "limit": 2000}
+        )
         if not isinstance(res, list):
             res = [res]
         for a in res:
-            txrefs = a.get('txrefs', []) + a.get('unconfirmed_txrefs', [])
+            txrefs = a.get("txrefs", []) + a.get("unconfirmed_txrefs", [])
             txids = []
             for t in txrefs[::-1]:
-                if t['tx_hash'] not in txids:
-                    txids.append(t['tx_hash'])
-                if t['tx_hash'] == after_txid:
+                if t["tx_hash"] not in txids:
+                    txids.append(t["tx_hash"])
+                if t["tx_hash"] == after_txid:
                     txids = []
             if len(txids) > 500:
-                _logger.info("BlockCypher: Large number of transactions for address %s, "
-                             "Transaction list may be incomplete" % address.address_orig)
+                _logger.info(
+                    "BlockCypher: Large number of transactions for address %s, "
+                    "BitcoinTransaction list may be incomplete" % address.address_orig
+                )
             for txid in txids[:limit]:
                 t = self.gettransaction(txid)
                 txs.append(t)
         return txs
 
     def getrawtransaction(self, txid):
-        return self.compose_request('txs', txid, variables={'includeHex': 'true'})['hex']
+        return self.compose_request("txs", txid, variables={"includeHex": "true"})[
+            "hex"
+        ]
 
     def sendrawtransaction(self, rawtx):
         # BlockCypher sometimes accepts transactions, but does not push them to the network :(
-        if self.network.name in ['bitcoin', 'litecoin']:
-            raise ClientError("Avoid stuck transactions, skip usage of blockcypher provider")
-        res = self.compose_request('txs', 'push', variables={'tx': rawtx}, method='post')
-        return {
-            'txid': res['tx']['hash'],
-            'response_dict': res
-        }
+        if self.network.name in ["bitcoin", "litecoin"]:
+            raise ClientError(
+                "Avoid stuck transactions, skip usage of blockcypher provider"
+            )
+        res = self.compose_request(
+            "txs", "push", variables={"tx": rawtx}, method="post"
+        )
+        return {"txid": res["tx"]["hash"], "response_dict": res}
 
     def estimatefee(self, blocks):
-        res = self.compose_request('', '')
+        res = self.compose_request("", "")
         if blocks <= 10:
-            return res['medium_fee_per_kb']
+            return res["medium_fee_per_kb"]
         else:
-            return res['low_fee_per_kb']
+            return res["low_fee_per_kb"]
 
     def blockcount(self):
-        return self.compose_request('', '')['height']
+        return self.compose_request("", "")["height"]
 
     def mempool(self, txid):
         if txid:
-            tx = self.compose_request('txs', txid)
-            if tx['confirmations'] == 0:
-                return [tx['hash']]
+            tx = self.compose_request("txs", txid)
+            if tx["confirmations"] == 0:
+                return [tx["hash"]]
             else:
                 return []
         return False
 
     def getblock(self, blockid, parse_transactions, page, limit):
         if limit > 100:
             limit = 100
-        bd = self.compose_request('blocks', str(blockid), variables={'limit': limit, 'txstart': ((page-1)*limit)})
+        bd = self.compose_request(
+            "blocks",
+            str(blockid),
+            variables={"limit": limit, "txstart": ((page - 1) * limit)},
+        )
         if parse_transactions:
             txs = []
-            for txid in bd['txids']:
+            for txid in bd["txids"]:
                 try:
                     txs.append(self.gettransaction(txid))
                 except Exception as e:
                     _logger.error("Could not parse tx %s with error %s" % (txid, e))
         else:
-            txs = bd['txids']
+            txs = bd["txids"]
 
         block = {
-            'bits': bd['bits'],
-            'depth': bd['depth'],
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['mrkl_root'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['prev_block'],
-            'time': int(datetime.strptime(bd['time'], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc).timestamp()),
-            'tx_count': bd['n_tx'],
-            'txs': txs,
-            'version': bd['ver'],
-            'page': page,
-            'pages': None if not limit else int(bd['n_tx'] // limit) + (bd['n_tx'] % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": bd["depth"],
+            "block_hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["mrkl_root"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["prev_block"],
+            "time": int(
+                datetime.strptime(bd["time"], "%Y-%m-%dT%H:%M:%SZ")
+                .replace(tzinfo=timezone.utc)
+                .timestamp()
+            ),
+            "tx_count": bd["n_tx"],
+            "txs": txs,
+            "version": bd["ver"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(bd["n_tx"] // limit) + (bd["n_tx"] % limit > 0),
+            "limit": limit,
         }
         return block
 
     # def getrawblock(self, blockid):
 
     def isspent(self, txid, output_n):
         t = self.gettransaction(txid)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/blocksmurfer.py` & `fluxwallet-0.1.0/fluxwallet/services/mempool.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    Blocksmurfer client
-#     2020 Januari - 1200 Web Development <http://1200wd.com/>
+#    mempool.space client
+#     2021-2022 - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -17,196 +17,266 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import logging
 from datetime import datetime
 
+from fluxwallet.encoding import varstr
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
-
-PROVIDERNAME = 'blocksmurfer'
+from fluxwallet.transactions import BitcoinTransaction
 
+PROVIDERNAME = "mempool"
+# Please note: In the Blockstream API, the first couple of Bitcoin blocks are not correctly indexed,
+# so transactions from these blocks are missing.
 
 _logger = logging.getLogger(__name__)
 
 
-class BlocksmurferClient(BaseClient):
-
+class MempoolClient(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, function, parameter='', parameter2='', variables=None, post_data='', method='get'):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self,
+        function,
+        data="",
+        parameter="",
+        parameter2="",
+        variables=None,
+        post_data="",
+        method="get",
+    ):
         url_path = function
+        if data:
+            url_path += "/" + data
         if parameter:
-            url_path += '/' + str(parameter)
+            url_path += "/" + parameter
         if parameter2:
-            url_path += '/' + str(parameter2)
+            url_path += "/" + parameter2
         if variables is None:
             variables = {}
         if self.api_key:
-            variables.update({'token': self.api_key})
+            variables.update({"token": self.api_key})
         return self.request(url_path, variables, method, post_data=post_data)
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('address_balance', address)
-            balance += res['balance']
+            res = self.compose_request("address", address)
+            balance += (
+                res["chain_stats"]["funded_txo_sum"]
+                - res["chain_stats"]["spent_txo_sum"]
+            )
         return balance
 
-    # TODO: fix blocksmurfer api
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        res = self.compose_request('utxos', address, variables={'after_txid': after_txid})
-        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        self.latest_block = (
+            self.blockcount() if not self.latest_block else self.latest_block
+        )
+        res = self.compose_request("address", address, "utxo")
         utxos = []
-        for u in res:
-            block_height = None if not u['block_height'] else u['block_height']
-            confirmations = u['confirmations']
-            if block_height and not confirmations:
+        # # key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True
+        res = sorted(
+            res,
+            key=lambda k: 0
+            if "block_height" not in k["status"]
+            else k["status"]["block_height"],
+        )
+        for a in res:
+            confirmations = 0
+            block_height = None
+            if "block_height" in a["status"]:
+                block_height = a["status"]["block_height"]
                 confirmations = self.latest_block - block_height
-            utxos.append({
-                'address': address,
-                'txid': u['txid'],
-                'confirmations': confirmations,
-                'output_n': u['output_n'],
-                'input_n': u['input_n'],
-                'block_height': block_height,
-                'fee': u['fee'],
-                'size': u['size'],
-                'value': u['value'],
-                'script': u['script'],
-                'date': datetime.strptime(u['date'][:19], "%Y-%m-%dT%H:%M:%S")
-            })
+            utxos.append(
+                {
+                    "address": address,
+                    "txid": a["txid"],
+                    "confirmations": confirmations,
+                    "output_n": a["vout"],
+                    "input_n": 0,
+                    "block_height": block_height,
+                    "fee": None,
+                    "size": 0,
+                    "value": a["value"],
+                    "script": "",
+                    "date": None
+                    if "block_time" not in a["status"]
+                    else datetime.utcfromtimestamp(a["status"]["block_time"]),
+                }
+            )
+            if a["txid"] == after_txid:
+                utxos = []
         return utxos[:limit]
 
-    def _parse_transaction(self, tx, block_height=None):
-        block_height = block_height if not tx['block_height'] else tx['block_height']
-        confirmations = tx['confirmations']
-        if block_height and not confirmations and tx['status'] == 'confirmed':
-            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-            confirmations = self.latest_block - block_height
-        # FIXME: Blocksmurfer returns 'date' or 'time', should be consistent
-        tx_date = None if not tx.get('date') else datetime.strptime(tx['date'], "%Y-%m-%dT%H:%M:%S")
-        if not tx_date and 'time' in tx:
-            tx_date = datetime.utcfromtimestamp(tx['time'])
-        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,
-                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, input_total=tx['input_total'],
-                        output_total=tx['output_total'], confirmations=confirmations, block_height=block_height,
-                        status=tx['status'], coinbase=tx['coinbase'], rawtx=bytes.fromhex(tx['raw_hex']),
-                        witness_type=tx['witness_type'])
-        for ti in tx['inputs']:
-            t.add_input(prev_txid=ti['prev_txid'], output_n=ti['output_n'], keys=ti.get('keys', []),
-                        index_n=ti['index_n'], unlocking_script=ti['script'], value=ti['value'],
-                        public_hash=bytes.fromhex(ti['public_hash']), address=ti['address'],
-                        witness_type=ti['witness_type'], locktime_cltv=ti['locktime_cltv'],
-                        locktime_csv=ti['locktime_csv'], signatures=ti['signatures'], compressed=ti['compressed'],
-                        encoding=ti['encoding'], unlocking_script_unsigned=ti['script_code'],
-                        sigs_required=ti['sigs_required'], sequence=ti['sequence'],
-                        witnesses=[bytes.fromhex(w) for w in ti['witnesses']], script_type=ti['script_type'],
-                        strict=self.strict)
-        for to in tx['outputs']:
-            t.add_output(value=to['value'], address=to['address'], public_hash=to['public_hash'],
-                         lock_script=to['script'], spent=to['spent'], strict=self.strict)
+    def _parse_transaction(self, tx):
+        block_height = (
+            None if "block_height" not in tx["status"] else tx["status"]["block_height"]
+        )
+        confirmations = 0
+        tx_date = None
+        status = "unconfirmed"
+        if tx["status"]["confirmed"]:
+            if block_height:
+                self.latest_block = (
+                    self.blockcount() if not self.latest_block else self.latest_block
+                )
+                confirmations = self.latest_block - block_height + 1
+            tx_date = datetime.utcfromtimestamp(tx["status"]["block_time"])
+            status = "confirmed"
+
+        t = BitcoinTransaction(
+            locktime=tx["locktime"],
+            version=tx["version"],
+            network=self.network,
+            block_height=block_height,
+            fee=tx["fee"],
+            size=tx["size"],
+            txid=tx["txid"],
+            date=tx_date,
+            confirmations=confirmations,
+            status=status,
+            coinbase=tx["vin"][0]["is_coinbase"],
+        )
+        for ti in tx["vin"]:
+            if ti["is_coinbase"]:
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    unlocking_script=ti["scriptsig"],
+                    value=0,
+                    sequence=ti["sequence"],
+                    strict=self.strict,
+                )
+            else:
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    unlocking_script=ti["scriptsig"],
+                    value=ti["prevout"]["value"],
+                    address=ti["prevout"].get("scriptpubkey_address", ""),
+                    unlocking_script_unsigned=ti["prevout"]["scriptpubkey"],
+                    sequence=ti["sequence"],
+                    witnesses=None
+                    if "witness" not in ti
+                    else [bytes.fromhex(w) for w in ti["witness"]],
+                    strict=self.strict,
+                )
+        for to in tx["vout"]:
+            t.add_output(
+                value=to["value"],
+                address=to.get("scriptpubkey_address", ""),
+                spent=None,
+                lock_script=to["scriptpubkey"],
+                strict=self.strict,
+            )
+        if "segwit" in [i.witness_type for i in t.inputs] or "p2sh-segwit" in [
+            i.witness_type for i in t.inputs
+        ]:
+            t.witness_type = "segwit"
         t.update_totals()
         return t
 
-    def gettransaction(self, txid, block_count=None):
-        tx = self.compose_request('transaction', txid)
-        return self._parse_transaction(tx, block_count)
+    def gettransaction(self, txid):
+        tx = self.compose_request("tx", txid)
+        return self._parse_transaction(tx)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         prtxs = []
+        before_txid = ""
         while True:
-            txs = self.compose_request('transactions', address, variables={'after_txid': after_txid})
+            txs = self.compose_request("address", address, "txs/chain", before_txid)
             prtxs += txs
-            if not txs or len(txs) < limit:
+            if len(txs) == 25:
+                before_txid = txs[-1:][0]["txid"]
+            else:
+                break
+            if len(prtxs) > limit:
                 break
-            after_txid = txs[-1:][0]['txid']
         txs = []
-        for tx in prtxs:
+        for tx in prtxs[::-1]:
             t = self._parse_transaction(tx)
             if t:
                 txs.append(t)
+            if t.txid == after_txid:
+                txs = []
+            if len(txs) > limit:
+                break
         return txs[:limit]
 
     def getrawtransaction(self, txid):
-        tx = self.compose_request('transaction', txid, variables={'raw': True})
-        return tx['raw_hex']
+        return self.compose_request("tx", txid, "hex")
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('transaction_broadcast', post_data=rawtx, method='post')
-        return {
-            'txid': res['txid'],
-            'response_dict': res
-        }
+        return self.compose_request("tx", post_data=rawtx, method="post")
 
     def estimatefee(self, blocks):
-        variables = {
-            'blocks': str(blocks)
-        }
-        res = self.compose_request('fees', variables=variables)
-        return res['estimated_fee_sat_kb']
+        estimates = self.compose_request("v1/fees", "recommended")
+        if blocks < 2:
+            return estimates["fastestFee"] * 1000
+        elif blocks < 4:
+            return estimates["halfHourFee"] * 1000
+        if blocks < 7:
+            return estimates["hourFee"] * 1000
+        else:
+            return estimates["minimumFee"] * 1000
 
     def blockcount(self):
-        return self.compose_request('blockcount')['blockcount']
+        res = self.compose_request("blocks", "tip", "height")
+        return res
 
-    def mempool(self, txid):
-        if txid:
-            t = self.gettransaction(txid)
-            if t and not t.confirmations:
-                return [t.txid]
-        # else:
-            # return self.compose_request('mempool', 'txids')
+    def mempool(self, txid=""):
+        txids = self.compose_request("mempool", "txids")
+        if not txid:
+            return txids
+        if txid in txids:
+            return [txid]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        variables = {'parse_transactions': parse_transactions, 'page': page, 'limit': limit}
-        bd = self.compose_request('block', str(blockid), variables=variables)
-
-        txs = []
-        if parse_transactions and bd['transactions'] and isinstance(bd['transactions'][0], dict):
-            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-            for tx in bd['transactions']:
-                tx['confirmations'] = bd['depth']
-                tx['time'] = bd['time']
-                tx['block_height'] = bd['height']
-                tx['block_hash'] = bd['block_hash']
-                t = self._parse_transaction(tx, self.latest_block)
-                if t.txid != tx['txid']:
-                    raise ClientError("Could not parse tx %s. Different txid's" % (tx['txid']))
-                txs.append(t)
+        if isinstance(blockid, int):
+            blockid = self.compose_request("block-height", str(blockid))
+        if (page == 1 and limit == 10) or limit > 25:
+            limit = 25
+        bd = self.compose_request("block", blockid)
+        btxs = self.compose_request("block", blockid, "txs", str((page - 1) * limit))
+        if parse_transactions:
+            txs = []
+            for tx in btxs[:limit]:
+                txs.append(self._parse_transaction(tx))
         else:
-            txs = bd['transactions']
+            txs = [tx["txid"] for tx in btxs]
 
         block = {
-            'bits': bd['bits'],
-            'depth': bd['depth'],
-            'block_hash': bd['block_hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkle_root'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['prev_block'],
-            'time': bd['time'],
-            'tx_count': bd['tx_count'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": None,
+            "block_hash": bd["id"],
+            "height": bd["height"],
+            "merkle_root": bd["merkle_root"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousblockhash"],
+            "time": bd["timestamp"],
+            "tx_count": bd["tx_count"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(bd["tx_count"] // limit) + (bd["tx_count"] % limit > 0),
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
-        res = self.compose_request('rawblock', blockid)
-        return res
+        if isinstance(blockid, int):
+            blockid = self.compose_request("block-height", str(blockid))
+        return self.compose_request("block", blockid, "raw").hex()
 
     def isspent(self, txid, output_n):
-        res = self.compose_request('isspent', txid, str(output_n))
-        return 1 if res['spent'] else 0
+        res = self.compose_request("tx", txid, "outspend", str(output_n))
+        return 1 if res["spent"] else 0
 
-    def getinfo(self):
-        res = self.compose_request('')
-        info = {k: v for k, v in res.items() if k in ['chain', 'blockcount', 'hashrate', 'mempool_size',
-                                                      'difficulty']}
-        return info
+    # def getinfo(self):
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/blockstream.py` & `fluxwallet-0.1.0/fluxwallet/services/blockstream.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,141 +19,201 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'blockstream'
+PROVIDERNAME = "blockstream"
 # Please note: In the Blockstream API, the first couple of Bitcoin blocks are not correctly indexed,
 # so transactions from these blocks are missing.
 
 _logger = logging.getLogger(__name__)
 
 
 class BlockstreamClient(BaseClient):
-
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='', method='get'):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self,
+        function,
+        data="",
+        parameter="",
+        parameter2="",
+        variables=None,
+        post_data="",
+        method="get",
+    ):
         url_path = function
         if data:
-            url_path += '/' + data
+            url_path += "/" + data
         if parameter:
-            url_path += '/' + parameter
+            url_path += "/" + parameter
         if parameter2:
-            url_path += '/' + parameter2
+            url_path += "/" + parameter2
         if variables is None:
             variables = {}
         if self.api_key:
-            variables.update({'token': self.api_key})
+            variables.update({"token": self.api_key})
         return self.request(url_path, variables, method, post_data=post_data)
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('address', data=address)
-            balance += (res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum'])
+            res = self.compose_request("address", data=address)
+            balance += (
+                res["chain_stats"]["funded_txo_sum"]
+                - res["chain_stats"]["spent_txo_sum"]
+            )
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        res = self.compose_request('address', address, 'utxo')
-        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        res = self.compose_request("address", address, "utxo")
+        self.latest_block = (
+            self.blockcount() if not self.latest_block else self.latest_block
+        )
         utxos = []
-        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])
+        res = sorted(
+            res,
+            key=lambda k: 0
+            if "block_height" not in k["status"]
+            else k["status"]["block_height"],
+        )
         for a in res:
             confirmations = 0
             block_height = None
-            if 'block_height' in a['status']:
-                block_height = a['status']['block_height']
+            if "block_height" in a["status"]:
+                block_height = a["status"]["block_height"]
                 confirmations = self.latest_block - block_height
-            utxos.append({
-                'address': address,
-                'txid': a['txid'],
-                'confirmations': confirmations,
-                'output_n': a['vout'],
-                'input_n': 0,
-                'block_height': block_height,
-                'fee': None,
-                'size': 0,
-                'value': a['value'],
-                'script': '',
-                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])
-            })
-            if a['txid'] == after_txid:
+            utxos.append(
+                {
+                    "address": address,
+                    "txid": a["txid"],
+                    "confirmations": confirmations,
+                    "output_n": a["vout"],
+                    "input_n": 0,
+                    "block_height": block_height,
+                    "fee": None,
+                    "size": 0,
+                    "value": a["value"],
+                    "script": "",
+                    "date": None
+                    if "block_time" not in a["status"]
+                    else datetime.utcfromtimestamp(a["status"]["block_time"]),
+                }
+            )
+            if a["txid"] == after_txid:
                 utxos = []
         return utxos[:limit]
 
     def _parse_transaction(self, tx):
         confirmations = 0
         block_height = None
-        if 'block_height' in tx['status']:
-            block_height = tx['status']['block_height']
+        if "block_height" in tx["status"]:
+            block_height = tx["status"]["block_height"]
             confirmations = self.latest_block - block_height
-        status = 'unconfirmed'
-        if tx['status']['confirmed']:
-            status = 'confirmed'
-        fee = None if 'fee' not in tx else tx['fee']
-        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,
-                        fee=fee, size=tx['size'], txid=tx['txid'],
-                        date=None if 'block_time' not in tx['status'] else datetime.utcfromtimestamp(tx['status']['block_time']),
-                        confirmations=confirmations, block_height=block_height, status=status,
-                        coinbase=tx['vin'][0]['is_coinbase'])
+        status = "unconfirmed"
+        if tx["status"]["confirmed"]:
+            status = "confirmed"
+        fee = None if "fee" not in tx else tx["fee"]
+        t = BitcoinTransaction(
+            locktime=tx["locktime"],
+            version=tx["version"],
+            network=self.network,
+            fee=fee,
+            size=tx["size"],
+            txid=tx["txid"],
+            date=None
+            if "block_time" not in tx["status"]
+            else datetime.utcfromtimestamp(tx["status"]["block_time"]),
+            confirmations=confirmations,
+            block_height=block_height,
+            status=status,
+            coinbase=tx["vin"][0]["is_coinbase"],
+        )
         index_n = 0
-        for ti in tx['vin']:
-            if tx['vin'][0]['is_coinbase']:
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,
-                            unlocking_script=ti['scriptsig'], value=0, sequence=ti['sequence'], strict=self.strict)
+        for ti in tx["vin"]:
+            if tx["vin"][0]["is_coinbase"]:
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    index_n=index_n,
+                    unlocking_script=ti["scriptsig"],
+                    value=0,
+                    sequence=ti["sequence"],
+                    strict=self.strict,
+                )
             else:
                 witnesses = []
-                if 'witness' in ti:
-                    witnesses = [bytes.fromhex(w) for w in ti['witness']]
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,
-                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],
-                            address='' if 'scriptpubkey_address' not in ti['prevout']
-                            else ti['prevout']['scriptpubkey_address'], sequence=ti['sequence'],
-                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], witnesses=witnesses, strict=self.strict)
+                if "witness" in ti:
+                    witnesses = [bytes.fromhex(w) for w in ti["witness"]]
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    index_n=index_n,
+                    unlocking_script=ti["scriptsig"],
+                    value=ti["prevout"]["value"],
+                    address=""
+                    if "scriptpubkey_address" not in ti["prevout"]
+                    else ti["prevout"]["scriptpubkey_address"],
+                    sequence=ti["sequence"],
+                    unlocking_script_unsigned=ti["prevout"]["scriptpubkey"],
+                    witnesses=witnesses,
+                    strict=self.strict,
+                )
             index_n += 1
         index_n = 0
-        if len(tx['vout']) > 101:
+        if len(tx["vout"]) > 101:
             # Every output needs an extra query, stop execution if there are too many transaction outputs
             return False
-        for to in tx['vout']:
-            address = ''
-            if 'scriptpubkey_address' in to:
-                address = to['scriptpubkey_address']
+        for to in tx["vout"]:
+            address = ""
+            if "scriptpubkey_address" in to:
+                address = to["scriptpubkey_address"]
             spent = self.isspent(t.txid, index_n)
-            t.add_output(value=to['value'], address=address, lock_script=to['scriptpubkey'],
-                         output_n=index_n, spent=spent, strict=self.strict)
+            t.add_output(
+                value=to["value"],
+                address=address,
+                lock_script=to["scriptpubkey"],
+                output_n=index_n,
+                spent=spent,
+                strict=self.strict,
+            )
             index_n += 1
-        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:
-            t.witness_type = 'segwit'
+        if "segwit" in [i.witness_type for i in t.inputs] or "p2sh-segwit" in [
+            i.witness_type for i in t.inputs
+        ]:
+            t.witness_type = "segwit"
         t.update_totals()
-        t.size = tx['size']
+        t.size = tx["size"]
         return t
 
     def gettransaction(self, txid):
-        tx = self.compose_request('tx', txid)
+        tx = self.compose_request("tx", txid)
         return self._parse_transaction(tx)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        self.latest_block = (
+            self.blockcount() if not self.latest_block else self.latest_block
+        )
         prtxs = []
-        before_txid = ''
+        before_txid = ""
         while True:
-            parameter = 'txs'
+            parameter = "txs"
             if before_txid:
-                parameter = 'txs/chain/%s' % before_txid
-            res = self.compose_request('address', address, parameter)
+                parameter = "txs/chain/%s" % before_txid
+            res = self.compose_request("address", address, parameter)
             prtxs += res
             if len(res) == 25:
-                before_txid = res[-1:][0]['txid']
+                before_txid = res[-1:][0]["txid"]
             else:
                 break
             if len(prtxs) > limit:
                 break
         txs = []
         for tx in prtxs[::-1]:
             t = self._parse_transaction(tx)
@@ -162,91 +222,92 @@
             if t.txid == after_txid:
                 txs = []
             if len(txs) > limit:
                 break
         return txs[:limit]
 
     def getrawtransaction(self, txid):
-        return self.compose_request('tx', txid, 'hex')
+        return self.compose_request("tx", txid, "hex")
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('tx', post_data=rawtx, method='post')
-        return {
-            'txid': res,
-            'response_dict': res
-        }
+        res = self.compose_request("tx", post_data=rawtx, method="post")
+        return {"txid": res, "response_dict": res}
 
     def estimatefee(self, blocks):
-        est = self.compose_request('fee-estimates')
-        closest = (sorted([int(i) - blocks for i in est.keys() if int(i) - blocks >= 0]))
+        est = self.compose_request("fee-estimates")
+        closest = sorted([int(i) - blocks for i in est.keys() if int(i) - blocks >= 0])
         # FIXME: temporary fix for too low testnet tx fees:
-        if self.network.name == 'testnet':
+        if self.network.name == "testnet":
             return 2000
         if closest:
             return int(est[str(closest[0] + blocks)] * 1000)
         else:
             return int(est[str(sorted([int(i) for i in est.keys()])[-1:][0])] * 1000)
 
     def blockcount(self):
-        return self.compose_request('blocks', 'tip', 'height')
+        return self.compose_request("blocks", "tip", "height")
 
     def mempool(self, txid):
         if txid:
             t = self.gettransaction(txid)
             if t and not t.confirmations:
                 return [t.txid]
             else:
                 return []
         else:
-            return self.compose_request('mempool', 'txids')
+            return self.compose_request("mempool", "txids")
 
     def getblock(self, blockid, parse_transactions, page, limit):
         if isinstance(blockid, int):
-            blockid = self.compose_request('block-height', str(blockid))
+            blockid = self.compose_request("block-height", str(blockid))
         if (page == 1 and limit == 10) or limit > 25:
             limit = 25
         # elif page > 1:
         #     if limit % 25 != 0:
         #         return False
-        bd = self.compose_request('block', blockid)
-        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))
+        bd = self.compose_request("block", blockid)
+        btxs = self.compose_request("block", blockid, "txs", str((page - 1) * limit))
         if parse_transactions:
             txs = []
-            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
+            self.latest_block = (
+                self.blockcount() if not self.latest_block else self.latest_block
+            )
             for tx in btxs[:limit]:
                 # try:
                 txs.append(self._parse_transaction(tx))
                 # except Exception as e:
                 #     _logger.error("Could not parse tx %s with error %s" % (tx['txid'], e))
         else:
-            txs = [tx['txid'] for tx in btxs]
+            txs = [tx["txid"] for tx in btxs]
 
         block = {
-            'bits': bd['bits'],
-            'depth': None,
-            'block_hash': bd['id'],
-            'height': bd['height'],
-            'merkle_root': bd['merkle_root'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousblockhash'],
-            'time': bd['timestamp'],
-            'tx_count': bd['tx_count'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": None,
+            "block_hash": bd["id"],
+            "height": bd["height"],
+            "merkle_root": bd["merkle_root"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousblockhash"],
+            "time": bd["timestamp"],
+            "tx_count": bd["tx_count"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(bd["tx_count"] // limit) + (bd["tx_count"] % limit > 0),
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
         if isinstance(blockid, int):
-            blockid = self.compose_request('block-height', str(blockid))
-        rawblock = self.compose_request('block', blockid, 'raw')
+            blockid = self.compose_request("block-height", str(blockid))
+        rawblock = self.compose_request("block", blockid, "raw")
         hexrawblock = rawblock.hex()
         return hexrawblock
 
     def isspent(self, txid, output_n):
-        res = self.compose_request('tx', txid, 'outspend', str(output_n))
-        return 1 if res['spent'] else 0
+        res = self.compose_request("tx", txid, "outspend", str(output_n))
+        return 1 if res["spent"] else 0
 
-    # def getinfo(self):
+    # def getinfo(self):
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/chainso.py` & `fluxwallet-0.1.0/fluxwallet/services/cryptoid.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    Chain.so client
-#     2017-2022 October - 1200 Web Development <http://1200wd.com/>
+#    CryptoID Chainz client
+#     2018-2022 October - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -19,184 +19,158 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
 _logger = logging.getLogger(__name__)
 
-PROVIDERNAME = 'chainso'
+PROVIDERNAME = "cryptoid"
 
 
-class ChainSo(BaseClient):
-
+class CryptoID(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, function, data='', parameter='', variables=None, method='get'):
-        url_path = function
-        url_path += '/' + self.provider_coin_id
-        if data:
-            url_path += '/' + data
-        if parameter:
-            url_path += '/' + parameter
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(self, func=None, path_type="api", variables=None, method="get"):
+        # API path: http://chainz.cryptoid.info/ltc/api.dws
+        # Explorer path for raw tx: https://chainz.cryptoid.info/explorer/tx.raw.dws
         if variables is None:
             variables = {}
+        if path_type == "api":
+            url_path = "%s/api.dws" % self.provider_coin_id
+            variables.update({"q": func})
+        else:
+            url_path = "explorer/tx.raw.dws"
+            variables.update({"coin": self.provider_coin_id})
+        # if not self.api_key:
+        #     raise ClientError("Request a CryptoID API key before using this provider")
         if self.api_key:
-            variables.update({'api_key': self.api_key})
+            variables.update({"key": self.api_key})
         return self.request(url_path, variables, method)
 
-    def sendrawtransaction(self, rawtx):
-        res = self.compose_request('send_tx', variables={'tx_hex': rawtx}, method='post')
-        return {
-            'txid': '' if 'data' not in res else res['data']['txid'],
-            'response_dict': res
-        }
-
     def getbalance(self, addresslist):
         balance = 0.0
-        for address in addresslist:
-            res = self.compose_request('get_address_balance', address)
-            balance += float(res['data']['confirmed_balance']) + float(res['data']['unconfirmed_balance'])
+        addresslist = self._addresslist_convert(addresslist)
+        for a in addresslist:
+            res = self.compose_request("getbalance", variables={"a": a.address})
+            balance += float(res)
         return int(balance * self.units)
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        txs = []
-        lasttx = after_txid
-        res = self.compose_request('get_tx_unspent', address, lasttx)
-        if res['status'] != 'success':
-            pass
-        for tx in res['data']['txs'][:limit]:
-            txs.append({
-                'address': address,
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': -1 if 'output_no' not in tx else tx['output_no'],
-                'input_n': -1 if 'input_no' not in tx else tx['input_no'],
-                'block_height': None,
-                'fee': None,
-                'size': 0,
-                'value': int(round(float(tx['value']) * self.units, 0)),
-                'script': tx['script_hex'],
-                'date': datetime.utcfromtimestamp(tx['time']),
-            })
-        if len(txs) >= 1000:
-            _logger.warning("ChainSo: transaction list has been truncated, and thus is incomplete")
-        return txs
-
-    def getrawtransaction(self, txid):
-        res = self.compose_request('get_tx', txid)
-        return res['data']['tx_hex']
-
-    def gettransaction(self, txid, block_height=None):
-        res = self.compose_request('get_tx', txid)
-        tx = res['data']
-        rawtx = tx['tx_hex']
-        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)
-        input_total = 0
-        output_total = 0
-        if not t.coinbase:
-            for n, i in enumerate(t.inputs):
-                i.value = int(round(float(tx['inputs'][n]['value']) * self.units, 0))
-                input_total += i.value
-        for o in t.outputs:
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        if not self.api_key:
+            raise ClientError(
+                "Method getutxos() is not available for CryptoID without API key"
+            )
+        utxos = []
+        address = self._address_convert(address)
+        variables = {"active": address.address}
+        res = self.compose_request("unspent", variables=variables)
+        if len(res["unspent_outputs"]) > 50:
+            _logger.info(
+                "CryptoID: Large number of outputs for address %s, "
+                "UTXO list may be incomplete" % address.address
+            )
+        for utxo in res["unspent_outputs"][::-1]:
+            if utxo["txid"] == after_txid:
+                break
+            utxos.append(
+                {
+                    "address": address.address_orig,
+                    "txid": utxo["txid"],
+                    "confirmations": utxo["confirmations"],
+                    "output_n": utxo["tx_output_n"]
+                    if "tx_output_n" in utxo
+                    else utxo["tx_ouput_n"],
+                    "input_n": 0,
+                    "block_height": None,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(utxo["value"]),
+                    "script": utxo["script"],
+                    "date": None,
+                }
+            )
+        return utxos[::-1][:limit]
+
+    def gettransaction(self, txid):
+        variables = {"id": txid, "hex": None}
+        tx = self.compose_request(path_type="explorer", variables=variables)
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        variables = {"t": txid}
+        tx_api = self.compose_request("txinfo", path_type="api", variables=variables)
+        for n, i in enumerate(t.inputs):
+            if i.script_type != "coinbase":
+                i.value = int(round(tx_api["inputs"][n]["amount"] * self.units, 0))
+            else:
+                i.value = 0
+                t.coinbase = True
+        for n, o in enumerate(t.outputs):
             o.spent = None
-            output_total += o.value
-        if not t.block_height and tx['confirmations']:
-            t.block_height = self.getblock(tx['blockhash'], False, 1, 1)['height']
-        t.block_hash = tx['blockhash']
-        t.rawtx = bytes.fromhex(rawtx)
-        t.size = tx['size']
+        if tx["confirmations"]:
+            t.status = "confirmed"
+        else:
+            t.status = "unconfirmed"
+        t.date = datetime.utcfromtimestamp(tx["time"])
+        t.block_height = tx_api["block"]
+        t.block_hash = tx["blockhash"]
+        t.confirmations = tx["confirmations"]
+        t.rawtx = bytes.fromhex(tx["hex"])
+        t.size = tx["size"]
         t.network = self.network
-        t.locktime = tx['locktime']
-        t.input_total = input_total
-        t.output_total = output_total
+        t.locktime = tx["locktime"]
+        t.version = tx["version"].to_bytes(4, "big")
+        t.output_total = int(round(tx_api["total_output"] * self.units, 0))
+        t.input_total = int(round(tx_api["total_input"] * self.units, 0))
         t.fee = 0
         if t.input_total:
             t.fee = t.input_total - t.output_total
-        t.confirmations = tx['confirmations']
-        if tx['confirmations']:
-            t.status = 'confirmed'
-            t.date = datetime.utcfromtimestamp(tx['time'])
-        else:
-            t.status = 'unconfirmed'
-            t.date = None
         return t
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        address = self._address_convert(address)
         txs = []
-        res1 = self.compose_request('get_tx_received', address, after_txid)
-        if res1['status'] != 'success':
-            raise ClientError("Chainso get_tx_received request unsuccessful, status: %s" % res1['status'])
-        res2 = self.compose_request('get_tx_spent', address, after_txid)
-        if res2['status'] != 'success':
-            raise ClientError("Chainso get_tx_spent request unsuccessful, status: %s" % res2['status'])
-        res = res1['data']['txs'] + res2['data']['txs']
-        res = sorted(res, key=lambda x: x['time'])
-        tx_conf = []
-        for t in res:
-            tt = (t['confirmations'], t['txid'])
-            if tt not in tx_conf:
-                tx_conf.append(tt)
-        for tx in tx_conf[:limit]:
-            t = self.gettransaction(tx[1])
+        txids = []
+        variables = {"active": address.address, "n": 100}
+        res = self.compose_request("multiaddr", variables=variables)
+        for tx in res["txs"]:
+            if tx["hash"] not in txids:
+                txids.insert(0, tx["hash"])
+        if after_txid:
+            txids = txids[txids.index(after_txid) + 1 :]
+        for txid in txids[:limit]:
+            t = self.gettransaction(txid)
             txs.append(t)
         return txs
 
+    def getrawtransaction(self, txid):
+        variables = {"id": txid, "hex": None}
+        tx = self.compose_request(path_type="explorer", variables=variables)
+        return tx["hex"]
+
+    # def sendrawtransaction
+
+    # def estimatefee
+
     def blockcount(self):
-        return self.compose_request('get_info')['data']['blocks']
+        r = self.compose_request("getblockcount", path_type="api")
+        return r
 
     def mempool(self, txid):
-        res = self.compose_request('is_tx_confirmed', txid)
-        if res['status'] == 'success' and res['data']['confirmations'] == 0:
-            return [txid]
+        variables = {"id": txid, "hex": None}
+        tx = self.compose_request(path_type="explorer", variables=variables)
+        if "confirmations" not in tx:
+            return [tx["txid"]]
         return []
 
-    def getblock(self, blockid, parse_transactions, page, limit):
-        if limit > 5:
-            limit = 5
-        bd = self.compose_request('get_block', str(blockid))['data']
-        if parse_transactions:
-            txs = []
-            for txid in bd['txs'][(page-1)*limit:page*limit]:
-                # try:
-                txs.append(self.gettransaction(txid, block_height=bd['block_no']))
-                # except Exception as e:
-                #     raise ClientError("Could not parse tx %s with error %s" % (txid, e))
-        else:
-            txs = bd['txs']
+    # def getblock
+
+    # def isspent
 
-        n_txs = len(bd['txs'])
-        block = {
-            'bits': None,
-            'depth': bd['confirmations'],
-            'block_hash': bd['blockhash'],
-            'height': bd['block_no'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': None,
-            'prev_block': bd['previous_blockhash'],
-            'time': bd['time'],
-            'tx_count': n_txs,
-            'txs': txs,
-            'version': b'',
-            'page': page,
-            'pages': None if not limit else int(n_txs // limit) + (n_txs % limit > 0),
-            'limit': limit
-        }
-        return block
-
-    # def getrawblock(self, blockid):
-
-    # def isspent(self, txid, output_n):
-
-    def getinfo(self):
-        info = self.compose_request('get_info')['data']
-        return {
-            'blockcount': info['blocks'],
-            'chain': info['name'],
-            'difficulty': int(float(info['mining_difficulty'])),
-            'hashrate': int(float(info['hashrate'])),
-            'mempool_size': int(info['unconfirmed_txs']),
-        }
+    # def getinfo(self):
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/dashd.py` & `fluxwallet-0.1.0/fluxwallet/services/dashd.py`

 * *Files 10% similar despite different names*

```diff
@@ -30,216 +30,239 @@
 # }
 
 import configparser
 
 from fluxwallet.main import *
 from fluxwallet.services.authproxy import AuthServiceProxy
 from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'dashd'
+PROVIDERNAME = "dashd"
 
 _logger = logging.getLogger(__name__)
 
 
 class ConfigError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.info(msg)
 
     def __str__(self):
         return self.msg
 
 
 class DashdClient(BaseClient):
     """
     Class to interact with dashd, the Dash deamon
     """
 
     @staticmethod
-    def from_config(configfile=None, network='dash'):
+    def from_config(configfile=None, network="dash"):
         """
         Read settings from dashd config file
 
         :param configfile: Path to config file. Leave empty to look in default places
         :type: str
         :param network: Dash mainnet or testnet. Default is dash mainnet
         :type: str
 
         :return DashdClient:
         """
         config = configparser.ConfigParser(strict=False)
         if not configfile:
-            cfn = os.path.join(os.path.expanduser("~"), '.fluxwallet/dash.conf')
+            cfn = os.path.join(os.path.expanduser("~"), ".fluxwallet/dash.conf")
             if not os.path.isfile(cfn):
-                cfn = os.path.join(os.path.expanduser("~"), '.dashcore/dash.conf')
+                cfn = os.path.join(os.path.expanduser("~"), ".dashcore/dash.conf")
             if not os.path.isfile(cfn):
-                raise ConfigError("Please install dash client and specify a path to config file if path is not "
-                                  "default. Or place a config file in .fluxwallet/dash.conf to reference to "
-                                  "an external server.")
+                raise ConfigError(
+                    "Please install dash client and specify a path to config file if path is not "
+                    "default. Or place a config file in .fluxwallet/dash.conf to reference to "
+                    "an external server."
+                )
         else:
-            cfn = os.path.join(FW_DATA_DIR, 'config', configfile)
+            cfn = os.path.join(FW_DATA_DIR, "config", configfile)
             if not os.path.isfile(cfn):
                 raise ConfigError("Config file %s not found" % cfn)
-        with open(cfn, 'r') as f:
-            config_string = '[rpc]\n' + f.read()
+        with open(cfn, "r") as f:
+            config_string = "[rpc]\n" + f.read()
         config.read_string(config_string)
 
         try:
-            if int(config.get('rpc', 'testnet')):
-                network = 'testnet'
+            if int(config.get("rpc", "testnet")):
+                network = "testnet"
         except configparser.NoOptionError:
             pass
-        if config.get('rpc', 'rpcpassword') == 'specify_rpc_password':
+        if config.get("rpc", "rpcpassword") == "specify_rpc_password":
             raise ConfigError("Please update config settings in %s" % cfn)
         try:
-            port = config.get('rpc', 'port')
+            port = config.get("rpc", "port")
         except configparser.NoOptionError:
-            if network == 'testnet':
+            if network == "testnet":
                 port = 19998
             else:
                 port = 9998
-        server = '127.0.0.1'
-        if 'bind' in config['rpc']:
-            server = config.get('rpc', 'bind')
-        elif 'externalip' in config['rpc']:
-            server = config.get('rpc', 'externalip')
-        url = "http://%s:%s@%s:%s" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)
+        server = "127.0.0.1"
+        if "bind" in config["rpc"]:
+            server = config.get("rpc", "bind")
+        elif "externalip" in config["rpc"]:
+            server = config.get("rpc", "externalip")
+        url = "http://%s:%s@%s:%s" % (
+            config.get("rpc", "rpcuser"),
+            config.get("rpc", "rpcpassword"),
+            server,
+            port,
+        )
         return DashdClient(network, url)
 
-    def __init__(self, network='dash', base_url='', denominator=100000000, *args):
+    def __init__(self, network="dash", base_url="", denominator=100000000, *args):
         """
         Open connection to dashcore node
 
         :param network: Dash mainnet or testnet. Default is dash mainnet
         :type: str
         :param base_url: Connection URL in format http(s)://user:password@host:port.
         :type: str
         :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for Dash
         :type: str
         """
         if not base_url:
-            bdc = self.from_config('', network)
+            bdc = self.from_config("", network)
             base_url = bdc.base_url
             network = bdc.network
-        if len(base_url.split(':')) != 4:
-            raise ConfigError("Dashd connection URL must be of format 'http(s)://user:password@host:port,"
-                              "current format is %s. Please set url in providers.json file" % base_url)
-        if 'password' in base_url:
-            raise ConfigError("Invalid password 'password' in dashd provider settings. "
-                              "Please set password and url in providers.json file")
+        if len(base_url.split(":")) != 4:
+            raise ConfigError(
+                "Dashd connection URL must be of format 'http(s)://user:password@host:port,"
+                "current format is %s. Please set url in providers.json file" % base_url
+            )
+        if "password" in base_url:
+            raise ConfigError(
+                "Invalid password 'password' in dashd provider settings. "
+                "Please set password and url in providers.json file"
+            )
         _logger.info("Connect to dashd")
         self.proxy = AuthServiceProxy(base_url)
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
     def _parse_transaction(self, tx, block_height=None, get_input_values=True):
-        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
-        t.confirmations = None if 'confirmations' not in tx else tx['confirmations']
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        t.confirmations = None if "confirmations" not in tx else tx["confirmations"]
         if t.confirmations or block_height:
-            t.status = 'confirmed'
+            t.status = "confirmed"
             t.verified = True
         for i in t.inputs:
-            if i.prev_txid == b'\x00' * 32:
-                i.script_type = 'coinbase'
+            if i.prev_txid == b"\x00" * 32:
+                i.script_type = "coinbase"
                 continue
             if get_input_values:
                 txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)
-                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))
+                i.value = int(
+                    round(
+                        float(txi["vout"][i.output_n_int]["value"])
+                        / self.network.denominator
+                    )
+                )
         for o in t.outputs:
             o.spent = None
         t.block_height = block_height
-        t.version = tx['version'].to_bytes(4, 'big')
-        t.date = datetime.utcfromtimestamp(tx['blocktime'])
+        t.version = tx["version"].to_bytes(4, "big")
+        t.date = datetime.utcfromtimestamp(tx["blocktime"])
         t.update_totals()
         return t
 
     def gettransaction(self, txid):
         tx = self.proxy.getrawtransaction(txid, 1)
         return self._parse_transaction(tx)
 
     def getrawtransaction(self, txid):
         res = self.proxy.getrawtransaction(txid)
         return res
 
     def sendrawtransaction(self, rawtx):
         res = self.proxy.sendrawtransaction(rawtx)
-        return {
-            'txid': res,
-            'response_dict': res
-        }
+        return {"txid": res, "response_dict": res}
 
     def estimatefee(self, blocks):
         try:
-            res = self.proxy.estimatesmartfee(blocks)['feerate']
+            res = self.proxy.estimatesmartfee(blocks)["feerate"]
         except KeyError:
             res = self.proxy.estimatefee(blocks)
         return int(res * self.units)
 
     def blockcount(self):
         return self.proxy.getblockcount()
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         txs = []
 
         txs_list = self.proxy.listunspent(0, 99999999, [address])
-        for t in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):
-            txs.append({
-                'address': t['address'],
-                'txid': t['txid'],
-                'confirmations': t['confirmations'],
-                'output_n': t['vout'],
-                'input_n': -1,
-                'block_height': None,
-                'fee': None,
-                'size': 0,
-                'value': int(t['amount'] * self.units),
-                'script': t['scriptPubKey'],
-                'date': None,
-            })
-            if t['txid'] == after_txid:
+        for t in sorted(txs_list, key=lambda x: x["confirmations"], reverse=True):
+            txs.append(
+                {
+                    "address": t["address"],
+                    "txid": t["txid"],
+                    "confirmations": t["confirmations"],
+                    "output_n": t["vout"],
+                    "input_n": -1,
+                    "block_height": None,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(t["amount"] * self.units),
+                    "script": t["scriptPubKey"],
+                    "date": None,
+                }
+            )
+            if t["txid"] == after_txid:
                 txs = []
 
         return txs
 
     def getblock(self, blockid, parse_transactions=True, page=1, limit=None):
         if isinstance(blockid, int):
             blockid = self.proxy.getblockhash(blockid)
         if not limit:
             limit = 99999
 
         txs = []
         if parse_transactions:
             bd = self.proxy.getblock(blockid, 2)
-            for tx in bd['tx'][(page - 1) * limit:page * limit]:
+            for tx in bd["tx"][(page - 1) * limit : page * limit]:
                 # try:
-                tx['blocktime'] = bd['time']
-                tx['blockhash'] = bd['hash']
-                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=False))
+                tx["blocktime"] = bd["time"]
+                tx["blockhash"] = bd["hash"]
+                txs.append(
+                    self._parse_transaction(
+                        tx, block_height=bd["height"], get_input_values=False
+                    )
+                )
                 # except Exception as e:
                 #     _logger.error("Could not parse tx %s with error %s" % (tx['txid'], e))
             # txs += [tx['hash'] for tx in bd['tx'][len(txs):]]
         else:
             bd = self.proxy.getblock(blockid, 1)
-            txs = bd['tx']
+            txs = bd["tx"]
 
         block = {
-            'bits': int(bd['bits'], 16),
-            'depth': bd['confirmations'],
-            'hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousblockhash'],
-            'time': bd['time'],
-            'total_txs': bd['nTx'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None,
-            'limit': limit
+            "bits": int(bd["bits"], 16),
+            "depth": bd["confirmations"],
+            "hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousblockhash"],
+            "time": bd["time"],
+            "total_txs": bd["nTx"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None,
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
         if isinstance(blockid, int):
             blockid = self.proxy.getblockhash(blockid)
         return self.proxy.getblock(blockid, 0)
@@ -249,23 +272,23 @@
         if not res:
             return 1
         return 0
 
     def getinfo(self):
         info = self.proxy.getmininginfo()
         return {
-            'blockcount': info['blocks'],
-            'chain': info['chain'],
-            'difficulty': int(info['difficulty']),
-            'hashrate': int(info['networkhashps']),
-            'mempool_size': int(info['pooledtx']),
+            "blockcount": info["blocks"],
+            "chain": info["chain"],
+            "difficulty": int(info["difficulty"]),
+            "hashrate": int(info["networkhashps"]),
+            "mempool_size": int(info["pooledtx"]),
         }
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     #
     # SOME EXAMPLES
     #
 
     from pprint import pprint
 
     # 1. Connect by specifying connection URL
@@ -276,23 +299,25 @@
 
     print("\n=== SERVERINFO ===")
     pprint(bdc.proxy.getnetworkinfo())
 
     print("\n=== Best Block ===")
     blockhash = bdc.proxy.getbestblockhash()
     bestblock = bdc.proxy.getblock(blockhash)
-    bestblock['tx'] = '...' + str(len(bestblock['tx'])) + ' transactions...'
+    bestblock["tx"] = "..." + str(len(bestblock["tx"])) + " transactions..."
     pprint(bestblock)
 
     print("\n=== Mempool ===")
     rmp = bdc.proxy.getrawmempool()
     pprint(rmp[:25])
-    print('... truncated ...')
+    print("... truncated ...")
     print("Mempool Size %d" % len(rmp))
 
-    print("\n=== Raw Transaction by txid ===")
-    t = bdc.getrawtransaction('c3d2a934ef8eb9b2291d113b330b9244c1521ef73df0a4b04c39e851112f01af')
+    print("\n=== Raw BitcoinTransaction by txid ===")
+    t = bdc.getrawtransaction(
+        "c3d2a934ef8eb9b2291d113b330b9244c1521ef73df0a4b04c39e851112f01af"
+    )
     pprint(t)
 
     print("\n=== Current network fees ===")
     t = bdc.estimatefee(5)
     pprint(t)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/dogecoind.py` & `fluxwallet-0.1.0/fluxwallet/services/dogecoind.py`

 * *Files 9% similar despite different names*

```diff
@@ -21,23 +21,23 @@
 import configparser
 from datetime import datetime
 
 from fluxwallet.main import *
 from fluxwallet.networks import Network
 from fluxwallet.services.authproxy import AuthServiceProxy
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'dogecoind'
+PROVIDERNAME = "dogecoind"
 
 _logger = logging.getLogger(__name__)
 
 
 class ConfigError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.info(msg)
 
     def __str__(self):
         return self.msg
 
 
@@ -50,189 +50,212 @@
 
 class DogecoindClient(BaseClient):
     """
     Class to interact with dogecoind, the Dogecoin daemon
     """
 
     @staticmethod
-    def from_config(configfile=None, network='dogecoin'):
+    def from_config(configfile=None, network="dogecoin"):
         """
         Read settings from dogecoind config file
 
         :param configfile: Path to config file. Leave empty to look in default places
         :type: str
         :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet
         :type: str
 
         :return DogecoindClient:
         """
         try:
             config = configparser.ConfigParser(strict=False)
         except TypeError:
             config = configparser.ConfigParser()
-        config_fn = 'dogecoin.conf'
+        config_fn = "dogecoin.conf"
         if isinstance(network, Network):
             network = network.name
-        if network == 'testnet':
-            config_fn = 'dogecoin-testnet.conf'
+        if network == "testnet":
+            config_fn = "dogecoin-testnet.conf"
 
         cfn = None
         if not configfile:
-            config_locations = ['~/.fluxwallet', '~/.dogecoin', '~/Application Data/Dogecoin',
-                                '~/Library/Application Support/Dogecoin']
+            config_locations = [
+                "~/.fluxwallet",
+                "~/.dogecoin",
+                "~/Application Data/Dogecoin",
+                "~/Library/Application Support/Dogecoin",
+            ]
             for location in config_locations:
                 cfn = Path(location, config_fn).expanduser()
                 if cfn.exists():
                     break
         else:
-            cfn = Path(FW_DATA_DIR, 'config', configfile)
+            cfn = Path(FW_DATA_DIR, "config", configfile)
         if not cfn or not cfn.is_file():
-            raise ConfigError("Config file %s not found. Please install dogecoin client and specify a path to config "
-                              "file if path is not default. Or place a config file in .fluxwallet/dogecoin.conf to "
-                              "reference to an external server." % cfn)
+            raise ConfigError(
+                "Config file %s not found. Please install dogecoin client and specify a path to config "
+                "file if path is not default. Or place a config file in .fluxwallet/dogecoin.conf to "
+                "reference to an external server." % cfn
+            )
 
         try:
             config.read(cfn)
         except Exception:
             with cfn.open() as f:
-                config_string = '[rpc]\n' + f.read()
+                config_string = "[rpc]\n" + f.read()
             config.read_string(config_string)
 
-        testnet = _read_from_config(config, 'rpc', 'testnet')
+        testnet = _read_from_config(config, "rpc", "testnet")
         if testnet:
-            network = 'testnet'
-        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':
+            network = "testnet"
+        if _read_from_config(config, "rpc", "rpcpassword") == "specify_rpc_password":
             raise ConfigError("Please update config settings in %s" % cfn)
-        if network == 'testnet':
+        if network == "testnet":
             port = 44555
         else:
             port = 22555
-        port = _read_from_config(config, 'rpc', 'rpcport', port)
-        server = '127.0.0.1'
-        server = _read_from_config(config, 'rpc', 'rpcconnect', server)
-        server = _read_from_config(config, 'rpc', 'bind', server)
-        server = _read_from_config(config, 'rpc', 'externalip', server)
-
-        url = "http://%s:%s@%s:%s" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)
+        port = _read_from_config(config, "rpc", "rpcport", port)
+        server = "127.0.0.1"
+        server = _read_from_config(config, "rpc", "rpcconnect", server)
+        server = _read_from_config(config, "rpc", "bind", server)
+        server = _read_from_config(config, "rpc", "externalip", server)
+
+        url = "http://%s:%s@%s:%s" % (
+            config.get("rpc", "rpcuser"),
+            config.get("rpc", "rpcpassword"),
+            server,
+            port,
+        )
         return DogecoindClient(network, url)
 
-    def __init__(self, network='dogecoin', base_url='', denominator=100000000, *args):
+    def __init__(self, network="dogecoin", base_url="", denominator=100000000, *args):
         """
         Open connection to dogecoin node
 
         :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet
         :type: str
         :param base_url: Connection URL in format http(s)://user:password@host:port.
         :type: str
         :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for dogecoin
         :type: str
         """
         if isinstance(network, Network):
             network = network.name
         if not base_url:
-            bdc = self.from_config('', network)
+            bdc = self.from_config("", network)
             base_url = bdc.base_url
             network = bdc.network
-        if len(base_url.split(':')) != 4:
-            raise ConfigError("Dogecoind connection URL must be of format 'http(s)://user:password@host:port,"
-                              "current format is %s. Please set url in providers.json file or check dogecoin config "
-                              "file" % base_url)
-        if 'password' in base_url:
-            raise ConfigError("Invalid password in dogecoind provider settings. "
-                              "Please replace default password and set url in providers.json or dogecoin.conf file")
+        if len(base_url.split(":")) != 4:
+            raise ConfigError(
+                "Dogecoind connection URL must be of format 'http(s)://user:password@host:port,"
+                "current format is %s. Please set url in providers.json file or check dogecoin config "
+                "file" % base_url
+            )
+        if "password" in base_url:
+            raise ConfigError(
+                "Invalid password in dogecoind provider settings. "
+                "Please replace default password and set url in providers.json or dogecoin.conf file"
+            )
         _logger.info("Connect to dogecoind")
         self.proxy = AuthServiceProxy(base_url)
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
-    def getutxos(self, address, after_txid='', max_txs=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", max_txs=MAX_TRANSACTIONS):
         txs = []
 
         for t in self.proxy.listunspent(0, 99999999, [address]):
-            txs.append({
-                'address': t['address'],
-                'txid': t['txid'],
-                'confirmations': t['confirmations'],
-                'output_n': t['vout'],
-                'input_n': -1,
-                'block_height': None,
-                'fee': None,
-                'size': 0,
-                'value': int(t['amount'] * self.units),
-                'script': t['scriptPubKey'],
-                'date': None,
-            })
+            txs.append(
+                {
+                    "address": t["address"],
+                    "txid": t["txid"],
+                    "confirmations": t["confirmations"],
+                    "output_n": t["vout"],
+                    "input_n": -1,
+                    "block_height": None,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(t["amount"] * self.units),
+                    "script": t["scriptPubKey"],
+                    "date": None,
+                }
+            )
 
         return txs
 
     def gettransaction(self, txid, block_height=None, get_input_values=True):
         tx = self.proxy.getrawtransaction(txid, 1)
-        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
-        t.confirmations = tx['confirmations']
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        t.confirmations = tx["confirmations"]
         if t.confirmations:
-            t.status = 'confirmed'
+            t.status = "confirmed"
             t.verified = True
         for i in t.inputs:
-            if i.prev_txid == b'\x00' * 32:
+            if i.prev_txid == b"\x00" * 32:
                 i.value = t.output_total
-                i.script_type = 'coinbase'
+                i.script_type = "coinbase"
                 continue
             if get_input_values:
                 txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)
-                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))
+                i.value = int(
+                    round(
+                        float(txi["vout"][i.output_n_int]["value"])
+                        / self.network.denominator
+                    )
+                )
         for o in t.outputs:
             o.spent = None
-        t.version = tx['version'].to_bytes(4, 'big')
-        t.date = datetime.fromtimestamp(tx['blocktime'])
+        t.version = tx["version"].to_bytes(4, "big")
+        t.date = datetime.fromtimestamp(tx["blocktime"])
         t.block_height = block_height
         t.update_totals()
         return t
 
     def getrawtransaction(self, txid):
         return self.proxy.getrawtransaction(txid)
 
     def sendrawtransaction(self, rawtx):
         res = self.proxy.sendrawtransaction(rawtx)
-        return {
-            'txid': res,
-            'response_dict': res
-        }
+        return {"txid": res, "response_dict": res}
 
     def estimatefee(self, blocks):
-        pres = ''
+        pres = ""
         try:
             pres = self.proxy.estimatesmartfee(blocks)
-            res = pres['feerate']
+            res = pres["feerate"]
         except KeyError as e:
             _logger.info("dogecoind error: %s, %s" % (e, pres))
             res = self.proxy.estimatefee(blocks)
         return int(res * self.units)
 
     def blockcount(self):
         return self.proxy.getblockcount()
 
-    def mempool(self, txid=''):
+    def mempool(self, txid=""):
         txids = self.proxy.getrawmempool()
         if not txid:
             return txids
         elif txid in txids:
             return [txid]
         return []
 
     def getinfo(self):
         info = self.proxy.getmininginfo()
         return {
-            'blockcount': info['blocks'],
-            'chain': info['chain'],
-            'difficulty': int(info['difficulty']),
-            'hashrate': int(info['networkhashps']),
-            'mempool_size': int(info['pooledtx']),
+            "blockcount": info["blocks"],
+            "chain": info["chain"],
+            "difficulty": int(info["difficulty"]),
+            "hashrate": int(info["networkhashps"]),
+            "mempool_size": int(info["pooledtx"]),
         }
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     #
     # SOME EXAMPLES
     #
 
     from pprint import pprint
 
     # 1. Connect by specifying connection URL
@@ -243,23 +266,25 @@
 
     print("\n=== SERVERINFO ===")
     pprint(bdc.proxy.getnetworkinfo())
 
     print("\n=== Best Block ===")
     blockhash = bdc.proxy.getbestblockhash()
     bestblock = bdc.proxy.getblock(blockhash)
-    bestblock['tx'] = '...' + str(len(bestblock['tx'])) + ' transactions...'
+    bestblock["tx"] = "..." + str(len(bestblock["tx"])) + " transactions..."
     pprint(bestblock)
 
     print("\n=== Mempool ===")
     rmp = bdc.proxy.getrawmempool()
     pprint(rmp[:25])
-    print('... truncated ...')
+    print("... truncated ...")
     print("Mempool Size %d" % len(rmp))
 
-    print("\n=== Raw Transaction by txid ===")
-    t = bdc.getrawtransaction('7eb5332699644b753cd3f5afba9562e67612ea71ef119af1ac46559adb69ea0d')
+    print("\n=== Raw BitcoinTransaction by txid ===")
+    t = bdc.getrawtransaction(
+        "7eb5332699644b753cd3f5afba9562e67612ea71ef119af1ac46559adb69ea0d"
+    )
     pprint(t)
 
     print("\n=== Current network fees ===")
     t = bdc.estimatefee(5)
     pprint(t)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/insightdash.py` & `fluxwallet-0.1.0/fluxwallet/services/litecoinblockexplorer.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    Litecore.io Client
-#     2018-2022 October - 1200 Web Development <http://1200wd.com/>
+#    litecoinblockexplorer.net Client
+#     2019-2022 - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -19,179 +19,221 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'insightdash'
+PROVIDERNAME = "litecoinblockexplorer"
 REQUEST_LIMIT = 50
 
 _logger = logging.getLogger(__name__)
 
 
-class InsightDashClient(BaseClient):
-
+class LitecoinBlockexplorerClient(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, category, data, cmd="", variables=None, method="get", offset=0
+    ):
         url_path = category
         if data:
-            url_path += '/' + data + '/' + cmd
+            url_path += "/" + data + ("" if not cmd else "/" + cmd)
         if variables is None:
             variables = {}
-        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})
+        variables.update({"from": offset, "to": offset + REQUEST_LIMIT})
         return self.request(url_path, variables, method=method)
 
     def _convert_to_transaction(self, tx):
-        if tx['confirmations']:
-            status = 'confirmed'
+        if tx["confirmations"]:
+            status = "confirmed"
         else:
-            status = 'unconfirmed'
-        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))
-        value_in = 0 if 'valueIn' not in tx else tx['valueIn']
+            status = "unconfirmed"
+        fees = (
+            None if "fees" not in tx else int(round(float(tx["fees"]) * self.units, 0))
+        )
+        value_in = (
+            0
+            if "valueIn" not in tx
+            else int(round(float(tx["valueIn"]) * self.units, 0))
+        )
         isCoinbase = False
-        if 'isCoinBase' in tx and tx['isCoinBase']:
+        if "isCoinBase" in tx and tx["isCoinBase"]:
             isCoinbase = True
         txdate = None
-        if 'blocktime' in tx:
-            txdate = datetime.utcfromtimestamp(tx['blocktime'])
-        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,
-                        fee=fees, size=tx['size'], txid=tx['txid'],
-                        date=txdate, confirmations=tx['confirmations'],
-                        block_height=tx['blockheight'], status=status,
-                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,
-                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))
-        for ti in tx['vin']:
+        if "blocktime" in tx:
+            txdate = datetime.utcfromtimestamp(tx["blocktime"])
+        t = BitcoinTransaction(
+            locktime=tx.get("locktime", 0),
+            version=tx["version"],
+            network=self.network,
+            fee=fees,
+            txid=tx["txid"],
+            date=txdate,
+            confirmations=tx["confirmations"],
+            block_height=tx["blockheight"],
+            status=status,
+            input_total=int(round(float(value_in) * self.units, 0)),
+            coinbase=isCoinbase,
+            output_total=int(round(float(tx["valueOut"]) * self.units, 0)),
+            size=len(tx["hex"]) // 2,
+        )
+        for ti in tx["vin"]:
             if isCoinbase:
-                t.add_input(prev_txid=32 * b'\0', output_n=4*b'\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],
-                            script_type='coinbase', sequence=ti['sequence'], value=0)
+                t.add_input(
+                    prev_txid=32 * b"\0",
+                    output_n=4 * b"\xff",
+                    unlocking_script=ti["coinbase"],
+                    index_n=ti["n"],
+                    script_type="coinbase",
+                    sequence=ti.get("sequence", 0),
+                    value=0,
+                )
             else:
-                value = int(round(float(ti['value']) * self.units, 0))
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],
-                            index_n=ti['n'], value=value, sequence=ti['sequence'],
-                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'],
-                            strict=self.strict)
-        for to in tx['vout']:
-            value = int(round(float(to['value']) * self.units, 0))
-            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],
-                         spent=True if to['spentTxId'] else False, output_n=to['n'],
-                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],
-                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)
+                value = int(round(float(ti["value"] or 0) * self.units, 0))
+                us = "" if "hex" not in ti["scriptSig"] else ti["scriptSig"]["hex"]
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    unlocking_script=us,
+                    index_n=ti["n"],
+                    value=value,
+                    sequence=ti.get("sequence", 0),
+                    double_spend=ti.get("doubleSpentTxID", False),
+                    strict=self.strict,
+                )
+        for to in tx["vout"]:
+            value = int(round(float(to["value"]) * self.units, 0))
+            t.add_output(
+                value=value,
+                lock_script=to["scriptPubKey"]["hex"],
+                address=to["scriptPubKey"]["addresses"][0],
+                spent=to["spent"],
+                output_n=to["n"],
+                strict=self.strict,
+            )
         return t
 
     def getbalance(self, addresslist):
         balance = 0
         addresslist = self._addresslist_convert(addresslist)
         for a in addresslist:
-            res = self.compose_request('addr', a.address, 'balance')
-            balance += res
+            res = self.compose_request("address", a.address)
+            balance += int(float(res["balance"]) / self.network.denominator)
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         address = self._address_convert(address)
-        res = self.compose_request('addrs', address.address, 'utxo')
+        res = self.compose_request("utxo", address.address)
         txs = []
         for tx in res:
-            if tx['txid'] == after_txid:
+            if tx["txid"] == after_txid:
                 break
-            txs.append({
-                'address': address.address_orig,
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': tx['vout'],
-                'input_n': 0,
-                'block_height': tx['height'],
-                'fee': None,
-                'size': 0,
-                'value': tx['satoshis'],
-                'script': tx['scriptPubKey'],
-                'date': None
-            })
+            txs.append(
+                {
+                    "address": address.address_orig,
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": tx["vout"],
+                    "input_n": 0,
+                    "block_height": tx["height"],
+                    "fee": None,
+                    "size": 0,
+                    "value": tx["satoshis"],
+                    "script": tx["scriptPubKey"],
+                    "date": None,
+                }
+            )
         return txs[::-1][:limit]
 
-    def gettransaction(self, tx_id):
-        tx = self.compose_request('tx', tx_id)
+    def gettransaction(self, txid):
+        tx = self.compose_request("tx", txid)
         return self._convert_to_transaction(tx)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        address = self._address_convert(address)
-        res = self.compose_request('addrs', address.address, 'txs')
-        txs = []
-        txs_dict = res['items'][::-1]
-        if after_txid:
-            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]
-        for tx in txs_dict[:limit]:
-            if tx['txid'] == after_txid:
-                break
-            txs.append(self._convert_to_transaction(tx))
-        return txs
-
-    def getrawtransaction(self, tx_id):
-        res = self.compose_request('rawtx', tx_id)
-        return res['rawtx']
+    # FIXME: Not available anymore
+    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    #     address = self._address_convert(address)
+    #     res = self.compose_request('addrs', address.address, 'txs')
+    #     txs = []
+    #     txs_dict = res['items'][::-1]
+    #     if after_txid:
+    #         txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]
+    #     for tx in txs_dict[:limit]:
+    #         if tx['txid'] == after_txid:
+    #             break
+    #         txs.append(self._convert_to_transaction(tx))
+    #     return txs
+
+    def getrawtransaction(self, txid):
+        res = self.compose_request("tx", txid)
+        return res["hex"]
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')
-        return {
-            'txid': res['txid'],
-            'response_dict': res
-        }
+        res = self.compose_request("sendtx", data=rawtx)
+        return {"txid": res["result"], "response_dict": res}
 
-    # def estimatefee
+    def estimatefee(self, blocks):
+        res = self.compose_request("estimatefee", str(blocks))
+        return int(float(res["result"]) / self.network.denominator)
 
     def blockcount(self):
-        res = self.compose_request('status', '', variables={'q': 'getinfo'})
-        return res['info']['blocks']
+        res = self.compose_request("status", "", variables={"q": "getinfo"})
+        return res["blockbook"]["bestHeight"]
 
     def mempool(self, txid):
-        res = self.compose_request('tx', txid)
-        if res['confirmations'] == 0:
-            return res['txid']
+        res = self.compose_request("tx", txid)
+        if res["confirmations"] == 0:
+            return res["txid"]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        bd = self.compose_request('block', str(blockid))
+        bd = self.compose_request("block", str(blockid))
         if parse_transactions:
             txs = []
-            for txid in bd['tx'][(page-1)*limit:page*limit]:
-                try:
-                    txs.append(self.gettransaction(txid))
-                except Exception as e:
-                    _logger.error("Could not parse tx %s with error %s" % (txid, e))
+            for tx in bd["txs"][(page - 1) * limit : page * limit]:
+                # try:
+                txs.append(self.gettransaction(tx["txid"]))
+                # except Exception as e:
+                #     _logger.error("Could not parse tx %s with error %s" % (tx['id'], e))
         else:
-            txs = bd['tx']
+            txs = [tx["txid"] for tx in bd["txs"]]
 
         block = {
-            'bits': bd['bits'],
-            'depth': bd['confirmations'],
-            'hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousblockhash'],
-            'time': datetime.utcfromtimestamp(bd['time']),
-            'total_txs': len(bd['tx']),
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": bd["confirmations"],
+            "block_hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleRoot"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousBlockHash"],
+            "time": bd["time"],
+            "tx_count": len(bd["txs"]),
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(len(bd["txs"]) // limit) + (len(bd["txs"]) % limit > 0),
+            "limit": limit,
         }
         return block
 
+    # def getrawblock(self, blockid):
+
     def isspent(self, txid, output_n):
         t = self.gettransaction(txid)
         return 1 if t.outputs[output_n].spent else 0
 
     def getinfo(self):
-        info = self.compose_request('status', '')['info']
+        info = self.compose_request("status", "")
         return {
-            'blockcount': info['blocks'],
-            'chain': info['network'],
-            'difficulty': int(float(info['difficulty'])),
-            'hashrate': 0,
-            'mempool_size': 0,
+            "blockcount": info["backend"]["blocks"],
+            "chain": info["backend"]["chain"],
+            "difficulty": int(float(info["backend"]["difficulty"])),
+            "hashrate": 0,
+            "mempool_size": info["blockbook"]["mempoolSize"],
         }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/litecoinblockexplorer.py` & `fluxwallet-0.1.0/fluxwallet/services/litecoreio.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    litecoinblockexplorer.net Client
-#     2019-2022 - 1200 Web Development <http://1200wd.com/>
+#    Litecore.io Client
+#     2018-2022 - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -19,182 +19,217 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'litecoinblockexplorer'
+PROVIDERNAME = "litecoreio"
 REQUEST_LIMIT = 50
 
 _logger = logging.getLogger(__name__)
 
 
-class LitecoinBlockexplorerClient(BaseClient):
-
+class LitecoreIOClient(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, category, data, cmd="", variables=None, method="get", offset=0
+    ):
         url_path = category
         if data:
-            url_path += '/' + data + ('' if not cmd else '/' + cmd)
+            url_path += "/" + data + "/" + cmd
         if variables is None:
             variables = {}
-        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})
+        variables.update({"from": offset, "to": offset + REQUEST_LIMIT})
         return self.request(url_path, variables, method=method)
 
     def _convert_to_transaction(self, tx):
-        if tx['confirmations']:
-            status = 'confirmed'
+        if tx["confirmations"]:
+            status = "confirmed"
         else:
-            status = 'unconfirmed'
-        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))
-        value_in = 0 if 'valueIn' not in tx else int(round(float(tx['valueIn']) * self.units, 0))
+            status = "unconfirmed"
+        fees = (
+            None if "fees" not in tx else int(round(float(tx["fees"]) * self.units, 0))
+        )
+        value_in = 0 if "valueIn" not in tx else tx["valueIn"]
         isCoinbase = False
-        if 'isCoinBase' in tx and tx['isCoinBase']:
+        if "isCoinBase" in tx and tx["isCoinBase"]:
             isCoinbase = True
         txdate = None
-        if 'blocktime' in tx:
-            txdate = datetime.utcfromtimestamp(tx['blocktime'])
-        t = Transaction(locktime=tx.get('locktime', 0), version=tx['version'], network=self.network, fee=fees,
-                        txid=tx['txid'], date=txdate,
-                        confirmations=tx['confirmations'], block_height=tx['blockheight'], status=status,
-                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,
-                        output_total=int(round(float(tx['valueOut']) * self.units, 0)), size=len(tx['hex']) // 2)
-        for ti in tx['vin']:
+        if "blocktime" in tx:
+            txdate = datetime.utcfromtimestamp(tx["blocktime"])
+        t = BitcoinTransaction(
+            locktime=tx["locktime"],
+            version=tx["version"],
+            network=self.network,
+            fee=fees,
+            size=tx["size"],
+            txid=tx["txid"],
+            date=txdate,
+            confirmations=tx["confirmations"],
+            block_height=tx["blockheight"],
+            status=status,
+            input_total=int(round(float(value_in) * self.units, 0)),
+            coinbase=isCoinbase,
+            output_total=int(round(float(tx["valueOut"]) * self.units, 0)),
+        )
+        for ti in tx["vin"]:
             if isCoinbase:
-                t.add_input(prev_txid=32 * b'\0', output_n=4*b'\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],
-                            script_type='coinbase', sequence=ti.get('sequence', 0), value=0)
+                t.add_input(
+                    prev_txid=32 * b"\0",
+                    output_n=4 * b"\xff",
+                    unlocking_script=ti["coinbase"],
+                    index_n=ti["n"],
+                    script_type="coinbase",
+                    sequence=ti["sequence"],
+                    value=0,
+                )
             else:
-                value = int(round(float(ti['value'] or 0) * self.units, 0))
-                us = '' if 'hex' not in ti['scriptSig'] else ti['scriptSig']['hex']
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=us,
-                            index_n=ti['n'], value=value, sequence=ti.get('sequence', 0),
-                            double_spend=ti.get('doubleSpentTxID', False),
-                            strict=self.strict)
-        for to in tx['vout']:
-            value = int(round(float(to['value']) * self.units, 0))
-            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'], address=to['scriptPubKey']['addresses'][0],
-                         spent=to['spent'], output_n=to['n'], strict=self.strict)
+                value = int(round(float(ti["value"]) * self.units, 0))
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    unlocking_script=ti["scriptSig"]["hex"],
+                    index_n=ti["n"],
+                    value=value,
+                    sequence=ti["sequence"],
+                    double_spend=False
+                    if ti["doubleSpentTxID"] is None
+                    else ti["doubleSpentTxID"],
+                )
+        for to in tx["vout"]:
+            value = int(round(float(to["value"]) * self.units, 0))
+            t.add_output(
+                value=value,
+                lock_script=to["scriptPubKey"]["hex"],
+                spent=True if to["spentTxId"] else False,
+                output_n=to["n"],
+                spending_txid=None if not to["spentTxId"] else to["spentTxId"],
+                spending_index_n=None if not to["spentIndex"] else to["spentIndex"],
+                strict=self.strict,
+            )
         return t
 
     def getbalance(self, addresslist):
         balance = 0
         addresslist = self._addresslist_convert(addresslist)
         for a in addresslist:
-            res = self.compose_request('address', a.address)
-            balance += int(float(res['balance']) / self.network.denominator)
+            res = self.compose_request("addr", a.address, "balance")
+            balance += res
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         address = self._address_convert(address)
-        res = self.compose_request('utxo', address.address)
+        res = self.compose_request("addrs", address.address, "utxo")
         txs = []
         for tx in res:
-            if tx['txid'] == after_txid:
+            if tx["txid"] == after_txid:
                 break
-            txs.append({
-                'address': address.address_orig,
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': tx['vout'],
-                'input_n': 0,
-                'block_height': tx['height'],
-                'fee': None,
-                'size': 0,
-                'value': tx['satoshis'],
-                'script': tx['scriptPubKey'],
-                'date': None
-            })
+            txs.append(
+                {
+                    "address": address.address_orig,
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": tx["vout"],
+                    "input_n": 0,
+                    "block_height": tx["height"],
+                    "fee": None,
+                    "size": 0,
+                    "value": tx["satoshis"],
+                    "script": tx["scriptPubKey"],
+                    "date": None,
+                }
+            )
         return txs[::-1][:limit]
 
-    def gettransaction(self, txid):
-        tx = self.compose_request('tx', txid)
+    def gettransaction(self, tx_id):
+        tx = self.compose_request("tx", tx_id)
         return self._convert_to_transaction(tx)
 
-    # FIXME: Not available anymore
-    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-    #     address = self._address_convert(address)
-    #     res = self.compose_request('addrs', address.address, 'txs')
-    #     txs = []
-    #     txs_dict = res['items'][::-1]
-    #     if after_txid:
-    #         txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]
-    #     for tx in txs_dict[:limit]:
-    #         if tx['txid'] == after_txid:
-    #             break
-    #         txs.append(self._convert_to_transaction(tx))
-    #     return txs
-
-    def getrawtransaction(self, txid):
-        res = self.compose_request('tx', txid)
-        return res['hex']
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        address = self._address_convert(address)
+        res = self.compose_request("addrs", address.address, "txs")
+        txs = []
+        txs_dict = res["items"][::-1]
+        if after_txid:
+            txs_dict = txs_dict[[t["txid"] for t in txs_dict].index(after_txid) + 1 :]
+        for tx in txs_dict[:limit]:
+            if tx["txid"] == after_txid:
+                break
+            txs.append(self._convert_to_transaction(tx))
+        return txs
+
+    def getrawtransaction(self, tx_id):
+        res = self.compose_request("rawtx", tx_id)
+        return res["rawtx"]
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('sendtx', data=rawtx)
-        return {
-            'txid': res['result'],
-            'response_dict': res
-        }
+        res = self.compose_request(
+            "tx", "send", variables={"rawtx": rawtx}, method="post"
+        )
+        return {"txid": res["txid"], "response_dict": res}
 
-    def estimatefee(self, blocks):
-        res = self.compose_request('estimatefee', str(blocks))
-        return int(float(res['result']) / self.network.denominator)
+    # def estimatefee
 
     def blockcount(self):
-        res = self.compose_request('status', '', variables={'q': 'getinfo'})
-        return res['blockbook']['bestHeight']
+        res = self.compose_request("status", "", variables={"q": "getinfo"})
+        return res["info"]["blocks"]
 
     def mempool(self, txid):
-        res = self.compose_request('tx', txid)
-        if res['confirmations'] == 0:
-            return res['txid']
+        res = self.compose_request("tx", txid)
+        if res["confirmations"] == 0:
+            return res["txid"]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        bd = self.compose_request('block', str(blockid))
+        if isinstance(blockid, int):
+            blockid = self.compose_request("block-index", str(blockid))["blockHash"]
+        bd = self.compose_request("block", blockid)
         if parse_transactions:
             txs = []
-            for tx in bd['txs'][(page-1)*limit:page*limit]:
+            for txid in bd["tx"][(page - 1) * limit : page * limit]:
                 # try:
-                txs.append(self.gettransaction(tx['txid']))
+                txs.append(self.gettransaction(txid))
                 # except Exception as e:
-                #     _logger.error("Could not parse tx %s with error %s" % (tx['id'], e))
+                #     _logger.error("Could not parse tx %s with error %s" % (txid, e))
         else:
-            txs = [tx['txid'] for tx in bd['txs']]
+            txs = bd["tx"]
 
         block = {
-            'bits': bd['bits'],
-            'depth': bd['confirmations'],
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleRoot'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousBlockHash'],
-            'time': bd['time'],
-            'tx_count': len(bd['txs']),
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(len(bd['txs']) // limit) + (len(bd['txs']) % limit > 0),
-            'limit': limit
+            "bits": int(bd["bits"], 16),
+            "depth": bd["confirmations"],
+            "block_hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousblockhash"],
+            "time": bd["time"],
+            "tx_count": len(bd["tx"]),
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(len(bd["tx"]) // limit) + (len(bd["tx"]) % limit > 0),
+            "limit": limit,
         }
         return block
 
-    # def getrawblock(self, blockid):
-
     def isspent(self, txid, output_n):
         t = self.gettransaction(txid)
         return 1 if t.outputs[output_n].spent else 0
 
     def getinfo(self):
-        info = self.compose_request('status', '')
+        info = self.compose_request("status", "")["info"]
         return {
-            'blockcount': info['backend']['blocks'],
-            'chain': info['backend']['chain'],
-            'difficulty': int(float(info['backend']['difficulty'])),
-            'hashrate': 0,
-            'mempool_size': info['blockbook']['mempoolSize'],
+            "blockcount": info["blocks"],
+            "chain": info["network"],
+            "difficulty": int(float(info["difficulty"])),
+            "hashrate": 0,
+            "mempool_size": 0,
         }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/litecoind.py` & `fluxwallet-0.1.0/fluxwallet/services/bitcoind.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    Client for litecoind deamon
-#     2018-2022 Oct - 1200 Web Development <http://1200wd.com/>
+#    Client for bitcoind deamon
+#     2017 - 2020 Oct - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -20,253 +20,292 @@
 
 import configparser
 
 from fluxwallet.main import *
 from fluxwallet.networks import Network
 from fluxwallet.services.authproxy import AuthServiceProxy
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'litecoind'
+PROVIDERNAME = "bitcoind"
 
 _logger = logging.getLogger(__name__)
 
 
 class ConfigError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.info(msg)
 
     def __str__(self):
         return self.msg
 
 
 def _read_from_config(configparser, section, value, fallback=None):
     try:
         return configparser.get(section, value)
     except Exception:
         return fallback
 
 
-class LitecoindClient(BaseClient):
+class BitcoindClient(BaseClient):
     """
-    Class to interact with litecoind, the Litecoin deamon
+    Class to interact with bitcoind, the Bitcoin deamon
     """
 
     @staticmethod
-    def from_config(configfile=None, network='litecoin'):
+    def from_config(configfile=None, network="bitcoin"):
         """
-        Read settings from litecoind config file
+        Read settings from bitcoind config file
 
         :param configfile: Path to config file. Leave empty to look in default places
         :type: str
-        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet
+        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet
         :type: str
 
-        :return LitecoindClient:
+        :return BitcoindClient:
         """
         try:
             config = configparser.ConfigParser(strict=False)
         except TypeError:
             config = configparser.ConfigParser()
-        config_fn = 'litecoin.conf'
+        config_fn = "bitcoin.conf"
         if isinstance(network, Network):
             network = network.name
-        if network == 'testnet':
-            config_fn = 'litecoin-testnet.conf'
+        if network == "testnet":
+            config_fn = "bitcoin-testnet.conf"
 
         cfn = None
         if not configfile:
-            config_locations = ['~/.fluxwallet', '~/.litecoin', '~/Application Data/Litecoin',
-                                '~/Library/Application Support/Litecoin']
+            config_locations = [
+                "~/.fluxwallet",
+                "~/.bitcoin",
+                "~/Application Data/Bitcoin",
+                "~/Library/Application Support/Bitcoin",
+            ]
             for location in config_locations:
                 cfn = Path(location, config_fn).expanduser()
                 if cfn.exists():
                     break
         else:
-            cfn = Path(FW_DATA_DIR, 'config', configfile)
+            cfn = Path(FW_DATA_DIR, "config", configfile)
 
         if not cfn or not cfn.is_file():
-            raise ConfigError("Config file %s not found. Please install Litecoin client and specify a path to config "
-                              "file if path is not default. Or place a config file in .fluxwallet/litecoin.conf to "
-                              "reference to an external server." % cfn)
+            raise ConfigError(
+                "Config file %s not found. Please install bitcoin client and specify a path to config "
+                "file if path is not default. Or place a config file in .fluxwallet/bitcoin.conf to "
+                "reference to an external server." % cfn
+            )
 
         try:
             config.read(cfn)
         except Exception:
             with cfn.open() as f:
-                config_string = '[rpc]\n' + f.read()
+                config_string = "[rpc]\n" + f.read()
             config.read_string(config_string)
 
-        testnet = _read_from_config(config, 'rpc', 'testnet')
+        testnet = _read_from_config(config, "rpc", "testnet")
         if testnet:
-            network = 'testnet'
-        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':
+            network = "testnet"
+        if _read_from_config(config, "rpc", "rpcpassword") == "specify_rpc_password":
             raise ConfigError("Please update config settings in %s" % cfn)
-        if network == 'testnet':
-            port = 19332
+        if network == "testnet":
+            port = 18332
         else:
-            port = 9332
-        port = _read_from_config(config, 'rpc', 'rpcport', port)
-        server = '127.0.0.1'
-        server = _read_from_config(config, 'rpc', 'rpcconnect', server)
-        server = _read_from_config(config, 'rpc', 'bind', server)
-        server = _read_from_config(config, 'rpc', 'externalip', server)
-        url = "http://%s:%s@%s:%s" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)
-        return LitecoindClient(network, url)
+            port = 8332
+        port = _read_from_config(config, "rpc", "rpcport", port)
+        server = "127.0.0.1"
+        server = _read_from_config(config, "rpc", "rpcconnect", server)
+        server = _read_from_config(config, "rpc", "bind", server)
+        server = _read_from_config(config, "rpc", "externalip", server)
+
+        url = "http://%s:%s@%s:%s" % (
+            config.get("rpc", "rpcuser"),
+            config.get("rpc", "rpcpassword"),
+            server,
+            port,
+        )
+        return BitcoindClient(network, url)
 
-    def __init__(self, network='litecoin', base_url='', denominator=100000000, *args):
+    def __init__(self, network="bitcoin", base_url="", denominator=100000000, *args):
         """
-        Open connection to litecoin node
+        Open connection to bitcoin node
 
-        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet
+        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet
         :type: str
         :param base_url: Connection URL in format http(s)://user:password@host:port.
         :type: str
-        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for litecoin
+        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for bitcoin
         :type: str
         """
         if isinstance(network, Network):
             network = network.name
         if not base_url:
-            bdc = self.from_config('', network)
+            bdc = self.from_config("", network)
             base_url = bdc.base_url
             network = bdc.network
-        if len(base_url.split(':')) != 4:
-            raise ConfigError("Litecoind connection URL must be of format 'http(s)://user:password@host:port,"
-                              "current format is %s. Please set url in providers.json file or check litecoin config "
-                              "file" % base_url)
-        if 'password' in base_url:
-            raise ConfigError("Invalid password in litecoind provider settings. "
-                              "Please replace default password and set url in providers.json or litecoin.conf file")
-        _logger.info("Connect to litecoind")
+        if len(base_url.split(":")) != 4:
+            raise ConfigError(
+                "Bitcoind connection URL must be of format 'http(s)://user:password@host:port,"
+                "current format is %s. Please set url in providers.json file or check bitcoin config "
+                "file" % base_url
+            )
+        if "password" in base_url:
+            raise ConfigError(
+                "Invalid password in bitcoind provider settings. "
+                "Please replace default password and set url in providers.json or bitcoin.conf file"
+            )
+        _logger.info("Connect to bitcoind")
         self.proxy = AuthServiceProxy(base_url)
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
             res = self.proxy.getaddressinfo(address)
-            if not (res['ismine'] or res['iswatchonly']):
+            if not (res["ismine"] or res["iswatchonly"]):
                 raise ClientError(
-                    "Address %s not found in litceoind wallet, use 'importpubkey' or 'importaddress' to add "
-                    "address to wallet." % address)
+                    "Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
+                    "address to wallet." % address
+                )
             txs_list = self.proxy.listunspent(0, 99999999, [address])
             for tx in txs_list:
-                balance += int(tx['amount'] * self.units)
+                balance += int(tx["amount"] * self.units)
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         utxos = []
         res = self.proxy.getaddressinfo(address)
-        if not (res['ismine'] or res['iswatchonly']):
-            raise ClientError("Address %s not found in litecoind wallet, use 'importpubkey' or 'importaddress' to add "
-                              "address to wallet." % address)
+        if not (res["ismine"] or res["iswatchonly"]):
+            raise ClientError(
+                "Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
+                "address to wallet." % address
+            )
 
-        txs_list = self.proxy.listunspent(0, 99999999, [address])
+        txs_list = self.proxy.listunspent(0, 9999999, [address])
         blockcount = self.blockcount()
-        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):
-            utxos.append({
-                'address': tx['address'],
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': tx['vout'],
-                'input_n': -1,
-                'block_height': blockcount - tx['confirmations'] + 1,
-                'fee': None,
-                'size': 0,
-                'value': int(tx['amount'] * self.units),
-                'script': tx['scriptPubKey'],
-                'date': None,
-            })
-            if tx['txid'] == after_txid:
+        for tx in sorted(txs_list, key=lambda x: x["confirmations"], reverse=True):
+            utxos.append(
+                {
+                    "address": tx["address"],
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": tx["vout"],
+                    "input_n": -1,
+                    "block_height": blockcount - tx["confirmations"] + 1,
+                    "fee": None,
+                    "size": 0,
+                    "value": int(tx["amount"] * self.units),
+                    "script": tx["scriptPubKey"],
+                    "date": None,
+                }
+            )
+            if tx["txid"] == after_txid:
                 utxos = []
 
         return utxos
 
     def _parse_transaction(self, tx, block_height=None, get_input_values=True):
-        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)
-        t.confirmations = tx.get('confirmations')
-        t.block_hash = tx.get('blockhash')
-        t.status = 'unconfirmed'
+        t = BitcoinTransaction.parse_hex(
+            tx["hex"], strict=self.strict, network=self.network
+        )
+        t.confirmations = tx.get("confirmations")
+        t.block_hash = tx.get("blockhash")
+        t.status = "unconfirmed"
         for i in t.inputs:
-            if i.prev_txid == b'\x00' * 32:
-                i.script_type = 'coinbase'
+            if i.prev_txid == b"\x00" * 32:
+                i.script_type = "coinbase"
                 continue
             if get_input_values:
                 txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)
-                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))
+                i.value = int(
+                    round(
+                        float(txi["vout"][i.output_n_int]["value"])
+                        / self.network.denominator
+                    )
+                )
         for o in t.outputs:
             o.spent = None
 
         if not block_height and t.block_hash:
-            block_height = self.proxy.getblock(t.block_hash, 1)['height']
+            block_height = self.proxy.getblock(t.block_hash, 1)["height"]
         t.block_height = block_height
         if not t.confirmations and block_height is not None:
             if not self.latest_block:
                 self.latest_block = self.blockcount()
             t.confirmations = (self.latest_block - block_height) + 1
         if t.confirmations or block_height:
-            t.status = 'confirmed'
+            t.status = "confirmed"
             t.verified = True
-        t.version = tx['version'].to_bytes(4, 'big')
-        t.version_int = tx['version']
-        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])
+        t.version = tx["version"].to_bytes(4, "big")
+        t.version_int = tx["version"]
+        t.date = None if "time" not in tx else datetime.utcfromtimestamp(tx["time"])
         t.update_totals()
         return t
 
     def gettransaction(self, txid):
         tx_raw = self.proxy.getrawtransaction(txid, 1)
         return self._parse_transaction(tx_raw)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         MAX_WALLET_TRANSACTIONS = 1000
         txs = []
         res = self.proxy.getaddressinfo(address)
-        if not (res['ismine'] or res['iswatchonly']):
-            raise ClientError("Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
-                              "address to wallet." % address)
+        if not (res["ismine"] or res["iswatchonly"]):
+            raise ClientError(
+                "Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add "
+                "address to wallet." % address
+            )
         txs_list = self.proxy.listtransactions("*", MAX_WALLET_TRANSACTIONS, 0, True)
         if len(txs_list) >= MAX_WALLET_TRANSACTIONS:
-            raise ClientError("Bitcoind wallet contains too many transactions %d, use other service provider for this "
-                              "wallet" % MAX_WALLET_TRANSACTIONS)
-        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))
-        for (txid, blockheight) in txids:
+            raise ClientError(
+                "Bitcoind wallet contains too many transactions %d, use other service provider for this "
+                "wallet" % MAX_WALLET_TRANSACTIONS
+            )
+        txids = list(
+            set(
+                [
+                    (tx["txid"], tx["blockheight"])
+                    for tx in txs_list
+                    if tx["address"] == address
+                ]
+            )
+        )
+        for txid, blockheight in txids:
             tx_raw = self.proxy.getrawtransaction(txid, 1)
             t = self._parse_transaction(tx_raw, blockheight)
             txs.append(t)
             if txid == after_txid:
                 txs = []
         return txs
 
     def getrawtransaction(self, txid):
         res = self.proxy.getrawtransaction(txid)
         return res
 
     def sendrawtransaction(self, rawtx):
         res = self.proxy.sendrawtransaction(rawtx)
-        return {
-            'txid': res,
-            'response_dict': res
-        }
+        return {"txid": res, "response_dict": res}
 
     def estimatefee(self, blocks):
-        pres = ''
+        pres = ""
         try:
             pres = self.proxy.estimatesmartfee(blocks)
-            res = pres['feerate']
+            res = pres["feerate"]
         except KeyError as e:
-            _logger.info("litecoind error: %s, %s" % (e, pres))
+            _logger.info("bitcoind error: %s, %s" % (e, pres))
             res = self.proxy.estimatefee(blocks)
         return int(res * self.units)
 
     def blockcount(self):
         return self.proxy.getblockcount()
 
-    def mempool(self, txid=''):
+    def mempool(self, txid=""):
         txids = self.proxy.getrawmempool()
         if not txid:
             return txids
         elif txid in txids:
             return [txid]
         return []
 
@@ -275,37 +314,43 @@
             blockid = self.proxy.getblockhash(int(blockid))
         if not limit:
             limit = 99999
 
         txs = []
         if parse_transactions:
             bd = self.proxy.getblock(blockid, 2)
-            for tx in bd['tx'][(page - 1) * limit:page * limit]:
-                tx['time'] = bd['time']
-                tx['blockhash'] = bd['hash']
-                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))
+            for tx in bd["tx"][(page - 1) * limit : page * limit]:
+                tx["time"] = bd["time"]
+                tx["blockhash"] = bd["hash"]
+                txs.append(
+                    self._parse_transaction(
+                        tx, block_height=bd["height"], get_input_values=True
+                    )
+                )
         else:
             bd = self.proxy.getblock(blockid, 1)
-            txs = bd['tx']
+            txs = bd["tx"]
 
         block = {
-            'bits': int(bd['bits'], 16),
-            'depth': bd['confirmations'],
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': bd['nonce'],
-            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],
-            'time': bd['time'],
-            'tx_count': bd['nTx'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None,
-            'limit': limit
+            "bits": int(bd["bits"], 16),
+            "depth": bd["confirmations"],
+            "block_hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": bd["nonce"],
+            "prev_block": None
+            if "previousblockhash" not in bd
+            else bd["previousblockhash"],
+            "time": bd["time"],
+            "tx_count": bd["nTx"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None,
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
         if isinstance(blockid, int):
             blockid = self.proxy.getblockhash(blockid)
         return self.proxy.getblock(blockid, 0)
@@ -315,50 +360,52 @@
         if not res:
             return 1
         return 0
 
     def getinfo(self):
         info = self.proxy.getmininginfo()
         return {
-            'blockcount': info['blocks'],
-            'chain': info['chain'],
-            'difficulty': int(info['difficulty']),
-            'hashrate': int(info['networkhashps']),
-            'mempool_size': int(info['pooledtx']),
+            "blockcount": info["blocks"],
+            "chain": info["chain"],
+            "difficulty": int(info["difficulty"]),
+            "hashrate": int(info["networkhashps"]),
+            "mempool_size": int(info["pooledtx"]),
         }
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     #
     # SOME EXAMPLES
     #
 
     from pprint import pprint
 
     # 1. Connect by specifying connection URL
-    # base_url = 'http://litecoin:passwd@host:9432'
-    # bdc = LitecoindClient(base_url=base_url)
+    # base_url = 'http://bitcoinrpc:passwd@host:8332'
+    # bdc = BitcoindClient(base_url=base_url)
     # 2. Or connect using default settings or settings from config file
-    client = LitecoindClient()
+    bdc = BitcoindClient()
 
     print("\n=== SERVERINFO ===")
-    pprint(client.proxy.getnetworkinfo())
+    pprint(bdc.proxy.getnetworkinfo())
 
     print("\n=== Best Block ===")
-    blockhash = client.proxy.getbestblockhash()
-    bestblock = client.proxy.getblock(blockhash)
-    bestblock['tx'] = '...' + str(len(bestblock['tx'])) + ' transactions...'
+    blockhash = bdc.proxy.getbestblockhash()
+    bestblock = bdc.proxy.getblock(blockhash)
+    bestblock["tx"] = "..." + str(len(bestblock["tx"])) + " transactions..."
     pprint(bestblock)
 
     print("\n=== Mempool ===")
-    rmp = client.proxy.getrawmempool()
+    rmp = bdc.proxy.getrawmempool()
     pprint(rmp[:25])
-    print('... truncated ...')
+    print("... truncated ...")
     print("Mempool Size %d" % len(rmp))
 
-    print("\n=== Raw Transaction by txid ===")
-    t = client.getrawtransaction('fa3906a4219078364372d0e2715f93e822edd0b47ce146c71ba7ba57179b50f6')
+    print("\n=== Raw BitcoinTransaction by txid ===")
+    t = bdc.getrawtransaction(
+        "7eb5332699644b753cd3f5afba9562e67612ea71ef119af1ac46559adb69ea0d"
+    )
     pprint(t)
 
     print("\n=== Current network fees ===")
-    t = client.estimatefee(5)
+    t = bdc.estimatefee(5)
     pprint(t)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/litecoreio.py` & `fluxwallet-0.1.0/fluxwallet/services/insightdash.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
 #    Litecore.io Client
-#     2018-2022 - 1200 Web Development <http://1200wd.com/>
+#     2018-2022 October - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -19,180 +19,216 @@
 #
 
 import logging
 from datetime import datetime
 
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'litecoreio'
+PROVIDERNAME = "insightdash"
 REQUEST_LIMIT = 50
 
 _logger = logging.getLogger(__name__)
 
 
-class LitecoreIOClient(BaseClient):
-
+class InsightDashClient(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self, category, data, cmd="", variables=None, method="get", offset=0
+    ):
         url_path = category
         if data:
-            url_path += '/' + data + '/' + cmd
+            url_path += "/" + data + "/" + cmd
         if variables is None:
             variables = {}
-        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})
+        variables.update({"from": offset, "to": offset + REQUEST_LIMIT})
         return self.request(url_path, variables, method=method)
 
     def _convert_to_transaction(self, tx):
-        if tx['confirmations']:
-            status = 'confirmed'
+        if tx["confirmations"]:
+            status = "confirmed"
         else:
-            status = 'unconfirmed'
-        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))
-        value_in = 0 if 'valueIn' not in tx else tx['valueIn']
+            status = "unconfirmed"
+        fees = (
+            None if "fees" not in tx else int(round(float(tx["fees"]) * self.units, 0))
+        )
+        value_in = 0 if "valueIn" not in tx else tx["valueIn"]
         isCoinbase = False
-        if 'isCoinBase' in tx and tx['isCoinBase']:
+        if "isCoinBase" in tx and tx["isCoinBase"]:
             isCoinbase = True
         txdate = None
-        if 'blocktime' in tx:
-            txdate = datetime.utcfromtimestamp(tx['blocktime'])
-        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,
-                        fee=fees, size=tx['size'], txid=tx['txid'],
-                        date=txdate, confirmations=tx['confirmations'],
-                        block_height=tx['blockheight'], status=status,
-                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,
-                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))
-        for ti in tx['vin']:
+        if "blocktime" in tx:
+            txdate = datetime.utcfromtimestamp(tx["blocktime"])
+        t = BitcoinTransaction(
+            locktime=tx["locktime"],
+            version=tx["version"],
+            network=self.network,
+            fee=fees,
+            size=tx["size"],
+            txid=tx["txid"],
+            date=txdate,
+            confirmations=tx["confirmations"],
+            block_height=tx["blockheight"],
+            status=status,
+            input_total=int(round(float(value_in) * self.units, 0)),
+            coinbase=isCoinbase,
+            output_total=int(round(float(tx["valueOut"]) * self.units, 0)),
+        )
+        for ti in tx["vin"]:
             if isCoinbase:
-                t.add_input(prev_txid=32 * b'\0', output_n=4*b'\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],
-                            script_type='coinbase', sequence=ti['sequence'], value=0)
+                t.add_input(
+                    prev_txid=32 * b"\0",
+                    output_n=4 * b"\xff",
+                    unlocking_script=ti["coinbase"],
+                    index_n=ti["n"],
+                    script_type="coinbase",
+                    sequence=ti["sequence"],
+                    value=0,
+                )
             else:
-                value = int(round(float(ti['value']) * self.units, 0))
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],
-                            index_n=ti['n'], value=value, sequence=ti['sequence'],
-                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'])
-        for to in tx['vout']:
-            value = int(round(float(to['value']) * self.units, 0))
-            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],
-                         spent=True if to['spentTxId'] else False, output_n=to['n'],
-                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],
-                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)
+                value = int(round(float(ti["value"]) * self.units, 0))
+                t.add_input(
+                    prev_txid=ti["txid"],
+                    output_n=ti["vout"],
+                    unlocking_script=ti["scriptSig"]["hex"],
+                    index_n=ti["n"],
+                    value=value,
+                    sequence=ti["sequence"],
+                    double_spend=False
+                    if ti["doubleSpentTxID"] is None
+                    else ti["doubleSpentTxID"],
+                    strict=self.strict,
+                )
+        for to in tx["vout"]:
+            value = int(round(float(to["value"]) * self.units, 0))
+            t.add_output(
+                value=value,
+                lock_script=to["scriptPubKey"]["hex"],
+                spent=True if to["spentTxId"] else False,
+                output_n=to["n"],
+                spending_txid=None if not to["spentTxId"] else to["spentTxId"],
+                spending_index_n=None if not to["spentIndex"] else to["spentIndex"],
+                strict=self.strict,
+            )
         return t
 
     def getbalance(self, addresslist):
         balance = 0
         addresslist = self._addresslist_convert(addresslist)
         for a in addresslist:
-            res = self.compose_request('addr', a.address, 'balance')
+            res = self.compose_request("addr", a.address, "balance")
             balance += res
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         address = self._address_convert(address)
-        res = self.compose_request('addrs', address.address, 'utxo')
+        res = self.compose_request("addrs", address.address, "utxo")
         txs = []
         for tx in res:
-            if tx['txid'] == after_txid:
+            if tx["txid"] == after_txid:
                 break
-            txs.append({
-                'address': address.address_orig,
-                'txid': tx['txid'],
-                'confirmations': tx['confirmations'],
-                'output_n': tx['vout'],
-                'input_n': 0,
-                'block_height': tx['height'],
-                'fee': None,
-                'size': 0,
-                'value': tx['satoshis'],
-                'script': tx['scriptPubKey'],
-                'date': None
-            })
+            txs.append(
+                {
+                    "address": address.address_orig,
+                    "txid": tx["txid"],
+                    "confirmations": tx["confirmations"],
+                    "output_n": tx["vout"],
+                    "input_n": 0,
+                    "block_height": tx["height"],
+                    "fee": None,
+                    "size": 0,
+                    "value": tx["satoshis"],
+                    "script": tx["scriptPubKey"],
+                    "date": None,
+                }
+            )
         return txs[::-1][:limit]
 
     def gettransaction(self, tx_id):
-        tx = self.compose_request('tx', tx_id)
+        tx = self.compose_request("tx", tx_id)
         return self._convert_to_transaction(tx)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         address = self._address_convert(address)
-        res = self.compose_request('addrs', address.address, 'txs')
+        res = self.compose_request("addrs", address.address, "txs")
         txs = []
-        txs_dict = res['items'][::-1]
+        txs_dict = res["items"][::-1]
         if after_txid:
-            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]
+            txs_dict = txs_dict[[t["txid"] for t in txs_dict].index(after_txid) + 1 :]
         for tx in txs_dict[:limit]:
-            if tx['txid'] == after_txid:
+            if tx["txid"] == after_txid:
                 break
             txs.append(self._convert_to_transaction(tx))
         return txs
 
     def getrawtransaction(self, tx_id):
-        res = self.compose_request('rawtx', tx_id)
-        return res['rawtx']
+        res = self.compose_request("rawtx", tx_id)
+        return res["rawtx"]
 
     def sendrawtransaction(self, rawtx):
-        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')
-        return {
-            'txid': res['txid'],
-            'response_dict': res
-        }
+        res = self.compose_request(
+            "tx", "send", variables={"rawtx": rawtx}, method="post"
+        )
+        return {"txid": res["txid"], "response_dict": res}
 
     # def estimatefee
 
     def blockcount(self):
-        res = self.compose_request('status', '', variables={'q': 'getinfo'})
-        return res['info']['blocks']
+        res = self.compose_request("status", "", variables={"q": "getinfo"})
+        return res["info"]["blocks"]
 
     def mempool(self, txid):
-        res = self.compose_request('tx', txid)
-        if res['confirmations'] == 0:
-            return res['txid']
+        res = self.compose_request("tx", txid)
+        if res["confirmations"] == 0:
+            return res["txid"]
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        if isinstance(blockid, int):
-            blockid = self.compose_request('block-index', str(blockid))['blockHash']
-        bd = self.compose_request('block', blockid)
+        bd = self.compose_request("block", str(blockid))
         if parse_transactions:
             txs = []
-            for txid in bd['tx'][(page-1)*limit:page*limit]:
-                # try:
-                txs.append(self.gettransaction(txid))
-                # except Exception as e:
-                #     _logger.error("Could not parse tx %s with error %s" % (txid, e))
+            for txid in bd["tx"][(page - 1) * limit : page * limit]:
+                try:
+                    txs.append(self.gettransaction(txid))
+                except Exception as e:
+                    _logger.error("Could not parse tx %s with error %s" % (txid, e))
         else:
-            txs = bd['tx']
+            txs = bd["tx"]
 
         block = {
-            'bits': int(bd['bits'], 16),
-            'depth': bd['confirmations'],
-            'block_hash': bd['hash'],
-            'height': bd['height'],
-            'merkle_root': bd['merkleroot'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousblockhash'],
-            'time': bd['time'],
-            'tx_count': len(bd['tx']),
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": bd["confirmations"],
+            "hash": bd["hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkleroot"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["previousblockhash"],
+            "time": datetime.utcfromtimestamp(bd["time"]),
+            "total_txs": len(bd["tx"]),
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(len(bd["tx"]) // limit) + (len(bd["tx"]) % limit > 0),
+            "limit": limit,
         }
         return block
 
     def isspent(self, txid, output_n):
         t = self.gettransaction(txid)
         return 1 if t.outputs[output_n].spent else 0
 
     def getinfo(self):
-        info = self.compose_request('status', '')['info']
+        info = self.compose_request("status", "")["info"]
         return {
-            'blockcount': info['blocks'],
-            'chain': info['network'],
-            'difficulty': int(float(info['difficulty'])),
-            'hashrate': 0,
-            'mempool_size': 0,
-        }
+            "blockcount": info["blocks"],
+            "chain": info["network"],
+            "difficulty": int(float(info["difficulty"])),
+            "hashrate": 0,
+            "mempool_size": 0,
+        }
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/mempool.py` & `fluxwallet-0.1.0/fluxwallet/services/blocksmurfer.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 #
 #    fluxwallet - Python Cryptocurrency Library
-#    mempool.space client
-#     2021-2022 - 1200 Web Development <http://1200wd.com/>
+#    Blocksmurfer client
+#     2020 Januari - 1200 Web Development <http://1200wd.com/>
 #
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as
 #    published by the Free Software Foundation, either version 3 of the
 #    License, or (at your option) any later version.
 #
 #    This program is distributed in the hope that it will be useful,
@@ -17,207 +17,264 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
 import logging
 from datetime import datetime
 
-from fluxwallet.encoding import varstr
 from fluxwallet.main import MAX_TRANSACTIONS
 from fluxwallet.services.baseclient import BaseClient, ClientError
-from fluxwallet.transactions import Transaction
+from fluxwallet.transactions import BitcoinTransaction
 
-PROVIDERNAME = 'mempool'
-# Please note: In the Blockstream API, the first couple of Bitcoin blocks are not correctly indexed,
-# so transactions from these blocks are missing.
+PROVIDERNAME = "blocksmurfer"
 
-_logger = logging.getLogger(__name__)
 
+_logger = logging.getLogger(__name__)
 
-class MempoolClient(BaseClient):
 
+class BlocksmurferClient(BaseClient):
     def __init__(self, network, base_url, denominator, *args):
-        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)
-
-    def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='',
-                        method='get'):
+        super(self.__class__, self).__init__(
+            network, PROVIDERNAME, base_url, denominator, *args
+        )
+
+    def compose_request(
+        self,
+        function,
+        parameter="",
+        parameter2="",
+        variables=None,
+        post_data="",
+        method="get",
+    ):
         url_path = function
-        if data:
-            url_path += '/' + data
         if parameter:
-            url_path += '/' + parameter
+            url_path += "/" + str(parameter)
         if parameter2:
-            url_path += '/' + parameter2
+            url_path += "/" + str(parameter2)
         if variables is None:
             variables = {}
         if self.api_key:
-            variables.update({'token': self.api_key})
+            variables.update({"token": self.api_key})
         return self.request(url_path, variables, method, post_data=post_data)
 
     def getbalance(self, addresslist):
         balance = 0
         for address in addresslist:
-            res = self.compose_request('address', address)
-            balance += res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum']
+            res = self.compose_request("address_balance", address)
+            balance += res["balance"]
         return balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
-        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-        res = self.compose_request('address', address, 'utxo')
+    # TODO: fix blocksmurfer api
+    def getutxos(self, address, after_txid="", limit=MAX_TRANSACTIONS):
+        res = self.compose_request(
+            "utxos", address, variables={"after_txid": after_txid}
+        )
+        self.latest_block = (
+            self.blockcount() if not self.latest_block else self.latest_block
+        )
         utxos = []
-        # # key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True
-        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])
-        for a in res:
-            confirmations = 0
-            block_height = None
-            if 'block_height' in a['status']:
-                block_height = a['status']['block_height']
+        for u in res:
+            block_height = None if not u["block_height"] else u["block_height"]
+            confirmations = u["confirmations"]
+            if block_height and not confirmations:
                 confirmations = self.latest_block - block_height
-            utxos.append({
-                'address': address,
-                'txid': a['txid'],
-                'confirmations': confirmations,
-                'output_n': a['vout'],
-                'input_n': 0,
-                'block_height': block_height,
-                'fee': None,
-                'size': 0,
-                'value': a['value'],
-                'script': '',
-                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])
-            })
-            if a['txid'] == after_txid:
-                utxos = []
+            utxos.append(
+                {
+                    "address": address,
+                    "txid": u["txid"],
+                    "confirmations": confirmations,
+                    "output_n": u["output_n"],
+                    "input_n": u["input_n"],
+                    "block_height": block_height,
+                    "fee": u["fee"],
+                    "size": u["size"],
+                    "value": u["value"],
+                    "script": u["script"],
+                    "date": datetime.strptime(u["date"][:19], "%Y-%m-%dT%H:%M:%S"),
+                }
+            )
         return utxos[:limit]
 
-    def _parse_transaction(self, tx):
-        block_height = None if 'block_height' not in tx['status'] else tx['status']['block_height']
-        confirmations = 0
-        tx_date = None
-        status = 'unconfirmed'
-        if tx['status']['confirmed']:
-            if block_height:
-                self.latest_block = self.blockcount() if not self.latest_block else self.latest_block
-                confirmations = self.latest_block - block_height + 1
-            tx_date = datetime.utcfromtimestamp(tx['status']['block_time'])
-            status = 'confirmed'
-
-        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network, block_height=block_height,
-                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, confirmations=confirmations,
-                        status=status, coinbase=tx['vin'][0]['is_coinbase'])
-        for ti in tx['vin']:
-            if ti['is_coinbase']:
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptsig'], value=0,
-                            sequence=ti['sequence'], strict=self.strict)
-            else:
-                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'],
-                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],
-                            address=ti['prevout'].get('scriptpubkey_address', ''),
-                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], sequence=ti['sequence'],
-                            witnesses=None if 'witness' not in ti else [bytes.fromhex(w) for w in ti['witness']],
-                            strict=self.strict)
-        for to in tx['vout']:
-            t.add_output(value=to['value'], address=to.get('scriptpubkey_address', ''), spent=None,
-                         lock_script=to['scriptpubkey'], strict=self.strict)
-        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:
-            t.witness_type = 'segwit'
+    def _parse_transaction(self, tx, block_height=None):
+        block_height = block_height if not tx["block_height"] else tx["block_height"]
+        confirmations = tx["confirmations"]
+        if block_height and not confirmations and tx["status"] == "confirmed":
+            self.latest_block = (
+                self.blockcount() if not self.latest_block else self.latest_block
+            )
+            confirmations = self.latest_block - block_height
+        # FIXME: Blocksmurfer returns 'date' or 'time', should be consistent
+        tx_date = (
+            None
+            if not tx.get("date")
+            else datetime.strptime(tx["date"], "%Y-%m-%dT%H:%M:%S")
+        )
+        if not tx_date and "time" in tx:
+            tx_date = datetime.utcfromtimestamp(tx["time"])
+        t = BitcoinTransaction(
+            locktime=tx["locktime"],
+            version=tx["version"],
+            network=self.network,
+            fee=tx["fee"],
+            size=tx["size"],
+            txid=tx["txid"],
+            date=tx_date,
+            input_total=tx["input_total"],
+            output_total=tx["output_total"],
+            confirmations=confirmations,
+            block_height=block_height,
+            status=tx["status"],
+            coinbase=tx["coinbase"],
+            rawtx=bytes.fromhex(tx["raw_hex"]),
+            witness_type=tx["witness_type"],
+        )
+        for ti in tx["inputs"]:
+            t.add_input(
+                prev_txid=ti["prev_txid"],
+                output_n=ti["output_n"],
+                keys=ti.get("keys", []),
+                index_n=ti["index_n"],
+                unlocking_script=ti["script"],
+                value=ti["value"],
+                public_hash=bytes.fromhex(ti["public_hash"]),
+                address=ti["address"],
+                witness_type=ti["witness_type"],
+                locktime_cltv=ti["locktime_cltv"],
+                locktime_csv=ti["locktime_csv"],
+                signatures=ti["signatures"],
+                compressed=ti["compressed"],
+                encoding=ti["encoding"],
+                unlocking_script_unsigned=ti["script_code"],
+                sigs_required=ti["sigs_required"],
+                sequence=ti["sequence"],
+                witnesses=[bytes.fromhex(w) for w in ti["witnesses"]],
+                script_type=ti["script_type"],
+                strict=self.strict,
+            )
+        for to in tx["outputs"]:
+            t.add_output(
+                value=to["value"],
+                address=to["address"],
+                public_hash=to["public_hash"],
+                lock_script=to["script"],
+                spent=to["spent"],
+                strict=self.strict,
+            )
         t.update_totals()
         return t
 
-    def gettransaction(self, txid):
-        tx = self.compose_request('tx', txid)
-        return self._parse_transaction(tx)
+    def gettransaction(self, txid, block_count=None):
+        tx = self.compose_request("transaction", txid)
+        return self._parse_transaction(tx, block_count)
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    def gettransactions(self, address, after_txid="", limit=MAX_TRANSACTIONS):
         prtxs = []
-        before_txid = ''
         while True:
-            txs = self.compose_request('address', address, 'txs/chain', before_txid)
+            txs = self.compose_request(
+                "transactions", address, variables={"after_txid": after_txid}
+            )
             prtxs += txs
-            if len(txs) == 25:
-                before_txid = txs[-1:][0]['txid']
-            else:
-                break
-            if len(prtxs) > limit:
+            if not txs or len(txs) < limit:
                 break
+            after_txid = txs[-1:][0]["txid"]
         txs = []
-        for tx in prtxs[::-1]:
+        for tx in prtxs:
             t = self._parse_transaction(tx)
             if t:
                 txs.append(t)
-            if t.txid == after_txid:
-                txs = []
-            if len(txs) > limit:
-                break
         return txs[:limit]
 
     def getrawtransaction(self, txid):
-        return self.compose_request('tx', txid, 'hex')
+        tx = self.compose_request("transaction", txid, variables={"raw": True})
+        return tx["raw_hex"]
 
     def sendrawtransaction(self, rawtx):
-        return self.compose_request('tx', post_data=rawtx, method='post')
+        res = self.compose_request(
+            "transaction_broadcast", post_data=rawtx, method="post"
+        )
+        return {"txid": res["txid"], "response_dict": res}
 
     def estimatefee(self, blocks):
-        estimates = self.compose_request('v1/fees', 'recommended')
-        if blocks < 2:
-            return estimates['fastestFee'] * 1000
-        elif blocks < 4:
-            return estimates['halfHourFee'] * 1000
-        if blocks < 7:
-            return estimates['hourFee'] * 1000
-        else:
-            return estimates['minimumFee'] * 1000
+        variables = {"blocks": str(blocks)}
+        res = self.compose_request("fees", variables=variables)
+        return res["estimated_fee_sat_kb"]
 
     def blockcount(self):
-        res = self.compose_request('blocks', 'tip', 'height')
-        return res
+        return self.compose_request("blockcount")["blockcount"]
 
-    def mempool(self, txid=''):
-        txids = self.compose_request('mempool', 'txids')
-        if not txid:
-            return txids
-        if txid in txids:
-            return [txid]
+    def mempool(self, txid):
+        if txid:
+            t = self.gettransaction(txid)
+            if t and not t.confirmations:
+                return [t.txid]
+        # else:
+        # return self.compose_request('mempool', 'txids')
         return []
 
     def getblock(self, blockid, parse_transactions, page, limit):
-        if isinstance(blockid, int):
-            blockid = self.compose_request('block-height', str(blockid))
-        if (page == 1 and limit == 10) or limit > 25:
-            limit = 25
-        bd = self.compose_request('block', blockid)
-        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))
-        if parse_transactions:
-            txs = []
-            for tx in btxs[:limit]:
-                txs.append(self._parse_transaction(tx))
+        variables = {
+            "parse_transactions": parse_transactions,
+            "page": page,
+            "limit": limit,
+        }
+        bd = self.compose_request("block", str(blockid), variables=variables)
+
+        txs = []
+        if (
+            parse_transactions
+            and bd["transactions"]
+            and isinstance(bd["transactions"][0], dict)
+        ):
+            self.latest_block = (
+                self.blockcount() if not self.latest_block else self.latest_block
+            )
+            for tx in bd["transactions"]:
+                tx["confirmations"] = bd["depth"]
+                tx["time"] = bd["time"]
+                tx["block_height"] = bd["height"]
+                tx["block_hash"] = bd["block_hash"]
+                t = self._parse_transaction(tx, self.latest_block)
+                if t.txid != tx["txid"]:
+                    raise ClientError(
+                        "Could not parse tx %s. Different txid's" % (tx["txid"])
+                    )
+                txs.append(t)
         else:
-            txs = [tx['txid'] for tx in btxs]
+            txs = bd["transactions"]
 
         block = {
-            'bits': bd['bits'],
-            'depth': None,
-            'block_hash': bd['id'],
-            'height': bd['height'],
-            'merkle_root': bd['merkle_root'],
-            'nonce': bd['nonce'],
-            'prev_block': bd['previousblockhash'],
-            'time': bd['timestamp'],
-            'tx_count': bd['tx_count'],
-            'txs': txs,
-            'version': bd['version'],
-            'page': page,
-            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),
-            'limit': limit
+            "bits": bd["bits"],
+            "depth": bd["depth"],
+            "block_hash": bd["block_hash"],
+            "height": bd["height"],
+            "merkle_root": bd["merkle_root"],
+            "nonce": bd["nonce"],
+            "prev_block": bd["prev_block"],
+            "time": bd["time"],
+            "tx_count": bd["tx_count"],
+            "txs": txs,
+            "version": bd["version"],
+            "page": page,
+            "pages": None
+            if not limit
+            else int(bd["tx_count"] // limit) + (bd["tx_count"] % limit > 0),
+            "limit": limit,
         }
         return block
 
     def getrawblock(self, blockid):
-        if isinstance(blockid, int):
-            blockid = self.compose_request('block-height', str(blockid))
-        return self.compose_request('block', blockid, 'raw').hex()
+        res = self.compose_request("rawblock", blockid)
+        return res
 
     def isspent(self, txid, output_n):
-        res = self.compose_request('tx', txid, 'outspend', str(output_n))
-        return 1 if res['spent'] else 0
+        res = self.compose_request("isspent", txid, str(output_n))
+        return 1 if res["spent"] else 0
 
-    # def getinfo(self):
+    def getinfo(self):
+        res = self.compose_request("")
+        info = {
+            k: v
+            for k, v in res.items()
+            if k in ["chain", "blockcount", "hashrate", "mempool_size", "difficulty"]
+        }
+        return info
```

### Comparing `fluxwallet-0.0.6/fluxwallet/services/services.py` & `fluxwallet-0.1.0/fluxwallet/services/services.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,55 +13,124 @@
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #    GNU Affero General Public License for more details.
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
+from __future__ import annotations
 
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from fluxwallet.wallet import GenericTransaction
+
+import asyncio
+import inspect
 import json
+import logging
 import random
 import time
-from datetime import timedelta
-
-from sqlalchemy import func
+from asyncio import Queue
+from collections.abc import Iterator
+from datetime import datetime, timedelta
+from functools import wraps
+from pathlib import Path
+
+from rich.pretty import pprint
+from sqlalchemy import func, select, update
+from sqlalchemy.exc import IntegrityError
+from sqlalchemy.ext.asyncio import AsyncSession
 
 from fluxwallet import services
-from fluxwallet.blocks import Block
-from fluxwallet.db_cache import *
-from fluxwallet.encoding import (int_to_varbyteint, to_bytes,
-                                 varbyteint_to_int, varstr)
+
+# from fluxwallet.blocks import Block
+from fluxwallet.config.config import (
+    BLOCK_COUNT_CACHE_TIME,
+    DEFAULT_NETWORK,
+    FW_DATA_DIR,
+    MAX_TRANSACTIONS,
+    SERVICE_CACHING_ENABLED,
+    SERVICE_MAX_ERRORS,
+    TIMEOUT_REQUESTS,
+    TYPE_TEXT,
+)
+from fluxwallet.db_cache import (
+    DbCache,
+    DbCacheAddress,
+    DbCacheBlock,
+    DbCacheTransaction,
+    DbCacheTransactionNode,
+    DbCacheVars,
+)
+from fluxwallet.encoding import int_to_varbyteint, to_bytes, varbyteint_to_int, varstr
 from fluxwallet.networks import Network
-from fluxwallet.transactions import Transaction, transaction_update_spents
+from fluxwallet.transactions import (
+    BitcoinTransaction,
+    FluxTransaction,
+    transaction_update_spents,
+)
 
 _logger = logging.getLogger(__name__)
 
 
+def test_cache(f):
+    @wraps(f)
+    async def inner(ref: Cache, *args, **kwargs):
+        if await ref.cache_enabled():
+            return await f(ref, *args, **kwargs)
+
+    return inner
+
+
+class SingletonNetwork(type):
+    _instances = {}
+
+    def __call__(cls, *args, **kwargs):
+        network = kwargs["network"]
+
+        if network not in cls._instances:
+            cls._instances[network] = super().__call__(*args, **kwargs)
+
+        return cls._instances[network]
+
+
 class ServiceError(Exception):
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.error(msg)
 
     def __str__(self):
         return self.msg
 
 
-class Service(object):
+class Service(metaclass=SingletonNetwork):
     """
     Class to connect to various cryptocurrency service providers. Use to receive network and blockchain information,
     get specific transaction information, current network fees or push a raw transaction.
 
     The Service class connects to 1 or more service providers at random to retrieve or send information. If a service
     providers fails to correctly respond the Service class will try another available provider.
 
     """
 
-    def __init__(self, network=DEFAULT_NETWORK, min_providers=1, max_providers=1, providers=None,
-                 timeout=TIMEOUT_REQUESTS, cache_uri=None, ignore_priority=False, exclude_providers=None,
-                 max_errors=SERVICE_MAX_ERRORS, strict=True):
+    def __init__(
+        self,
+        *,
+        network: str | Network = DEFAULT_NETWORK,
+        min_providers: int = 1,
+        max_providers: int = 1,
+        providers: list | None = None,
+        timeout: int = TIMEOUT_REQUESTS,
+        cache_uri: str | None = None,
+        ignore_priority: bool = False,
+        exclude_providers: list | None = None,
+        max_errors: int = SERVICE_MAX_ERRORS,
+        strict: bool = True,
+    ):
         """
         Create a service object for the specified network. By default, the object connect to 1 service provider, but you
         can specify a list of providers or a minimum or maximum number of providers.
 
         :param network: Specify network used
         :type network: str, Network
         :param min_providers: Minimum number of providers to connect to. Default is 1. Use for instance to receive fee information from a number of providers and calculate the average fee.
@@ -76,161 +145,204 @@
         :type cache_uri: str
         :param ignore_priority: Ignores provider priority if set to True. Could be used for unit testing, so no providers are missed when testing. Default is False
         :type ignore_priority: bool
         :param exclude_providers: Exclude providers in this list, can be used when problems with certain providers arise.
         :type exclude_providers: list of str
         :param strict: Strict checks of valid signatures, scripts and transactions. Normally use strict=True for wallets, transaction validations etcetera. For blockchain parsing strict=False should be used, but be sure to check warnings in the log file. Default is True.
         :type strict: bool
-
         """
 
-        self.network = network
         if not isinstance(network, Network):
             self.network = Network(network)
+        else:
+            self.network = network
+
         if min_providers > max_providers:
             max_providers = min_providers
-        fn = Path(FW_DATA_DIR, 'providers.json')
+
+        fn = Path(FW_DATA_DIR, "providers.json")
         f = fn.open("r")
 
         try:
             self.providers_defined = json.loads(f.read())
         except json.decoder.JSONDecodeError as e:  # pragma: no cover
             errstr = "Error reading provider definitions from %s: %s" % (fn, e)
             _logger.warning(errstr)
             raise ServiceError(errstr)
         f.close()
 
-        provider_list = list([self.providers_defined[x]['provider'] for x in self.providers_defined])
+        provider_list = list(
+            [self.providers_defined[x]["provider"] for x in self.providers_defined]
+        )
         if providers is None:
             providers = []
         if exclude_providers is None:
             exclude_providers = []
         if not isinstance(providers, list):
             providers = [providers]
         for p in providers:
             if p not in provider_list:
-                raise ServiceError("Provider '%s' not found in provider definitions" % p)
+                raise ServiceError(
+                    "Provider '%s' not found in provider definitions" % p
+                )
 
         self.providers = {}
         for p in self.providers_defined:
-            if (self.providers_defined[p]['network'] == network or self.providers_defined[p]['network'] == '') and \
-                    (not providers or self.providers_defined[p]['provider'] in providers):
+            if (
+                self.providers_defined[p]["network"] == network
+                or self.providers_defined[p]["network"] == ""
+            ) and (not providers or self.providers_defined[p]["provider"] in providers):
                 self.providers.update({p: self.providers_defined[p]})
         for nop in exclude_providers:
             if nop in self.providers:
-                del(self.providers[nop])
+                del self.providers[nop]
 
         if not self.providers:
             raise ServiceError("No providers found for network %s" % network)
         self.min_providers = min_providers
         self.max_providers = max_providers
         self.results = {}
         self.errors = {}
         self.resultcount = 0
         self.max_errors = max_errors
         self.complete = None
         self.timeout = timeout
         self._blockcount_update = 0
-        self._blockcount = None
+        self._blockcount = 0
         self.cache = None
         self.cache_uri = cache_uri
+
         try:
             self.cache = Cache(self.network, db_uri=cache_uri)
         except Exception as e:
-            self.cache = Cache(self.network, db_uri='')
+            self.cache = Cache(self.network, db_uri="")
             _logger.warning("Could not connect to cache database. Error: %s" % e)
+
         self.results_cache_n = 0
         self.ignore_priority = ignore_priority
         self.strict = strict
-        if self.min_providers > 1:
-            self._blockcount = Service(network=network, cache_uri=cache_uri).blockcount()
-        else:
-            self._blockcount = self.blockcount()
-
-    def __exit__(self):
-        try:
-            self.cache.session.close()
-        except Exception:
-            pass
+        # if self.min_providers > 1:
+        #     self._blockcount = Service(
+        #         network=network, cache_uri=cache_uri
+        #     ).blockcount()
+        # else:
+        #     self._blockcount = self.blockcount()
+
+    # def __exit__(self):
+    #     try:
+    #         self.cache.session.close()
+    #     except Exception:
+    #         pass
 
     def _reset_results(self):
         self.results = {}
         self.errors = {}
         self.complete = None
         self.resultcount = 0
 
-    def _provider_execute(self, method, *arguments):
+    async def _provider_execute(self, method: str, *arguments):
         self._reset_results()
-        provider_lst = [p[0] for p in sorted([(x, self.providers[x]['priority']) for x in self.providers],
-                        key=lambda x: (x[1], random.random()), reverse=True)]
+
+        provider_lst = [
+            p[0]
+            for p in sorted(
+                [(x, self.providers[x]["priority"]) for x in self.providers],
+                key=lambda x: (x[1], random.random()),
+                reverse=True,
+            )
+        ]
+
         if self.ignore_priority:
             random.shuffle(provider_lst)
 
         for sp in provider_lst:
             if self.resultcount >= self.max_providers:
                 break
             try:
-                if sp not in ['bitcoind', 'litecoind', 'dashd', 'dogecoind', 'caching'] and not self.providers[sp]['url'] and \
-                        self.network.name != 'fluxwallet_test':
+                if (
+                    sp not in ["bitcoind", "litecoind", "dashd", "dogecoind", "caching"]
+                    and not self.providers[sp]["url"]
+                    and self.network.name != "fluxwallet_test"
+                ):
                     continue
-                client = getattr(services, self.providers[sp]['provider'])
-                providerclient = getattr(client, self.providers[sp]['client_class'])
+                client = getattr(services, self.providers[sp]["provider"])
+                providerclient = getattr(client, self.providers[sp]["client_class"])
                 pc_instance = providerclient(
-                    self.network, self.providers[sp]['url'], self.providers[sp]['denominator'],
-                    self.providers[sp]['api_key'], self.providers[sp]['provider_coin_id'],
-                    self.providers[sp]['network_overrides'], self.timeout, self._blockcount, self.strict)
+                    self.network,
+                    self.providers[sp]["url"],
+                    self.providers[sp]["denominator"],
+                    self.providers[sp]["api_key"],
+                    self.providers[sp]["provider_coin_id"],
+                    self.providers[sp]["network_overrides"],
+                    self.timeout,
+                    self._blockcount,
+                    self.strict,
+                )
                 if not hasattr(pc_instance, method):
                     _logger.debug("Method %s not found for provider %s" % (method, sp))
                     continue
-                if self.providers[sp]['api_key'] == 'api-key-needed':
+                if self.providers[sp]["api_key"] == "api-key-needed":
                     _logger.debug("API key needed for provider %s" % sp)
                     continue
                 providermethod = getattr(pc_instance, method)
-                res = providermethod(*arguments)
+
+                if asyncio.iscoroutinefunction(providermethod):
+                    res = await providermethod(*arguments)
+                else:
+                    # this can be an Iterator
+                    res = providermethod(*arguments)
+
                 if res is False:  # pragma: no cover
-                    self.errors.update(
-                        {sp: 'Received empty response'}
+                    self.errors.update({sp: "Received empty response"})
+                    _logger.info(
+                        "Empty response from %s when calling %s" % (sp, method)
                     )
-                    _logger.info("Empty response from %s when calling %s" % (sp, method))
                     continue
-                self.results.update(
-                    {sp: res}
-                )
+                self.results.update({sp: res})
                 _logger.debug("Executed method %s from provider %s" % (method, sp))
                 self.resultcount += 1
             except Exception as e:
+                # remember to fix this!
+                raise
+
                 if not isinstance(e, AttributeError):
                     try:
                         err = e.msg
                     except AttributeError:
                         err = e
-                    self.errors.update(
-                        {sp: err}
-                    )
+                    self.errors.update({sp: err})
                     _logger.debug("Error %s on provider %s" % (e, sp))
                     # -- Use this to debug specific Services errors --
                     # from pprint import pprint
                     # pprint(self.errors)
 
                 if len(self.errors) >= self.max_errors:
-                    _logger.warning("Aborting, max errors exceeded: %s" %
-                                    list(self.errors.keys()))
+                    _logger.warning(
+                        "Aborting, max errors exceeded: %s" % list(self.errors.keys())
+                    )
                     if len(self.results):
                         return list(self.results.values())[0]
                     else:
                         return False
 
             if self.resultcount >= self.max_providers:
                 break
 
         if not self.resultcount:
-            raise ServiceError("No successful response from any serviceprovider: %s" % list(self.providers.keys()))
+            raise ServiceError(
+                "No successful response from any serviceprovider: %s"
+                % list(self.providers.keys())
+            )
+
+        # ok
         return list(self.results.values())[0]
 
-    def getbalance(self, addresslist, addresses_per_request=5):
+    async def getbalance(
+        self, addresslist: list[str] | str, addresses_per_request: int = 5
+    ) -> int:
         """
         Get total balance for address or list of addresses
 
         :param addresslist: Address or list of addresses
         :type addresslist: list, str
         :param addresses_per_request: Maximum number of addresses per request. Default is 5. Use lower setting when you experience timeouts or service request errors, or higher when possible.
         :type addresses_per_request: int
@@ -239,100 +351,171 @@
         """
         if isinstance(addresslist, TYPE_TEXT):
             addresslist = [addresslist]
 
         tot_balance = 0
         while addresslist:
             for address in addresslist:
-                db_addr = self.cache.getaddress(address)
-                if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount() and db_addr.balance:
+                db_addr = await self.cache.getaddress(address)
+                if (
+                    db_addr
+                    and db_addr.last_block
+                    and db_addr.last_block >= await self.blockcount()
+                    and db_addr.balance
+                ):
                     tot_balance += db_addr.balance
                     addresslist.remove(address)
 
-            balance = self._provider_execute('getbalance', addresslist[:addresses_per_request])
+            balance: int = await self._provider_execute(
+                "getbalance", addresslist[:addresses_per_request]
+            )
             if balance:
                 tot_balance += balance
+
             if len(addresslist) == 1:
-                self.cache.store_address(addresslist[0], balance=balance)
+                await self.cache.store_address(addresslist[0], balance=balance)
+
             addresslist = addresslist[addresses_per_request:]
         return tot_balance
 
-    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    async def getutxos(
+        self, address: str, after_txid: str = "", limit: int = MAX_TRANSACTIONS
+    ):
         """
         Get list of unspent outputs (UTXO's) for specified address.
 
         Sorted from old to new, so the highest number of confirmations first.
 
         :param address: Address string
         :type address: str
         :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.
         :type after_txid: str
         :param limit: Maximum number of utxo's to return. Sometimes ignored by service providers if more results are returned by default.
         :type limit: int
 
-        :return dict: UTXO's per address
+        :return list: UTXO's for address
         """
         if not isinstance(address, TYPE_TEXT):
             raise ServiceError("Address parameter must be of type text")
+
         self.results_cache_n = 0
         self.complete = True
 
         utxos_cache = []
         if self.min_providers <= 1:
-            utxos_cache = self.cache.getutxos(address, bytes.fromhex(after_txid)) or []
+            utxos_cache = await self.cache.getutxos(address, bytes.fromhex(after_txid))
+
         if utxos_cache:
             self.results_cache_n = len(utxos_cache)
 
             # Last updated block does not always include spent info...
             # if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount():
             #     return utxos_cache
-            after_txid = utxos_cache[-1:][0]['txid']
+            after_txid = utxos_cache[-1:][0]["txid"]
 
-        utxos = self._provider_execute('getutxos', address, after_txid, limit)
-        if utxos is False:
-            raise ServiceError("Error when retrieving UTXO's")
-        else:
-            # Update cache_transactions_node
-            for utxo in utxos:
-                self.cache.store_utxo(utxo['txid'], utxo['output_n'], commit=False)
-            self.cache.commit()
-            if utxos and len(utxos) >= limit:
-                self.complete = False
-            elif not after_txid:
-                balance = sum(u['value'] for u in utxos)
-                self.cache.store_address(address, balance=balance, n_utxos=len(utxos))
+        utxos: list[dict] = await self._provider_execute(
+            "getutxos", address, after_txid, limit
+        )
+        # start raising errors
+
+        # if utxos is False:
+        #     raise ServiceError("Error when retrieving UTXO's")
+
+        # Update cache_transactions_node
+        tasks = []
+        for utxo in utxos:
+            tasks.append(self.cache.store_utxo(utxo["txid"], utxo["output_n"]))
+
+        await asyncio.gather(*tasks)
+
+        if utxos and len(utxos) >= limit:
+            self.complete = False
+        elif not after_txid:
+            balance = sum(u["value"] for u in utxos)
+            await self.cache.store_address(address, balance=balance, n_utxos=len(utxos))
 
         return utxos_cache + utxos
 
-    def gettransaction(self, txid):
+    async def get_transaction(self, txid: str) -> GenericTransaction:
         """
         Get a transaction by its transaction hash. Convert to fluxwallet Transaction object.
 
         :param txid: Transaction identification hash
         :type txid: str
 
         :return Transaction: A single transaction object
         """
         tx = None
         self.results_cache_n = 0
 
         if self.min_providers <= 1:
-            tx = self.cache.gettransaction(bytes.fromhex(txid))
+            tx = await self.cache.get_transaction(bytes.fromhex(txid))
             if tx:
                 self.results_cache_n = 1
+
         if not tx:
-            tx = self._provider_execute('gettransaction', txid)
+            tx: GenericTransaction = await self._provider_execute(
+                "get_transaction", txid
+            )
+
             if tx and tx.txid != txid:
                 _logger.warning("Incorrect txid after parsing")
                 tx.txid = txid
+
             if len(self.results) and self.min_providers <= 1:
-                self.cache.store_transaction(tx)
+                await self.cache.store_transaction(tx)
+
         return tx
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    async def get_transactions(self, txids: list) -> list[GenericTransaction]:
+        """
+        Get a transaction by its transaction hash. Convert to fluxwallet Transaction object.
+
+        :param txid: Transaction identification hash
+        :type txid: str
+
+        :return Transaction: A single transaction object
+        """
+
+        # this is just for tests to be able to do assertions
+        self.results_cache_n = 0
+
+        cache_txs: list[GenericTransaction] = []
+        provider_txs: list[GenericTransaction] = []
+        cache_misses: list[str] = []
+
+        if self.min_providers <= 1:
+            for txid in txids:
+                tx = await self.cache.get_transaction(bytes.fromhex(txid))
+                if tx:
+                    self.results_cache_n += 1
+                    cache_txs.append(tx)
+                else:
+                    cache_misses.append(txid)
+
+            txs: list[GenericTransaction] = await self._provider_execute(
+                "get_transactions", cache_misses
+            )
+
+            for tx in txs:
+                if tx and tx.txid not in cache_misses:
+                    _logger.warning("Incorrect txid after parsing")
+                    continue
+                    # tx.txid = txid
+                provider_txs.append(tx)
+
+                # what is this results thing?
+                if len(self.results):
+                    await self.cache.store_transaction(tx)
+
+        return cache_txs + provider_txs
+
+    async def get_transactions_by_address(
+        self, address: str, after_tx_index: int = 0, limit: int = MAX_TRANSACTIONS
+    ) -> Iterator[list[FluxTransaction]]:
         """
         Get all transactions for specified address.
 
         Sorted from old to new, so transactions with highest number of confirmations first.
 
         :param address: Address string
         :type address: str
@@ -341,175 +524,241 @@
         :param limit: Maximum number of transactions to return
         :type limit: int
 
         :return list: List of Transaction objects
         """
         self._reset_results()
         self.results_cache_n = 0
-        if not address:
-            return []
+
+        # if not address:
+        #     yield []
+
         if not isinstance(address, TYPE_TEXT):
             raise ServiceError("Address parameter must be of type text")
-        if after_txid is None:
-            after_txid = ''
-        db_addr = self.cache.getaddress(address)
-        txs_cache = []
-        qry_after_txid = bytes.fromhex(after_txid)
+
+        db_addr = await self.cache.getaddress(address)
+        txs_cache: list[GenericTransaction] = []
+        # qry_after_txid = bytes.fromhex(after_txid)
 
         # Retrieve transactions from cache
         caching_enabled = True
         if self.min_providers > 1:  # Disable cache if comparing providers
             caching_enabled = False
 
         if caching_enabled:
-            txs_cache = self.cache.gettransactions(address, qry_after_txid, limit) or []
-            if txs_cache:
+            # change this to yield
+            if txs_cache := await self.cache.get_transactions(
+                address, after_tx_index, limit
+            ):
                 self.results_cache_n = len(txs_cache)
-                if len(txs_cache) == limit:
-                    return txs_cache
-                limit = limit - len(txs_cache)
-                qry_after_txid = bytes.fromhex(txs_cache[-1:][0].txid)
+                # if len(txs_cache) == limit:
+                #     return txs_cache
+
+                # limit = limit - len(txs_cache)
+                # qry_after_txid = bytes.fromhex(txs_cache[-1:][0].txid)
+
+        if txs_cache:
+            txs_cache = transaction_update_spents(txs_cache, address)
+            yield txs_cache
 
         # Get (extra) transactions from service providers
-        txs = []
-        if not(db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount()) or not caching_enabled:
-            txs = self._provider_execute('gettransactions', address, qry_after_txid.hex(),  limit)
-            if txs is False:
-                raise ServiceError("Error when retrieving transactions from service provider")
+        tx_generator = None
+
+        # if our cache isn't up to date with the latest block, go out to service provider and get more
+        if (
+            not (
+                db_addr
+                and db_addr.last_block
+                and db_addr.last_block >= await self.blockcount()
+            )
+            or not caching_enabled
+        ):
+            tx_generator = await self._provider_execute(
+                "get_transactions_by_address", address, after_tx_index, limit
+            )
+            # start raising errors instead of False
+
+            # if txs is False:
+            #     raise ServiceError(
+            #         "Error when retrieving transactions from service provider"
+            #     )
 
         # Store transactions and address in cache
         # - disable cache if comparing providers or if after_txid is used and no cache is available
-        last_block = None
-        last_txid = None
-        if self.min_providers <= 1 and not(after_txid and not db_addr) and caching_enabled:
-            last_block = self.blockcount()
-            last_txid = qry_after_txid
-            self.complete = True
-            if len(txs) == limit:
-                self.complete = False
-                last_block = txs[-1:][0].block_height
-            if len(txs):
-                last_txid = bytes.fromhex(txs[-1:][0].txid)
-            if len(self.results):
-                order_n = 0
-                for t in txs:
-                    if t.confirmations != 0:
-                        res = self.cache.store_transaction(t, order_n, commit=False)
-                        order_n += 1
-                        # Failure to store transaction: stop caching transaction and store last tx block height - 1
-                        if res is False:
-                            if t.block_height:
-                                last_block = t.block_height - 1
-                            break
-                self.cache.commit()
-                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=self.complete)
+        last_block = await self.blockcount()
+        # last_txid = qry_after_txid
+        self.complete = True
+        # store_in_cache = False
+        # if (
+        #     self.min_providers <= 1
+        #     and not (after_txid and not db_addr)
+        #     and caching_enabled
+        # ):
+        #     store_in_cache = True
+        # if len(txs) == limit:
+        #     self.complete = False
+        #     last_block = txs[-1:][0].block_height
+
+        if not tx_generator:
+            # print(db_addr, db_addr.last_block, await self.blockcount())
+            # empty generator
+            # yield []
+            return
+
+        new_tx_count = 0
+        async for txs in tx_generator:
+            new_tx_count += len(txs)
+            # if len(txs) and not last_txid:
+            #     last_txid = bytes.fromhex(txs[0].txid)
+
+            # order_n = 0
+            # tasks = []
+            # if store_in_cache:
+            #     for t in txs:
+            #         if t.confirmations != 0:
+            #             # tasks.append(self.cache.store_transaction(t, order_n))
+            #             tasks.append(self.cache.store_transaction(t))
+            #             order_n += 1
+
+            #     await asyncio.gather(*tasks)
+            txs = transaction_update_spents(txs, address)
 
-        all_txs = txs_cache + txs
-        # If we have txs for this address update spent and balance information in cache
-        if self.complete:
-            all_txs = transaction_update_spents(all_txs, address)
             if caching_enabled:
-                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=True)
-                for t in all_txs:
-                    self.cache.store_transaction(t, commit=False)
-                self.cache.commit()
-        return all_txs
+                # await self.cache.store_address(
+                #     address, last_block, last_txid=last_txid, txs_complete=True
+                # )
 
-    def getrawtransaction(self, txid):
+                # tasks = []
+                for t in txs:
+                    # asyncio.create_task(self.cache.store_transaction(t))
+                    await self.cache.store_transaction(t)
+                # await asyncio.gather(*tasks)
+
+            yield txs
+
+        if caching_enabled:
+            await self.cache.store_address(
+                address,
+                last_block,
+                last_tx_index=new_tx_count + after_tx_index,
+                txs_complete=self.complete,
+            )
+
+    async def getrawtransaction(self, txid: str) -> str:
         """
         Get a raw transaction by its transaction hash
 
         :param txid: Transaction identification hash
         :type txid: str
 
         :return str: Raw transaction as hexstring
         """
         self.results_cache_n = 0
-        rawtx = self.cache.getrawtransaction(bytes.fromhex(txid))
+        rawtx = await self.cache.getrawtransaction(bytes.fromhex(txid))
         if rawtx:
             self.results_cache_n = 1
             return rawtx
-        return self._provider_execute('getrawtransaction', txid)
 
-    def sendrawtransaction(self, rawtx):
+        return await self._provider_execute("getrawtransaction", txid)
+
+    async def sendrawtransaction(self, rawtx: str) -> dict:
         """
         Push a raw transaction to the network
 
         :param rawtx: Raw transaction as hexstring or bytes
         :type rawtx: str
 
         :return dict: Send transaction result
         """
-        return self._provider_execute('sendrawtransaction', rawtx)
+        return await self._provider_execute("sendrawtransaction", rawtx)
 
-    def estimatefee(self, blocks=3, priority=''):
+    async def estimatefee(self, blocks: int = 3, priority: str = ""):
         """
         Estimate fee per kilobyte for a transaction for this network with expected confirmation within a certain
         amount of blocks
 
         :param blocks: Expected confirmation time in blocks. Default is 3.
         :type blocks: int
         :param priority: Priority for transaction: can be 'low', 'medium' or 'high'. Overwrites value supplied in 'blocks' argument
         :type priority: str
 
         :return int: Fee in the smallest network denominator (satoshi)
         """
         self.results_cache_n = 0
+
         if priority:
-            if priority == 'low':
+            if priority == "low":
                 blocks = 10
-            elif priority == 'high':
+            elif priority == "high":
                 blocks = 1
+
         if self.min_providers <= 1:  # Disable cache if comparing providers
-            fee = self.cache.estimatefee(blocks)
+            fee = await self.cache.estimatefee(blocks)
             if fee:
                 self.results_cache_n = 1
                 return fee
-        fee = self._provider_execute('estimatefee', blocks)
+
+        fee = await self._provider_execute("estimatefee", blocks)
         if not fee:  # pragma: no cover
             if self.network.fee_default:
                 fee = self.network.fee_default
             else:
-                raise ServiceError("Could not estimate fees, please define default fees in network settings")
+                raise ServiceError(
+                    "Could not estimate fees, please define default fees in network settings"
+                )
         if fee < self.network.fee_min:
             fee = self.network.fee_min
         elif fee > self.network.fee_max:
             fee = self.network.fee_max
-        self.cache.store_estimated_fee(blocks, fee)
+
+        await self.cache.store_estimated_fee(blocks, fee)
+
         return fee
 
-    def blockcount(self):
+    async def blockcount(self) -> int:
         """
         Get the latest block number: The block number of last block in longest chain on the Blockchain.
 
         Block count is cashed for BLOCK_COUNT_CACHE_TIME seconds to avoid to many calls to service providers.
 
         :return int:
         """
 
-        blockcount = self.cache.blockcount()
-        last_cache_blockcount = self.cache.blockcount(never_expires=True)
+        blockcount = await self.cache.blockcount()
+        last_cache_blockcount = await self.cache.blockcount(never_expires=True)
+
         if blockcount:
             self._blockcount = blockcount
             return blockcount
 
         current_timestamp = time.time()
         if self._blockcount_update < current_timestamp - BLOCK_COUNT_CACHE_TIME:
-            new_count = self._provider_execute('blockcount')
+            new_count = await self._provider_execute("blockcount")
+
             if not self._blockcount or (new_count and new_count > self._blockcount):
                 self._blockcount = new_count
                 self._blockcount_update = current_timestamp
-            if last_cache_blockcount > self._blockcount:
+
+            # if cache is disabled, returns None
+            if last_cache_blockcount and last_cache_blockcount > self._blockcount:
                 return last_cache_blockcount
+
             # Store result in cache
-            if len(self.results) and list(self.results.keys())[0] != 'caching':
-                self.cache.store_blockcount(self._blockcount)
+            if len(self.results) and list(self.results.keys())[0] != "caching":
+                await self.cache.store_blockcount(self._blockcount)
+
         return self._blockcount
 
-    def getblock(self, blockid, parse_transactions=True, page=1, limit=None):
+    async def getblock(
+        self,
+        blockid: int | str,
+        parse_transactions: bool = True,
+        page: int = 1,
+        limit: int | None = None,
+    ) -> Block | None:
         """
         Get block with specified block height or block hash from service providers.
 
         If parse_transaction is set to True a list of Transaction object will be returned otherwise a
         list of transaction ID's.
 
         Some providers require 1 or 2 extra request per transaction, so to avoid timeouts or rate limiting errors
@@ -535,119 +784,145 @@
         :type limit: int
 
         :return Block:
         """
         if limit is None:
             limit = 25 if parse_transactions else 99999
 
-        block = self.cache.getblock(blockid)
+        block = await self.cache.getblock(blockid)
         is_last_page = False
+
         if block:
             # Block found get transactions from cache
-            block.transactions = self.cache.getblocktransactions(block.height, page, limit)
+            block.transactions = await self.cache.getblocktransactions(
+                block.height, page, limit
+            )
             if block.transactions:
                 self.results_cache_n = 1
-            is_last_page = page*limit > block.tx_count
-        if not block or (not len(block.transactions) and limit != 0) or (not is_last_page and len(block.transactions) < limit) or \
-                (is_last_page and ((page-1)*limit - block.tx_count + len(block.transactions)) < 0):
+            is_last_page = page * limit > block.tx_count
+        if (
+            not block
+            or (not len(block.transactions) and limit != 0)
+            or (not is_last_page and len(block.transactions) < limit)
+            or (
+                is_last_page
+                and ((page - 1) * limit - block.tx_count + len(block.transactions)) < 0
+            )
+        ):
             self.results_cache_n = 0
-            bd = self._provider_execute('getblock', blockid, parse_transactions, page, limit)
-            if not bd or isinstance(bd, bool):
-                return False
-            block = Block(bd['block_hash'], bd['version'], bd['prev_block'], bd['merkle_root'], bd['time'], bd['bits'],
-                          bd['nonce'], bd['txs'], bd['height'], bd['depth'], self.network)
-            block.tx_count = bd['tx_count']
+            bd = await self._provider_execute(
+                "getblock", blockid, parse_transactions, page, limit
+            )
+            if not bd:
+                return
+
+            block = Block(
+                bd["block_hash"],
+                bd["version"],
+                bd["prev_block"],
+                bd["merkle_root"],
+                bd["time"],
+                bd["bits"],
+                bd["nonce"],
+                bd["txs"],
+                bd["height"],
+                bd["depth"],
+                self.network,
+            )
+            block.tx_count = bd["tx_count"]
             block.limit = limit
             block.page = page
 
             if parse_transactions and self.min_providers <= 1:
-                order_n = (page-1)*limit
+                order_n = (page - 1) * limit
                 for tx in block.transactions:
-                    if isinstance(tx, Transaction):
+                    if isinstance(tx, BitcoinTransaction):
                         self.cache.store_transaction(tx, order_n, commit=False)
                     order_n += 1
                 self.cache.commit()
             self.complete = True if len(block.transactions) == block.tx_count else False
             self.cache.store_block(block)
         return block
 
-    def getrawblock(self, blockid):
+    async def getrawblock(self, blockid: str | int):
         """
         Get raw block as hexadecimal string for block with specified hash or block height.
 
         Not many providers offer this option, and it can be slow, so it is advised to use a local client such
         as bitcoind.
 
         :param blockid: Block hash or block height
         :type blockid: str, int
 
         :return str:
         """
-        return self._provider_execute('getrawblock', blockid)
+        return await self._provider_execute("getrawblock", blockid)
 
-    def mempool(self, txid=''):
+    async def mempool(self, txid: str = "") -> list:
         """
         Get list of all transaction IDs in the current mempool
 
         A full list of transactions ID's will only be returned if a bcoin or bitcoind client is available. Otherwise
         specify the txid option to verify if a transaction is added to the mempool.
 
         :param txid: Check if transaction with this hash exists in memory pool
         :type txid: str
 
         :return list:
         """
-        return self._provider_execute('mempool', txid)
+        return await self._provider_execute("mempool", txid)
 
-    def getcacheaddressinfo(self, address):
+    async def getcacheaddressinfo(self, address: str) -> dict[str, str]:
         """
         Get address information from cache. I.e. balance, number of transactions, number of utox's, etc
 
-        Cache will only be filled after all transactions for a specific address are retrieved (with gettransactions ie)
+        Cache will only be filled after all transactions for a specific address are retrieved (with get_transactions ie)
 
         :param address: address string
         :type address: str
 
         :return dict:
         """
-        addr_dict = {'address': address}
-        addr_rec = self.cache.getaddress(address)
+        addr_dict = {"address": address}
+        addr_rec = await self.cache.getaddress(address)
+
         if isinstance(addr_rec, DbCacheAddress):
-            addr_dict['balance'] = addr_rec.balance
-            addr_dict['last_block'] = addr_rec.last_block
-            addr_dict['n_txs'] = addr_rec.n_txs
-            addr_dict['n_utxos'] = addr_rec.n_utxos
+            addr_dict["balance"] = addr_rec.balance
+            addr_dict["last_block"] = addr_rec.last_block
+            addr_dict["n_txs"] = addr_rec.n_txs
+            addr_dict["n_utxos"] = addr_rec.n_utxos
+
         return addr_dict
 
-    def isspent(self, txid, output_n):
+    async def isspent(self, txid: str, output_n: int) -> bool:
         """
         Check if the output with provided transaction ID and output number is spent.
 
         :param txid: Transaction ID hex
         :type txid: str
         :param output_n: Output number
         :type output_n: int
 
         :return bool:
         """
-        t = self.cache.gettransaction(bytes.fromhex(txid))
+        t = await self.cache.get_transaction(bytes.fromhex(txid))
         if t and len(t.outputs) > output_n and t.outputs[output_n].spent is not None:
             return t.outputs[output_n].spent
         else:
-            return bool(self._provider_execute('isspent', txid, output_n))
+            return bool(await self._provider_execute("isspent", txid, output_n))
 
-    def getinfo(self):
+    async def getinfo(self):
         """
         Returns info about current network. Such as difficulty, latest block, mempool size and network hashrate.
 
         :return dict:
         """
-        return self._provider_execute('getinfo')
+        return await self._provider_execute("getinfo")
 
-    def getinputvalues(self, t):
+    async def getinputvalues(self, t: GenericTransaction) -> GenericTransaction:
         """
         Retrieve values for transaction inputs for given Transaction.
 
         Raw transactions as stored on the blockchain do not contain the input values but only the previous
         transaction hash and index number. This method retrieves the previous transaction and reads the value.
 
         :param t: Transaction
@@ -655,538 +930,843 @@
 
         :return Transaction:
         """
         prev_txs = []
         for i in t.inputs:
             if not i.value:
                 if i.prev_txid not in prev_txs:
-                    prev_t = self.gettransaction(i.prev_txid.hex())
+                    prev_t = await self.get_transactions([i.prev_txid.hex()])
                 else:
                     prev_t = [t for t in prev_txs if t.txid == i.prev_txid][0]
                 i.value = prev_t.outputs[i.output_n_int].value
         return t
 
 
-class Cache(object):
+class Cache:
     """
     Store transaction, utxo and address information in database to increase speed and avoid duplicate calls to
     service providers.
 
     Once confirmed a transaction is immutable so we have to fetch it from a service provider only once. When checking
     for new transactions or utxo's for a certain address we only have to check the new blocks.
 
     This class is used by the Service class and normally you won't need to access it directly.
 
     """
 
-    def __init__(self, network, db_uri=''):
+    def __init__(self, network: Network, db_uri: str = ""):
         """
         Open Cache class
 
         :param network: Specify network used
-        :type network: str, Network
+        :type network: Network
         :param db_uri: Database to use for caching
         :type db_uri: str
         """
-        self.session = None
-        if SERVICE_CACHING_ENABLED:
-            self.session = DbCache(db_uri=db_uri).session
+
+        # self.session = None
+        # if SERVICE_CACHING_ENABLED:
+        #     self.cache = DbCache(db_uri)
+
+        self.db_uri = db_uri
         self.network = network
+        self.cache: DbCache | None = None
+        self.cache_started = False
 
     def __exit__(self):
         try:
             self.session.close()
         except Exception:
             pass
 
-    def cache_enabled(self):
+    async def cache_enabled(self) -> bool:
         """
         Check if caching is enabled. Returns False if SERVICE_CACHING_ENABLED is False or no session is defined.
 
         :return bool:
         """
-        if not SERVICE_CACHING_ENABLED or not self.session:
+        if not self.cache_started and SERVICE_CACHING_ENABLED:
+            self.cache = await DbCache.start(self.db_uri)
+            self.cache_started = True
+
+        if not SERVICE_CACHING_ENABLED or not self.cache.connection_possible:
             return False
-        return True
 
-    def commit(self):
-        """
-        Commit queries in self.session. Rollback if commit fails.
+        return True
 
-        :return:
-        """
-        if not self.session:
-            return
-        try:
-            self.session.commit()
-        except Exception:
-            self.session.rollback()
-            raise
+    # def commit(self):
+    #     """
+    #     Commit queries in self.session. Rollback if commit fails.
+
+    #     :return:
+    #     """
+    #     if not self.session:
+    #         return
+    #     try:
+    #         self.session.commit()
+    #     except Exception:
+    #         self.session.rollback()
+    #         raise
 
     @staticmethod
-    def _parse_db_transaction(db_tx):
-        t = Transaction(locktime=db_tx.locktime, version=db_tx.version, network=db_tx.network_name,
-                        fee=db_tx.fee, txid=db_tx.txid.hex(), date=db_tx.date, confirmations=db_tx.confirmations,
-                        block_height=db_tx.block_height, status='confirmed', witness_type=db_tx.witness_type.value)
+    def _parse_db_transaction(db_tx: DbCacheTransaction):
+        # probably store this on provider or something
+        if db_tx.network_name == "flux":
+            klass = FluxTransaction
+        else:
+            klass = BitcoinTransaction
+
+        t = klass(
+            locktime=db_tx.locktime,
+            version=db_tx.version,
+            network=db_tx.network_name,
+            fee=db_tx.fee,
+            txid=db_tx.txid.hex(),
+            date=db_tx.date,
+            confirmations=db_tx.confirmations,
+            block_height=db_tx.block_height,
+            status="confirmed",
+            witness_type=db_tx.witness_type.value,
+        )
+
         for n in db_tx.nodes:
             if n.is_input:
-                if n.ref_txid == b'\00' * 32:
+                if n.ref_txid == b"\00" * 32:
                     t.coinbase = True
-                t.add_input(n.ref_txid.hex(), n.ref_index_n, unlocking_script=n.script, address=n.address,
-                            sequence=n.sequence, value=n.value, index_n=n.index_n, witnesses=n.witnesses, strict=False)
+                t.add_input(
+                    n.ref_txid.hex(),
+                    n.ref_index_n,
+                    unlocking_script=n.script,
+                    address=n.address,
+                    sequence=n.sequence,
+                    value=n.value,
+                    index_n=n.index_n,
+                    witnesses=n.witnesses,
+                    strict=False,
+                )
             else:
-                t.add_output(n.value, n.address, lock_script=n.script, spent=n.spent, output_n=n.index_n,
-                             spending_txid=None if not n.ref_txid else n.ref_txid.hex(),
-                             spending_index_n=n.ref_index_n, strict=False)
+                t.add_output(
+                    n.value,
+                    n.address,
+                    lock_script=n.script,
+                    spent=n.spent,
+                    output_n=n.index_n,
+                    spending_txid=None if not n.ref_txid else n.ref_txid.hex(),
+                    spending_index_n=n.ref_index_n,
+                    strict=False,
+                )
 
         t.update_totals()
         t.size = len(t.raw())
         t.calc_weight_units()
         _logger.info("Retrieved transaction %s from cache" % t.txid)
         return t
 
-    def gettransaction(self, txid):
+    @test_cache
+    async def get_transaction(self, txid: bytes) -> GenericTransaction:
         """
         Get transaction from cache. Returns False if not available
 
         :param txid: Transaction identification hash
         :type txid: bytes
 
         :return Transaction: A single Transaction object
         """
-        if not self.cache_enabled():
-            return False
-        db_tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()
-        if not db_tx:
-            return False
-        db_tx.txid = txid
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheTransaction).filter_by(
+                    txid=txid, network_name=self.network.name
+                )
+            )
+
+            db_tx = res.first()
+
+            if not db_tx:
+                return False
+
+            await db_tx.awaitable_attrs.nodes
+
+        # ??? removed this
+        # db_tx.txid = txid
+
         t = self._parse_db_transaction(db_tx)
+
         if t.block_height:
-            t.confirmations = (self.blockcount() - t.block_height) + 1
+            t.confirmations = (await self.blockcount() - t.block_height) + 1
+
         return t
 
-    def getaddress(self, address):
+    @test_cache
+    async def getaddress(self, address: str) -> DbCacheAddress | None:
         """
         Get address information from cache, with links to transactions and utxo's and latest update information.
 
         :param address: Address string
         :type address: str
 
         :return DbCacheAddress: An address cache database object
         """
-        if not self.cache_enabled():
-            return
-        return self.session.query(DbCacheAddress).filter_by(address=address, network_name=self.network.name).scalar()
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheAddress).filter_by(
+                    address=address, network_name=self.network.name
+                )
+            )
+
+        return res.first()
 
-    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):
+    @test_cache
+    async def get_transactions(
+        self, address: str, after_txid: bytes = b"", limit: int = MAX_TRANSACTIONS
+    ) -> list[GenericTransaction]:
         """
         Get transactions from cache. Returns empty list if no transactions are found or caching is disabled.
 
         :param address: Address string
         :type address: str
         :param after_txid: Transaction ID of last known transaction. Only check for transactions after given tx id. Default: Leave empty to return all transaction. If used only provide a single address
         :type after_txid: bytes
         :param limit: Maximum number of transactions to return
         :type limit: int
 
         :return list: List of Transaction objects
         """
-        if not self.cache_enabled():
-            return False
-        db_addr = self.getaddress(address)
-        txs = []
-        if db_addr:
+        db_addr = await self.getaddress(address)
+
+        if not db_addr:
+            return []
+
+        async with self.cache.get_session() as session:
             if after_txid:
-                after_tx = self.session.query(DbCacheTransaction).\
-                    filter_by(txid=after_txid, network_name=self.network.name).scalar()
-                if after_tx and db_addr.last_block and after_tx.block_height:
-                    db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).\
-                        filter(DbCacheTransactionNode.address == address,
-                               DbCacheTransaction.block_height >= after_tx.block_height,
-                               DbCacheTransaction.block_height <= db_addr.last_block).\
-                        order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()
+                res = await session.scalars(
+                    select(DbCacheTransaction).filter_by(
+                        txid=after_txid, network_name=self.network.name
+                    )
+                )
+                target_tx = res.first()
+
+                if target_tx and db_addr.last_block and target_tx.block_height:
+                    res = await session.scalars(
+                        select(DbCacheTransaction)
+                        .join(DbCacheTransactionNode)
+                        .filter(
+                            DbCacheTransactionNode.address == address,
+                            DbCacheTransaction.block_height >= target_tx.block_height,
+                            DbCacheTransaction.block_height <= db_addr.last_block,
+                        )
+                        .order_by(
+                            DbCacheTransaction.block_height,
+                            DbCacheTransaction.order_n,
+                        )
+                    )
+                    db_txs = res.all()
+
                     db_txs2 = []
+                    # this seems fucked, add breakpoint
                     for d in db_txs:
                         db_txs2.append(d)
                         if d.txid == after_txid:
                             db_txs2 = []
                     db_txs = db_txs2
                 else:
                     return []
             else:
-                db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode). \
-                    filter(DbCacheTransactionNode.address == address). \
-                    order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()
+                res = await session.scalars(
+                    select(DbCacheTransaction)
+                    .join(DbCacheTransactionNode)
+                    .filter(DbCacheTransactionNode.address == address)
+                    .order_by(
+                        DbCacheTransaction.block_height, DbCacheTransaction.order_n
+                    )
+                )
+                db_txs = res.all()
+
             for db_tx in db_txs:
-                t = self._parse_db_transaction(db_tx)
-                if t:
-                    if t.block_height:
-                        t.confirmations = (self.blockcount() - t.block_height) + 1
-                    txs.append(t)
-                    if len(txs) >= limit:
-                        break
-            return txs
-        return []
+                await db_tx.awaitable_attrs.nodes
+
+        txs: list[GenericTransaction] = []
+        for db_tx in db_txs:
+            t = self._parse_db_transaction(db_tx)
+
+            if t:
+                if t.block_height:
+                    t.confirmations = (await self.blockcount() - t.block_height) + 1
+                txs.append(t)
+                if len(txs) >= limit:
+                    break
 
-    def getblocktransactions(self, height, page, limit):
+        return txs
+
+    @test_cache
+    async def getblocktransactions(
+        self, height: int, page: int, limit: int
+    ) -> list[GenericTransaction]:
         """
         Get range of transactions from a block
 
         :param height: Block height
         :type height: int
         :param page: Transaction page
         :type page: int
         :param limit: Number of transactions per page
         :type limit: int
 
         :return:
         """
-        if not self.cache_enabled():
-            return False
-        n_from = (page-1) * limit
+        n_from = (page - 1) * limit
         n_to = page * limit
-        db_txs = self.session.query(DbCacheTransaction).\
-            filter(DbCacheTransaction.block_height == height, DbCacheTransaction.order_n >= n_from,
-                   DbCacheTransaction.order_n < n_to).all()
-        txs = []
+
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheTransaction).filter(
+                    DbCacheTransaction.block_height == height,
+                    DbCacheTransaction.order_n >= n_from,
+                    DbCacheTransaction.order_n < n_to,
+                )
+            )
+            db_txs = res.all()
+
+        txs: list[GenericTransaction] = []
         for db_tx in db_txs:
             t = self._parse_db_transaction(db_tx)
+            # why if here?
             if t:
                 txs.append(t)
         return txs
 
-    def getrawtransaction(self, txid):
+    @test_cache
+    async def getrawtransaction(self, txid: bytes) -> str | None:
         """
         Get a raw transaction string from the database cache if available
 
         :param txid: Transaction identification hash
         :type txid: bytes
 
         :return str: Raw transaction as hexstring
         """
-        if not self.cache_enabled():
-            return False
-        tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheTransaction).filter_by(
+                    txid=txid, network_name=self.network.name
+                )
+            )
+            tx = res.first()
+
         if not tx:
-            return False
+            return
+
         t = self._parse_db_transaction(tx)
         return t.raw_hex()
 
-    def getutxos(self, address, after_txid=''):
+    @test_cache
+    async def getutxos(
+        self, address: str, after_txid: bytes | None = None
+    ) -> list[dict]:
         """
         Get list of unspent outputs (UTXO's) for specified address from database cache.
 
         Sorted from old to new, so highest number of confirmations first.
 
         :param address: Address string
         :type address: str
         :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.
         :type after_txid: bytes
 
         :return dict: UTXO's per address
         """
-        if not self.cache_enabled():
-            return False
-        db_utxos = self.session.query(DbCacheTransactionNode.spent, DbCacheTransactionNode.index_n,
-                                      DbCacheTransactionNode.value, DbCacheTransaction.confirmations,
-                                      DbCacheTransaction.block_height, DbCacheTransaction.fee,
-                                      DbCacheTransaction.date, DbCacheTransaction.txid).join(DbCacheTransaction). \
-            order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n). \
-            filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.is_input == False,
-                   DbCacheTransaction.network_name == self.network.name).all()
-        utxos = []
+        async with self.cache.get_session() as session:
+            db_utxos = await session.execute(
+                select(
+                    DbCacheTransactionNode.spent,
+                    DbCacheTransactionNode.index_n,
+                    DbCacheTransactionNode.value,
+                    DbCacheTransaction.confirmations,
+                    DbCacheTransaction.block_height,
+                    DbCacheTransaction.fee,
+                    DbCacheTransaction.date,
+                    DbCacheTransaction.txid,
+                )
+                .join(DbCacheTransaction.nodes)
+                .order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n)
+                .filter(
+                    DbCacheTransactionNode.address == address,
+                    DbCacheTransactionNode.is_input == False,
+                    DbCacheTransaction.network_name == self.network.name,
+                )
+            )
+
+        utxos: list[dict] = []
         for db_utxo in db_utxos:
             if db_utxo.spent is False:
-                utxos.append({
-                    'address': address,
-                    'txid': db_utxo.txid.hex(),
-                    'confirmations': db_utxo.confirmations,
-                    'output_n': db_utxo.index_n,
-                    'input_n': 0,
-                    'block_height': db_utxo.block_height,
-                    'fee': db_utxo.fee,
-                    'size': 0,
-                    'value': db_utxo.value,
-                    'script': '',
-                    'date': db_utxo.date
-                })
+                utxos.append(
+                    {
+                        "address": address,
+                        "txid": db_utxo.txid.hex(),
+                        "confirmations": db_utxo.confirmations,
+                        "output_n": db_utxo.index_n,
+                        "input_n": 0,
+                        "block_height": db_utxo.block_height,
+                        "fee": db_utxo.fee,
+                        "size": 0,
+                        "value": db_utxo.value,
+                        "script": "",
+                        "date": db_utxo.date,
+                    }
+                )
             elif db_utxo.spent is None:
                 return utxos
+
             if db_utxo.txid == after_txid:
+                # this makes no sense
                 utxos = []
+
         return utxos
 
-    def estimatefee(self, blocks):
+    @test_cache
+    async def estimatefee(self, blocks) -> int | None:
         """
         Get fee estimation from cache for confirmation within specified amount of blocks.
 
         Stored in cache in three groups: low, medium and high fees.
 
         :param blocks: Expected confirmation time in blocks.
         :type blocks: int
 
         :return int: Fee in the smallest network denominator (satoshi)
         """
-        if not self.cache_enabled():
-            return False
         if blocks <= 1:
-            varname = 'fee_high'
+            varname = "fee_high"
         elif blocks <= 5:
-            varname = 'fee_medium'
+            varname = "fee_medium"
         else:
-            varname = 'fee_low'
-        dbvar = self.session.query(DbCacheVars).filter_by(varname=varname, network_name=self.network.name).\
-            filter(DbCacheVars.expires > datetime.now()).scalar()
-        if dbvar:
+            varname = "fee_low"
+
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheVars)
+                .filter_by(varname=varname, network_name=self.network.name)
+                .filter(DbCacheVars.expires > datetime.now())
+            )
+
+        if dbvar := res.first():
             return int(dbvar.value)
-        return False
 
-    def blockcount(self, never_expires=False):
+    @test_cache
+    async def blockcount(self, never_expires=False) -> int | None:
         """
         Get number of blocks on the current network from cache if recent data is available.
 
         :param never_expires: Always return latest blockcount found. Can be used to avoid return to old blocks if service providers are not up-to-date.
         :type never_expires: bool
 
         :return int:
         """
-        if not self.cache_enabled():
-            return False
-        qr = self.session.query(DbCacheVars).filter_by(varname='blockcount', network_name=self.network.name)
-        if not never_expires:
-            qr = qr.filter(DbCacheVars.expires > datetime.now())
-        dbvar = qr.scalar()
-        if dbvar:
+        async with self.cache.get_session() as session:
+            stmt = select(DbCacheVars).filter_by(
+                varname="blockcount", network_name=self.network.name
+            )
+            if not never_expires:
+                stmt = stmt.filter(DbCacheVars.expires > datetime.now())
+
+            res = await session.scalars(stmt)
+
+        if dbvar := res.first():
             return int(dbvar.value)
-        return False
+        else:
+            return 0
 
-    def getblock(self, blockid):
+    @test_cache
+    async def getblock(self, blockid: int | str) -> Block | None:
         """
         Get specific block from database cache.
 
         :param blockid: Block height or block hash
         :type blockid: int, str
 
         :return Block:
         """
-        if not self.cache_enabled():
-            return False
-        qr = self.session.query(DbCacheBlock)
-        if isinstance(blockid, int):
-            block = qr.filter_by(height=blockid, network_name=self.network.name).scalar()
-        else:
-            block = qr.filter_by(block_hash=to_bytes(blockid)).scalar()
+        async with self.cache.get_session() as session:
+            stmt = select(DbCacheBlock)
+
+            if isinstance(blockid, int):
+                stmt = stmt.where(height=blockid, network_name=self.network.name)
+            else:
+                stmt = stmt.where(block_hash=to_bytes(blockid))
+
+            res = await session.scalars(stmt)
+            block = res.first()
+
         if not block:
-            return False
-        b = Block(block_hash=block.block_hash, height=block.height, network=block.network_name,
-                  merkle_root=block.merkle_root, time=block.time, nonce=block.nonce,
-                  version=block.version, prev_block=block.prev_block, bits=block.bits)
+            return
+
+        b = Block(
+            block_hash=block.block_hash,
+            height=block.height,
+            network=block.network_name,
+            merkle_root=block.merkle_root,
+            time=block.time,
+            nonce=block.nonce,
+            version=block.version,
+            prev_block=block.prev_block,
+            bits=block.bits,
+        )
         b.tx_count = block.tx_count
         _logger.info("Retrieved block with height %d from cache" % b.height)
         return b
 
-    def store_blockcount(self, blockcount):
+    @test_cache
+    async def store_blockcount(self, blockcount: int | str):
         """
         Store network blockcount in cache for 60 seconds
 
         :param blockcount: Number of latest block
         :type blockcount: int, str
 
         :return:
         """
-        if not self.cache_enabled():
-            return
-        dbvar = DbCacheVars(varname='blockcount', network_name=self.network.name, value=str(blockcount), type='int',
-                            expires=datetime.now() + timedelta(seconds=60))
-        self.session.merge(dbvar)
-        self.commit()
-
-    def store_transaction(self, t, order_n=None, commit=True):
+        async with self.cache.get_session() as session:
+            dbvar = DbCacheVars(
+                varname="blockcount",
+                network_name=self.network.name,
+                value=str(blockcount),
+                type="int",
+                expires=datetime.now() + timedelta(seconds=60),
+            )
+            await session.merge(dbvar)
+            await session.commit()
+
+    @test_cache
+    async def store_transaction(
+        self, t: GenericTransaction, order_n: int | None = None
+    ):
         """
         Store transaction in cache. Use order number to determine order in a block
 
         :param t: Transaction
         :type t: Transaction
         :param order_n: Order in block
         :type order_n: int
         :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.
         :type commit: bool
 
         :return:
         """
-        if not self.cache_enabled():
-            return
         # Only store complete and confirmed transaction in cache
-        if not t.txid:    # pragma: no cover
+        if not t.txid:  # pragma: no cover
             _logger.info("Caching failure tx: Missing transaction hash")
-            return False
+            return
         elif not t.date or not t.block_height or not t.network:
-            _logger.info("Caching failure tx: Incomplete transaction missing date, block height or network info")
-            return False
+            _logger.info(
+                "Caching failure tx: Incomplete transaction missing date, block height or network info"
+            )
+            return
         elif not t.coinbase and [i for i in t.inputs if not i.value]:
             _logger.info("Caching failure tx: One the transaction inputs has value 0")
-            return False
+            return
         # TODO: Check if inputs / outputs are complete? script, value, prev_txid, sequence, output/input_n
 
         txid = bytes.fromhex(t.txid)
-        if self.session.query(DbCacheTransaction).filter_by(txid=txid).count():
-            return
-        new_tx = DbCacheTransaction(txid=txid, date=t.date, confirmations=t.confirmations,
-                                    block_height=t.block_height, network_name=t.network.name,
-                                    fee=t.fee, order_n=order_n, version=t.version_int,
-                                    locktime=t.locktime, witness_type=t.witness_type)
-        self.session.add(new_tx)
-        for i in t.inputs:
-            if i.value is None or i.address is None or i.output_n is None:    # pragma: no cover
-                _logger.info("Caching failure tx: Input value, address or output_n missing")
-                return False
-            witnesses = int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])
-            new_node = DbCacheTransactionNode(txid=txid, address=i.address, index_n=i.index_n, value=i.value,
-                                              is_input=True, ref_txid=i.prev_txid, ref_index_n=i.output_n_int,
-                                              script=i.unlocking_script, sequence=i.sequence, witnesses=witnesses)
-            self.session.add(new_node)
-        for o in t.outputs:
-            if o.value is None or o.address is None or o.output_n is None:    # pragma: no cover
-                _logger.info("Caching failure tx: Output value, address or output_n missing")
-                return False
-            new_node = DbCacheTransactionNode(
-                txid=txid, address=o.address, index_n=o.output_n, value=o.value, is_input=False, spent=o.spent,
-                ref_txid=None if not o.spending_txid else bytes.fromhex(o.spending_txid),
-                ref_index_n=o.spending_index_n, script=o.lock_script)
-            self.session.add(new_node)
 
-        if commit:
+        async with self.cache.get_session() as session:
+            res = await session.scalars(
+                select(DbCacheTransaction.txid).where(DbCacheTransaction.txid == txid)
+            )
+            found = res.first()
+
+            # breakpoint()
+            if found:
+                return
+
+            new_tx = DbCacheTransaction(
+                txid=txid,
+                date=t.date,
+                confirmations=t.confirmations,
+                block_height=t.block_height,
+                network_name=t.network.name,
+                fee=t.fee,
+                order_n=order_n,
+                version=t.version_int,
+                locktime=t.locktime,
+                witness_type=t.witness_type,
+                expiry_height=t.expiry_height,
+            )
+            session.add(new_tx)
+
+            for i in t.inputs:
+                if (
+                    i.value is None or i.address is None or i.output_n is None
+                ):  # pragma: no cover
+                    _logger.info(
+                        "Caching failure tx: Input value, address or output_n missing"
+                    )
+                    return
+
+                witnesses = int_to_varbyteint(len(i.witnesses)) + b"".join(
+                    [bytes(varstr(w)) for w in i.witnesses]
+                )
+
+                new_node = DbCacheTransactionNode(
+                    txid=txid,
+                    address=i.address,
+                    index_n=i.index_n,
+                    value=i.value,
+                    is_input=True,
+                    ref_txid=i.prev_txid,
+                    ref_index_n=i.output_n_int,
+                    script=i.unlocking_script,
+                    sequence=i.sequence,
+                    witnesses=witnesses,
+                )
+                session.add(new_node)
+
+            for o in t.outputs:
+                if (
+                    o.value is None or o.address is None or o.output_n is None
+                ):  # pragma: no cover
+                    _logger.info(
+                        "Caching failure tx: Output value, address or output_n missing"
+                    )
+                    return
+
+                new_node = DbCacheTransactionNode(
+                    txid=txid,
+                    address=o.address,
+                    index_n=o.output_n,
+                    value=o.value,
+                    is_input=False,
+                    spent=o.spent,
+                    ref_txid=None
+                    if not o.spending_txid
+                    else bytes.fromhex(o.spending_txid),
+                    ref_index_n=o.spending_index_n,
+                    script=o.lock_script,
+                )
+                session.add(new_node)
+
             try:
-                self.commit()
-                _logger.info("Added transaction %s to cache" % t.txid)
-            except Exception as e:    # pragma: no cover
-                _logger.warning("Caching failure tx: %s" % e)
+                await session.commit()
+                _logger.info(f"Added transaction {t.txid} to cache")
 
-    def store_utxo(self, txid, index_n, commit=True):
+            except IntegrityError:
+                _logger.info(
+                    f"Rolling back this transaction, already stored for tx: {txid}"
+                )
+                await session.rollback()
+
+            except Exception as e:  # pragma: no cover
+                _logger.warning(f"Caching failure tx: {e}")
+
+    @test_cache
+    async def store_utxo(self, txid: str, index_n: int):
         """
         Store utxo in cache. Updates only known transaction outputs for transactions which are fully cached
 
         :param txid: Transaction ID
         :type txid: str
         :param index_n: Index number of output
         :type index_n: int
         :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.
         :type commit: bool
 
         :return:
         """
-        if not self.cache_enabled():
-            return False
         txid = bytes.fromhex(txid)
-        result = self.session.query(DbCacheTransactionNode). \
-            filter(DbCacheTransactionNode.txid == txid, DbCacheTransactionNode.index_n == index_n,
-                   DbCacheTransactionNode.is_input == False).\
-            update({DbCacheTransactionNode.spent: False})
-        if commit:
-            try:
-                self.commit()
-            except Exception as e:    # pragma: no cover
-                _logger.warning("Caching failure utxo %s:%d: %s" % (txid.hex(), index_n, e))
 
-    def store_address(self, address, last_block=None, balance=0, n_utxos=None, txs_complete=False, last_txid=None):
-        """
-        Store address information in cache
+        async with self.cache.get_session() as session:
+            result = await session.execute(
+                update(DbCacheTransactionNode)
+                .filter(
+                    DbCacheTransactionNode.txid == txid,
+                    DbCacheTransactionNode.index_n == index_n,
+                    DbCacheTransactionNode.is_input == False,
+                )
+                .where({DbCacheTransactionNode.spent: False})
+            )
 
-        :param address: Address string
-        :type address: str
-        :param last_block: Number or last block retrieved from service provider. For instance if address contains a large number of transactions and they will be retrieved in more then one request.
-        :type last_block: int
-        :param balance: Total balance of address in sathosis, or smallest network detominator
-        :type balance: int
-        :param n_utxos: Total number of UTXO's for this address
-        :type n_utxos: int
-        :param txs_complete: True if all transactions for this address are added to cache
-        :type txs_complete: bool
-        :param last_txid: Transaction ID of last transaction downloaded from blockchain
-        :type last_txid: bytes
+            try:
+                await session.commit()
+            except Exception as e:  # pragma: no cover
+                _logger.warning(
+                    "Caching failure utxo %s:%d: %s" % (txid.hex(), index_n, e)
+                )
 
- .       :return:
+    @test_cache
+    async def store_address(
+        self,
+        address: str,
+        last_block: int | None = None,
+        balance: int = 0,
+        n_utxos: int | None = None,
+        txs_complete: bool = False,
+        last_txid: bytes | None = None,
+        last_tx_index: int | None = None,
+    ):
+        """
+               Store address information in cache
+
+               :param address: Address string
+               :type address: str
+               :param last_block: Number or last block retrieved from service provider. For instance if address contains a large number of transactions and they will be retrieved in more then one request.
+               :type last_block: int
+               :param balance: Total balance of address in sathosis, or smallest network detominator
+               :type balance: int
+               :param n_utxos: Total number of UTXO's for this address
+               :type n_utxos: int
+               :param txs_complete: True if all transactions for this address are added to cache
+               :type txs_complete: bool
+               :param last_txid: Transaction ID of last transaction downloaded from blockchain
+               :type last_txid: bytes
+
+        .       :return:
         """
-        if not self.cache_enabled():
-            return
         n_txs = None
-        if txs_complete:
-            n_txs = len(self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).
-                        filter(DbCacheTransactionNode.address == address).all())
-            if n_utxos is None:
-                n_utxos = self.session.query(DbCacheTransactionNode).\
-                    filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(False),
-                           DbCacheTransactionNode.is_input.is_(False)).count()
-                if self.session.query(DbCacheTransactionNode).\
-                        filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(None),
-                               DbCacheTransactionNode.is_input.is_(False)).count():
-                    n_utxos = None
-            if not balance:
-                plusmin = self.session.query(DbCacheTransactionNode.is_input, func.sum(DbCacheTransactionNode.value)). \
-                    filter(DbCacheTransactionNode.address == address). \
-                    group_by(DbCacheTransactionNode.is_input).all()
-                balance = 0 if not plusmin else sum([(-p[1] if p[0] else p[1]) for p in plusmin])
-        db_addr = self.getaddress(address)
-        new_address = DbCacheAddress(
-            address=address, network_name=self.network.name,
-            last_block=last_block if last_block else getattr(db_addr, 'last_block', None),
-            balance=balance if balance is not None else getattr(db_addr, 'balance', None),
-            n_utxos=n_utxos if n_utxos is not None else getattr(db_addr, 'n_utxos', None),
-            n_txs=n_txs if n_txs is not None else getattr(db_addr, 'n_txs', None),
-            last_txid=last_txid if last_txid is not None else getattr(db_addr, 'last_txid', None))
-        self.session.merge(new_address)
-        try:
-            self.commit()
-        except Exception as e:    # pragma: no cover
-            _logger.warning("Caching failure addr: %s" % e)
+        async with self.cache.get_session() as session:
+            if txs_complete:
+                res = await session.scalars(
+                    select(DbCacheTransaction)
+                    .join(DbCacheTransactionNode)
+                    .filter(DbCacheTransactionNode.address == address)
+                )
+                n_txs = len(res.all())
 
-    def store_estimated_fee(self, blocks, fee):
+                if n_utxos is None:
+                    n_utxos = await session.scalars(
+                        select(func.count(DbCacheTransactionNode.txid)).where(
+                            DbCacheTransactionNode.address == address,
+                            DbCacheTransactionNode.spent.is_(False),
+                            DbCacheTransactionNode.is_input.is_(False),
+                        )
+                    )
+                    if await session.scalars(
+                        select(func.count(DbCacheTransactionNode.txid)).where(
+                            DbCacheTransactionNode.address == address,
+                            DbCacheTransactionNode.spent.is_(None),
+                            DbCacheTransactionNode.is_input.is_(False),
+                        )
+                    ):
+                        n_utxos = None
+
+                if not balance:
+                    res = await session.execute(
+                        select(
+                            DbCacheTransactionNode.is_input,
+                            func.sum(DbCacheTransactionNode.value),
+                        )
+                        .filter(DbCacheTransactionNode.address == address)
+                        .group_by(DbCacheTransactionNode.is_input)
+                    )
+                    plusmin = res.all()
+
+                    # this could really use some explaining
+                    balance = (
+                        0
+                        if not plusmin
+                        else sum([(-p[1] if p[0] else p[1]) for p in plusmin])
+                    )
+
+            db_addr = await self.getaddress(address)
+
+            # this seems ridiculous
+            new_address = DbCacheAddress(
+                address=address,
+                network_name=self.network.name,
+                last_block=last_block
+                if last_block
+                else getattr(db_addr, "last_block", None),
+                balance=balance
+                if balance is not None
+                else getattr(db_addr, "balance", None),
+                n_utxos=n_utxos
+                if n_utxos is not None
+                else getattr(db_addr, "n_utxos", None),
+                n_txs=n_txs if n_txs is not None else getattr(db_addr, "n_txs", None),
+                last_txid=last_txid
+                if last_txid is not None
+                else getattr(db_addr, "last_txid", None),
+                last_tx_index=last_tx_index
+                if last_tx_index is not None
+                else getattr(db_addr, "last_tx_index", None),
+            )
+
+            await session.merge(new_address)
+            try:
+                await session.commit()
+            except Exception as e:  # pragma: no cover
+                _logger.warning("Caching failure addr: %s" % e)
+
+    @test_cache
+    async def store_estimated_fee(self, blocks: int, fee: int):
         """
         Store estimated fee retrieved from service providers in cache.
 
         :param blocks: Confirmation within x blocks
         :type blocks: int
         :param fee: Estimated fee in Sathosis
         :type fee: int
 
         :return:
         """
-        if not self.cache_enabled():
-            return
         if blocks <= 1:
-            varname = 'fee_high'
+            varname = "fee_high"
         elif blocks <= 5:
-            varname = 'fee_medium'
+            varname = "fee_medium"
         else:
-            varname = 'fee_low'
-        dbvar = DbCacheVars(varname=varname, network_name=self.network.name, value=str(fee), type='int',
-                            expires=datetime.now() + timedelta(seconds=600))
-        self.session.merge(dbvar)
-        self.commit()
+            varname = "fee_low"
+        dbvar = DbCacheVars(
+            varname=varname,
+            network_name=self.network.name,
+            value=str(fee),
+            type="int",
+            expires=datetime.now() + timedelta(seconds=600),
+        )
+
+        async with self.cache.get_session() as session:
+            await session.merge(dbvar)
+            await session.commit()
 
-    def store_block(self, block):
+    @test_cache
+    async def store_block(self, block: Block):
         """
         Store block in cache database
 
         :param block: Block
         :type block: Block
 
         :return:
         """
-        if not self.cache_enabled():
-            return
-        if not (block.height and block.block_hash and block.prev_block and block.merkle_root and
-                block.bits and block.version) \
-                and not block.block_hash == b'\x00\x00\x00\x00\x00\x19\xd6h\x9c\x08Z\xe1e\x83\x1e\x93O\xf7c\xaeF' \
-                                            b'\xa2\xa6\xc1r\xb3\xf1\xb6\n\x8c\xe2o':  # Bitcoin genesis block
+
+        # this genesis block thing seems fucked
+        if (
+            not (
+                block.height
+                and block.block_hash
+                and block.prev_block
+                and block.merkle_root
+                and block.bits
+                and block.version
+            )
+            and not block.block_hash
+            == b"\x00\x00\x00\x00\x00\x19\xd6h\x9c\x08Z\xe1e\x83\x1e\x93O\xf7c\xaeF"
+            b"\xa2\xa6\xc1r\xb3\xf1\xb6\n\x8c\xe2o"
+        ):  # Bitcoin genesis block
             _logger.info("Caching failure block: incomplete data")
             return
 
         new_block = DbCacheBlock(
-            block_hash=block.block_hash, height=block.height, network_name=self.network.name,
-            version=block.version_int, prev_block=block.prev_block, bits=block.bits_int,
-            merkle_root=block.merkle_root, nonce=block.nonce_int, time=block.time, tx_count=block.tx_count)
-        self.session.merge(new_block)
-        try:
-            self.commit()
-        except Exception as e:    # pragma: no cover
-            _logger.warning("Caching failure block: %s" % e)
+            block_hash=block.block_hash,
+            height=block.height,
+            network_name=self.network.name,
+            version=block.version_int,
+            prev_block=block.prev_block,
+            bits=block.bits_int,
+            merkle_root=block.merkle_root,
+            nonce=block.nonce_int,
+            time=block.time,
+            tx_count=block.tx_count,
+        )
+        async with self.cache.get_session() as session:
+            await session.merge(new_block)
+
+            try:
+                await session.commit()
+            except Exception as e:  # pragma: no cover
+                _logger.warning("Caching failure block: %s" % e)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/tools/__init__.py` & `fluxwallet-0.1.0/fluxwallet/tools/__init__.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/tools/mnemonic_key_create.py` & `fluxwallet-0.1.0/fluxwallet/tools/mnemonic_key_create.py`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/tools/sign_raw.py` & `fluxwallet-0.1.0/fluxwallet/tools/sign_raw.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,17 +9,17 @@
 
 from pprint import pprint
 
 from fluxwallet.keys import HDKey
 from fluxwallet.mnemonic import Mnemonic
 from fluxwallet.services.services import Service
 from fluxwallet.transactions import Transaction
-from fluxwallet.wallets import wallet_create_or_open, wallet_delete_if_exists
+from fluxwallet.wallet import wallet_create_or_open, wallet_delete_if_exists
 
-network = 'testnet'
+network = "testnet"
 # # Example wallet
 # phrase1 = 'meadow bag inquiry eyebrow exotic onion skill clerk dish hunt caught road'
 # phrase2 = 'east amount soap pause erosion invite mom finger oak still vast bacon'
 # password2 = 'test'
 # k2 = HDKey.from_passphrase(phrase2, network=network, password=password2, key_type='single').public()
 # # wallet_delete_if_exists('Sign_raw_testwallet', force=True)
 # w = wallet_create_or_open('Sign_raw_testwallet', [phrase1, k2], network=network, cosigner_id=0)
@@ -27,15 +27,15 @@
 # w.utxos_update()
 # w.info()
 # t = w.sweep(w.new_key().address, 10000, fee=1000)
 # raw_tx = t.raw_hex()
 # t.info()
 
 # Raw partially signed transaction transaction
-raw_tx = ''
+raw_tx = ""
 if not raw_tx:
     raw_tx = input("Paste raw transaction hex: ")
 
 t = Transaction.import_raw(raw_tx)
 
 key_str = input("Enter private key or mnemonic passphrase: ")
 if len(key_str.split(" ")) < 2:
@@ -47,11 +47,11 @@
 
 t.sign(hdkey)
 t.info()
 
 print("Raw signed transaction: ")
 print(t.raw_hex())
 
-if input("Try to send transaction [y/n] ") in ['y', 'Y']:
+if input("Try to send transaction [y/n] ") in ["y", "Y"]:
     srv = Service(network=network)
     res = srv.sendrawtransaction(t.raw())
     pprint(res)
```

### Comparing `fluxwallet-0.0.6/fluxwallet/tools/wallet_multisig_2of3.py` & `fluxwallet-0.1.0/fluxwallet/tools/wallet_multisig_2of3.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,111 +13,139 @@
 
 from __future__ import print_function
 
 from pprint import pprint
 
 from fluxwallet.keys import HDKey
 from fluxwallet.mnemonic import Mnemonic
-from fluxwallet.wallets import Wallet, wallet_exists
+from fluxwallet.wallet import Wallet, wallet_exists
 
 WALLET_NAME = "Multisig-2of3"
-NETWORK = 'testnet'
+NETWORK = "testnet"
 KEY_STRENGTH = 128  # Remove this line to use the default 256 bit key strength
 SIGNATURES_REQUIRED = 2
-WITNESS_TYPE = 'segwit'  # Witness type can be legacy, p2sh-segwit or segwit
+WITNESS_TYPE = "segwit"  # Witness type can be legacy, p2sh-segwit or segwit
 
 # from fluxwallet.wallets import wallet_delete_if_exists
 # wallet_delete_if_exists(WALLET_NAME, force=True)
 
 if not wallet_exists(WALLET_NAME):
     # Define cosigners, format (name, key_type, [password], wallet)
     cosigners = [
-        ('Offline PC', 'bip32', 'password'),
-        ('Online PC', 'bip32', ''),
-        ('Paper backup', 'single', ''),
+        ("Offline PC", "bip32", "password"),
+        ("Online PC", "bip32", ""),
+        ("Paper backup", "single", ""),
     ]
 
-    print("We will generate 3 private keys, to sign and send a transaction 2 keys are needed:"
-          "\n- With 1 private key a wallet on this Offline PC is created"
-          "\n- Use private key 2 to create a wallet on the Online PC"
-          "\n- Store key 3 on a Paper in a safe in case one of the PC's is not available anymore"
-          )
+    print(
+        "We will generate 3 private keys, to sign and send a transaction 2 keys are needed:"
+        "\n- With 1 private key a wallet on this Offline PC is created"
+        "\n- Use private key 2 to create a wallet on the Online PC"
+        "\n- Store key 3 on a Paper in a safe in case one of the PC's is not available anymore"
+    )
     key_lists = {}
     w_id = 0
     for cosigner in cosigners:
         print("\n")
         words = Mnemonic().generate(KEY_STRENGTH)
-        password = ''
-        if cosigner[2] == 'password':
+        password = ""
+        if cosigner[2] == "password":
             password = input("Please give password for cosigner '%s': " % cosigner[0])
         seed = Mnemonic().to_seed(words, password)
-        hdkey = HDKey.from_seed(seed, network=NETWORK, key_type=cosigner[1], witness_type=WITNESS_TYPE)
-        if cosigner[1] == 'bip32':
+        hdkey = HDKey.from_seed(
+            seed, network=NETWORK, key_type=cosigner[1], witness_type=WITNESS_TYPE
+        )
+        if cosigner[1] == "bip32":
             public_account = hdkey.public_master_multisig(witness_type=WITNESS_TYPE)
         else:
             public_account = hdkey
-        print("Key for cosigner '%s' generated. Please store both passphrase and password carefully!" % cosigner[0])
+        print(
+            "Key for cosigner '%s' generated. Please store both passphrase and password carefully!"
+            % cosigner[0]
+        )
         print("Passphrase: %s" % words)
-        print("Password: %s" % ('*' * len(password)))
+        print("Password: %s" % ("*" * len(password)))
         print("Share this public key below with other cosigner")
         print("Public key: %s" % public_account.wif_public())
 
         for w in cosigners:
             if cosigner[0] == w[0]:
                 addkey = hdkey
             else:
                 addkey = public_account.public()
             if w[0] not in key_lists:
                 key_lists[w[0]] = []
             if addkey not in key_lists[w[0]]:
                 key_lists[w[0]].append(addkey)
 
-    offline_wallet = Wallet.create(WALLET_NAME, key_lists['Offline PC'], sigs_required=SIGNATURES_REQUIRED,
-                                     witness_type=WITNESS_TYPE, network=NETWORK)
+    offline_wallet = Wallet.create(
+        WALLET_NAME,
+        key_lists["Offline PC"],
+        sigs_required=SIGNATURES_REQUIRED,
+        witness_type=WITNESS_TYPE,
+        network=NETWORK,
+    )
     offline_wallet.new_key()
 
     print("\n\nA multisig wallet has been created on this system")
     offline_wallet.info()
 
     print("\n---> Please create a wallet on your Online PC like this:")
     print("from fluxwallet.wallets import Wallet")
     print("from fluxwallet.keys import HDKey")
     print("")
     print("key_list = [")
-    for key in key_lists['Online PC']:
-        if key.key_type == 'single':
-            print("     HDKey('%s', key_type='single', witness_type='%s')" % (key.wif_private(), WITNESS_TYPE))
+    for key in key_lists["Online PC"]:
+        if key.key_type == "single":
+            print(
+                "     HDKey('%s', key_type='single', witness_type='%s')"
+                % (key.wif_private(), WITNESS_TYPE)
+            )
         else:
             print("     '%s'," % key.wif_private())
     print("]")
-    print("wlt = Wallet.create('%s', key_list, sigs_required=2, witness_type='%s', network='%s')" %
-          (WALLET_NAME, WITNESS_TYPE, NETWORK))
+    print(
+        "wlt = Wallet.create('%s', key_list, sigs_required=2, witness_type='%s', network='%s')"
+        % (WALLET_NAME, WITNESS_TYPE, NETWORK)
+    )
     print("wlt.get_key()")
     print("wlt.info()")
 else:
-    from fluxwallet.config.config import FW_DATABASE_DIR, FLUXWALLET_VERSION
-    online_wallet = Wallet(WALLET_NAME, db_uri=FW_DATABASE_DIR + '/fluxwallet.tmp.sqlite')
+    from fluxwallet.config.config import FLUXWALLET_VERSION, FW_DATABASE_DIR
+
+    online_wallet = Wallet(
+        WALLET_NAME, db_uri=FW_DATABASE_DIR + "/fluxwallet.tmp.sqlite"
+    )
     online_wallet.utxos_update()
     online_wallet.info()
     utxos = online_wallet.utxos()
     if utxos:
         print("\nNew unspent outputs found!")
-        print("Now a new transaction will be created to sweep this wallet and send bitcoins to a testnet faucet")
-        send_to_address = 'n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi'
+        print(
+            "Now a new transaction will be created to sweep this wallet and send bitcoins to a testnet faucet"
+        )
+        send_to_address = "n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi"
         t = online_wallet.sweep(send_to_address, min_confirms=0)
         print(t.raw_hex())
-        print("Now copy-and-paste the raw transaction hex to your Offline PC and sign it there with a second signature:")
+        print(
+            "Now copy-and-paste the raw transaction hex to your Offline PC and sign it there with a second signature:"
+        )
         print("\nfrom fluxwallet.wallets import Wallet")
         print("")
         print("wlt = Wallet('%s')" % WALLET_NAME)
-        print("utxos = ", end='')
+        print("utxos = ", end="")
         pprint(utxos)
         print("")
         print("wlt.utxos_update(utxos=utxos)")
         print("t = wlt.transaction_import_raw('%s')" % t.raw_hex())
         print("t.sign()")
         print("")
-        print("# Push the following raw transaction to the blockchain network on any online PC:")
+        print(
+            "# Push the following raw transaction to the blockchain network on any online PC:"
+        )
         print("print(t.raw_hex())")
     else:
-        print("\nPlease send funds to %s, so we can create a transaction" % online_wallet.get_key().address)
+        print(
+            "\nPlease send funds to %s, so we can create a transaction"
+            % online_wallet.get_key().address
+        )
         print("\nRestart this program when funds are send...")
```

### Comparing `fluxwallet-0.0.6/fluxwallet/transactions.py` & `fluxwallet-0.1.0/fluxwallet/transactions.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,66 +13,67 @@
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #    GNU Affero General Public License for more details.
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
+from __future__ import annotations
+
+import asyncio
+import inspect
 import json
 import pickle
 import random
+import time
+from abc import ABC, abstractmethod
 from datetime import datetime
 from io import BytesIO
+from typing import TYPE_CHECKING
 
 from fluxwallet.config.opcodes import *
 from fluxwallet.encoding import *
-from fluxwallet.keys import (Address, HDKey, Key, Signature,
-                             deserialize_address, sign, verify)
+from fluxwallet.flux_transaction import OutPoint, SaplingTx
+from fluxwallet.flux_transaction import Script as FluxScript
+from fluxwallet.flux_transaction import TxIn, TxOut
+from fluxwallet.keys import (
+    Address,
+    HDKey,
+    Key,
+    Signature,
+    deserialize_address,
+    sign,
+    verify,
+)
 from fluxwallet.networks import Network
 from fluxwallet.scripts import Script
 from fluxwallet.values import Value, value_to_satoshi
 
-from fluxwallet.flux_transaction import TxIn, TxOut, OutPoint, SaplingTx, Script as FluxScript
-
-from abc import ABC, abstractmethod
+if TYPE_CHECKING:
+    from fluxwallet.wallet import GenericTransaction
 
 _logger = logging.getLogger(__name__)
 
 
 class TransactionError(Exception):
     """
     Handle Transaction class Exceptions
     """
 
-    def __init__(self, msg=''):
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.error(msg)
 
     def __str__(self):
         return self.msg
 
 
-@deprecated  # Replaced by Script class in version 0.6
-def script_add_locktime_cltv(locktime_cltv, script):  # pragma: no cover
-    lockbytes = bytes([op.op_checklocktimeverify, op.op_drop])
-    if script and len(script) > 6:
-        if script[4:6] == lockbytes:
-            return script
-    return varstr(locktime_cltv.to_bytes(4, 'little')) + lockbytes + script
-
-
-@deprecated  # Replaced by Script class in version 0.6
-def script_add_locktime_csv(locktime_csv, script):  # pragma: no cover
-    lockbytes = bytes([op.op_checklocktimeverify, op.op_drop])
-    if script and len(script) > 6:
-        if script[4:6] == lockbytes:
-            return script
-    return varstr(locktime_csv.to_bytes(4, 'little')) + lockbytes + script
-
-def get_unlocking_script_type(locking_script_type, witness_type='legacy', multisig=False):
+def get_unlocking_script_type(
+    locking_script_type, witness_type="legacy", multisig=False
+):
     """
     Specify locking script type and get corresponding script type for unlocking script
 
     >>> get_unlocking_script_type('p2wsh')
     'p2sh_multisig'
 
     :param locking_script_type: Locking script type. I.e.: p2pkh, p2sh, p2wpkh, p2wsh
@@ -81,30 +82,32 @@
     :type witness_type: str
     :param multisig: Is multisig script or not? Default is False
     :type multisig: bool
 
     :return str: Unlocking script type such as sig_pubkey or p2sh_multisig
     """
 
-    if locking_script_type in ['p2pkh', 'p2wpkh']:
-        return 'sig_pubkey'
-    elif locking_script_type == 'p2wsh' or (witness_type == 'legacy' and multisig):
-        return 'p2sh_multisig'
-    elif locking_script_type == 'p2sh':
+    if locking_script_type in ["p2pkh", "p2wpkh"]:
+        return "sig_pubkey"
+    elif locking_script_type == "p2wsh" or (witness_type == "legacy" and multisig):
+        return "p2sh_multisig"
+    elif locking_script_type == "p2sh":
         if not multisig:
-            return 'sig_pubkey'
+            return "sig_pubkey"
         else:
-            return 'p2sh_multisig'
-    elif locking_script_type == 'p2pk':
-        return 'signature'
+            return "p2sh_multisig"
+    elif locking_script_type == "p2pk":
+        return "signature"
     else:
         raise TransactionError("Unknown locking script type %s" % locking_script_type)
 
 
-def transaction_update_spents(txs, address):
+def transaction_update_spents(
+    txs: list[GenericTransaction], address: str
+) -> list[GenericTransaction]:
     """
     Update spent information for list of transactions for a specific address. This method assumes the list of
     transaction complete and up-to-date.
 
     This method loops through all the transaction and update all transaction outputs for given address, checks
     if the output is spent and add the spending transaction ID and index number to the outputs.
 
@@ -113,51 +116,82 @@
     :param txs: Complete list of transactions for given address
     :type txs: list of Transaction
     :param address: Address string
     :type address: str
 
     :return list of Transaction:
     """
-    spend_list = {}
+    spend_list: dict[tuple, GenericTransaction] = {}
     for t in txs:
         for inp in t.inputs:
             if inp.address == address:
                 spend_list.update({(inp.prev_txid.hex(), inp.output_n_int): t})
+
     address_inputs = list(spend_list.keys())
     for t in txs:
         for to in t.outputs:
             if to.address != address:
                 continue
+
             spent = True if (t.txid, to.output_n) in address_inputs else False
             txs[txs.index(t)].outputs[to.output_n].spent = spent
+
             if spent:
                 spending_tx = spend_list[(t.txid, to.output_n)]
-                spending_index_n = \
-                    [inp for inp in txs[txs.index(spending_tx)].inputs
-                     if inp.prev_txid.hex() == t.txid and inp.output_n_int == to.output_n][0].index_n
+                spending_index_n = [
+                    inp
+                    for inp in txs[txs.index(spending_tx)].inputs
+                    if inp.prev_txid.hex() == t.txid and inp.output_n_int == to.output_n
+                ][0].index_n
+
                 txs[txs.index(t)].outputs[to.output_n].spending_txid = spending_tx.txid
-                txs[txs.index(t)].outputs[to.output_n].spending_index_n = spending_index_n
+                txs[txs.index(t)].outputs[
+                    to.output_n
+                ].spending_index_n = spending_index_n
     return txs
 
 
-class Input(object):
+class Input:
     """
     Transaction Input class, used by Transaction class
 
     An Input contains a reference to an UTXO or Unspent Transaction Output (prev_txid + output_n).
     To spend the UTXO an unlocking script can be included to prove ownership.
 
     Inputs are verified by the Transaction class.
     """
 
-    def __init__(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',
-                 unlocking_script_unsigned=None, script=None, script_type=None, address='',
-                 sequence=0xffffffff, compressed=None, sigs_required=None, sort=False, index_n=0,
-                 value=0, double_spend=False, locktime_cltv=None, locktime_csv=None, key_path='', witness_type=None,
-                 witnesses=None, encoding=None, strict=True, network=DEFAULT_NETWORK):
+    def __init__(
+        self,
+        prev_txid,
+        output_n,
+        keys=None,
+        signatures=None,
+        public_hash=b"",
+        unlocking_script=b"",
+        unlocking_script_unsigned=None,
+        script=None,
+        script_type=None,
+        address="",
+        sequence=0xFFFFFFFF,
+        compressed=None,
+        sigs_required=None,
+        sort=False,
+        index_n=0,
+        value=0,
+        double_spend=False,
+        locktime_cltv=None,
+        locktime_csv=None,
+        key_path="",
+        witness_type=None,
+        witnesses=None,
+        encoding=None,
+        strict=True,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create a new transaction input
 
         :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.
         :type prev_txid: bytes, str
         :param output_n: Output number in previous transaction.
         :type output_n: bytes, int
@@ -207,27 +241,32 @@
         :type network: str, Network
         """
 
         self.prev_txid = to_bytes(prev_txid)
         self.output_n = output_n
         if isinstance(output_n, int):
             self.output_n_int = output_n
-            self.output_n = output_n.to_bytes(4, 'big')
+            self.output_n = output_n.to_bytes(4, "big")
         else:
-            self.output_n_int = int.from_bytes(output_n, 'big')
+            self.output_n_int = int.from_bytes(output_n, "big")
             self.output_n = output_n
-        self.unlocking_script = b'' if unlocking_script is None else to_bytes(unlocking_script)
-        self.unlocking_script_unsigned = b'' if unlocking_script_unsigned is None \
+        self.unlocking_script = (
+            b"" if unlocking_script is None else to_bytes(unlocking_script)
+        )
+        self.unlocking_script_unsigned = (
+            b""
+            if unlocking_script_unsigned is None
             else to_bytes(unlocking_script_unsigned)
+        )
         self.script = None
         self.hash_type = SIGHASH_ALL
         if isinstance(sequence, numbers.Number):
             self.sequence = sequence
         else:
-            self.sequence = int.from_bytes(sequence, 'little')
+            self.sequence = int.from_bytes(sequence, "little")
         self.compressed = compressed
         self.network = network
         if not isinstance(network, Network):
             self.network = Network(network)
         self.index_n = index_n
         self.value = value_to_satoshi(value, network=network)
         if not keys:
@@ -244,87 +283,104 @@
         if isinstance(address, Address):
             self.address = address.address
             self.encoding = address.encoding
             self.network = address.network
         else:
             self.address = address
         self.signatures = []
-        self.redeemscript = b''
+        self.redeemscript = b""
         self.script_type = script_type
-        if self.prev_txid == b'\0' * 32:
-            self.script_type = 'coinbase'
+        if self.prev_txid == b"\0" * 32:
+            self.script_type = "coinbase"
         self.double_spend = double_spend
         self.locktime_cltv = locktime_cltv
         self.locktime_csv = locktime_csv
         self.witness_type = witness_type
         if encoding is None:
-            self.encoding = 'base58'
-            if self.witness_type == 'segwit':
-                self.encoding = 'bech32'
+            self.encoding = "base58"
+            if self.witness_type == "segwit":
+                self.encoding = "bech32"
         else:
             self.encoding = encoding
         self.valid = None
         self.key_path = key_path
 
         self.witnesses = []
         if isinstance(witnesses, bytes):
             n_items, cursor = varbyteint_to_int(witnesses[0:9])
             for m in range(0, n_items):
-                witness = b'\0'
-                item_size, size = varbyteint_to_int(witnesses[cursor:cursor + 9])
+                witness = b"\0"
+                item_size, size = varbyteint_to_int(witnesses[cursor : cursor + 9])
                 if item_size:
-                    witness = witnesses[cursor + size:cursor + item_size + size]
+                    witness = witnesses[cursor + size : cursor + item_size + size]
                 cursor += item_size + size
                 self.witnesses.append(witness)
         elif witnesses:
-            self.witnesses = [bytes.fromhex(w) if isinstance(w, str) else w for w in witnesses]
-        self.script_code = b''
+            self.witnesses = [
+                bytes.fromhex(w) if isinstance(w, str) else w for w in witnesses
+            ]
+        self.script_code = b""
         self.script = script
 
         # If unlocking script is specified extract keys, signatures, type from script
-        if self.unlocking_script and self.script_type != 'coinbase' and not (signatures and keys) and not script:
+        if (
+            self.unlocking_script
+            and self.script_type != "coinbase"
+            and not (signatures and keys)
+            and not script
+        ):
             self.script = Script.parse_bytes(self.unlocking_script, strict=strict)
             self.keys = self.script.keys
             self.signatures = self.script.signatures
             if len(self.signatures):
                 self.hash_type = self.signatures[0].hash_type
             sigs_required = self.script.sigs_required
-            self.redeemscript = self.script.redeemscript if self.script.redeemscript else self.redeemscript
+            self.redeemscript = (
+                self.script.redeemscript
+                if self.script.redeemscript
+                else self.redeemscript
+            )
             if len(self.script.script_types) == 1 and not self.script_type:
                 self.script_type = self.script.script_types[0]
-            elif self.script.script_types == ['signature_multisig', 'multisig']:
-                self.script_type = 'p2sh_multisig'
+            elif self.script.script_types == ["signature_multisig", "multisig"]:
+                self.script_type = "p2sh_multisig"
             # TODO: Check if this if is necessary
-            if 'p2wpkh' in self.script.script_types:
-                self.script_type = 'p2sh_p2wpkh'
-                self.witness_type = 'p2sh-segwit'
-            elif 'p2wsh' in self.script.script_types:
-                self.script_type = 'p2sh_p2wsh'
-                self.witness_type = 'p2sh-segwit'
+            if "p2wpkh" in self.script.script_types:
+                self.script_type = "p2sh_p2wpkh"
+                self.witness_type = "p2sh-segwit"
+            elif "p2wsh" in self.script.script_types:
+                self.script_type = "p2sh_p2wsh"
+                self.witness_type = "p2sh-segwit"
         if self.unlocking_script_unsigned and not self.signatures:
             ls = Script.parse_bytes(self.unlocking_script_unsigned, strict=strict)
-            self.public_hash = self.public_hash if not ls.public_hash else ls.public_hash
-            if ls.script_types[0] in ['p2wpkh', 'p2wsh']:
-                self.witness_type = 'segwit'
+            self.public_hash = (
+                self.public_hash if not ls.public_hash else ls.public_hash
+            )
+            if ls.script_types[0] in ["p2wpkh", "p2wsh"]:
+                self.witness_type = "segwit"
         self.sigs_required = sigs_required if sigs_required else 1
 
         if self.script_type is None and self.witness_type is None and self.witnesses:
-            self.witness_type = 'segwit'
-        if self.witness_type is None or self.witness_type == 'legacy':
+            self.witness_type = "segwit"
+        if self.witness_type is None or self.witness_type == "legacy":
             # if self.script_type in ['p2wpkh', 'p2wsh', 'p2sh_p2wpkh', 'p2sh_p2wsh']:
-            if self.script_type in ['p2wpkh', 'p2wsh']:
-                self.witness_type = 'segwit'
-            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:
-                self.witness_type = 'p2sh-segwit'
+            if self.script_type in ["p2wpkh", "p2wsh"]:
+                self.witness_type = "segwit"
+            elif self.script_type in ["p2sh_p2wpkh", "p2sh_p2wsh"]:
+                self.witness_type = "p2sh-segwit"
             else:
-                self.witness_type = 'legacy'
-        elif self.witness_type == 'segwit' and self.script_type == 'sig_pubkey' and encoding is None:
-            self.encoding = 'bech32'
+                self.witness_type = "legacy"
+        elif (
+            self.witness_type == "segwit"
+            and self.script_type == "sig_pubkey"
+            and encoding is None
+        ):
+            self.encoding = "bech32"
         if not self.script_type:
-            self.script_type = 'sig_pubkey'
+            self.script_type = "sig_pubkey"
 
         for key in keys:
             if not isinstance(key, Key):
                 kobj = Key(key, network=network, strict=strict)
             else:
                 kobj = key
             if kobj not in self.keys:
@@ -340,33 +396,45 @@
         self.strict = strict
 
         for sig in signatures:
             if not isinstance(sig, Signature):
                 try:
                     sig = Signature.parse(sig)
                 except Exception as e:
-                    _logger.error("Could not parse signature %s in Input. Error: %s" % (to_hexstring(sig), e))
+                    _logger.error(
+                        "Could not parse signature %s in Input. Error: %s"
+                        % (to_hexstring(sig), e)
+                    )
                     continue
-            if sig.as_der_encoded() not in [x.as_der_encoded() for x in self.signatures]:
+            if sig.as_der_encoded() not in [
+                x.as_der_encoded() for x in self.signatures
+            ]:
                 self.signatures.append(sig)
                 if sig.hash_type:
                     self.hash_type = sig.hash_type
 
         # fixme: p2wpkh == p2sh_p2wpkh
-        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh'] and self.witnesses and not self.signatures and \
-                self.script_type in ['sig_pubkey', 'p2sh_p2wpkh'] and len(self.witnesses) == 2 and \
-                b'\0' not in self.witnesses:
+        if (
+            self.script_type in ["sig_pubkey", "p2sh_p2wpkh", "p2wpkh"]
+            and self.witnesses
+            and not self.signatures
+            and self.script_type in ["sig_pubkey", "p2sh_p2wpkh"]
+            and len(self.witnesses) == 2
+            and b"\0" not in self.witnesses
+        ):
             self.signatures = [Signature.parse_bytes(self.witnesses[0])]
             self.hash_type = self.signatures[0].hash_type
             self.keys = [Key(self.witnesses[1], network=self.network)]
 
         self.update_scripts(hash_type=self.hash_type)
 
     @classmethod
-    def parse(cls, raw, witness_type='segwit', index_n=0, strict=True, network=DEFAULT_NETWORK):
+    def parse(
+        cls, raw, witness_type="segwit", index_n=0, strict=True, network=DEFAULT_NETWORK
+    ):
         """
         Parse raw BytesIO string and return Input object
 
         :param raw: Input
         :type raw: BytesIO
         :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Derived from script if not specified.
         :type witness_type: str
@@ -377,165 +445,213 @@
         :param network: Network, leave empty for default
         :type network: str, Network
 
         :return Input:
         """
         prev_hash = raw.read(32)[::-1]
         if len(prev_hash) != 32:
-            raise TransactionError("Input transaction hash not found. Probably malformed raw transaction")
+            raise TransactionError(
+                "Input transaction hash not found. Probably malformed raw transaction"
+            )
         output_n = raw.read(4)[::-1]
         unlocking_script_size = read_varbyteint(raw)
         unlocking_script = raw.read(unlocking_script_size)
         # TODO - handle non-standard input script b'\1\0',
         #  see tx 38cf5779d1c5ca32b79cd5052b54e824102e878f041607d3b962038f5a8cf1ed
         # if unlocking_script_size == 1 and unlocking_script == b'\0':
 
-        inp_type = 'legacy'
-        if witness_type == 'segwit' and not unlocking_script_size:
-            inp_type = 'segwit'
+        inp_type = "legacy"
+        if witness_type == "segwit" and not unlocking_script_size:
+            inp_type = "segwit"
         sequence_number = raw.read(4)
 
-        return Input(prev_txid=prev_hash, output_n=output_n, unlocking_script=unlocking_script,
-                     witness_type=inp_type, sequence=sequence_number, index_n=index_n, strict=strict, network=network)
+        return Input(
+            prev_txid=prev_hash,
+            output_n=output_n,
+            unlocking_script=unlocking_script,
+            witness_type=inp_type,
+            sequence=sequence_number,
+            index_n=index_n,
+            strict=strict,
+            network=network,
+        )
 
     def update_scripts(self, hash_type=SIGHASH_ALL):
         """
         Method to update Input scripts.
 
         Creates or updates unlocking script, witness script for segwit inputs, multisig redeemscripts and
         locktime scripts. This method is called when initializing an Input class or when signing an input.
 
         :param hash_type: Specific hash type, default is SIGHASH_ALL
         :type hash_type: int
 
         :return bool: Always returns True when method is completed
         """
 
-        addr_data = b''
-        unlock_script = b''
-        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh']:  # fixme: p2wpkh == p2sh_p2wpkh
+        addr_data = b""
+        unlock_script = b""
+        if self.script_type in [
+            "sig_pubkey",
+            "p2sh_p2wpkh",
+            "p2wpkh",
+        ]:  # fixme: p2wpkh == p2sh_p2wpkh
             if not self.public_hash and self.keys:
                 self.public_hash = self.keys[0].hash160
             if not self.keys and not self.public_hash:
                 return
-            self.script_code = b'\x76\xa9\x14' + self.public_hash + b'\x88\xac'
+            self.script_code = b"\x76\xa9\x14" + self.public_hash + b"\x88\xac"
             self.unlocking_script_unsigned = self.script_code
             addr_data = self.public_hash
             if self.signatures and self.keys:
-                self.witnesses = [self.signatures[0].as_der_encoded() if hash_type else b'', self.keys[0].public_byte]
-                unlock_script = b''.join([bytes(varstr(w)) for w in self.witnesses])
+                self.witnesses = [
+                    self.signatures[0].as_der_encoded() if hash_type else b"",
+                    self.keys[0].public_byte,
+                ]
+                unlock_script = b"".join([bytes(varstr(w)) for w in self.witnesses])
             if not self.unlocking_script or self.strict:
-                if self.witness_type == 'p2sh-segwit':
-                    self.unlocking_script = varstr(b'\0' + varstr(self.public_hash))
-                elif self.witness_type == 'segwit':
-                    self.unlocking_script = b''
-                elif unlock_script != b'':
+                if self.witness_type == "p2sh-segwit":
+                    self.unlocking_script = varstr(b"\0" + varstr(self.public_hash))
+                elif self.witness_type == "segwit":
+                    self.unlocking_script = b""
+                elif unlock_script != b"":
                     self.unlocking_script = unlock_script
-        elif self.script_type in ['p2sh_multisig', 'p2sh_p2wsh', 'p2wsh']:  # fixme: p2sh_p2wsh == p2wsh
+        elif self.script_type in [
+            "p2sh_multisig",
+            "p2sh_p2wsh",
+            "p2wsh",
+        ]:  # fixme: p2sh_p2wsh == p2wsh
             if not self.redeemscript and self.keys:
-                self.redeemscript = Script(script_types=['multisig'], keys=self.keys,
-                                           sigs_required=self.sigs_required).serialize()
+                self.redeemscript = Script(
+                    script_types=["multisig"],
+                    keys=self.keys,
+                    sigs_required=self.sigs_required,
+                ).serialize()
             if self.redeemscript:
-                if self.witness_type == 'segwit' or self.witness_type == 'p2sh-segwit':
+                if self.witness_type == "segwit" or self.witness_type == "p2sh-segwit":
                     self.public_hash = hashlib.sha256(self.redeemscript).digest()
                 else:
                     self.public_hash = hash160(self.redeemscript)
             addr_data = self.public_hash
             self.unlocking_script_unsigned = self.redeemscript
 
             if self.redeemscript and self.keys:
                 n_tag = self.redeemscript[0:1]
                 if not isinstance(n_tag, int):
-                    n_tag = int.from_bytes(n_tag, 'big')
+                    n_tag = int.from_bytes(n_tag, "big")
                 self.sigs_required = n_tag - 80
-                signatures = [s.as_der_encoded() for s in self.signatures[:self.sigs_required]]
-                if b'' in signatures:
-                    raise TransactionError("Empty signature found in signature list when signing. "
-                                           "Is DER encoded version of signature defined?")
-                if len(signatures) == self.sigs_required:  # and not self.unlocking_script
-                    unlock_script_obj = Script(script_types=['p2sh_multisig'], keys=[k.public_byte for k in self.keys],
-                                               signatures=self.signatures[:self.sigs_required],
-                                               sigs_required=self.sigs_required, redeemscript=self.redeemscript)
-                    if self.witness_type in ['segwit', 'p2sh-segwit']:
+                signatures = [
+                    s.as_der_encoded() for s in self.signatures[: self.sigs_required]
+                ]
+                if b"" in signatures:
+                    raise TransactionError(
+                        "Empty signature found in signature list when signing. "
+                        "Is DER encoded version of signature defined?"
+                    )
+                if (
+                    len(signatures) == self.sigs_required
+                ):  # and not self.unlocking_script
+                    unlock_script_obj = Script(
+                        script_types=["p2sh_multisig"],
+                        keys=[k.public_byte for k in self.keys],
+                        signatures=self.signatures[: self.sigs_required],
+                        sigs_required=self.sigs_required,
+                        redeemscript=self.redeemscript,
+                    )
+                    if self.witness_type in ["segwit", "p2sh-segwit"]:
                         unlock_script = unlock_script_obj.serialize_list()
                     else:
                         unlock_script = unlock_script_obj.serialize()
-                if self.witness_type == 'segwit':
-                    script_code = b''
+                if self.witness_type == "segwit":
+                    script_code = b""
                     for k in self.keys:
-                        script_code += varstr(k.public_byte) + b'\xad\xab'
+                        script_code += varstr(k.public_byte) + b"\xad\xab"
                     if len(script_code) > 3:
-                        script_code = script_code[:-2] + b'\xac'
+                        script_code = script_code[:-2] + b"\xac"
                     self.script_code = script_code
                     if signatures:
                         self.witnesses = unlock_script
-                elif self.witness_type == 'p2sh-segwit':
-                    self.unlocking_script = varstr(b'\0' + varstr(self.public_hash))
+                elif self.witness_type == "p2sh-segwit":
+                    self.unlocking_script = varstr(b"\0" + varstr(self.public_hash))
                     self.script_code = self.unlocking_script
                     if signatures:
                         self.witnesses = unlock_script
-                elif unlock_script != b'' and self.strict:
+                elif unlock_script != b"" and self.strict:
                     self.unlocking_script = unlock_script
-        elif self.script_type == 'signature':
+        elif self.script_type == "signature":
             if self.keys:
-                self.script_code = varstr(self.keys[0].public_byte) + b'\xac'
+                self.script_code = varstr(self.keys[0].public_byte) + b"\xac"
                 self.unlocking_script_unsigned = self.script_code
                 addr_data = self.keys[0].public_byte
             if self.signatures and not self.unlocking_script:
                 self.unlocking_script = varstr(self.signatures[0].as_der_encoded())
-        elif self.script_type not in ['coinbase', 'unknown'] and self.strict:
-            raise TransactionError("Unknown unlocking script type %s for input %d" % (self.script_type, self.index_n))
+        elif self.script_type not in ["coinbase", "unknown"] and self.strict:
+            raise TransactionError(
+                "Unknown unlocking script type %s for input %d"
+                % (self.script_type, self.index_n)
+            )
         if addr_data and not self.address:
-            self.address = Address(hashed_data=addr_data, encoding=self.encoding, network=self.network,
-                                   script_type=self.script_type, witness_type=self.witness_type).address
+            self.address = Address(
+                hashed_data=addr_data,
+                encoding=self.encoding,
+                network=self.network,
+                script_type=self.script_type,
+                witness_type=self.witness_type,
+            ).address
 
         if self.locktime_cltv:
-            self.unlocking_script_unsigned = script_add_locktime_cltv(self.locktime_cltv,
-                                                                      self.unlocking_script_unsigned)
-            self.unlocking_script = script_add_locktime_cltv(self.locktime_cltv, self.unlocking_script)
+            self.unlocking_script_unsigned = script_add_locktime_cltv(
+                self.locktime_cltv, self.unlocking_script_unsigned
+            )
+            self.unlocking_script = script_add_locktime_cltv(
+                self.locktime_cltv, self.unlocking_script
+            )
         elif self.locktime_csv:
-            self.unlocking_script_unsigned = script_add_locktime_csv(self.locktime_csv, self.unlocking_script_unsigned)
-            self.unlocking_script = script_add_locktime_csv(self.locktime_csv, self.unlocking_script)
+            self.unlocking_script_unsigned = script_add_locktime_csv(
+                self.locktime_csv, self.unlocking_script_unsigned
+            )
+            self.unlocking_script = script_add_locktime_csv(
+                self.locktime_csv, self.unlocking_script
+            )
         return True
 
     def verify(self, transaction_hash):
         """
         Verify input with provided transaction hash, check if signatures matches public key.
 
         Does not check if UTXO is valid or has already been spent
 
         :param transaction_hash: Double SHA256 Hash of Transaction signature
         :type transaction_hash: bytes
 
         :return bool: True if enough signatures provided and if all signatures are valid
         """
 
-        if self.script_type == 'coinbase':
+        if self.script_type == "coinbase":
             self.valid = True
             return True
         if not self.signatures:
             _logger.info("No signatures found for transaction input %d" % self.index_n)
             return False
 
         sig_n = 0
         key_n = 0
         sigs_verified = 0
         while sigs_verified < self.sigs_required:
             if key_n >= len(self.keys):
                 _logger.info(
-                    "Not enough valid signatures provided for input %d. Found %d signatures but %d needed" %
-                    (self.index_n, sigs_verified, self.sigs_required))
+                    "Not enough valid signatures provided for input %d. Found %d signatures but %d needed"
+                    % (self.index_n, sigs_verified, self.sigs_required)
+                )
                 return False
             if sig_n >= len(self.signatures):
                 _logger.info("No valid signatures found")
                 return False
             key = self.keys[key_n]
-            print('key', key)
             sig = self.signatures[sig_n]
-            print('sig', sig)
             if verify(transaction_hash, sig, key):
                 sigs_verified += 1
                 sig_n += 1
             elif sig_n > 0:
                 # try previous signature
                 prev_sig = deepcopy(self.signatures[sig_n - 1])
                 if verify(transaction_hash, prev_sig, key):
@@ -553,56 +669,77 @@
 
         pks = []
         for k in self.keys:
             pks.append(k.public_hex)
         if len(self.keys) == 1:
             pks = pks[0]
         return {
-            'index_n': self.index_n,
-            'prev_txid': self.prev_txid.hex(),
-            'output_n': self.output_n_int,
-            'script_type': self.script_type,
-            'address': self.address,
-            'value': self.value,
-            'public_keys': pks,
-            'compressed': self.compressed,
-            'encoding': self.encoding,
-            'double_spend': self.double_spend,
-            'script': self.unlocking_script.hex(),
-            'redeemscript': self.redeemscript.hex(),
-            'sequence': self.sequence,
-            'signatures': [s.hex() for s in self.signatures],
-            'sigs_required': self.sigs_required,
-            'locktime_cltv': self.locktime_cltv,
-            'locktime_csv': self.locktime_csv,
-            'public_hash': self.public_hash.hex(),
-            'script_code': self.script_code.hex(),
-            'unlocking_script': self.unlocking_script.hex(),
-            'unlocking_script_unsigned': self.unlocking_script_unsigned.hex(),
-            'witness_type': self.witness_type,
-            'witness': b''.join(self.witnesses).hex(),
-            'sort': self.sort,
-            'valid': self.valid,
+            "index_n": self.index_n,
+            "prev_txid": self.prev_txid.hex(),
+            "output_n": self.output_n_int,
+            "script_type": self.script_type,
+            "address": self.address,
+            "value": self.value,
+            "public_keys": pks,
+            "compressed": self.compressed,
+            "encoding": self.encoding,
+            "double_spend": self.double_spend,
+            "script": self.unlocking_script.hex(),
+            "redeemscript": self.redeemscript.hex(),
+            "sequence": self.sequence,
+            "signatures": [s.hex() for s in self.signatures],
+            "sigs_required": self.sigs_required,
+            "locktime_cltv": self.locktime_cltv,
+            "locktime_csv": self.locktime_csv,
+            "public_hash": self.public_hash.hex(),
+            "script_code": self.script_code.hex(),
+            "unlocking_script": self.unlocking_script.hex(),
+            "unlocking_script_unsigned": self.unlocking_script_unsigned.hex(),
+            "witness_type": self.witness_type,
+            "witness": b"".join(self.witnesses).hex(),
+            "sort": self.sort,
+            "valid": self.valid,
         }
 
     def __repr__(self):
-        return "<Input(prev_txid='%s', output_n=%d, address='%s', index_n=%s, type='%s')>" % \
-               (self.prev_txid.hex(), self.output_n_int, self.address, self.index_n, self.script_type)
+        return (
+            "<Input(prev_txid='%s', output_n=%d, address='%s', index_n=%s, type='%s')>"
+            % (
+                self.prev_txid.hex(),
+                self.output_n_int,
+                self.address,
+                self.index_n,
+                self.script_type,
+            )
+        )
 
 
 class Output(object):
     """
     Transaction Output class, normally part of Transaction class.
 
     Contains the amount and destination of a transaction.
     """
 
-    def __init__(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,
-                 output_n=0, script_type=None, encoding=None, spending_txid='', spending_index_n=None, strict=True,
-                 network=DEFAULT_NETWORK):
+    def __init__(
+        self,
+        value,
+        address="",
+        public_hash=b"",
+        public_key=b"",
+        lock_script=b"",
+        spent=False,
+        output_n=0,
+        script_type=None,
+        encoding=None,
+        spending_txid="",
+        spending_index_n=None,
+        strict=True,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create a new transaction output
 
         A transaction outputs locks the specified amount to a public key. Anyone with the private key can unlock
         this output.
 
         The transaction output class contains an amount and the destination which can be provided either as address,
@@ -634,100 +771,126 @@
         :param strict: Raise exception when output is malformed, incomplete or not understood
         :type strict: bool
         :param network: Network, leave empty for default
         :type network: str, Network
         """
 
         if strict and not (address or public_hash or public_key or lock_script):
-            raise TransactionError("Please specify address, lock_script, public key or public key hash when "
-                                   "creating output")
+            raise TransactionError(
+                "Please specify address, lock_script, public key or public key hash when "
+                "creating output"
+            )
 
         self.network = network
         if not isinstance(network, Network):
             self.network = Network(network)
         self.value = value_to_satoshi(value, network=network)
-        self.lock_script = b'' if lock_script is None else to_bytes(lock_script)
+        self.lock_script = b"" if lock_script is None else to_bytes(lock_script)
         self.public_hash = to_bytes(public_hash)
         if isinstance(address, Address):
             self._address = address.address
             self._address_obj = address
         elif isinstance(address, HDKey):
             self._address = address.address()
             self._address_obj = address.address_obj
             public_key = address.public_byte
             if not script_type:
-                script_type = script_type_default(address.witness_type, address.multisig, True)
+                script_type = script_type_default(
+                    address.witness_type, address.multisig, True
+                )
             self.public_hash = address.hash160
         else:
             self._address = address
             self._address_obj = None
         self.public_key = to_bytes(public_key)
         self.compressed = True
         self.k = None
         self.versionbyte = self.network.prefix_address
         self.script_type = script_type
         self.encoding = encoding
         if not self._address and self.encoding is None:
-            self.encoding = 'base58'
+            self.encoding = "base58"
         self.spent = spent
         self.output_n = output_n
         self.script = Script.parse_bytes(self.lock_script, strict=strict)
 
         if self._address_obj:
-            self.script_type = self._address_obj.script_type if script_type is None else script_type
+            self.script_type = (
+                self._address_obj.script_type if script_type is None else script_type
+            )
             self.public_hash = self._address_obj.hash_bytes
             self.network = self._address_obj.network
             self.encoding = self._address_obj.encoding
 
         if self.script:
-            self.script_type = self.script_type if not self.script.script_types else self.script.script_types[0]
-            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:
-                self.encoding = 'bech32'
+            self.script_type = (
+                self.script_type
+                if not self.script.script_types
+                else self.script.script_types[0]
+            )
+            if self.script_type in ["p2wpkh", "p2wsh", "p2tr"]:
+                self.encoding = "bech32"
             self.public_hash = self.script.public_hash
             if self.script.keys:
                 self.public_key = self.script.keys[0].public_hex
 
         if self.public_key and not self.public_hash:
             k = Key(self.public_key, is_private=False, network=network)
             self.public_hash = k.hash160
-        elif self._address and (not self.public_hash or not self.script_type or not self.encoding):
-            address_dict = deserialize_address(self._address, self.encoding, self.network.name)
-            if address_dict['script_type'] and not script_type:
-                self.script_type = address_dict['script_type']
+        elif self._address and (
+            not self.public_hash or not self.script_type or not self.encoding
+        ):
+            address_dict = deserialize_address(
+                self._address, self.encoding, self.network.name
+            )
+            if address_dict["script_type"] and not script_type:
+                self.script_type = address_dict["script_type"]
             if not self.script_type:
-                raise TransactionError("Could not determine script type of address %s" % self._address)
-            self.encoding = address_dict['encoding']
-            network_guesses = address_dict['networks']
-            if address_dict['network'] and self.network.name != address_dict['network']:
-                raise TransactionError("Address %s is from %s network and transaction from %s network" %
-                                       (self._address, address_dict['network'], self.network.name))
+                raise TransactionError(
+                    "Could not determine script type of address %s" % self._address
+                )
+            self.encoding = address_dict["encoding"]
+            network_guesses = address_dict["networks"]
+            if address_dict["network"] and self.network.name != address_dict["network"]:
+                raise TransactionError(
+                    "Address %s is from %s network and transaction from %s network"
+                    % (self._address, address_dict["network"], self.network.name)
+                )
             elif self.network.name not in network_guesses:
-                raise TransactionError("Network for output address %s is different from transaction network. %s not "
-                                       "in %s" % (self._address, self.network.name, network_guesses))
-            self.public_hash = address_dict['public_key_hash_bytes']
+                raise TransactionError(
+                    "Network for output address %s is different from transaction network. %s not "
+                    "in %s" % (self._address, self.network.name, network_guesses)
+                )
+            self.public_hash = address_dict["public_key_hash_bytes"]
         if not self.encoding:
-            self.encoding = 'base58'
-            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:
-                self.encoding = 'bech32'
+            self.encoding = "base58"
+            if self.script_type in ["p2wpkh", "p2wsh", "p2tr"]:
+                self.encoding = "bech32"
 
         if self.script_type is None:
-            self.script_type = 'p2pkh'
-            if self.encoding == 'bech32':
-                self.script_type = 'p2wpkh'
+            self.script_type = "p2pkh"
+            if self.encoding == "bech32":
+                self.script_type = "p2wpkh"
         # if self.public_hash and not self._address:
         #     self.address_obj = Address(hashed_data=self.public_hash, script_type=self.script_type,
         #                                encoding=self.encoding, network=self.network)
         #     self.address = self.address_obj.address
         #     self.versionbyte = self.address_obj.prefix
         if not self.script and strict and (self.public_hash or self.public_key):
-            self.script = Script(script_types=[self.script_type], public_hash=self.public_hash, keys=[self.public_key])
+            self.script = Script(
+                script_types=[self.script_type],
+                public_hash=self.public_hash,
+                keys=[self.public_key],
+            )
             self.lock_script = self.script.serialize()
             if not self.script:
-                raise TransactionError("Unknown output script type %s, please provide locking script" %
-                                       self.script_type)
+                raise TransactionError(
+                    "Unknown output script type %s, please provide locking script"
+                    % self.script_type
+                )
         self.spending_txid = spending_txid
         self.spending_index_n = spending_index_n
         # if self.script_type != 'nulldata' and value < self.network.dust_amount:
         #     raise TransactionError("Output to %s must be more than dust amount %d" %
         #                            (self.address, self.network.dust_amount))
 
     @property
@@ -735,26 +898,30 @@
         """
         Get address object property. Create standard address object if not defined already.
 
         :return Address:
         """
         if not self._address_obj:
             if self.public_hash:
-                self._address_obj = Address(hashed_data=self.public_hash, script_type=self.script_type,
-                                            encoding=self.encoding, network=self.network)
+                self._address_obj = Address(
+                    hashed_data=self.public_hash,
+                    script_type=self.script_type,
+                    encoding=self.encoding,
+                    network=self.network,
+                )
                 self._address = self._address_obj.address
                 self.versionbyte = self._address_obj.prefix
         return self._address_obj
 
     @property
     def address(self):
         if not self._address:
             address_obj = self.address_obj
             if not address_obj:
-                return ''
+                return ""
             self._address = address_obj.address
         return self._address
 
     @classmethod
     def parse(cls, raw, output_n=0, strict=True, network=DEFAULT_NETWORK):
         """
         Parse raw BytesIO string and return Output object
@@ -766,18 +933,24 @@
         :param strict: Raise exception when output is malformed, incomplete or not understood
         :type strict: bool
         :param network: Network, leave empty for default network
         :type network: str, Network
 
         :return Output:
         """
-        value = int.from_bytes(raw.read(8)[::-1], 'big')
+        value = int.from_bytes(raw.read(8)[::-1], "big")
         lock_script_size = read_varbyteint(raw)
         lock_script = raw.read(lock_script_size)
-        return Output(value=value, lock_script=lock_script, output_n=output_n, strict=strict, network=network)
+        return Output(
+            value=value,
+            lock_script=lock_script,
+            output_n=output_n,
+            strict=strict,
+            network=network,
+        )
 
     # TODO: Write and rewrite locktime methods
     # def set_locktime - CLTV (BIP65)
     # def set_locktime_blocks
     # def set_locktime_time
 
     def set_locktime_relative(self, locktime):
@@ -836,28 +1009,32 @@
         """
         Get transaction output information in json format
 
         :return dict: Json with amount, locking script, public key, public key hash and address
         """
 
         return {
-            'value': self.value,
-            'script': self.lock_script.hex(),
-            'script_type': self.script_type,
-            'public_key': self.public_key.hex(),
-            'public_hash': self.public_hash.hex(),
-            'address': self.address,
-            'output_n': self.output_n,
-            'spent': self.spent,
-            'spending_txid': self.spending_txid,
-            'spending_index_n': self.spending_index_n,
+            "value": self.value,
+            "script": self.lock_script.hex(),
+            "script_type": self.script_type,
+            "public_key": self.public_key.hex(),
+            "public_hash": self.public_hash.hex(),
+            "address": self.address,
+            "output_n": self.output_n,
+            "spent": self.spent,
+            "spending_txid": self.spending_txid,
+            "spending_index_n": self.spending_index_n,
         }
 
     def __repr__(self):
-        return "<Output(value=%d, address=%s, type=%s)>" % (self.value, self.address, self.script_type)
+        return "<Output(value=%d, address=%s, type=%s)>" % (
+            self.value,
+            self.address,
+            self.script_type,
+        )
 
 
 class BaseTransaction(ABC):
     @classmethod
     def parse(cls, rawtx, strict=True, network=DEFAULT_NETWORK):
         """
         Parse a raw transaction and create a Transaction object
@@ -910,18 +1087,41 @@
         :type network: str, Network
 
         :return Transaction:
         """
 
         return cls.parse(BytesIO(rawtx), strict, network)
 
-    def __init__(self, inputs=None, outputs=None, locktime=0, version=None,
-                 network=DEFAULT_NETWORK, fee=None, fee_per_kb=None, size=None, txid='', txhash='', date=None,
-                 confirmations=None, block_height=None, block_hash=None, input_total=0, output_total=0, rawtx=b'',
-                 status='new', coinbase=False, verified=False, witness_type='legacy', flag=None, expiry_height: int=0):
+    def __init__(
+        self,
+        *,
+        inputs: list[Input] | None = None,
+        outputs: list[Output] | None = None,
+        locktime: int = 0,
+        version: bytes | int | None = None,
+        network: str = DEFAULT_NETWORK,
+        fee: int | None = None,
+        fee_per_kb: int | None = None,
+        size: int | None = None,
+        txid: str = "",
+        txhash: str = "",
+        date: datetime | None = None,
+        confirmations: int | None = None,
+        block_height: int | None = None,
+        block_hash: str | None = None,
+        input_total: int = 0,
+        output_total: int = 0,
+        rawtx: bytes = b"",
+        status: str = "new",
+        coinbase: bool = False,
+        verified: bool = False,
+        witness_type: str = "legacy",
+        flag: str | None = None,
+        expiry_height: int = 0,
+    ):
         """
         Create a new transaction class with provided inputs and outputs.
 
         You can also create an empty transaction and add input and outputs later.
 
         To verify and sign transactions all inputs and outputs need to be included in transaction. Any modification
         after signing makes the transaction invalid.
@@ -971,51 +1171,60 @@
         :param flag: Transaction flag to indicate version, for example for SegWit
         :type flag: bytes, str
 
         """
         self.expiry_height = expiry_height
 
         self.coinbase = coinbase
-        self.inputs = []
-        if inputs is not None:
-            for inp in inputs:
-                self.inputs.append(inp)
-            if not input_total:
-                input_total = sum([i.value for i in inputs])
-        id_list = [i.index_n for i in self.inputs]
-        if list(dict.fromkeys(id_list)) != id_list:
-            _logger.info("Identical transaction indexes (tid) found in inputs, please specify unique index. "
-                         "Indexes will be automatically recreated")
-            index_n = 0
-            for inp in self.inputs:
-                inp.index_n = index_n
-                index_n += 1
-        if outputs is None:
-            self.outputs = []
-        else:
-            self.outputs = outputs
-            if not output_total:
-                output_total = sum([o.value for o in outputs])
+
+        self.inputs = inputs if inputs else []
+
+        if not input_total:
+            input_total = sum([i.value for i in self.inputs])
+
+        # wtaf?!? removed
+        # id_list = [i.index_n for i in self.inputs]
+        # if list(dict.fromkeys(id_list)) != id_list:
+        #     _logger.info(
+        #         "Identical transaction indexes (tid) found in inputs, please specify unique index. "
+        #         "Indexes will be automatically recreated"
+        #     )
+        #     index_n = 0
+        #     for inp in self.inputs:
+        #         inp.index_n = index_n
+        #         index_n += 1
+
+        self.outputs = outputs if outputs else []
+
+        if not output_total:
+            output_total = sum([o.value for o in self.outputs])
+
         if fee is None and output_total and input_total:
             fee = input_total - output_total
             if fee < 0 or fee == 0 and not self.coinbase:
-                raise TransactionError("Transaction inputs total value must be greater then total value of "
-                                       "transaction outputs")
+                raise TransactionError(
+                    "Transaction inputs total value must be greater then total value of "
+                    "transaction outputs"
+                )
         if not version:
-            version = b'\x00\x00\x00\x01'
+            version = b"\x00\x00\x00\x01"
+
         if isinstance(version, int):
-            self.version = version.to_bytes(4, 'big')
+            self.version = version.to_bytes(4, "big")
             self.version_int = version
         else:
             self.version = version
-            self.version_int = int.from_bytes(version, 'big')
+            self.version_int = int.from_bytes(version, "big")
+
         self.locktime = locktime
         self.network = network
+
         if not isinstance(network, Network):
             self.network = Network(network)
+
         self.flag = flag
         self.fee = fee
         self.fee_per_kb = fee_per_kb
         self.size = size
         self.vsize = size
         self.txid = txid
         self.txhash = txhash
@@ -1028,23 +1237,21 @@
         self.rawtx = rawtx
         self.status = status
         self.verified = verified
         self.witness_type = witness_type
         self.change = 0
         self.calc_weight_units()
 
-        if self.witness_type not in ['legacy', 'segwit']:
-            raise TransactionError("Please specify a valid witness type: legacy or segwit")
+        if self.witness_type not in ["legacy", "segwit"]:
+            raise TransactionError(
+                "Please specify a valid witness type: legacy or segwit"
+            )
         if not self.txid:
             self.txid = self.signature_hash()[::-1].hex()
 
-    def __repr__(self):
-        return "<Transaction(id=%s, inputs=%d, outputs=%d, status=%s, network=%s)>" % \
-               (self.txid, len(self.inputs), len(self.outputs), self.status, self.network.name)
-
     def __str__(self):
         return self.txid
 
     def __add__(self, other):
         """
         Merge this transaction with another transaction keeping the original transaction intact.
 
@@ -1062,16 +1269,18 @@
         Compare two transaction, must have same transaction ID
 
         :param other: Other transaction object
         :type other: Transaction
 
         :return bool:
         """
-        if not isinstance(other, Transaction):
-            raise TransactionError("Can only compare with other Transaction object")
+        if not isinstance(other, BaseTransaction):
+            raise TransactionError(
+                f"Can only compare with other BaseTransaction object"
+            )
         return self.txid == other.txid
 
     @staticmethod
     def load(txid=None, filename=None):
         """
         Load transaction object from file which has been stored with the :func:`save` method.
 
@@ -1083,40 +1292,40 @@
         :type filename: str
 
         :return Transaction:
         """
         if not filename and not txid:
             raise TransactionError("Please supply filename or txid")
         elif not filename and txid:
-            p = Path(FW_DATA_DIR, '%s.tx' % txid)
+            p = Path(FW_DATA_DIR, "%s.tx" % txid)
         else:
             p = Path(filename)
-            if not p.parent or str(p.parent) == '.':
+            if not p.parent or str(p.parent) == ".":
                 p = Path(FW_DATA_DIR, filename)
-        f = p.open('rb')
+        f = p.open("rb")
         t = pickle.load(f)
         f.close()
         return t
 
     def save(self, filename=None):
         """
         Store transaction object as file, so it can be imported in fluxwallet later with the :func:`load` method.
 
         :param filename: Location and name of file, leave empty to store transaction in fluxwallet data directory: .fluxwallet/<transaction_id.tx)
         :type filename: str
 
         :return:
         """
         if not filename:
-            p = Path(FW_DATA_DIR, '%s.tx' % self.txid)
+            p = Path(FW_DATA_DIR, "%s.tx" % self.txid)
         else:
             p = Path(filename)
-            if not p.parent or str(p.parent) == '.':
+            if not p.parent or str(p.parent) == ".":
                 p = Path(FW_DATA_DIR, filename)
-        f = p.open('wb')
+        f = p.open("wb")
         pickle.dump(self, f)
         f.close()
 
     def as_dict(self):
         """
         Return Json dictionary with transaction information: Inputs, outputs, version and locktime
 
@@ -1126,37 +1335,37 @@
         inputs = []
         outputs = []
         for i in self.inputs:
             inputs.append(i.as_dict())
         for o in self.outputs:
             outputs.append(o.as_dict())
         return {
-            'txid': self.txid,
-            'date': self.date,
-            'network': self.network.name,
-            'witness_type': self.witness_type,
-            'coinbase': self.coinbase,
-            'flag': None if not self.flag else ord(self.flag),
-            'txhash': self.txhash,
-            'confirmations': self.confirmations,
-            'block_height': self.block_height,
-            'block_hash': self.block_hash,
-            'fee': self.fee,
-            'fee_per_kb': self.fee_per_kb,
-            'inputs': inputs,
-            'outputs': outputs,
-            'input_total': self.input_total,
-            'output_total': self.output_total,
-            'version': self.version_int,
-            'locktime': self.locktime,
-            'raw': self.raw_hex(),
-            'size': self.size,
-            'vsize': self.vsize,
-            'verified': self.verified,
-            'status': self.status
+            "txid": self.txid,
+            "date": self.date,
+            "network": self.network.name,
+            "witness_type": self.witness_type,
+            "coinbase": self.coinbase,
+            "flag": None if not self.flag else ord(self.flag),
+            "txhash": self.txhash,
+            "confirmations": self.confirmations,
+            "block_height": self.block_height,
+            "block_hash": self.block_hash,
+            "fee": self.fee,
+            "fee_per_kb": self.fee_per_kb,
+            "inputs": inputs,
+            "outputs": outputs,
+            "input_total": self.input_total,
+            "output_total": self.output_total,
+            "version": self.version_int,
+            "locktime": self.locktime,
+            "raw": self.raw_hex(),
+            "size": self.size,
+            "vsize": self.vsize,
+            "verified": self.verified,
+            "status": self.status,
         }
 
     def as_json(self):
         """
         Get current key as json formatted string
 
         :return str:
@@ -1168,67 +1377,101 @@
         """
         Prints transaction information to standard output
         """
 
         print("Transaction %s" % self.txid)
         print("Date: %s" % self.date)
         print("Network: %s" % self.network.name)
-        if self.locktime and self.locktime != 0xffffffff:
+        if self.locktime and self.locktime != 0xFFFFFFFF:
             if self.locktime < 500000000:
                 print("Locktime: Until block %d" % self.locktime)
             else:
-                print("Locktime: Until %s UTC" % datetime.utcfromtimestamp(self.locktime))
+                print(
+                    "Locktime: Until %s UTC" % datetime.utcfromtimestamp(self.locktime)
+                )
         print("Version: %d" % self.version_int)
         print("Witness type: %s" % self.witness_type)
         print("Status: %s" % self.status)
         print("Verified: %s" % self.verified)
         print("Inputs")
         replace_by_fee = False
         for ti in self.inputs:
-            print("-", ti.address, Value.from_satoshi(ti.value, network=self.network).str(1), ti.prev_txid.hex(),
-                  ti.output_n_int)
+            print(
+                "-",
+                ti.address,
+                Value.from_satoshi(ti.value, network=self.network).str(1),
+                ti.prev_txid.hex(),
+                ti.output_n_int,
+            )
             validstr = "not validated"
             if ti.valid:
                 validstr = "valid"
             elif ti.valid is False:
                 validstr = "invalid"
-            print("  %s %s; sigs: %d (%d-of-%d) %s" %
-                  (ti.witness_type, ti.script_type, len(ti.signatures), ti.sigs_required or 0, len(ti.keys), validstr))
+            print(
+                "  %s %s; sigs: %d (%d-of-%d) %s"
+                % (
+                    ti.witness_type,
+                    ti.script_type,
+                    len(ti.signatures),
+                    ti.sigs_required or 0,
+                    len(ti.keys),
+                    validstr,
+                )
+            )
             if ti.sequence <= SEQUENCE_REPLACE_BY_FEE:
                 replace_by_fee = True
             if ti.sequence <= SEQUENCE_LOCKTIME_DISABLE_FLAG:
                 if ti.sequence & SEQUENCE_LOCKTIME_TYPE_FLAG:
-                    print("  Relative timelock for %d seconds" % (512 * (ti.sequence - SEQUENCE_LOCKTIME_TYPE_FLAG)))
+                    print(
+                        "  Relative timelock for %d seconds"
+                        % (512 * (ti.sequence - SEQUENCE_LOCKTIME_TYPE_FLAG))
+                    )
                 else:
                     print("  Relative timelock for %d blocks" % ti.sequence)
             if ti.locktime_cltv:
                 if ti.locktime_cltv & SEQUENCE_LOCKTIME_TYPE_FLAG:
-                    print("  Check Locktime Verify (CLTV) for %d seconds" %
-                          (512 * (ti.locktime_cltv - SEQUENCE_LOCKTIME_TYPE_FLAG)))
+                    print(
+                        "  Check Locktime Verify (CLTV) for %d seconds"
+                        % (512 * (ti.locktime_cltv - SEQUENCE_LOCKTIME_TYPE_FLAG))
+                    )
                 else:
-                    print("  Check Locktime Verify (CLTV) for %d blocks" % ti.locktime_cltv)
+                    print(
+                        "  Check Locktime Verify (CLTV) for %d blocks"
+                        % ti.locktime_cltv
+                    )
             if ti.locktime_csv:
                 if ti.locktime_csv & SEQUENCE_LOCKTIME_TYPE_FLAG:
-                    print("  Check Sequence Verify Timelock (CSV) for %d seconds" %
-                          (512 * (ti.locktime_csv - SEQUENCE_LOCKTIME_TYPE_FLAG)))
+                    print(
+                        "  Check Sequence Verify Timelock (CSV) for %d seconds"
+                        % (512 * (ti.locktime_csv - SEQUENCE_LOCKTIME_TYPE_FLAG))
+                    )
                 else:
-                    print("  Check Sequence Verify Timelock (CSV) for %d blocks" % ti.locktime_csv)
+                    print(
+                        "  Check Sequence Verify Timelock (CSV) for %d blocks"
+                        % ti.locktime_csv
+                    )
 
         print("Outputs")
         for to in self.outputs:
-            if to.script_type == 'nulldata':
+            if to.script_type == "nulldata":
                 print("- NULLDATA ", to.lock_script[2:])
             else:
-                spent_str = ''
+                spent_str = ""
                 if to.spent:
-                    spent_str = 'S'
+                    spent_str = "S"
                 elif to.spent is False:
-                    spent_str = 'U'
-                print("-", to.address, Value.from_satoshi(to.value, network=self.network).str(1), to.script_type,
-                      spent_str)
+                    spent_str = "U"
+                print(
+                    "-",
+                    to.address,
+                    Value.from_satoshi(to.value, network=self.network).str(1),
+                    to.script_type,
+                    spent_str,
+                )
         if replace_by_fee:
             print("Replace by fee: Enabled")
         print("Size: %s" % self.size)
         print("Vsize: %s" % self.vsize)
         print("Fee: %s" % self.fee)
         print("Confirmations: %s" % self.confirmations)
         print("Block: %s" % self.block_height)
@@ -1244,20 +1487,23 @@
         :param blocks: The blocks value is the number of blocks since the previous transaction output has been confirmed.
         :type blocks: int
         :param input_index_n: Index number of input for nSequence locktime
         :type input_index_n: int
 
         :return:
         """
-        if blocks == 0 or blocks == 0xffffffff:
-            self.inputs[input_index_n].sequence = 0xffffffff
+        if blocks == 0 or blocks == 0xFFFFFFFF:
+            self.inputs[input_index_n].sequence = 0xFFFFFFFF
             self.sign(index_n=input_index_n, replace_signatures=True)
             return
         if blocks > SEQUENCE_LOCKTIME_MASK:
-            raise TransactionError("Number of nSequence timelock blocks exceeds %d" % SEQUENCE_LOCKTIME_MASK)
+            raise TransactionError(
+                "Number of nSequence timelock blocks exceeds %d"
+                % SEQUENCE_LOCKTIME_MASK
+            )
         self.inputs[input_index_n].sequence = blocks
         self.version_int = 2
         self.sign_and_update(index_n=input_index_n)
 
     def set_locktime_relative_time(self, seconds, input_index_n=0):
         """
         Set nSequence relative locktime for this transaction. The transaction will only be valid if the specified amount of seconds have been passed since the previous UTXO is confirmed.
@@ -1271,78 +1517,96 @@
         :param seconds: Number of seconds since the related previous transaction output has been confirmed.
         :type seconds: int
         :param input_index_n: Index number of input for nSequence locktime
         :type input_index_n: int
 
         :return:
         """
-        if seconds == 0 or seconds == 0xffffffff:
-            self.inputs[input_index_n].sequence = 0xffffffff
+        if seconds == 0 or seconds == 0xFFFFFFFF:
+            self.inputs[input_index_n].sequence = 0xFFFFFFFF
             self.sign(index_n=input_index_n, replace_signatures=True)
             return
         elif seconds < 512:
             seconds = 512
         elif (seconds // 512) > SEQUENCE_LOCKTIME_MASK:
-            raise TransactionError("Number of relative nSeqence timelock seconds exceeds %d" % SEQUENCE_LOCKTIME_MASK)
-        self.inputs[input_index_n].sequence = seconds // 512 + SEQUENCE_LOCKTIME_TYPE_FLAG
+            raise TransactionError(
+                "Number of relative nSeqence timelock seconds exceeds %d"
+                % SEQUENCE_LOCKTIME_MASK
+            )
+        self.inputs[input_index_n].sequence = (
+            seconds // 512 + SEQUENCE_LOCKTIME_TYPE_FLAG
+        )
         self.version_int = 2
         self.sign_and_update(index_n=input_index_n)
 
     def set_locktime_blocks(self, blocks):
         """
         Set nLocktime, a transaction level absolute lock time in blocks using the transaction sequence field.
 
         So for example if you set this value to 600000 the transaction will only be valid after block 600000.
 
         :param blocks: Transaction is valid after supplied block number. Value must be between 0 and 500000000. Zero means no locktime.
         :type blocks: int
 
         :return:
         """
-        if blocks == 0 or blocks == 0xffffffff:
-            self.locktime = 0xffffffff
+        if blocks == 0 or blocks == 0xFFFFFFFF:
+            self.locktime = 0xFFFFFFFF
             self.sign(replace_signatures=True)
             self.verify()
             return
         elif blocks > 500000000:
-            raise TransactionError("Number of locktime blocks must be below %d" % 500000000)
+            raise TransactionError(
+                "Number of locktime blocks must be below %d" % 500000000
+            )
         self.locktime = blocks
-        if blocks != 0 and blocks != 0xffffffff:
+        if blocks != 0 and blocks != 0xFFFFFFFF:
             for i in self.inputs:
-                if i.sequence == 0xffffffff:
-                    i.sequence = 0xfffffffd
+                if i.sequence == 0xFFFFFFFF:
+                    i.sequence = 0xFFFFFFFD
         self.sign_and_update()
 
     def set_locktime_time(self, timestamp):
         """
         Set nLocktime, a transaction level absolute lock time in timestamp using the transaction sequence field.
 
         :param timestamp: Transaction is valid after the given timestamp. Value must be between 500000000 and 0xfffffffe
         :return:
         """
-        if timestamp == 0 or timestamp == 0xffffffff:
-            self.locktime = 0xffffffff
+        if timestamp == 0 or timestamp == 0xFFFFFFFF:
+            self.locktime = 0xFFFFFFFF
             self.sign(replace_signatures=True)
             self.verify()
             return
 
         if timestamp <= 500000000:
-            raise TransactionError("Timestamp must have a value higher then %d" % 500000000)
-        if timestamp > 0xfffffffe:
-            raise TransactionError("Timestamp must have a value lower then %d" % 0xfffffffe)
+            raise TransactionError(
+                "Timestamp must have a value higher then %d" % 500000000
+            )
+        if timestamp > 0xFFFFFFFE:
+            raise TransactionError(
+                "Timestamp must have a value lower then %d" % 0xFFFFFFFE
+            )
         self.locktime = timestamp
 
         # Input sequence value must be below 0xffffffff
         for i in self.inputs:
-            if i.sequence == 0xffffffff:
-                i.sequence = 0xfffffffd
+            if i.sequence == 0xFFFFFFFF:
+                i.sequence = 0xFFFFFFFD
         self.sign_and_update()
 
-    def sign(self, keys=None, index_n=None, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=True,
-             replace_signatures=False):
+    def sign(
+        self,
+        keys=None,
+        index_n=None,
+        multisig_key_n=None,
+        hash_type=SIGHASH_ALL,
+        fail_on_unknown_key=True,
+        replace_signatures=False,
+    ):
         """
         Sign the transaction input with provided private key
 
         :param keys: A private key or list of private keys
         :type keys: HDKey, Key, bytes, list
         :param index_n: Index of transaction input. Leave empty to sign all inputs
         :type index_n: int
@@ -1366,97 +1630,133 @@
         if keys is None:
             keys = []
         elif not isinstance(keys, list):
             keys = [keys]
 
         for tid in tids:
             n_signs = 0
-            tid_keys = [k if isinstance(k, (HDKey, Key)) else Key(k, compressed=self.inputs[tid].compressed)
-                        for k in keys]
+            tid_keys = [
+                k
+                if isinstance(k, (HDKey, Key))
+                else Key(k, compressed=self.inputs[tid].compressed)
+                for k in keys
+            ]
             for k in self.inputs[tid].keys:
                 if k.is_private and k not in tid_keys:
                     tid_keys.append(k)
             # If input does not contain any keys, try using provided keys
             if not self.inputs[tid].keys:
                 self.inputs[tid].keys = tid_keys
                 self.inputs[tid].update_scripts(hash_type=hash_type)
-            if self.inputs[tid].script_type == 'coinbase':
+            if self.inputs[tid].script_type == "coinbase":
                 raise TransactionError("Can not sign coinbase transactions")
             pub_key_list = [k.public_byte for k in self.inputs[tid].keys]
             n_total_sigs = len(self.inputs[tid].keys)
-            sig_domain = [''] * n_total_sigs
+            sig_domain = [""] * n_total_sigs
 
+            # this should store on the tx
             txid = self.signature_hash(tid, witness_type=self.inputs[tid].witness_type)
             for key in tid_keys:
                 # Check if signature signs known key and is not already in list
                 if key.public_byte not in pub_key_list:
                     if fail_on_unknown_key:
-                        raise TransactionError("This key does not sign any known key: %s" % key.public_hex)
+                        raise TransactionError(
+                            "This key does not sign any known key: %s" % key.public_hex
+                        )
                     else:
-                        _logger.info("This key does not sign any known key: %s" % key.public_hex)
+                        _logger.info(
+                            "This key does not sign any known key: %s" % key.public_hex
+                        )
                         continue
-                if not replace_signatures and key in [x.public_key for x in self.inputs[tid].signatures]:
+                if not replace_signatures and key in [
+                    x.public_key for x in self.inputs[tid].signatures
+                ]:
                     _logger.info("Key %s already signed" % key.public_hex)
                     break
 
                 if not key.private_byte:
-                    raise TransactionError("Please provide a valid private key to sign the transaction")
+                    raise TransactionError(
+                        "Please provide a valid private key to sign the transaction"
+                    )
                 sig = sign(txid, key)
                 newsig_pos = pub_key_list.index(key.public_byte)
                 sig_domain[newsig_pos] = sig
                 n_signs += 1
 
             if not n_signs:
                 break
 
             # Add already known signatures on correct position
             n_sigs_to_insert = len(self.inputs[tid].signatures)
             for sig in self.inputs[tid].signatures:
                 if not sig.public_key:
                     break
                 newsig_pos = pub_key_list.index(sig.public_key.public_byte)
-                if sig_domain[newsig_pos] == '':
+                if sig_domain[newsig_pos] == "":
                     sig_domain[newsig_pos] = sig
                     n_sigs_to_insert -= 1
             if n_sigs_to_insert:
                 for sig in self.inputs[tid].signatures:
-                    free_positions = [i for i, s in enumerate(sig_domain) if s == '']
+                    free_positions = [i for i, s in enumerate(sig_domain) if s == ""]
                     for pos in free_positions:
                         sig_domain[pos] = sig
                         n_sigs_to_insert -= 1
                         break
             if n_sigs_to_insert:
-                _logger.info("Some signatures are replaced with the signatures of the provided keys")
-            self.inputs[tid].signatures = [s for s in sig_domain if s != '']
+                _logger.info(
+                    "Some signatures are replaced with the signatures of the provided keys"
+                )
+            self.inputs[tid].signatures = [s for s in sig_domain if s != ""]
             self.inputs[tid].update_scripts(hash_type)
 
     def sign_and_update(self, index_n=None):
         """
         Update transaction ID and resign. Use if some properties of the transaction changed
 
         :param index_n: Index of transaction input. Leave empty to sign all inputs
         :type index_n: int
 
         :return:
         """
 
-        self.version = self.version_int.to_bytes(4, 'big')
+        self.version = self.version_int.to_bytes(4, "big")
         self.sign(index_n=index_n, replace_signatures=True)
         self.txid = self.signature_hash()[::-1].hex()
         self.size = len(self.raw())
         self.calc_weight_units()
         self.update_totals()
         if self.fee:
             self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)
 
-    def add_input(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',
-                  unlocking_script_unsigned=None, script_type=None, address='',
-                  sequence=0xffffffff, compressed=True, sigs_required=None, sort=False, index_n=None,
-                  value=None, double_spend=False, locktime_cltv=None, locktime_csv=None,
-                  key_path='', witness_type=None, witnesses=None, encoding=None, strict=True):
+    def add_input(
+        self,
+        prev_txid,
+        output_n,
+        keys=None,
+        signatures=None,
+        public_hash=b"",
+        unlocking_script=b"",
+        unlocking_script_unsigned=None,
+        script_type=None,
+        address="",
+        sequence=0xFFFFFFFF,
+        compressed=True,
+        sigs_required=None,
+        sort=False,
+        index_n=None,
+        value=None,
+        double_spend=False,
+        locktime_cltv=None,
+        locktime_csv=None,
+        key_path="",
+        witness_type=None,
+        witnesses=None,
+        encoding=None,
+        strict=True,
+    ):
         """
         Add input to this transaction
 
         Wrapper for append method of Input class.
 
         :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.
         :type prev_txid: bytes, hexstring
@@ -1507,32 +1807,72 @@
 
         :return int: Transaction index number (index_n)
         """
 
         if index_n is None:
             index_n = len(self.inputs)
         sequence_int = sequence
+
         if isinstance(sequence, bytes):
-            sequence_int = int.from_bytes(sequence, 'little')
-        if self.version == b'\x00\x00\x00\x01' and 0 < sequence_int < SEQUENCE_LOCKTIME_DISABLE_FLAG:
-            self.version = b'\x00\x00\x00\x02'
+            sequence_int = int.from_bytes(sequence, "little")
+
+        if (
+            self.version == b"\x00\x00\x00\x01"
+            and 0 < sequence_int < SEQUENCE_LOCKTIME_DISABLE_FLAG
+        ):
+            self.version = b"\x00\x00\x00\x02"
             self.version_int = 2
+
         if witness_type is None:
             witness_type = self.witness_type
+
         self.inputs.append(
-            Input(prev_txid=prev_txid, output_n=output_n, keys=keys, signatures=signatures, public_hash=public_hash,
-                  unlocking_script=unlocking_script, unlocking_script_unsigned=unlocking_script_unsigned,
-                  script_type=script_type, address=address, sequence=sequence, compressed=compressed,
-                  sigs_required=sigs_required, sort=sort, index_n=index_n, value=value, double_spend=double_spend,
-                  locktime_cltv=locktime_cltv, locktime_csv=locktime_csv, key_path=key_path, witness_type=witness_type,
-                  witnesses=witnesses, encoding=encoding, strict=strict, network=self.network.name))
+            Input(
+                prev_txid=prev_txid,
+                output_n=output_n,
+                keys=keys,
+                signatures=signatures,
+                public_hash=public_hash,
+                unlocking_script=unlocking_script,
+                unlocking_script_unsigned=unlocking_script_unsigned,
+                script_type=script_type,
+                address=address,
+                sequence=sequence,
+                compressed=compressed,
+                sigs_required=sigs_required,
+                sort=sort,
+                index_n=index_n,
+                value=value,
+                double_spend=double_spend,
+                locktime_cltv=locktime_cltv,
+                locktime_csv=locktime_csv,
+                key_path=key_path,
+                witness_type=witness_type,
+                witnesses=witnesses,
+                encoding=encoding,
+                strict=strict,
+                network=self.network.name,
+            )
+        )
         return index_n
 
-    def add_output(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,
-                   output_n=None, encoding=None, spending_txid=None, spending_index_n=None, strict=True):
+    def add_output(
+        self,
+        value,
+        address="",
+        public_hash=b"",
+        public_key=b"",
+        lock_script=b"",
+        spent=False,
+        output_n=None,
+        encoding=None,
+        spending_txid=None,
+        spending_index_n=None,
+        strict=True,
+    ):
         """
         Add an output to this transaction
 
         Wrapper for the append method of the Output class.
 
         :param value: Value of output in the smallest denominator of currency, for example satoshi's for bitcoins
         :type value: int
@@ -1560,22 +1900,36 @@
         :return int: Transaction output number (output_n)
         """
 
         lock_script = to_bytes(lock_script)
         if output_n is None:
             output_n = len(self.outputs)
         if not float(value).is_integer():
-            raise TransactionError("Output must be of type integer and contain no decimals")
-        if lock_script.startswith(b'\x6a'):
+            raise TransactionError(
+                "Output must be of type integer and contain no decimals"
+            )
+        if lock_script.startswith(b"\x6a"):
             if value != 0:
                 raise TransactionError("Output value for OP_RETURN script must be 0")
-        self.outputs.append(Output(value=int(value), address=address, public_hash=public_hash,
-                                   public_key=public_key, lock_script=lock_script, spent=spent, output_n=output_n,
-                                   encoding=encoding, spending_txid=spending_txid, spending_index_n=spending_index_n,
-                                   strict=strict, network=self.network.name))
+        self.outputs.append(
+            Output(
+                value=int(value),
+                address=address,
+                public_hash=public_hash,
+                public_key=public_key,
+                lock_script=lock_script,
+                spent=spent,
+                output_n=output_n,
+                encoding=encoding,
+                spending_txid=spending_txid,
+                spending_index_n=spending_index_n,
+                strict=strict,
+                network=self.network.name,
+            )
+        )
         return output_n
 
     def merge_transaction(self, transaction):
         """
         Merge this transaction with provided Transaction object.
 
         Add all inputs and outputs of a transaction to this Transaction object. Because the transaction signature
@@ -1607,83 +1961,93 @@
         :return int: Estimated transaction size
         """
 
         # if self.input_total and self.output_total + self.fee == self.input_total:
         #     add_change_output = False
         est_size = 10
         witness_size = 2
-        if self.witness_type != 'legacy':
+        if self.witness_type != "legacy":
             est_size += 2
         # TODO: if no inputs assume 1 input
         if not self.inputs:
             est_size += 125
             witness_size += 72
         for inp in self.inputs:
             est_size += 40
             scr_size = 0
-            if inp.witness_type != 'legacy':
+            if inp.witness_type != "legacy":
                 est_size += 1
             if inp.unlocking_script and len(inp.signatures) >= inp.sigs_required:
                 scr_size += len(varstr(inp.unlocking_script))
-                if inp.witness_type == 'p2sh-segwit':
+                if inp.witness_type == "p2sh-segwit":
                     scr_size += sum([1 + len(w) for w in inp.witnesses])
             else:
-                if inp.script_type == 'sig_pubkey':
+                if inp.script_type == "sig_pubkey":
                     scr_size += 107
                     if not inp.compressed:
                         scr_size += 33
-                    if inp.witness_type == 'p2sh-segwit':
+                    if inp.witness_type == "p2sh-segwit":
                         scr_size += 24
                 # elif inp.script_type in ['p2sh_multisig', 'p2sh_p2wpkh', 'p2sh_p2wsh']:
-                elif inp.script_type == 'p2sh_multisig':
+                elif inp.script_type == "p2sh_multisig":
                     scr_size += 9 + (len(inp.keys) * 34) + (inp.sigs_required * 72)
-                    if inp.witness_type == 'p2sh-segwit':
+                    if inp.witness_type == "p2sh-segwit":
                         scr_size += 17 * inp.sigs_required
-                elif inp.script_type == 'signature':
+                elif inp.script_type == "signature":
                     scr_size += 9 + 72
                 else:
-                    raise TransactionError("Unknown input script type %s cannot estimate transaction size" %
-                                           inp.script_type)
+                    raise TransactionError(
+                        "Unknown input script type %s cannot estimate transaction size"
+                        % inp.script_type
+                    )
             est_size += scr_size
             witness_size += scr_size
         for outp in self.outputs:
             est_size += 8
             if outp.lock_script:
                 est_size += len(varstr(outp.lock_script))
             else:
-                raise TransactionError("Need locking script for output %d to estimate size" % outp.output_n)
+                raise TransactionError(
+                    "Need locking script for output %d to estimate size" % outp.output_n
+                )
         if number_of_change_outputs:
-            is_multisig = True if self.inputs and self.inputs[0].script_type == 'p2sh_multisig' else False
+            is_multisig = (
+                True
+                if self.inputs and self.inputs[0].script_type == "p2sh_multisig"
+                else False
+            )
             co_size = 8
-            if not self.inputs or self.inputs[0].witness_type == 'legacy':
+            if not self.inputs or self.inputs[0].witness_type == "legacy":
                 co_size += 24 if is_multisig else 26
-            elif self.inputs[0].witness_type == 'p2sh-segwit':
+            elif self.inputs[0].witness_type == "p2sh-segwit":
                 co_size += 24
             else:
                 co_size += 33 if is_multisig else 23
-            est_size += (number_of_change_outputs * co_size)
+            est_size += number_of_change_outputs * co_size
         self.size = est_size
         self.vsize = est_size
-        if self.witness_type == 'legacy':
+        if self.witness_type == "legacy":
             return est_size
         else:
-            self.vsize = math.ceil((((est_size - witness_size) * 3 + est_size) / 4) - 1.5)
+            self.vsize = math.ceil(
+                (((est_size - witness_size) * 3 + est_size) / 4) - 1.5
+            )
             return self.vsize
 
     def calc_weight_units(self):
         """
         Calculate weight units and vsize for this Transaction. Weight units are used to determine fee.
 
         :return int:
         """
         if not self.size:
             return None
         witness_data_size = len(self.witness_data())
         wu = self.size * 4
-        if self.witness_type == 'segwit' and witness_data_size > 1:
+        if self.witness_type == "segwit" and witness_data_size > 1:
             wu = wu - 6  # for segwit marker and flag
             wu = wu - witness_data_size * 3
         self.vsize = math.ceil(wu / 4)
         return wu
 
     @property
     def weight_units(self):
@@ -1694,15 +2058,17 @@
         Get fee for this transaction in the smallest denominator (i.e. Satoshi) based on its size and the
         transaction.fee_per_kb value
 
         :return int: Estimated transaction fee
         """
 
         if not self.fee_per_kb:
-            raise TransactionError("Cannot calculate transaction fees: transaction.fee_per_kb is not set")
+            raise TransactionError(
+                "Cannot calculate transaction fees: transaction.fee_per_kb is not set"
+            )
         if self.fee_per_kb < self.network.fee_min:
             self.fee_per_kb = self.network.fee_min
         elif self.fee_per_kb > self.network.fee_max:
             self.fee_per_kb = self.network.fee_max
         if not self.vsize:
             self.estimate_size()
         fee = int(self.vsize / 1000.0 * self.fee_per_kb)
@@ -1721,16 +2087,14 @@
             self.input_total = self.output_total
         # self.fee = 0
         if self.input_total:
             self.fee = self.input_total - self.output_total
             if self.vsize:
                 self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)
 
-
-
     def shuffle_inputs(self):
         """
         Shuffle transaction inputs in random order.
 
         :return:
         """
         random.shuffle(self.inputs)
@@ -1780,23 +2144,26 @@
 
         :return bool: True if enough signatures provided and if all signatures are valid
         """
 
         self.verified = False
         for inp in self.inputs:
             try:
-                transaction_hash = self.signature_hash(inp.index_n, inp.hash_type, inp.witness_type)
+                transaction_hash = self.signature_hash(
+                    inp.index_n, inp.hash_type, inp.witness_type
+                )
             except TransactionError as e:
                 _logger.info("Could not create transaction hash. Error: %s" % e)
                 return False
             if not transaction_hash:
-                _logger.info("Need at least 1 key to create segwit transaction signature")
+                _logger.info(
+                    "Need at least 1 key to create segwit transaction signature"
+                )
                 return False
             self.verified = inp.verify(transaction_hash)
-            print('ver', self.verified)
             if not self.verified:
                 return False
 
         self.verified = True
         return True
 
     @abstractmethod
@@ -1808,15 +2175,16 @@
         pass
 
     @classmethod
     @abstractmethod
     def parse_bytesio(self):
         pass
 
-class Transaction(BaseTransaction):
+
+class BitcoinTransaction(BaseTransaction):
     """
     Transaction Class
 
     Contains 1 or more Input class object with UTXO's to spent and 1 or more Output class objects with destinations.
     Besides the transaction class contains a locktime and version.
 
     Inputs and outputs can be included when creating the transaction, or can be added later with add_input and
@@ -1839,108 +2207,150 @@
         :param network: Network, leave empty for default network
         :type network: str, Network
 
         :return Transaction:
         """
         coinbase = False
         flag = None
-        witness_type = 'legacy'
+        witness_type = "legacy"
         network = network
         if not isinstance(network, Network):
             cls.network = Network(network)
-        raw_bytes = b''
+        raw_bytes = b""
 
         try:
             pos_start = rawtx.tell()
         except AttributeError:
-            raise TransactionError("Provide raw transaction as BytesIO. Use parse, parse_bytes, parse_hex to parse "
-                                   "other data types")
+            raise TransactionError(
+                "Provide raw transaction as BytesIO. Use parse, parse_bytes, parse_hex to parse "
+                "other data types"
+            )
 
         version = rawtx.read(4)[::-1]
-        if rawtx.read(1) == b'\0':
+        if rawtx.read(1) == b"\0":
             flag = rawtx.read(1)
-            if flag == b'\1':
-                witness_type = 'segwit'
+            if flag == b"\1":
+                witness_type = "segwit"
         else:
             rawtx.seek(-1, 1)
 
         n_inputs = read_varbyteint(rawtx)
         inputs = []
         for n in range(0, n_inputs):
-            inp = Input.parse(rawtx, index_n=n, witness_type=witness_type, strict=strict, network=network)
-            if inp.prev_txid == 32 * b'\0':
+            inp = Input.parse(
+                rawtx,
+                index_n=n,
+                witness_type=witness_type,
+                strict=strict,
+                network=network,
+            )
+            if inp.prev_txid == 32 * b"\0":
                 coinbase = True
             inputs.append(inp)
 
         outputs = []
         output_total = 0
         n_outputs = read_varbyteint(rawtx)
         for n in range(0, n_outputs):
             o = Output.parse(rawtx, output_n=n, strict=strict, network=network)
             outputs.append(o)
             output_total += o.value
         if not outputs:
             raise TransactionError("Error no outputs found in this transaction")
 
-        if witness_type == 'segwit':
+        if witness_type == "segwit":
             for n in range(0, len(inputs)):
                 n_items = read_varbyteint(rawtx)
                 if not n_items:
                     continue
                 script = Script()
                 for m in range(0, n_items):
                     item_size = read_varbyteint(rawtx)
                     witness = rawtx.read(item_size)
                     inputs[n].witnesses.append(witness)
                     s = Script.parse_bytes(varstr(witness), strict=strict)
                     script += s
 
-                inputs[n].script = script if not inputs[n].script else inputs[n].script + script
+                inputs[n].script = (
+                    script if not inputs[n].script else inputs[n].script + script
+                )
                 inputs[n].keys = script.keys
                 inputs[n].signatures = script.signatures
-                if script.script_types[0][:13] == 'p2sh_multisig' or script.script_types[0] == 'signature_multisig':  # , 'p2sh_p2wsh'
-                    inputs[n].script_type = 'p2sh_multisig'
+                if (
+                    script.script_types[0][:13] == "p2sh_multisig"
+                    or script.script_types[0] == "signature_multisig"
+                ):  # , 'p2sh_p2wsh'
+                    inputs[n].script_type = "p2sh_multisig"
                     inputs[n].redeemscript = inputs[n].witnesses[-1]
-                elif inputs[n].script_type == 'p2wpkh':
-                    inputs[n].script_type = 'p2sh_p2wpkh'
-                    inputs[n].witness_type = 'p2sh-segwit'
-                elif inputs[n].script_type == 'p2wpkh' or inputs[n].script_type == 'p2wsh':
-                    inputs[n].script_type = 'p2sh_p2wsh'
-                    inputs[n].witness_type = 'p2sh-segwit'
+                elif inputs[n].script_type == "p2wpkh":
+                    inputs[n].script_type = "p2sh_p2wpkh"
+                    inputs[n].witness_type = "p2sh-segwit"
+                elif (
+                    inputs[n].script_type == "p2wpkh"
+                    or inputs[n].script_type == "p2wsh"
+                ):
+                    inputs[n].script_type = "p2sh_p2wsh"
+                    inputs[n].witness_type = "p2sh-segwit"
 
                 inputs[n].update_scripts()
 
-        locktime = int.from_bytes(rawtx.read(4)[::-1], 'big')
+        locktime = int.from_bytes(rawtx.read(4)[::-1], "big")
         raw_len = len(raw_bytes)
         if not raw_bytes:
             pos_end = rawtx.tell()
             raw_len = pos_end - pos_start
             rawtx.seek(pos_start)
             raw_bytes = rawtx.read(raw_len)
 
-        return Transaction(inputs, outputs, locktime, version, network, size=raw_len, output_total=output_total,
-                           coinbase=coinbase, flag=flag, witness_type=witness_type, rawtx=raw_bytes)
+        return BitcoinTransaction(
+            inputs,
+            outputs,
+            locktime,
+            version,
+            network,
+            size=raw_len,
+            output_total=output_total,
+            coinbase=coinbase,
+            flag=flag,
+            witness_type=witness_type,
+            rawtx=raw_bytes,
+        )
 
+    def __repr__(self):
+        return (
+            "<BitcoinTransaction(id=%s, inputs=%d, outputs=%d, status=%s, network=%s)>"
+            % (
+                self.txid,
+                len(self.inputs),
+                len(self.outputs),
+                self.status,
+                self.network.name,
+            )
+        )
 
-    def signature_hash(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False):
+    def signature_hash(
+        self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False
+    ):
         """
         Double SHA256 Hash of Transaction signature
 
         :param sign_id: Index of input to sign
         :type sign_id: int
         :param hash_type: Specific hash type, default is SIGHASH_ALL
         :type hash_type: int
         :param witness_type: Legacy or Segwit witness type? Leave empty to use Transaction witness type
         :type witness_type: str
         :param as_hex: Return value as hexadecimal string. Default is False
         :type as_hex: bool
 
         :return bytes: Transaction signature hash
         """
-        return double_sha256(self.signature(sign_id, hash_type, witness_type), as_hex=as_hex)
+        return double_sha256(
+            self.signature(sign_id, hash_type, witness_type), as_hex=as_hex
+        )
 
     def signature(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):
         """
         Serializes transaction and calculates signature for Legacy or Segwit transactions
 
         :param sign_id: Index of input to sign
         :type sign_id: int
@@ -1950,17 +2360,17 @@
         :type witness_type: str
 
         :return bytes: Transaction signature
         """
 
         if witness_type is None:
             witness_type = self.witness_type
-        if witness_type == 'legacy' or sign_id is None:
-            return self.raw(sign_id, hash_type, 'legacy')
-        elif witness_type in ['segwit', 'p2sh-segwit']:
+        if witness_type == "legacy" or sign_id is None:
+            return self.raw(sign_id, hash_type, "legacy")
+        elif witness_type in ["segwit", "p2sh-segwit"]:
             return self.signature_segwit(sign_id, hash_type)
         else:
             raise TransactionError("Witness_type %s not supported" % self.witness_type)
 
     def signature_segwit(self, sign_id, hash_type=SIGHASH_ALL):
         """
         Serialize transaction signature for segregated witness transaction
@@ -1968,57 +2378,74 @@
         :param sign_id: Index of input to sign
         :type sign_id: int
         :param hash_type: Specific hash type, default is SIGHASH_ALL
         :type hash_type: int
 
         :return bytes: Segwit transaction signature
         """
-        assert (self.witness_type == 'segwit')
-        prevouts_serialized = b''
-        sequence_serialized = b''
-        outputs_serialized = b''
-        hash_prevouts = b'\0' * 32
-        hash_sequence = b'\0' * 32
-        hash_outputs = b'\0' * 32
+        assert self.witness_type == "segwit"
+        prevouts_serialized = b""
+        sequence_serialized = b""
+        outputs_serialized = b""
+        hash_prevouts = b"\0" * 32
+        hash_sequence = b"\0" * 32
+        hash_outputs = b"\0" * 32
 
         for i in self.inputs:
             prevouts_serialized += i.prev_txid[::-1] + i.output_n[::-1]
-            sequence_serialized += i.sequence.to_bytes(4, 'little')
+            sequence_serialized += i.sequence.to_bytes(4, "little")
         if not hash_type & SIGHASH_ANYONECANPAY:
             hash_prevouts = double_sha256(prevouts_serialized)
-            if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:
+            if (hash_type & 0x1F) != SIGHASH_SINGLE and (
+                hash_type & 0x1F
+            ) != SIGHASH_NONE:
                 hash_sequence = double_sha256(sequence_serialized)
-        if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:
+        if (hash_type & 0x1F) != SIGHASH_SINGLE and (hash_type & 0x1F) != SIGHASH_NONE:
             for o in self.outputs:
-                outputs_serialized += int(o.value).to_bytes(8, 'little')
+                outputs_serialized += int(o.value).to_bytes(8, "little")
                 outputs_serialized += varstr(o.lock_script)
             hash_outputs = double_sha256(outputs_serialized)
-        elif (hash_type & 0x1f) != SIGHASH_SINGLE and sign_id < len(self.outputs):
-            outputs_serialized += int(self.outputs[sign_id].value).to_bytes(8, 'little')
+        elif (hash_type & 0x1F) != SIGHASH_SINGLE and sign_id < len(self.outputs):
+            outputs_serialized += int(self.outputs[sign_id].value).to_bytes(8, "little")
             outputs_serialized += varstr(self.outputs[sign_id].lock_script)
             hash_outputs = double_sha256(outputs_serialized)
 
-        is_coinbase = self.inputs[sign_id].script_type == 'coinbase'
+        is_coinbase = self.inputs[sign_id].script_type == "coinbase"
         if not self.inputs[sign_id].value and not is_coinbase:
-            raise TransactionError("Need value of input %d to create transaction signature, value can not be 0" %
-                                   sign_id)
+            raise TransactionError(
+                "Need value of input %d to create transaction signature, value can not be 0"
+                % sign_id
+            )
 
         if not self.inputs[sign_id].redeemscript:
             self.inputs[sign_id].redeemscript = self.inputs[sign_id].script_code
 
-        if (not self.inputs[sign_id].redeemscript or self.inputs[sign_id].redeemscript == b'\0') and \
-                self.inputs[sign_id].redeemscript != 'unknown' and not is_coinbase:
+        if (
+            (
+                not self.inputs[sign_id].redeemscript
+                or self.inputs[sign_id].redeemscript == b"\0"
+            )
+            and self.inputs[sign_id].redeemscript != "unknown"
+            and not is_coinbase
+        ):
             raise TransactionError("Redeem script missing")
 
-        ser_tx = \
-            self.version[::-1] + hash_prevouts + hash_sequence + self.inputs[sign_id].prev_txid[::-1] + \
-            self.inputs[sign_id].output_n[::-1] + \
-            varstr(self.inputs[sign_id].redeemscript) + int(self.inputs[sign_id].value).to_bytes(8, 'little') + \
-            self.inputs[sign_id].sequence.to_bytes(4, 'little') + \
-            hash_outputs + self.locktime.to_bytes(4, 'little') + hash_type.to_bytes(4, 'little')
+        ser_tx = (
+            self.version[::-1]
+            + hash_prevouts
+            + hash_sequence
+            + self.inputs[sign_id].prev_txid[::-1]
+            + self.inputs[sign_id].output_n[::-1]
+            + varstr(self.inputs[sign_id].redeemscript)
+            + int(self.inputs[sign_id].value).to_bytes(8, "little")
+            + self.inputs[sign_id].sequence.to_bytes(4, "little")
+            + hash_outputs
+            + self.locktime.to_bytes(4, "little")
+            + hash_type.to_bytes(4, "little")
+        )
         return ser_tx
 
     def raw(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):
         """
         Serialize raw transaction
 
         Return transaction with signed inputs if signatures are available
@@ -2033,72 +2460,78 @@
         :return bytes:
         """
 
         if witness_type is None:
             witness_type = self.witness_type
 
         r = self.version[::-1]
-        if sign_id is None and witness_type == 'segwit':
-            r += b'\x00'  # marker (BIP 141)
-            r += b'\x01'  # flag (BIP 141)
+        if sign_id is None and witness_type == "segwit":
+            r += b"\x00"  # marker (BIP 141)
+            r += b"\x01"  # flag (BIP 141)
 
         r += int_to_varbyteint(len(self.inputs))
-        r_witness = b''
+        r_witness = b""
         for i in self.inputs:
             r += i.prev_txid[::-1] + i.output_n[::-1]
-            if i.witnesses and i.witness_type != 'legacy':
-                r_witness += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])
+            if i.witnesses and i.witness_type != "legacy":
+                r_witness += int_to_varbyteint(len(i.witnesses)) + b"".join(
+                    [bytes(varstr(w)) for w in i.witnesses]
+                )
             else:
-                r_witness += b'\0'
+                r_witness += b"\0"
             if sign_id is None:
                 r += varstr(i.unlocking_script)
             elif sign_id == i.index_n:
                 r += varstr(i.unlocking_script_unsigned)
             else:
-                r += b'\0'
-            r += i.sequence.to_bytes(4, 'little')
+                r += b"\0"
+            r += i.sequence.to_bytes(4, "little")
 
         r += int_to_varbyteint(len(self.outputs))
         for o in self.outputs:
             if o.value < 0:
                 raise TransactionError("Output value < 0 not allowed")
-            r += int(o.value).to_bytes(8, 'little')
+            r += int(o.value).to_bytes(8, "little")
             r += varstr(o.lock_script)
 
-        if sign_id is None and witness_type == 'segwit':
+        if sign_id is None and witness_type == "segwit":
             r += r_witness
 
-        r += self.locktime.to_bytes(4, 'little')
+        r += self.locktime.to_bytes(4, "little")
         if sign_id is not None:
-            r += hash_type.to_bytes(4, 'little')
+            r += hash_type.to_bytes(4, "little")
         else:
-            if not self.size and b'' not in [i.unlocking_script for i in self.inputs]:
+            if not self.size and b"" not in [i.unlocking_script for i in self.inputs]:
                 self.size = len(r)
                 self.calc_weight_units()
         return r
 
     def witness_data(self):
         """
         Get witness data for all inputs of this transaction
 
         :return bytes:
         """
-        witness_data = b''
+        witness_data = b""
         for i in self.inputs:
-            witness_data += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])
+            witness_data += int_to_varbyteint(len(i.witnesses)) + b"".join(
+                [bytes(varstr(w)) for w in i.witnesses]
+            )
         return witness_data
 
 
 class FluxTransaction(BaseTransaction):
     @classmethod
     def parse_input_bytes(cls, raw: BytesIO) -> TxIn:
         prev_hash = raw.read(32)
 
         if len(prev_hash) != 32:
-            raise TransactionError("Input transaction hash not found. Probably malformed raw transaction")
+            raise TransactionError(
+                "Input transaction hash not found. Probably malformed raw transaction"
+            )
 
         output_n = raw.read(4)
         output_n = int.from_bytes(output_n, "little")
         unlocking_script_size = read_varbyteint(raw)
         unlocking_script = raw.read(unlocking_script_size)
         sequence_number = raw.read(4)
         sequence_number = int.from_bytes(sequence_number, "little")
@@ -2128,14 +2561,15 @@
         :param strict: Raise exception when transaction is malformed, incomplete or not understood
         :type strict: bool
         :param network: Network, leave empty for default network
         :type network: str, Network
 
         :return Transaction:
         """
+
         coinbase = False
         flag = None
         witness_type = "legacy"
 
         raw_bytes = b""
 
         try:
@@ -2194,18 +2628,40 @@
             vin=inputs,
             vout=outputs,
             nLockTime=locktime,
             nExpiryHeight=expiry_height,
             valuebalance=value_balance,
         )
 
-    def __init__(self, *args, version: int = 4, expiry_height: int = 0, lock_time: int = 0, **kwargs):
+    def __init__(
+        self,
+        *args,
+        version: int | bytes = 4,
+        expiry_height: int = 0,
+        lock_time: int = 0,
+        **kwargs,
+    ):
+        # so we don't have to modify BaseTransaction
+        if isinstance(version, bytes):
+            version = int.from_bytes(version, byteorder="big")
+
         self.sapling_tx = SaplingTx(version, nExpiryHeight=expiry_height)
+        super().__init__(*args, version=version, expiry_height=expiry_height, **kwargs)
 
-        super(FluxTransaction, self).__init__(*args, **kwargs)
+    def __repr__(self):
+        return (
+            "<FluxTransaction(id=%s, inputs=%d, outputs=%d, status=%s, network=%s)>"
+            % (
+                self.txid,
+                len(self.inputs),
+                len(self.outputs),
+                self.status,
+                self.network.name,
+            )
+        )
 
     def raw(self, sign_id=None, hash_type=SIGHASH_ALL, **kwargs) -> bytes:
         for i in self.inputs:
             match sign_id:
                 case None:
                     script = FluxScript.from_bytes(i.unlocking_script)
                 case i.index_n:
@@ -2222,26 +2678,41 @@
         if self.inputs or self.outputs:
             self.sapling_tx.vout = []
             self.sapling_tx.vin = []
             for input in self.inputs:
                 # investigate why prev_txid is reversed?!?
                 outpoint = OutPoint(input.prev_txid[::-1], input.output_n_int)
                 unlocking_script = FluxScript(input.unlocking_script)
-                self.sapling_tx.vin.append(TxIn(outpoint, unlocking_script, input.sequence))
+                self.sapling_tx.vin.append(
+                    TxIn(outpoint, unlocking_script, input.sequence)
+                )
 
             for output in self.outputs:
-                self.sapling_tx.vout.append(TxOut(output.value, FluxScript.from_bytes(output.script.raw)))
-
-    def signature_hash(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False) -> bytes:
-
+                self.sapling_tx.vout.append(
+                    TxOut(output.value, FluxScript.from_bytes(output.script.raw))
+                )
+
+    def signature_hash(
+        self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False
+    ) -> bytes:
         if sign_id == None:
             return b""
 
         self.sync_tx()
         value = self.inputs[sign_id].value if self.inputs else 0
         n_inputs = len(self.inputs)
 
         script_code = self.inputs[sign_id].unlocking_script_unsigned
 
         sighash = self.sapling_tx.signature_hash(script_code, value, sign_id, n_inputs)
 
-        return sighash
+        return sighash
+
+    def witness_data(self):
+        """
+        Get witness data for all inputs of this transaction
+
+        Just a hack, so we don't have to modify BaseTransaction as FLux has no witness data.
+
+        :return bytes:
+        """
+        return b""
```

### Comparing `fluxwallet-0.0.6/fluxwallet/values.py` & `fluxwallet-0.1.0/fluxwallet/values.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,15 +33,18 @@
 
     :return int:
     """
     if isinstance(value, str):
         value = Value(value)
     if isinstance(value, Value):
         if network and value.network != network:
-            raise ValueError("Value uses different network (%s) then supplied network: %s" % (value.network.name, network))
+            raise ValueError(
+                "Value uses different network (%s) then supplied network: %s"
+                % (value.network.name, network)
+            )
         value = value.value_sat
     return value
 
 
 class Value:
     """
     Class to represent and convert cryptocurrency values
@@ -64,15 +67,19 @@
         """
         if not isinstance(network, Network):
             network = Network(network)
         if denominator is None:
             denominator = network.denominator
         else:
             if isinstance(denominator, str):
-                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]
+                dens = [
+                    den
+                    for den, symb in NETWORK_DENOMINATORS.items()
+                    if symb == denominator
+                ]
                 if dens:
                     denominator = dens[0]
             value = value * (network.denominator / denominator)
         return cls(value or 0, denominator, network)
 
     def __init__(self, value, denominator=None, network=DEFAULT_NETWORK):
         """
@@ -138,37 +145,46 @@
         :type network: str, Network
 
         """
         self.network = network
         if not isinstance(network, Network):
             self.network = Network(network)
         if isinstance(denominator, str):
-            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]
+            dens = [
+                den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator
+            ]
             if dens:
                 denominator = dens[0]
         den_arg = denominator
 
         if isinstance(value, str):
             value_items = value.split()
             value = value_items[0]
             cur_code = self.network.currency_code
             den_input = 1
             if len(value_items) > 1:
                 cur_code = value_items[1]
-            network_names = [n for n in NETWORK_DEFINITIONS if
-                             NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]
+            network_names = [
+                n
+                for n in NETWORK_DEFINITIONS
+                if NETWORK_DEFINITIONS[n]["currency_code"].upper() == cur_code.upper()
+            ]
             if network_names:
                 self.network = Network(network_names[0])
                 self.currency = cur_code
             else:
                 for den, symb in NETWORK_DENOMINATORS.items():
-                    if len(symb) and cur_code[:len(symb)] == symb:
-                        cur_code = cur_code[len(symb):]
-                        network_names = [n for n in NETWORK_DEFINITIONS if
-                                         NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]
+                    if len(symb) and cur_code[: len(symb)] == symb:
+                        cur_code = cur_code[len(symb) :]
+                        network_names = [
+                            n
+                            for n in NETWORK_DEFINITIONS
+                            if NETWORK_DEFINITIONS[n]["currency_code"].upper()
+                            == cur_code.upper()
+                        ]
                         if network_names:
                             self.network = Network(network_names[0])
                             self.currency = cur_code
                         elif len(cur_code):
                             raise ValueError("Currency symbol not recognised")
                         den_input = den
                         break
@@ -178,16 +194,19 @@
             self.denominator = den_arg or 1.0
             self.value = float(value) * self.denominator
 
     def __str__(self):
         return self.str()
 
     def __repr__(self):
-        return "Value(value=%.14f, denominator=%.8f, network='%s')" % \
-               (self.value, self.denominator, self.network.name)
+        return "Value(value=%.14f, denominator=%.8f, network='%s')" % (
+            self.value,
+            self.denominator,
+            self.network.name,
+        )
 
     def __int__(self):
         return int(self.value)
 
     def __float__(self):
         if self.value > self.network.denominator:
             return round(self.value, -int(math.log10(self.network.denominator)))
@@ -227,54 +246,68 @@
         return self.value > other.value
 
     def __add__(self, other):
         if isinstance(other, Value):
             if self.network != other.network:
                 raise ValueError("Cannot calculate with values from different networks")
             other = other.value
-        return Value((self.value + other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value + other) / self.denominator, self.denominator, self.network
+        )
 
     def __iadd__(self, other):
         if isinstance(other, Value):
             if self.network != other.network:
                 raise ValueError("Cannot calculate with values from different networks")
             other = other.value
-        return Value((self.value + other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value + other) / self.denominator, self.denominator, self.network
+        )
 
     def __isub__(self, other):
         if isinstance(other, Value):
             if self.network != other.network:
                 raise ValueError("Cannot calculate with values from different networks")
             other = other.value
-        return Value((self.value - other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value - other) / self.denominator, self.denominator, self.network
+        )
 
     def __sub__(self, other):
         if isinstance(other, Value):
             if self.network != other.network:
                 raise ValueError("Cannot calculate with values from different networks")
             other = other.value
-        return Value((self.value - other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value - other) / self.denominator, self.denominator, self.network
+        )
 
     def __mul__(self, other):
-        return Value((self.value * other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value * other) / self.denominator, self.denominator, self.network
+        )
 
     def __truediv__(self, other):
-        return Value((self.value / other) / self.denominator, self.denominator, self.network)
+        return Value(
+            (self.value / other) / self.denominator, self.denominator, self.network
+        )
 
     def __floordiv__(self, other):
-        return Value(((self.value / self.denominator) // other), self.denominator, self.network)
+        return Value(
+            ((self.value / self.denominator) // other), self.denominator, self.network
+        )
 
     def __round__(self, n=0):
         val = round(self.value / self.denominator, n) * self.denominator
         return Value(val, self.denominator, self.network)
 
     def __index__(self):
         return self.value_sat
 
-    def str(self, denominator=None, decimals=None, currency_repr='code'):
+    def str(self, denominator=None, decimals=None, currency_repr="code"):
         """
         Get string representation of Value with requested denominator and number of decimals.
 
         >>> Value(1200000, 'sat').str('m')  # milli Bitcoin
         '12.00000 mBTC'
 
         >>> Value(12000.3, 'sat').str(1)  # Use denominator = 1 for Bitcoin
@@ -308,30 +341,38 @@
         :param currency_repr: Representation of currency. I.e. code: BTC, name: bitcoins, symbol: 
         :type currency_repr: str
 
         :return str:
         """
         if denominator is None:
             denominator = self.denominator
-        elif denominator == 'auto':
+        elif denominator == "auto":
             # First try denominator=1 and smallest denominator (satoshi)
             if 0.001 <= self.value < 1000:
                 denominator = 1
             elif 1 <= self.value / self.network.denominator < 1000:
                 denominator = self.network.denominator
             else:  # Try other frequently used denominators
                 for den, symb in NETWORK_DENOMINATORS.items():
-                    if symb in ['n', 'fin', 'da', 'c', 'd', 'h']:
+                    if symb in ["n", "fin", "da", "c", "d", "h"]:
                         continue
                     if 1 <= self.value / den < 1000:
                         denominator = den
         elif isinstance(denominator, str):
-            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator[:len(symb)] and len(symb)]
+            dens = [
+                den
+                for den, symb in NETWORK_DENOMINATORS.items()
+                if symb == denominator[: len(symb)] and len(symb)
+            ]
             if len(dens) > 1:
-                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]
+                dens = [
+                    den
+                    for den, symb in NETWORK_DENOMINATORS.items()
+                    if symb == denominator
+                ]
             if dens:
                 denominator = dens[0]
         if denominator in NETWORK_DENOMINATORS:
             den_symb = NETWORK_DENOMINATORS[denominator]
         else:
             raise ValueError("Denominator not found in NETWORK_DENOMINATORS definition")
 
@@ -339,38 +380,40 @@
             decimals = -int(math.log10(self.network.denominator / denominator))
             if decimals > 8:
                 decimals = 8
         if decimals < 0:
             decimals = 0
         balance = round(self.value / denominator, decimals)
         cur_code = self.network.currency_code
-        if currency_repr == 'symbol':
+        if currency_repr == None:
+            cur_code = ""
+        if currency_repr == "symbol":
             cur_code = self.network.currency_symbol
-        if currency_repr == 'name':
+        if currency_repr == "name":
             cur_code = self.network.currency_name_plural
-        if 'sat' in den_symb and self.network.name == 'bitcoin':
-            cur_code = ''
+        if "sat" in den_symb and self.network.name == "bitcoin":
+            cur_code = ""
         return ("%%.%df %%s%%s" % decimals) % (balance, den_symb, cur_code)
 
-    def str_unit(self, decimals=None, currency_repr='code'):
+    def str_unit(self, decimals=None, currency_repr="code"):
         """
         String representation of this Value. Wrapper for the :func:`str` method, but always uses 1 as denominator, meaning main denominator such as BTC, LTC.
 
         >>> Value('12000 sat').str_unit()
         '0.00012000 BTC'
 
         :param decimals: Number of decimals to use
         :type decimals: float
         :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: 
         :type currency_repr: str
         :return str:
         """
         return self.str(1, decimals, currency_repr)
 
-    def str_auto(self, decimals=None, currency_repr='code'):
+    def str_auto(self, decimals=None, currency_repr="code"):
         """
         String representation of this Value. Wrapper for the :func:`str` method, but automatically determines the denominator depending on the value.
 
         >>> Value('0.0000012 BTC').str_auto()
         '120 sat'
 
         >>> Value('0.0005 BTC').str_auto()
@@ -379,26 +422,26 @@
         :param decimals: Number of decimals to use
         :type decimals: float
         :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: 
         :type currency_repr: str
         :return str:
         """
 
-        return self.str('auto', decimals, currency_repr)
+        return self.str("auto", decimals, currency_repr)
 
     @property
     def value_sat(self):
         """
         Value in the smallest denominator, i.e. Satoshi for the Bitcoin network
 
         :return int:
         """
         return round(self.value / self.network.denominator)
 
-    def to_bytes(self, length=8, byteorder='little'):
+    def to_bytes(self, length=8, byteorder="little"):
         """
         Representation of value_sat (value in the smallest denominator: satoshi's) as bytes string. Used for script or transaction serialization.
 
         >>> Value('1 sat').to_bytes()
         b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00'
 
         :param length: Length of bytes string to return, default is 8 bytes
@@ -406,15 +449,15 @@
         :param byteorder: Order of bytes: little or big endian. Default is 'little'
         :type byteorder: str
 
         :return bytes:
         """
         return self.value_sat.to_bytes(length, byteorder)
 
-    def to_hex(self, length=16, byteorder='little'):
+    def to_hex(self, length=16, byteorder="little"):
         """
         Representation of value_sat (value in the smallest denominator: satoshi's) as hexadecimal string.
 
         >>> Value('15 sat').to_hex()
         '0f00000000000000'
 
         :param length: Length of hexadecimal string to return, default is 16 characters
```

### Comparing `fluxwallet-0.0.6/fluxwallet/wallets.py` & `fluxwallet-0.1.0/fluxwallet/wallets.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,44 +12,57 @@
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 #    GNU Affero General Public License for more details.
 #
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
-
 import json
 import pickle
 import random
 from itertools import groupby
 from operator import itemgetter
 
 import numpy as np
+from rich.pretty import pprint
 from sqlalchemy import func, or_
 
 from fluxwallet.db import *
 from fluxwallet.encoding import *
-from fluxwallet.keys import (Address, BKeyError, HDKey, check_network_and_key,
-                             path_expand)
+from fluxwallet.keys import (
+    Address,
+    BKeyError,
+    HDKey,
+    check_network_and_key,
+    path_expand,
+)
 from fluxwallet.mnemonic import Mnemonic
 from fluxwallet.networks import Network
 from fluxwallet.scripts import Script
 from fluxwallet.services.services import Service
-from fluxwallet.transactions import Input, Output, BaseTransaction, Transaction, FluxTransaction, get_unlocking_script_type
+from fluxwallet.transactions import (
+    BaseTransaction,
+    FluxTransaction,
+    Input,
+    Output,
+    Transaction,
+    get_unlocking_script_type,
+)
 from fluxwallet.values import Value, value_to_satoshi
 
 _logger = logging.getLogger(__name__)
 
 
 class WalletError(Exception):
     """
     Handle Wallet class Exceptions
 
     """
-    def __init__(self, msg=''):
+
+    def __init__(self, msg=""):
         self.msg = msg
         _logger.error(msg)
 
     def __str__(self):
         return self.msg
 
 
@@ -63,29 +76,32 @@
     :param include_cosigners: Child wallets for multisig wallets are for internal use only and are skipped by default
     :type include_cosigners: bool
 
     :return dict: Dictionary of wallets defined in database
     """
 
     session = Db(db_uri=db_uri).session
+
     wallets = session.query(DbWallet).order_by(DbWallet.id).all()
     wlst = []
     for w in wallets:
         if w.parent_id and not include_cosigners:
             continue
-        wlst.append({
-            'id': w.id,
-            'name': w.name,
-            'owner': w.owner,
-            'network': w.network_name,
-            'purpose': w.purpose,
-            'scheme': w.scheme,
-            'main_key_id': w.main_key_id,
-            'parent_id': w.parent_id,
-        })
+        wlst.append(
+            {
+                "id": w.id,
+                "name": w.name,
+                "owner": w.owner,
+                "network": w.network_name,
+                "purpose": w.purpose,
+                "scheme": w.scheme,
+                "main_key_id": w.main_key_id,
+                "parent_id": w.parent_id,
+            }
+        )
     session.close()
     return wlst
 
 
 def wallet_exists(wallet, db_uri=None):
     """
     Check if Wallets is defined in database
@@ -94,40 +110,69 @@
     :type wallet: int, str
     :param db_uri: URI of the database
     :type db_uri: str
 
     :return bool: True if wallet exists otherwise False
     """
 
-    if wallet in [x['name'] for x in wallets_list(db_uri)]:
+    if wallet in [x["name"] for x in wallets_list(db_uri)]:
         return True
-    if isinstance(wallet, int) and wallet in [x['id'] for x in wallets_list(db_uri)]:
+    if isinstance(wallet, int) and wallet in [x["id"] for x in wallets_list(db_uri)]:
         return True
     return False
 
 
 def wallet_create_or_open(
-        name, keys='', owner='', network=None, account_id=0, purpose=None, scheme='bip32', sort_keys=True,
-        password='', witness_type=None, encoding=None, multisig=None, sigs_required=None, cosigner_id=None,
-        key_path=None, db_uri=None):
+    name,
+    keys="",
+    owner="",
+    network=None,
+    account_id=0,
+    purpose=None,
+    scheme="bip32",
+    sort_keys=True,
+    password="",
+    witness_type=None,
+    encoding=None,
+    multisig=None,
+    sigs_required=None,
+    cosigner_id=None,
+    key_path=None,
+    db_uri=None,
+):
     """
     Create a wallet with specified options if it doesn't exist, otherwise just open
 
     Returns Wallet object
 
     See Wallets class create method for option documentation
     """
     if wallet_exists(name, db_uri=db_uri):
         if keys or owner or password or witness_type or key_path:
             _logger.warning("Opening existing wallet, extra options are ignored")
         return Wallet(name, db_uri=db_uri)
     else:
-        return Wallet.create(name, keys, owner, network, account_id, purpose, scheme, sort_keys,
-                             password, witness_type, encoding, multisig, sigs_required, cosigner_id,
-                             key_path, db_uri=db_uri)
+        return Wallet.create(
+            name,
+            keys,
+            owner,
+            network,
+            account_id,
+            purpose,
+            scheme,
+            sort_keys,
+            password,
+            witness_type,
+            encoding,
+            multisig,
+            sigs_required,
+            cosigner_id,
+            key_path,
+            db_uri=db_uri,
+        )
 
 
 def wallet_delete(wallet, db_uri=None, force=False):
     """
     Delete wallet and associated keys and transactions from the database. If wallet has unspent outputs it raises a
     WalletError exception unless 'force=True' is specified
 
@@ -155,33 +200,43 @@
     for cw in session.query(DbWallet).filter_by(parent_id=wallet_id).all():
         wallet_delete(cw.id, db_uri=db_uri, force=force)
 
     # Delete keys from this wallet and update transactions (remove key_id)
     ks = session.query(DbKey).filter_by(wallet_id=wallet_id)
     if bool([k for k in ks if k.balance and k.is_private]) and not force:
         session.close()
-        raise WalletError("Wallet still has unspent outputs. Use 'force=True' to delete this wallet")
+        raise WalletError(
+            "Wallet still has unspent outputs. Use 'force=True' to delete this wallet"
+        )
     k_ids = [k.id for k in ks]
-    session.query(DbTransactionOutput).filter(DbTransactionOutput.key_id.in_(k_ids)).update(
-        {DbTransactionOutput.key_id: None})
-    session.query(DbTransactionInput).filter(DbTransactionInput.key_id.in_(k_ids)).update(
-        {DbTransactionInput.key_id: None})
-    session.query(DbKeyMultisigChildren).filter(DbKeyMultisigChildren.parent_id.in_(k_ids)).delete()
-    session.query(DbKeyMultisigChildren).filter(DbKeyMultisigChildren.child_id.in_(k_ids)).delete()
+    session.query(DbTransactionOutput).filter(
+        DbTransactionOutput.key_id.in_(k_ids)
+    ).update({DbTransactionOutput.key_id: None})
+    session.query(DbTransactionInput).filter(
+        DbTransactionInput.key_id.in_(k_ids)
+    ).update({DbTransactionInput.key_id: None})
+    session.query(DbKeyMultisigChildren).filter(
+        DbKeyMultisigChildren.parent_id.in_(k_ids)
+    ).delete()
+    session.query(DbKeyMultisigChildren).filter(
+        DbKeyMultisigChildren.child_id.in_(k_ids)
+    ).delete()
     ks.delete()
 
     # Delete incomplete transactions from wallet
     txs = session.query(DbTransaction).filter_by(wallet_id=wallet_id, is_complete=False)
     for tx in txs:
         session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()
         session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()
     txs.delete()
 
     # Unlink transactions from this wallet (remove wallet_id)
-    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update({DbTransaction.wallet_id: None})
+    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update(
+        {DbTransaction.wallet_id: None}
+    )
 
     res = w.delete()
     session.commit()
     session.close()
 
     _logger.info("Wallet '%s' deleted" % wallet)
 
@@ -209,29 +264,35 @@
     if not w or not w.first():
         raise WalletError("Wallet '%s' not found" % wallet)
     wallet_id = w.first().id
 
     # Delete keys from this wallet and update transactions (remove key_id)
     ks = session.query(DbKey).filter(DbKey.wallet_id == wallet_id, DbKey.parent_id != 0)
     for k in ks:
-        session.query(DbTransactionOutput).filter_by(key_id=k.id).update({DbTransactionOutput.key_id: None})
-        session.query(DbTransactionInput).filter_by(key_id=k.id).update({DbTransactionInput.key_id: None})
+        session.query(DbTransactionOutput).filter_by(key_id=k.id).update(
+            {DbTransactionOutput.key_id: None}
+        )
+        session.query(DbTransactionInput).filter_by(key_id=k.id).update(
+            {DbTransactionInput.key_id: None}
+        )
         session.query(DbKeyMultisigChildren).filter_by(parent_id=k.id).delete()
         session.query(DbKeyMultisigChildren).filter_by(child_id=k.id).delete()
     ks.delete()
 
     # Delete incomplete transactions from wallet
     txs = session.query(DbTransaction).filter_by(wallet_id=wallet_id, is_complete=False)
     for tx in txs:
         session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()
         session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()
     txs.delete()
 
     # Unlink transactions from this wallet (remove wallet_id)
-    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update({DbTransaction.wallet_id: None})
+    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update(
+        {DbTransaction.wallet_id: None}
+    )
 
     session.commit()
     session.close()
 
     _logger.info("All keys and transactions from wallet '%s' deleted" % wallet)
 
     return True
@@ -280,26 +341,40 @@
             nlevel = level[:-1] + "'"
         npath += nlevel + "/"
     if npath[-1] == "/":
         npath = npath[:-1]
     return npath
 
 
-class WalletKey(object):
+class WalletKey:
     """
     Used as attribute of Wallet class. Contains HDKey class, and adds extra wallet related information such as
     key ID, name, path and balance.
 
     All WalletKeys are stored in a database
     """
 
     @staticmethod
-    def from_key(name, wallet_id, session, key, account_id=0, network=None, change=0, purpose=44, parent_id=0,
-                 path='m', key_type=None, encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False,
-                 cosigner_id=None):
+    def from_key(
+        name,
+        wallet_id,
+        session,
+        key: HDKey | Address | str | bytes,
+        account_id: int = 0,
+        network: str | None = None,
+        change: int = 0,
+        purpose: int = 44,
+        parent_id: int = 0,
+        path: str = "m",
+        key_type=None,
+        encoding=None,
+        witness_type=DEFAULT_WITNESS_TYPE,
+        multisig=False,
+        cosigner_id=None,
+    ):
         """
         Create WalletKey from a HDKey object or key.
 
         Normally you don't need to call this method directly. Key creation is handled by the Wallet class.
 
         >>> w = wallet_create_or_open('hdwalletkey_test')
         >>> wif = 'xprv9s21ZrQH143K2mcs9jcK4EjALbu2z1N9qsMTUG1frmnXM3NNCSGR57yLhwTccfNCwdSQEDftgjCGm96P29wGGcbBsPqZH85iqpoHA7LrqVy'
@@ -338,80 +413,140 @@
         :param multisig: Specify if key is part of multisig wallet, used for create keys and key representations such as WIF and addreses
         :type multisig: bool
         :param cosigner_id: Set this if you would like to create keys for other cosigners.
         :type cosigner_id: int
 
         :return WalletKey: WalletKey object
         """
-
         key_is_address = False
         if isinstance(key, HDKey):
             k = key
             if network is None:
                 network = k.network.name
             elif network != k.network.name:
-                raise WalletError("Specified network and key network should be the same")
+                raise WalletError(
+                    "Specified network and key network should be the same"
+                )
         elif isinstance(key, Address):
             k = key
             key_is_address = True
             if network is None:
                 network = k.network.name
             elif network != k.network.name:
-                raise WalletError("Specified network and key network should be the same")
+                raise WalletError(
+                    "Specified network and key network should be the same"
+                )
         else:
             if network is None:
                 network = DEFAULT_NETWORK
             k = HDKey(import_key=key, network=network)
         if not encoding and witness_type:
             encoding = get_encoding_from_witness(witness_type)
         script_type = script_type_default(witness_type, multisig)
 
         if not key_is_address:
-            keyexists = session.query(DbKey).\
-                filter(DbKey.wallet_id == wallet_id,
-                       DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=True)).first()
+            keyexists = (
+                session.query(DbKey)
+                .filter(
+                    DbKey.wallet_id == wallet_id,
+                    DbKey.wif
+                    == k.wif(
+                        witness_type=witness_type, multisig=multisig, is_private=True
+                    ),
+                )
+                .first()
+            )
             if keyexists:
-                _logger.warning("Key already exists in this wallet. Key ID: %d" % keyexists.id)
+                _logger.warning(
+                    "Key already exists in this wallet. Key ID: %d" % keyexists.id
+                )
                 return WalletKey(keyexists.id, session, k)
 
-            if key_type != 'single' and k.depth != len(path.split('/'))-1:
-                if path == 'm' and k.depth > 1:
+            if key_type != "single" and k.depth != len(path.split("/")) - 1:
+                if path == "m" and k.depth > 1:
                     path = "M"
 
             address = k.address(encoding=encoding, script_type=script_type)
-            wk = session.query(DbKey).filter(
-                DbKey.wallet_id == wallet_id,
-                or_(DbKey.public == k.public_byte,
-                    DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=False),
-                    DbKey.address == address)).first()
+            wk = (
+                session.query(DbKey)
+                .filter(
+                    DbKey.wallet_id == wallet_id,
+                    or_(
+                        DbKey.public == k.public_byte,
+                        DbKey.wif
+                        == k.wif(
+                            witness_type=witness_type,
+                            multisig=multisig,
+                            is_private=False,
+                        ),
+                        DbKey.address == address,
+                    ),
+                )
+                .first()
+            )
             if wk:
-                wk.wif = k.wif(witness_type=witness_type, multisig=multisig, is_private=True)
+                wk.wif = k.wif(
+                    witness_type=witness_type, multisig=multisig, is_private=True
+                )
                 wk.is_private = True
                 wk.private = k.private_byte
                 wk.public = k.public_byte
                 wk.path = path
                 session.commit()
                 return WalletKey(wk.id, session, k)
 
-            nk = DbKey(name=name[:80], wallet_id=wallet_id, public=k.public_byte, private=k.private_byte, purpose=purpose,
-                       account_id=account_id, depth=k.depth, change=change, address_index=k.child_index,
-                       wif=k.wif(witness_type=witness_type, multisig=multisig, is_private=True), address=address,
-                       parent_id=parent_id, compressed=k.compressed, is_private=k.is_private, path=path,
-                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)
+            nk = DbKey(
+                name=name[:80],
+                wallet_id=wallet_id,
+                public=k.public_byte,
+                private=k.private_byte,
+                purpose=purpose,
+                account_id=account_id,
+                depth=k.depth,
+                change=change,
+                address_index=k.child_index,
+                wif=k.wif(
+                    witness_type=witness_type, multisig=multisig, is_private=True
+                ),
+                address=address,
+                parent_id=parent_id,
+                compressed=k.compressed,
+                is_private=k.is_private,
+                path=path,
+                key_type=key_type,
+                network_name=network,
+                encoding=encoding,
+                cosigner_id=cosigner_id,
+            )
         else:
-            keyexists = session.query(DbKey).\
-                filter(DbKey.wallet_id == wallet_id,
-                       DbKey.address == k.address).first()
+            keyexists = (
+                session.query(DbKey)
+                .filter(DbKey.wallet_id == wallet_id, DbKey.address == k.address)
+                .first()
+            )
             if keyexists:
                 _logger.warning("Key with ID %s already exists" % keyexists.id)
                 return WalletKey(keyexists.id, session, k)
-            nk = DbKey(name=name[:80], wallet_id=wallet_id, purpose=purpose,
-                       account_id=account_id, depth=k.depth, change=change, address=k.address,
-                       parent_id=parent_id, compressed=k.compressed, is_private=False, path=path,
-                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)
+            nk = DbKey(
+                name=name[:80],
+                wallet_id=wallet_id,
+                purpose=purpose,
+                account_id=account_id,
+                depth=k.depth,
+                change=change,
+                address=k.address,
+                parent_id=parent_id,
+                compressed=k.compressed,
+                is_private=False,
+                path=path,
+                key_type=key_type,
+                network_name=network,
+                encoding=encoding,
+                cosigner_id=cosigner_id,
+            )
 
         session.merge(DbNetwork(name=network))
         session.add(nk)
         session.commit()
         return WalletKey(nk.id, session, k)
 
     def _commit(self):
@@ -436,16 +571,16 @@
 
         self._session = session
         wk = session.query(DbKey).filter_by(id=key_id).first()
         if wk:
             self._dbkey = wk
             self._hdkey_object = hdkey_object
             if hdkey_object and isinstance(hdkey_object, HDKey):
-                assert(not wk.public or wk.public == hdkey_object.public_byte)
-                assert(not wk.private or wk.private == hdkey_object.private_byte)
+                assert not wk.public or wk.public == hdkey_object.public_byte
+                assert not wk.private or wk.private == hdkey_object.private_byte
                 self._hdkey_object = hdkey_object
             self.key_id = key_id
             self._name = wk.name
             self.wallet_id = wk.wallet_id
             self.key_public = None if not wk.public else wk.public
             self.key_private = None if not wk.private else wk.private
             self.account_id = wk.account_id
@@ -469,15 +604,20 @@
             self.encoding = wk.encoding
             self.cosigner_id = wk.cosigner_id
             self.used = wk.used
         else:
             raise WalletError("Key with id %s not found" % key_id)
 
     def __repr__(self):
-        return "<WalletKey(key_id=%d, name=%s, wif=%s, path=%s)>" % (self.key_id, self.name, self.wif, self.path)
+        return "<WalletKey(key_id=%d, name=%s, wif=%s, path=%s)>" % (
+            self.key_id,
+            self.name,
+            self.wif,
+            self.path,
+        )
 
     @property
     def name(self):
         """
         Return name of wallet key
 
         :return str:
@@ -503,20 +643,28 @@
         """
         Get HDKey object for current WalletKey
 
         :return HDKey:
         """
 
         self._hdkey_object = None
-        if self.key_type == 'multisig':
+        if self.key_type == "multisig":
             self._hdkey_object = []
             for kc in self._dbkey.multisig_children:
-                self._hdkey_object.append(HDKey.from_wif(kc.child_key.wif, network=kc.child_key.network_name, compressed=self.compressed))
+                self._hdkey_object.append(
+                    HDKey.from_wif(
+                        kc.child_key.wif,
+                        network=kc.child_key.network_name,
+                        compressed=self.compressed,
+                    )
+                )
         if self._hdkey_object is None and self.wif:
-            self._hdkey_object = HDKey.from_wif(self.wif, network=self.network_name, compressed=self.compressed)
+            self._hdkey_object = HDKey.from_wif(
+                self.wif, network=self.network_name, compressed=self.compressed
+            )
         return self._hdkey_object
 
     def balance(self, as_string=False):
         """
         Get total value of unspent outputs
 
         :param as_string: Specify 'string' to return a string in currency format
@@ -552,36 +700,38 @@
 
         :param include_private: Include private key information in dictionary
         :type include_private: bool
 
         """
 
         kdict = {
-            'id': self.key_id,
-            'key_type': self.key_type,
-            'network': self.network.name,
-            'is_private': self.is_private,
-            'name': self.name,
-            'key_public': '' if not self.key_public else self.key_public.hex(),
-            'account_id':  self.account_id,
-            'parent_id': self.parent_id,
-            'depth': self.depth,
-            'change': self.change,
-            'address_index': self.address_index,
-            'address': self.address,
-            'encoding': self.encoding,
-            'path': self.path,
-            'balance': self.balance(),
-            'balance_str': self.balance(as_string=True)
+            "id": self.key_id,
+            "key_type": self.key_type,
+            "network": self.network.name,
+            "is_private": self.is_private,
+            "name": self.name,
+            "key_public": "" if not self.key_public else self.key_public.hex(),
+            "account_id": self.account_id,
+            "parent_id": self.parent_id,
+            "depth": self.depth,
+            "change": self.change,
+            "address_index": self.address_index,
+            "address": self.address,
+            "encoding": self.encoding,
+            "path": self.path,
+            "balance": self.balance(),
+            "balance_str": self.balance(as_string=True),
         }
         if include_private:
-            kdict.update({
-                'key_private': self.key_private.hex(),
-                'wif': self.wif,
-            })
+            kdict.update(
+                {
+                    "key_private": self.key_private.hex(),
+                    "wif": self.wif,
+                }
+            )
         return kdict
 
 
 # class TransactionMeta(type):
 #     def __call__(cls, *args, **kwargs):
 #         hdwallet =kwargs.get("hdwallet")
 #         network = hdwallet.network
@@ -599,15 +749,14 @@
     """
     Used as attribute of Wallet class. Child of Transaction object with extra reference to
     wallet and database object.
 
     All WalletTransaction items are stored in a database
     """
 
-
     def __init__(self, hdwallet, account_id=None, *args, **kwargs):
         """
         Initialize WalletTransaction object with reference to a Wallet object
 
         :param hdwallet: Wallet object, wallet name or ID
         :type hdWallet: HDwallet, str, int
         :param account_id: Account ID
@@ -621,40 +770,51 @@
         self.hdwallet = hdwallet
         self.pushed = False
         self.error = None
         self.response_dict = None
         self.account_id = account_id
         if not account_id:
             self.account_id = self.hdwallet.default_account_id
-        witness_type = 'legacy'
-        if hdwallet.witness_type in ['segwit', 'p2sh-segwit']:
-            witness_type = 'segwit'
+        witness_type = "legacy"
+        if hdwallet.witness_type in ["segwit", "p2sh-segwit"]:
+            witness_type = "segwit"
 
+        # this is horrific
         if self.hdwallet.network == "flux":
-            self.__class__ = type("WalletTransaction", (WalletTransaction, FluxTransaction), {})
+            self.__class__ = type(
+                "WalletTransaction", (WalletTransaction, FluxTransaction), {}
+            )
         else:
-            self.__class__ = type("WalletTransaction", (WalletTransaction, Transaction), {})
+            self.__class__ = type(
+                "WalletTransaction", (WalletTransaction, Transaction), {}
+            )
 
-        super(WalletTransaction, self).__init__(witness_type=witness_type, *args, **kwargs)
+        super().__init__(witness_type=witness_type, *args, **kwargs)
 
         addresslist = hdwallet.addresslist()
-        self.outgoing_tx = bool([i.address for i in self.inputs if i.address in addresslist])
-        self.incoming_tx = bool([o.address for o in self.outputs if o.address in addresslist])
+        self.outgoing_tx = bool(
+            [i.address for i in self.inputs if i.address in addresslist]
+        )
+        self.incoming_tx = bool(
+            [o.address for o in self.outputs if o.address in addresslist]
+        )
 
     def __repr__(self):
-        return "<WalletTransaction(input_count=%d, output_count=%d, status=%s, network=%s)>" % \
-               (len(self.inputs), len(self.outputs), self.status, self.network.name)
+        return (
+            "<WalletTransaction(input_count=%d, output_count=%d, status=%s, network=%s)>"
+            % (len(self.inputs), len(self.outputs), self.status, self.network.name)
+        )
 
     def __deepcopy__(self, memo):
         cls = self.__class__
         result = cls.__new__(cls)
         memo[id(self)] = result
         self_dict = self.__dict__
         for k, v in self_dict.items():
-            if k != 'hdwallet':
+            if k != "hdwallet":
                 setattr(result, k, deepcopy(v, memo))
         result.hdwallet = self.hdwallet
         return result
 
     @classmethod
     def from_transaction(cls, hdwallet, t):
         """
@@ -663,20 +823,40 @@
         :param hdwallet: Wallet object, wallet name or ID
         :type hdwallet: HDwallet, str, int
         :param t: Specify Transaction object
         :type t: Transaction
 
         :return WalletClass:
         """
-        print("VERSIONVERSION", t.version)
-        return cls(hdwallet=hdwallet, inputs=t.inputs, outputs=t.outputs, locktime=t.locktime, version=t.version,
-                   network=t.network.name, fee=t.fee, fee_per_kb=t.fee_per_kb, size=t.size, txid=t.txid,
-                   txhash=t.txhash, date=t.date, confirmations=t.confirmations, block_height=t.block_height,
-                   block_hash=t.block_hash, input_total=t.input_total, output_total=t.output_total,
-                   rawtx=t.rawtx, status=t.status, coinbase=t.coinbase, verified=t.verified, flag=t.flag)
+
+        return cls(
+            hdwallet=hdwallet,
+            inputs=t.inputs,
+            outputs=t.outputs,
+            locktime=t.locktime,
+            version=t.version,
+            network=t.network.name,
+            fee=t.fee,
+            fee_per_kb=t.fee_per_kb,
+            size=t.size,
+            txid=t.txid,
+            txhash=t.txhash,
+            date=t.date,
+            confirmations=t.confirmations,
+            block_height=t.block_height,
+            block_hash=t.block_hash,
+            input_total=t.input_total,
+            output_total=t.output_total,
+            rawtx=t.rawtx,
+            status=t.status,
+            coinbase=t.coinbase,
+            verified=t.verified,
+            flag=t.flag,
+            expiry_height=t.expiry_height,
+        )
 
     @classmethod
     def from_txid(cls, hdwallet, txid):
         """
         Read single transaction from database with given transaction ID / transaction hash
 
         :param hdwallet: Wallet object
@@ -685,255 +865,401 @@
         :type txid: str, bytes
 
         :return WalletClass:
 
         """
         sess = hdwallet._session
         # If txid is unknown add it to database, else update
-        db_tx_query = sess.query(DbTransaction). \
-            filter(DbTransaction.wallet_id == hdwallet.wallet_id, DbTransaction.txid == to_bytes(txid))
+        db_tx_query = sess.query(DbTransaction).filter(
+            DbTransaction.wallet_id == hdwallet.wallet_id,
+            DbTransaction.txid == to_bytes(txid),
+        )
         db_tx = db_tx_query.scalar()
         if not db_tx:
             return
 
         fee_per_kb = None
         if db_tx.fee and db_tx.size:
             fee_per_kb = int((db_tx.fee / db_tx.size) * 1000)
         network = Network(db_tx.network_name)
 
         inputs = []
         for inp in db_tx.inputs:
-            sequence = 0xffffffff
+            sequence = 0xFFFFFFFF
             if inp.sequence:
                 sequence = inp.sequence
             inp_keys = []
             if inp.key_id:
                 key = hdwallet.key(inp.key_id)
-                if key.key_type == 'multisig':
+                if key.key_type == "multisig":
                     db_key = sess.query(DbKey).filter_by(id=key.key_id).scalar()
                     for ck in db_key.multisig_children:
                         inp_keys.append(ck.child_key.public.hex())
                 else:
                     inp_keys = key.key()
 
-            inputs.append(Input(
-                prev_txid=inp.prev_txid, output_n=inp.output_n, keys=inp_keys, unlocking_script=inp.script,
-                script_type=inp.script_type, sequence=sequence, index_n=inp.index_n, value=inp.value,
-                double_spend=inp.double_spend, witness_type=inp.witness_type, network=network, address=inp.address,
-                witnesses=inp.witnesses))
+            inputs.append(
+                Input(
+                    prev_txid=inp.prev_txid,
+                    output_n=inp.output_n,
+                    keys=inp_keys,
+                    unlocking_script=inp.script,
+                    script_type=inp.script_type,
+                    sequence=sequence,
+                    index_n=inp.index_n,
+                    value=inp.value,
+                    double_spend=inp.double_spend,
+                    witness_type=inp.witness_type,
+                    network=network,
+                    address=inp.address,
+                    witnesses=inp.witnesses,
+                )
+            )
 
         outputs = []
         for out in db_tx.outputs:
-            address = ''
-            public_key = b''
+            address = ""
+            public_key = b""
             if out.key_id:
                 key = hdwallet.key(out.key_id)
                 address = key.address
-                if key.key_type != 'multisig':
+                if key.key_type != "multisig":
                     if key.key() and not isinstance(key.key(), Address):
                         public_key = key.key().public_hex
-            outputs.append(Output(value=out.value, address=address, public_key=public_key,
-                                  lock_script=out.script, spent=out.spent, output_n=out.output_n,
-                                  script_type=out.script_type, network=network))
-
-        return cls(hdwallet=hdwallet, inputs=inputs, outputs=outputs, locktime=db_tx.locktime,
-                   version=db_tx.version, network=network, fee=db_tx.fee, fee_per_kb=fee_per_kb,
-                   size=db_tx.size, txid=to_hexstring(txid), date=db_tx.date, confirmations=db_tx.confirmations,
-                   block_height=db_tx.block_height, input_total=db_tx.input_total, output_total=db_tx.output_total,
-                   rawtx=db_tx.raw, status=db_tx.status, coinbase=db_tx.coinbase,
-                   verified=db_tx.verified)
+            outputs.append(
+                Output(
+                    value=out.value,
+                    address=address,
+                    public_key=public_key,
+                    lock_script=out.script,
+                    spent=out.spent,
+                    output_n=out.output_n,
+                    script_type=out.script_type,
+                    network=network,
+                )
+            )
+        return cls(
+            hdwallet=hdwallet,
+            inputs=inputs,
+            outputs=outputs,
+            locktime=db_tx.locktime,
+            version=db_tx.version,
+            network=network,
+            fee=db_tx.fee,
+            fee_per_kb=fee_per_kb,
+            size=db_tx.size,
+            txid=to_hexstring(txid),
+            date=db_tx.date,
+            confirmations=db_tx.confirmations,
+            block_height=db_tx.block_height,
+            input_total=db_tx.input_total,
+            output_total=db_tx.output_total,
+            rawtx=db_tx.raw,
+            status=db_tx.status,
+            coinbase=db_tx.coinbase,
+            verified=db_tx.verified,
+        )
 
     def to_transaction(self):
-        return Transaction(self.inputs, self.outputs, self.locktime, self.version,
-                           self.network.name, self.fee, self.fee_per_kb, self.size,
-                           self.txid, self.txhash, self.date, self.confirmations,
-                           self.block_height, self.block_hash, self.input_total,
-                           self.output_total, self.rawtx, self.status, self.coinbase,
-                           self.verified, self.witness_type, self.flag)
-
-    def sign(self, keys=None, index_n=0, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=False,
-             replace_signatures=False):
-        """
-        Sign this transaction. Use existing keys from wallet or use keys argument for extra keys.
-
-        :param keys: Extra private keys to sign the transaction
-        :type keys: HDKey, str
-        :param index_n: Transaction index_n to sign
-        :type index_n: int
-        :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked
-        :type multisig_key_n: int
-        :param hash_type: Hashtype to use, default is SIGHASH_ALL
-        :type hash_type: int
-        :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list
-        :type fail_on_unknown_key: bool
-        :param replace_signatures: Replace signature with new one if already signed.
-        :type replace_signatures: bool
-
-        :return None:
-        """
-        priv_key_list_arg = []
-        if keys:
-            key_paths = list(dict.fromkeys([ti.key_path for ti in self.inputs if ti.key_path[0] == 'm']))
-            if not isinstance(keys, list):
-                keys = [keys]
-            for priv_key in keys:
-                if not isinstance(priv_key, HDKey):
-                    if isinstance(priv_key, str) and len(str(priv_key).split(' ')) > 4:
-                        priv_key = HDKey.from_passphrase(priv_key, network=self.network)
-                    else:
-                        priv_key = HDKey(priv_key, network=self.network.name)
-                priv_key_list_arg.append((None, priv_key))
-                if key_paths and priv_key.depth == 0 and priv_key.key_type != "single":
-                    for key_path in key_paths:
-                        priv_key_list_arg.append((key_path, priv_key.subkey_for_path(key_path)))
-        for ti in self.inputs:
-            priv_key_list = []
-            for (key_path, priv_key) in priv_key_list_arg:
-                if (not key_path or key_path == ti.key_path) and priv_key not in priv_key_list:
-                    priv_key_list.append(priv_key)
-            priv_key_list += [k for k in ti.keys if k.is_private]
-            Transaction.sign(self, priv_key_list, ti.index_n, multisig_key_n, hash_type, fail_on_unknown_key,
-                             replace_signatures)
-        self.verify()
-        self.error = ""
-
-    def send(self, offline=False):
-        """
-        Verify and push transaction to network. Update UTXO's in database after successful send
-
-        :param offline: Just return the transaction object and do not send it when offline = True. Default is False
-        :type offline: bool
-
-        :return None:
-
-        """
-
-        self.error = None
-        if not self.verified and not self.verify():
-            self.error = "Cannot verify transaction"
-            return None
-
-        if offline:
-            return None
-
-        srv = Service(network=self.network.name, providers=self.hdwallet.providers,
-                      cache_uri=self.hdwallet.db_cache_uri)
-        res = srv.sendrawtransaction(self.raw_hex())
-        if not res:
-            self.error = "Cannot send transaction. %s" % srv.errors
-            return None
-        if 'txid' in res:
-            _logger.info("Successfully pushed transaction, result: %s" % res)
-            self.txid = res['txid']
-            self.status = 'unconfirmed'
-            self.confirmations = 0
-            self.pushed = True
-            self.response_dict = srv.results
-            self.store()
-
-            # Update db: Update spent UTXO's, add transaction to database
-            for inp in self.inputs:
-                txid = inp.prev_txid
-                utxos = self.hdwallet._session.query(DbTransactionOutput).join(DbTransaction).\
-                    filter(DbTransaction.txid == txid,
-                           DbTransactionOutput.output_n == inp.output_n_int,
-                           DbTransactionOutput.spent.is_(False)).all()
-                for u in utxos:
-                    u.spent = True
-
-            self.hdwallet._commit()
-            self.hdwallet._balance_update(network=self.network.name)
-            return None
-        self.error = "Transaction not send, unknown response from service providers"
+        return Transaction(
+            self.inputs,
+            self.outputs,
+            self.locktime,
+            self.version,
+            self.network.name,
+            self.fee,
+            self.fee_per_kb,
+            self.size,
+            self.txid,
+            self.txhash,
+            self.date,
+            self.confirmations,
+            self.block_height,
+            self.block_hash,
+            self.input_total,
+            self.output_total,
+            self.rawtx,
+            self.status,
+            self.coinbase,
+            self.verified,
+            self.witness_type,
+            self.flag,
+        )
+
+    # def sign(
+    #     self,
+    #     keys=None,
+    #     index_n=0,
+    #     multisig_key_n=None,
+    #     hash_type=SIGHASH_ALL,
+    #     fail_on_unknown_key=False,
+    #     replace_signatures=False,
+    # ):
+    #     """
+    #     Sign this transaction. Use existing keys from wallet or use keys argument for extra keys.
+
+    #     :param keys: Extra private keys to sign the transaction
+    #     :type keys: HDKey, str
+    #     :param index_n: Transaction index_n to sign
+    #     :type index_n: int
+    #     :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked
+    #     :type multisig_key_n: int
+    #     :param hash_type: Hashtype to use, default is SIGHASH_ALL
+    #     :type hash_type: int
+    #     :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list
+    #     :type fail_on_unknown_key: bool
+    #     :param replace_signatures: Replace signature with new one if already signed.
+    #     :type replace_signatures: bool
+
+    #     :return None:
+    #     """
+    #     priv_key_list_arg = []
+    #     if keys:
+    #         key_paths = list(
+    #             dict.fromkeys(
+    #                 [ti.key_path for ti in self.inputs if ti.key_path[0] == "m"]
+    #             )
+    #         )
+    #         if not isinstance(keys, list):
+    #             keys = [keys]
+
+    #         for priv_key in keys:
+    #             if not isinstance(priv_key, HDKey):
+    #                 if isinstance(priv_key, str) and len(str(priv_key).split(" ")) > 4:
+    #                     priv_key = HDKey.from_passphrase(priv_key, network=self.network)
+    #                 else:
+    #                     priv_key = HDKey(priv_key, network=self.network.name)
+
+    #             priv_key_list_arg.append((None, priv_key))
+
+    #             if key_paths and priv_key.depth == 0 and priv_key.key_type != "single":
+    #                 for key_path in key_paths:
+    #                     priv_key_list_arg.append(
+    #                         (key_path, priv_key.subkey_for_path(key_path))
+    #                     )
+
+    #     for ti in self.inputs:
+    #         priv_key_list = []
+    #         for key_path, priv_key in priv_key_list_arg:
+    #             if (
+    #                 not key_path or key_path == ti.key_path
+    #             ) and priv_key not in priv_key_list:
+    #                 priv_key_list.append(priv_key)
+    #         priv_key_list += [k for k in ti.keys if k.is_private]
+    #         Transaction.sign(
+    #             self,
+    #             priv_key_list,
+    #             ti.index_n,
+    #             multisig_key_n,
+    #             hash_type,
+    #             fail_on_unknown_key,
+    #             replace_signatures,
+    #         )
+    #     self.verify()
+    #     self.error = ""
+
+    # async def send(self, offline=False):
+    #     """
+    #     Verify and push transaction to network. Update UTXO's in database after successful send
+
+    #     :param offline: Just return the transaction object and do not send it when offline = True. Default is False
+    #     :type offline: bool
+
+    #     :return None:
+
+    #     """
+
+    #     self.error = None
+    #     if not self.verified and not self.verify():
+    #         self.error = "Cannot verify transaction"
+    #         return None
+
+    #     if offline:
+    #         return None
+
+    #     srv = Service(
+    #         network=self.hdwallet.network.name,
+    #         providers=self.hdwallet.providers,
+    #         cache_uri=self.hdwallet.db_cache_uri,
+    #     )
+    #     res = await srv.sendrawtransaction(self.raw_hex())
+    #     print(res)
+    #     if not res:
+    #         self.error = "Cannot send transaction. %s" % srv.errors
+    #         return None
+    #     if "txid" in res:
+    #         _logger.info("Successfully pushed transaction, result: %s" % res)
+    #         self.txid = res["txid"]
+    #         self.status = "unconfirmed"
+    #         self.confirmations = 0
+    #         self.pushed = True
+    #         self.response_dict = srv.results
+    #         self.store()
+
+    #         # Update db: Update spent UTXO's, add transaction to database
+    #         for inp in self.inputs:
+    #             txid = inp.prev_txid
+    #             utxos = (
+    #                 self.hdwallet._session.query(DbTransactionOutput)
+    #                 .join(DbTransaction)
+    #                 .filter(
+    #                     DbTransaction.txid == txid,
+    #                     DbTransactionOutput.output_n == inp.output_n_int,
+    #                     DbTransactionOutput.spent.is_(False),
+    #                 )
+    #                 .all()
+    #             )
+    #             for u in utxos:
+    #                 u.spent = True
+
+    #         self.hdwallet._commit()
+    #         self.hdwallet._balance_update(network=self.network.name)
+    #         return None
+    #     self.error = "Transaction not send, unknown response from service providers"
 
     def store(self):
         """
         Store this transaction to database
 
         :return int: Transaction index number
         """
-
-        print("TXID", self.txid)
-
         sess = self.hdwallet._session
         # If txid is unknown add it to database, else update
-        db_tx_query = sess.query(DbTransaction). \
-            filter(DbTransaction.wallet_id == self.hdwallet.wallet_id, DbTransaction.txid == bytes.fromhex(self.txid))
+        db_tx_query = sess.query(DbTransaction).filter(
+            DbTransaction.wallet_id == self.hdwallet.wallet_id,
+            DbTransaction.txid == bytes.fromhex(self.txid),
+        )
         db_tx = db_tx_query.scalar()
         if not db_tx:
-            db_tx_query = sess.query(DbTransaction). \
-                filter(DbTransaction.wallet_id.is_(None), DbTransaction.txid == bytes.fromhex(self.txid))
+            db_tx_query = sess.query(DbTransaction).filter(
+                DbTransaction.wallet_id.is_(None),
+                DbTransaction.txid == bytes.fromhex(self.txid),
+            )
             db_tx = db_tx_query.first()
             if db_tx:
                 db_tx.wallet_id = self.hdwallet.wallet_id
 
         if not db_tx:
+            version = 4 if self.network.name == "flux" else 1
             new_tx = DbTransaction(
-                wallet_id=self.hdwallet.wallet_id, txid=bytes.fromhex(self.txid), block_height=self.block_height,
-                size=self.size, confirmations=self.confirmations, date=self.date, fee=self.fee, status=self.status,
-                input_total=self.input_total, output_total=self.output_total, network_name=self.network.name,
-                raw=self.rawtx, verified=self.verified, account_id=self.account_id)
+                wallet_id=self.hdwallet.wallet_id,
+                version=version,
+                txid=bytes.fromhex(self.txid),
+                block_height=self.block_height,
+                size=self.size,
+                confirmations=self.confirmations,
+                date=self.date,
+                fee=self.fee,
+                status=self.status,
+                input_total=self.input_total,
+                output_total=self.output_total,
+                network_name=self.network.name,
+                raw=self.rawtx,
+                verified=self.verified,
+                account_id=self.account_id,
+                expiry_height=self.expiry_height,
+            )
             sess.add(new_tx)
             self.hdwallet._commit()
             txidn = new_tx.id
         else:
             txidn = db_tx.id
-            db_tx.block_height = self.block_height if self.block_height else db_tx.block_height
-            db_tx.confirmations = self.confirmations if self.confirmations else db_tx.confirmations
+            db_tx.block_height = (
+                self.block_height if self.block_height else db_tx.block_height
+            )
+            db_tx.confirmations = (
+                self.confirmations if self.confirmations else db_tx.confirmations
+            )
             db_tx.date = self.date if self.date else db_tx.date
             db_tx.fee = self.fee if self.fee else db_tx.fee
             db_tx.status = self.status if self.status else db_tx.status
-            db_tx.input_total = self.input_total if self.input_total else db_tx.input_total
-            db_tx.output_total = self.output_total if self.output_total else db_tx.output_total
+            db_tx.input_total = (
+                self.input_total if self.input_total else db_tx.input_total
+            )
+            db_tx.output_total = (
+                self.output_total if self.output_total else db_tx.output_total
+            )
             db_tx.network_name = self.network.name if self.network.name else db_tx.name
             db_tx.raw = self.rawtx if self.rawtx else db_tx.raw
             db_tx.verified = self.verified
             self.hdwallet._commit()
 
         assert txidn
         for ti in self.inputs:
-            tx_key = sess.query(DbKey).filter_by(wallet_id=self.hdwallet.wallet_id, address=ti.address).scalar()
+            tx_key = (
+                sess.query(DbKey)
+                .filter_by(wallet_id=self.hdwallet.wallet_id, address=ti.address)
+                .scalar()
+            )
             key_id = None
             if tx_key:
                 key_id = tx_key.id
                 tx_key.used = True
-            tx_input = sess.query(DbTransactionInput). \
-                filter_by(transaction_id=txidn, index_n=ti.index_n).scalar()
+            tx_input = (
+                sess.query(DbTransactionInput)
+                .filter_by(transaction_id=txidn, index_n=ti.index_n)
+                .scalar()
+            )
             if not tx_input:
-                witnesses = int_to_varbyteint(len(ti.witnesses)) + b''.join([bytes(varstr(w)) for w in ti.witnesses])
+                witnesses = int_to_varbyteint(len(ti.witnesses)) + b"".join(
+                    [bytes(varstr(w)) for w in ti.witnesses]
+                )
                 new_tx_item = DbTransactionInput(
-                    transaction_id=txidn, output_n=ti.output_n_int, key_id=key_id, value=ti.value,
-                    prev_txid=ti.prev_txid, index_n=ti.index_n, double_spend=ti.double_spend,
-                    script=ti.unlocking_script, script_type=ti.script_type, witness_type=ti.witness_type,
-                    sequence=ti.sequence, address=ti.address, witnesses=witnesses)
+                    transaction_id=txidn,
+                    output_n=ti.output_n_int,
+                    key_id=key_id,
+                    value=ti.value,
+                    prev_txid=ti.prev_txid,
+                    index_n=ti.index_n,
+                    double_spend=ti.double_spend,
+                    script=ti.unlocking_script,
+                    script_type=ti.script_type,
+                    witness_type=ti.witness_type,
+                    sequence=ti.sequence,
+                    address=ti.address,
+                    witnesses=witnesses,
+                )
                 sess.add(new_tx_item)
             elif key_id:
                 tx_input.key_id = key_id
                 if ti.value:
                     tx_input.value = ti.value
                 if ti.prev_txid:
                     tx_input.prev_txid = ti.prev_txid
                 if ti.unlocking_script:
                     tx_input.script = ti.unlocking_script
 
             self.hdwallet._commit()
         for to in self.outputs:
-            tx_key = sess.query(DbKey).\
-                filter_by(wallet_id=self.hdwallet.wallet_id, address=to.address).scalar()
+            tx_key = (
+                sess.query(DbKey)
+                .filter_by(wallet_id=self.hdwallet.wallet_id, address=to.address)
+                .scalar()
+            )
             key_id = None
             if tx_key:
                 key_id = tx_key.id
                 tx_key.used = True
             spent = to.spent
-            tx_output = sess.query(DbTransactionOutput). \
-                filter_by(transaction_id=txidn, output_n=to.output_n).scalar()
+            tx_output = (
+                sess.query(DbTransactionOutput)
+                .filter_by(transaction_id=txidn, output_n=to.output_n)
+                .scalar()
+            )
             if not tx_output:
                 new_tx_item = DbTransactionOutput(
-                    transaction_id=txidn, output_n=to.output_n, key_id=key_id, address=to.address, value=to.value,
-                    spent=spent, script=to.lock_script, script_type=to.script_type)
+                    transaction_id=txidn,
+                    output_n=to.output_n,
+                    key_id=key_id,
+                    address=to.address,
+                    value=to.value,
+                    spent=spent,
+                    script=to.lock_script,
+                    script_type=to.script_type,
+                )
                 sess.add(new_tx_item)
             elif key_id:
                 tx_output.key_id = key_id
                 tx_output.spent = spent if spent is not None else tx_output.spent
             self.hdwallet._commit()
         return txidn
 
@@ -969,38 +1295,58 @@
             for o in self.outputs:
                 o_value = -o.value
                 if o.address in wlt_addresslist:
                     if skip_change:
                         continue
                     elif self.incoming_tx:
                         o_value = 0
-                mut_list.append((self.date, self.txid, 'out', input_addresslist, o.address, o_value, fee_per_output))
+                mut_list.append(
+                    (
+                        self.date,
+                        self.txid,
+                        "out",
+                        input_addresslist,
+                        o.address,
+                        o_value,
+                        fee_per_output,
+                    )
+                )
         else:
             for o in self.outputs:
                 if o.address not in wlt_addresslist:
                     continue
-                mut_list.append((self.date, self.txid, 'in', input_addresslist, o.address, o.value, 0))
+                mut_list.append(
+                    (
+                        self.date,
+                        self.txid,
+                        "in",
+                        input_addresslist,
+                        o.address,
+                        o.value,
+                        0,
+                    )
+                )
         return mut_list
 
     def save(self, filename=None):
         """
         Store transaction object as file, so it can be imported in fluxwallet later with the :func:`load` method.
 
         :param filename: Location and name of file, leave empty to store transaction in fluxwallet data directory: .fluxwallet/<transaction_id.tx)
         :type filename: str
 
         :return:
         """
         if not filename:
-            p = Path(FW_DATA_DIR, '%s.tx' % self.txid)
+            p = Path(FW_DATA_DIR, "%s.tx" % self.txid)
         else:
             p = Path(filename)
-            if not p.parent or str(p.parent) == '.':
+            if not p.parent or str(p.parent) == ".":
                 p = Path(FW_DATA_DIR, filename)
-        f = p.open('wb')
+        f = p.open("wb")
         t = self.to_transaction()
         pickle.dump(t, f)
         f.close()
 
     def delete(self):
         """
         Delete this transaction from database.
@@ -1012,92 +1358,144 @@
 
         session = self.hdwallet._session
         txid = bytes.fromhex(self.txid)
         tx_query = session.query(DbTransaction).filter_by(txid=txid)
         tx = tx_query.scalar()
         session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()
         session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()
-        session.query(DbKey).filter_by(latest_txid=txid).update({DbKey.latest_txid: None})
+        session.query(DbKey).filter_by(latest_txid=txid).update(
+            {DbKey.latest_txid: None}
+        )
         res = tx_query.delete()
         self.hdwallet._commit()
         return res
 
 
-class Wallet(object):
+class Wallet:
     """
     Class to create and manage keys Using the BIP0044 Hierarchical Deterministic wallet definitions, so you can
     use one Masterkey to generate as much child keys as you want in a structured manner.
 
     You can import keys in many format such as WIF or extended WIF, bytes, hexstring, seeds or private key integer.
     For the Bitcoin network, Litecoin or any other network you define in the settings.
 
     Easily send and receive transactions. Compose transactions automatically or select unspent outputs.
 
     Each wallet name must be unique and can contain only one cointype and purpose, but practically unlimited
     accounts and addresses.
     """
 
     @classmethod
-    def _create(cls, name, key, owner, network, account_id, purpose, scheme, parent_id, sort_keys,
-                witness_type, encoding, multisig, sigs_required, cosigner_id, key_path, db_uri):
-
+    def _create(
+        cls,
+        name,
+        key,
+        owner,
+        network,
+        account_id,
+        purpose,
+        scheme,
+        parent_id,
+        sort_keys,
+        witness_type,
+        encoding,
+        multisig,
+        sigs_required,
+        cosigner_id,
+        key_path,
+        db_uri,
+    ):
         session = Db(db_uri=db_uri).session
         if session.query(DbWallet).filter_by(name=name).count():
             raise WalletError("Wallet with name '%s' already exists" % name)
         else:
             _logger.info("Create new wallet '%s'" % name)
         if not name:
             raise WalletError("Please enter wallet name")
 
         if not isinstance(key_path, list):
-            key_path = key_path.split('/')
+            key_path = key_path.split("/")
         key_depth = 1 if not key_path else len(key_path) - 1
-        base_path = 'm'
-        if hasattr(key, 'depth'):
+        base_path = "m"
+        if hasattr(key, "depth"):
             if key.depth is None:
                 key.depth = key_depth
             if key.depth > 0:
                 hardened_keys = [x for x in key_path if x[-1:] == "'"]
                 if hardened_keys:
                     depth_public_master = key_path.index(hardened_keys[-1])
                     if depth_public_master != key.depth:
-                        raise WalletError("Depth of provided public master key %d does not correspond with key path "
-                                          "%s. Did you provide correct witness_type and multisig attribute?" %
-                                          (key.depth, key_path))
-                key_path = ['M'] + key_path[key.depth+1:]
-                base_path = 'M'
+                        raise WalletError(
+                            "Depth of provided public master key %d does not correspond with key path "
+                            "%s. Did you provide correct witness_type and multisig attribute?"
+                            % (key.depth, key_path)
+                        )
+                key_path = ["M"] + key_path[key.depth + 1 :]
+                base_path = "M"
 
         if isinstance(key_path, list):
-            key_path = '/'.join(key_path)
+            key_path = "/".join(key_path)
         session.merge(DbNetwork(name=network))
-        new_wallet = DbWallet(name=name, owner=owner, network_name=network, purpose=purpose, scheme=scheme,
-                              sort_keys=sort_keys, witness_type=witness_type, parent_id=parent_id, encoding=encoding,
-                              multisig=multisig, multisig_n_required=sigs_required, cosigner_id=cosigner_id,
-                              key_path=key_path)
+        new_wallet = DbWallet(
+            name=name,
+            owner=owner,
+            network_name=network,
+            purpose=purpose,
+            scheme=scheme,
+            sort_keys=sort_keys,
+            witness_type=witness_type,
+            parent_id=parent_id,
+            encoding=encoding,
+            multisig=multisig,
+            multisig_n_required=sigs_required,
+            cosigner_id=cosigner_id,
+            key_path=key_path,
+        )
         session.add(new_wallet)
         session.commit()
         new_wallet_id = new_wallet.id
 
-        if scheme == 'bip32' and multisig and parent_id is None:
+        if scheme == "bip32" and multisig and parent_id is None:
             w = cls(new_wallet_id, db_uri=db_uri)
-        elif scheme == 'bip32':
-            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,
-                                    account_id=account_id, purpose=purpose, key_type='bip32', encoding=encoding,
-                                    witness_type=witness_type, multisig=multisig, path=base_path)
+        elif scheme == "bip32":
+            mk = WalletKey.from_key(
+                key=key,
+                name=name,
+                session=session,
+                wallet_id=new_wallet_id,
+                network=network,
+                account_id=account_id,
+                purpose=purpose,
+                key_type="bip32",
+                encoding=encoding,
+                witness_type=witness_type,
+                multisig=multisig,
+                path=base_path,
+            )
             new_wallet.main_key_id = mk.key_id
             session.commit()
 
             w = cls(new_wallet_id, db_uri=db_uri, main_key_object=mk.key())
             w.key_for_path([0, 0], account_id=account_id, cosigner_id=cosigner_id)
         else:  # scheme == 'single':
             if not key:
                 key = HDKey(network=network, depth=key_depth)
-            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,
-                                    account_id=account_id, purpose=purpose, key_type='single', encoding=encoding,
-                                    witness_type=witness_type, multisig=multisig)
+            mk = WalletKey.from_key(
+                key=key,
+                name=name,
+                session=session,
+                wallet_id=new_wallet_id,
+                network=network,
+                account_id=account_id,
+                purpose=purpose,
+                key_type="single",
+                encoding=encoding,
+                witness_type=witness_type,
+                multisig=multisig,
+            )
             new_wallet.main_key_id = mk.key_id
             session.commit()
             w = cls(new_wallet_id, db_uri=db_uri, main_key_object=mk.key())
 
         session.close()
         return w
 
@@ -1105,17 +1503,33 @@
         try:
             self._session.commit()
         except Exception:
             self._session.rollback()
             raise
 
     @classmethod
-    def create(cls, name, keys=None, owner='', network=None, account_id=0, purpose=0, scheme='bip32',
-               sort_keys=True, password='', witness_type=None, encoding=None, multisig=None, sigs_required=None,
-               cosigner_id=None, key_path=None, db_uri=None):
+    def create(
+        cls,
+        name,
+        keys=None,
+        owner="",
+        network=None,
+        account_id=0,
+        purpose=0,
+        scheme="bip32",
+        sort_keys=True,
+        password="",
+        witness_type=None,
+        encoding=None,
+        multisig=None,
+        sigs_required=None,
+        cosigner_id=None,
+        key_path=None,
+        db_uri=None,
+    ):
         """
         Create Wallet and insert in database. Generate masterkey or import key when specified.
 
         When only a name is specified a legacy Wallet with a single masterkey is created with standard p2wpkh
         scripts.
 
         >>> if wallet_delete_if_exists('create_legacy_wallet_test'): pass
@@ -1188,145 +1602,218 @@
         """
 
         if multisig is None:
             if keys and isinstance(keys, list) and len(keys) > 1:
                 multisig = True
             else:
                 multisig = False
-        if scheme not in ['bip32', 'single']:
-            raise WalletError("Only bip32 or single key scheme's are supported at the moment")
-        if witness_type not in [None, 'legacy', 'p2sh-segwit', 'segwit']:
-            raise WalletError("Witness type %s not supported at the moment" % witness_type)
+        if scheme not in ["bip32", "single"]:
+            raise WalletError(
+                "Only bip32 or single key scheme's are supported at the moment"
+            )
+        if witness_type not in [None, "legacy", "p2sh-segwit", "segwit"]:
+            raise WalletError(
+                "Witness type %s not supported at the moment" % witness_type
+            )
         if name.isdigit():
-            raise WalletError("Wallet name '%s' invalid, please include letter characters" % name)
+            raise WalletError(
+                "Wallet name '%s' invalid, please include letter characters" % name
+            )
 
         if multisig:
             if password:
                 raise WalletError("Password protected multisig wallets not supported")
-            if scheme != 'bip32':
-                raise WalletError("Multisig wallets should use bip32 scheme not %s" % scheme)
+            if scheme != "bip32":
+                raise WalletError(
+                    "Multisig wallets should use bip32 scheme not %s" % scheme
+                )
             if sigs_required is None:
                 sigs_required = len(keys)
             if sigs_required > len(keys):
-                raise WalletError("Number of keys required to sign is greater then number of keys provided")
+                raise WalletError(
+                    "Number of keys required to sign is greater then number of keys provided"
+                )
         elif not isinstance(keys, list):
             keys = [keys]
         if len(keys) > 15:
-            raise WalletError("Redeemscripts with more then 15 keys are non-standard and could result in "
-                              "locked up funds")
+            raise WalletError(
+                "Redeemscripts with more then 15 keys are non-standard and could result in "
+                "locked up funds"
+            )
 
         hdkey_list = []
         if keys and isinstance(keys, list) and sort_keys:
-            keys.sort(key=lambda x: ('0' if isinstance(x, HDKey) else '1'))
+            keys.sort(key=lambda x: ("0" if isinstance(x, HDKey) else "1"))
         for key in keys:
             if isinstance(key, HDKey):
                 if network and network != key.network.name:
-                    raise WalletError("Network from key (%s) is different then specified network (%s)" %
-                                      (key.network.name, network))
+                    raise WalletError(
+                        "Network from key (%s) is different then specified network (%s)"
+                        % (key.network.name, network)
+                    )
                 network = key.network.name
                 if witness_type is None:
                     witness_type = key.witness_type
             elif key:
                 # If key consists of several words assume it is a passphrase and convert it to a HDKey object
                 if isinstance(key, str) and len(key.split(" ")) > 1:
                     if not network:
-                        raise WalletError("Please specify network when using passphrase to create a key")
-                    key = HDKey.from_seed(Mnemonic().to_seed(key, password), network=network)
+                        raise WalletError(
+                            "Please specify network when using passphrase to create a key"
+                        )
+                    key = HDKey.from_seed(
+                        Mnemonic().to_seed(key, password), network=network
+                    )
                 else:
                     try:
                         if isinstance(key, WalletKey):
                             key = key._hdkey_object
                         else:
                             key = HDKey(key, password=password, network=network)
                     except BKeyError:
                         try:
-                            scheme = 'single'
+                            scheme = "single"
                             key = Address.parse(key, encoding=encoding, network=network)
                         except Exception:
                             raise WalletError("Invalid key or address: %s" % key)
                     if network is None:
                         network = key.network.name
                     if witness_type is None:
                         witness_type = key.witness_type
             hdkey_list.append(key)
 
         if network is None:
             network = DEFAULT_NETWORK
         if witness_type is None:
             witness_type = DEFAULT_WITNESS_TYPE
-        if network in ['dash', 'dash_testnet', 'dogecoin', 'dogecoin_testnet'] and witness_type != 'legacy':
-            raise WalletError("Segwit is not supported for %s wallets" % network.capitalize())
-        elif network in ('dogecoin', 'dogecoin_testnet') and witness_type not in ('legacy', 'p2sh-segwit'):
-            raise WalletError("Pure segwit addresses are not supported for Dogecoin wallets. "
-                              "Please use p2sh-segwit instead")
+        if (
+            network in ["dash", "dash_testnet", "dogecoin", "dogecoin_testnet"]
+            and witness_type != "legacy"
+        ):
+            raise WalletError(
+                "Segwit is not supported for %s wallets" % network.capitalize()
+            )
+        elif network in ("dogecoin", "dogecoin_testnet") and witness_type not in (
+            "legacy",
+            "p2sh-segwit",
+        ):
+            raise WalletError(
+                "Pure segwit addresses are not supported for Dogecoin wallets. "
+                "Please use p2sh-segwit instead"
+            )
 
         if not key_path:
-            if scheme == 'single':
-                key_path = ['m']
+            if scheme == "single":
+                key_path = ["m"]
                 purpose = 0
             else:
-                ks = [k for k in WALLET_KEY_STRUCTURES if k['witness_type'] == witness_type and
-                      k['multisig'] == multisig and k['purpose'] is not None]
+                ks = [
+                    k
+                    for k in WALLET_KEY_STRUCTURES
+                    if k["witness_type"] == witness_type
+                    and k["multisig"] == multisig
+                    and k["purpose"] is not None
+                ]
                 if len(ks) > 1:
-                    raise WalletError("Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
-                                      "witness_type - multisig combination")
+                    raise WalletError(
+                        "Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
+                        "witness_type - multisig combination"
+                    )
                 if ks and not purpose:
-                    purpose = ks[0]['purpose']
+                    purpose = ks[0]["purpose"]
                 if ks and not encoding:
-                    encoding = ks[0]['encoding']
-                key_path = ks[0]['key_path']
+                    encoding = ks[0]["encoding"]
+                key_path = ks[0]["key_path"]
         else:
             if purpose is None:
                 purpose = 0
         if not encoding:
             encoding = get_encoding_from_witness(witness_type)
 
         if multisig:
-            key = ''
+            key = ""
         else:
             key = hdkey_list[0]
 
         main_key_path = key_path
         if multisig:
             if sort_keys:
                 hdkey_list.sort(key=lambda x: x.public_byte)
             cos_prv_lst = [hdkey_list.index(cw) for cw in hdkey_list if cw.is_private]
             if cosigner_id is None:
                 if not cos_prv_lst:
-                    raise WalletError("This wallet does not contain any private keys, please specify cosigner_id for "
-                                      "this wallet")
+                    raise WalletError(
+                        "This wallet does not contain any private keys, please specify cosigner_id for "
+                        "this wallet"
+                    )
                 elif len(cos_prv_lst) > 1:
-                    raise WalletError("This wallet contains more then 1 private key, please specify "
-                                      "cosigner_id for this wallet")
+                    raise WalletError(
+                        "This wallet contains more then 1 private key, please specify "
+                        "cosigner_id for this wallet"
+                    )
                 cosigner_id = 0 if not cos_prv_lst else cos_prv_lst[0]
-            if hdkey_list[cosigner_id].key_type == 'single':
-                main_key_path = 'm'
+            if hdkey_list[cosigner_id].key_type == "single":
+                main_key_path = "m"
 
-        hdpm = cls._create(name, key, owner=owner, network=network, account_id=account_id, purpose=purpose,
-                           scheme=scheme, parent_id=None, sort_keys=sort_keys, witness_type=witness_type,
-                           encoding=encoding, multisig=multisig, sigs_required=sigs_required, cosigner_id=cosigner_id,
-                           key_path=main_key_path, db_uri=db_uri)
+        hdpm = cls._create(
+            name,
+            key,
+            owner=owner,
+            network=network,
+            account_id=account_id,
+            purpose=purpose,
+            scheme=scheme,
+            parent_id=None,
+            sort_keys=sort_keys,
+            witness_type=witness_type,
+            encoding=encoding,
+            multisig=multisig,
+            sigs_required=sigs_required,
+            cosigner_id=cosigner_id,
+            key_path=main_key_path,
+            db_uri=db_uri,
+        )
 
         if multisig:
             wlt_cos_id = 0
             for cokey in hdkey_list:
                 if hdpm.network.name != cokey.network.name:
-                    raise WalletError("Network for key %s (%s) is different then network specified: %s/%s" %
-                                      (cokey.wif(is_private=False), cokey.network.name, network, hdpm.network.name))
-                scheme = 'bip32'
-                wn = name + '-cosigner-%d' % wlt_cos_id
+                    raise WalletError(
+                        "Network for key %s (%s) is different then network specified: %s/%s"
+                        % (
+                            cokey.wif(is_private=False),
+                            cokey.network.name,
+                            network,
+                            hdpm.network.name,
+                        )
+                    )
+                scheme = "bip32"
+                wn = name + "-cosigner-%d" % wlt_cos_id
                 c_key_path = key_path
-                if cokey.key_type == 'single':
-                    scheme = 'single'
-                    c_key_path = ['m']
-                w = cls._create(name=wn, key=cokey, owner=owner, network=network, account_id=account_id,
-                                purpose=hdpm.purpose, scheme=scheme, parent_id=hdpm.wallet_id, sort_keys=sort_keys,
-                                witness_type=hdpm.witness_type, encoding=encoding, multisig=True,
-                                sigs_required=None, cosigner_id=wlt_cos_id, key_path=c_key_path,
-                                db_uri=db_uri)
+                if cokey.key_type == "single":
+                    scheme = "single"
+                    c_key_path = ["m"]
+                w = cls._create(
+                    name=wn,
+                    key=cokey,
+                    owner=owner,
+                    network=network,
+                    account_id=account_id,
+                    purpose=hdpm.purpose,
+                    scheme=scheme,
+                    parent_id=hdpm.wallet_id,
+                    sort_keys=sort_keys,
+                    witness_type=hdpm.witness_type,
+                    encoding=encoding,
+                    multisig=True,
+                    sigs_required=None,
+                    cosigner_id=wlt_cos_id,
+                    key_path=c_key_path,
+                    db_uri=db_uri,
+                )
                 hdpm.cosigner.append(w)
                 wlt_cos_id += 1
             # hdpm._dbwallet = hdpm._session.query(DbWallet).filter(DbWallet.id == hdpm.wallet_id)
             # hdpm._dbwallet.update({DbWallet.cosigner_id: hdpm.cosigner_id})
             # hdpm._dbwallet.update({DbWallet.key_path: hdpm.key_path})
             # hdpm._session.commit()
 
@@ -1344,14 +1831,15 @@
         :param db_uri: URI of the database
         :type db_uri: str
         :param session: Sqlalchemy session
         :type session: sqlalchemy.orm.session.Session
         :param main_key_object: Pass main key object to save time
         :type main_key_object: HDKey
         """
+        self.run_async = False
 
         if session:
             self._session = session
         else:
             dbinit = Db(db_uri=db_uri)
             self._session = dbinit.session
             self._engine = dbinit.engine
@@ -1363,56 +1851,71 @@
             db_wlt = self._session.query(DbWallet).filter_by(name=wallet).scalar()
         if db_wlt:
             self._dbwallet = db_wlt
             self.wallet_id = db_wlt.id
             self._name = db_wlt.name
             self._owner = db_wlt.owner
             self.network = Network(db_wlt.network_name)
+
+            if self.network == "flux":
+                self.run_async = True
+
             self.purpose = db_wlt.purpose
             self.scheme = db_wlt.scheme
             self._balance = None
             self._balances = []
             self.main_key_id = db_wlt.main_key_id
             self.main_key = None
             self._default_account_id = db_wlt.default_account_id
             self.multisig_n_required = db_wlt.multisig_n_required
-            co_sign_wallets = self._session.query(DbWallet).\
-                filter(DbWallet.parent_id == self.wallet_id).order_by(DbWallet.name).all()
+            co_sign_wallets = (
+                self._session.query(DbWallet)
+                .filter(DbWallet.parent_id == self.wallet_id)
+                .order_by(DbWallet.name)
+                .all()
+            )
             self.cosigner = [Wallet(w.id, db_uri=db_uri) for w in co_sign_wallets]
             self.sort_keys = db_wlt.sort_keys
             if db_wlt.main_key_id:
-                self.main_key = WalletKey(self.main_key_id, session=self._session, hdkey_object=main_key_object)
+                self.main_key = WalletKey(
+                    self.main_key_id,
+                    session=self._session,
+                    hdkey_object=main_key_object,
+                )
             if self._default_account_id is None:
                 self._default_account_id = 0
                 if self.main_key:
                     self._default_account_id = self.main_key.account_id
             _logger.info("Opening wallet '%s'" % self.name)
-            self._key_objects = {
-                self.main_key_id: self.main_key
-            }
+            self._key_objects = {self.main_key_id: self.main_key}
             self.providers = None
             self.witness_type = db_wlt.witness_type
             self.encoding = db_wlt.encoding
             self.multisig = db_wlt.multisig
             self.cosigner_id = db_wlt.cosigner_id
-            self.script_type = script_type_default(self.witness_type, self.multisig, locking_script=True)
-            self.key_path = [] if not db_wlt.key_path else db_wlt.key_path.split('/')
+            self.script_type = script_type_default(
+                self.witness_type, self.multisig, locking_script=True
+            )
+            self.key_path = [] if not db_wlt.key_path else db_wlt.key_path.split("/")
             self.depth_public_master = 0
             self.parent_id = db_wlt.parent_id
             if self.main_key and self.main_key.depth > 0:
                 self.depth_public_master = self.main_key.depth
                 self.key_depth = self.depth_public_master + len(self.key_path) - 1
             else:
                 hardened_keys = [x for x in self.key_path if x[-1:] == "'"]
                 if hardened_keys:
                     self.depth_public_master = self.key_path.index(hardened_keys[-1])
                 self.key_depth = len(self.key_path) - 1
             self.last_updated = None
         else:
-            raise WalletError("Wallet '%s' not found, please specify correct wallet ID or name." % wallet)
+            raise WalletError(
+                "Wallet '%s' not found, please specify correct wallet ID or name."
+                % wallet
+            )
 
     def __exit__(self, exception_type, exception_value, traceback):
         try:
             self._session.close()
             self._engine.dispose()
         except Exception:
             pass
@@ -1421,16 +1924,15 @@
         try:
             self._session.close()
             self._engine.dispose()
         except Exception:
             pass
 
     def __repr__(self):
-        return "<Wallet(name=%s, db_uri=\"%s\")>" % \
-               (self.name, self.db_uri)
+        return '<Wallet(name=%s, db_uri="%s")>' % (self.name, self.db_uri)
 
     def __str__(self):
         return self.name
 
     def _get_account_defaults(self, network=None, account_id=None, key_id=None):
         """
         Check parameter values for network and account ID, return defaults if no network or account ID is specified.
@@ -1450,39 +1952,47 @@
             kobj = self.key(key_id)
             network = kobj.network_name
             account_id = kobj.account_id
         if network is None:
             network = self.network.name
         if account_id is None and network == self.network.name:
             account_id = self.default_account_id
-        qr = self._session.query(DbKey).\
-            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, depth=self.depth_public_master,
-                      network_name=network)
+        qr = self._session.query(DbKey).filter_by(
+            wallet_id=self.wallet_id,
+            purpose=self.purpose,
+            depth=self.depth_public_master,
+            network_name=network,
+        )
         if account_id is not None:
             qr = qr.filter_by(account_id=account_id)
         acckey = qr.first()
         if len(qr.all()) > 1 and "account'" in self.key_path:
-            _logger.warning("No account_id specified and more than one account found for this network %s. "
-                            "Using a random account" % network)
+            _logger.warning(
+                "No account_id specified and more than one account found for this network %s. "
+                "Using a random account" % network
+            )
         if account_id is None:
             if acckey:
                 account_id = acckey.account_id
             else:
                 account_id = 0
         return network, account_id, acckey
 
     @property
     def default_account_id(self):
         return self._default_account_id
 
     @default_account_id.setter
     def default_account_id(self, value):
         self._default_account_id = value
-        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id). \
-            update({DbWallet.default_account_id: value})
+        self._dbwallet = (
+            self._session.query(DbWallet)
+            .filter(DbWallet.id == self.wallet_id)
+            .update({DbWallet.default_account_id: value})
+        )
         self._commit()
 
     @property
     def owner(self):
         """
         Get wallet Owner
 
@@ -1499,16 +2009,19 @@
         :param value: Owner
         :type value: str
 
         :return str:
         """
 
         self._owner = value
-        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\
-            update({DbWallet.owner: value})
+        self._dbwallet = (
+            self._session.query(DbWallet)
+            .filter(DbWallet.id == self.wallet_id)
+            .update({DbWallet.owner: value})
+        )
         self._commit()
 
     @property
     def name(self):
         """
         Get wallet name
 
@@ -1527,26 +2040,29 @@
 
         :return str:
         """
 
         if wallet_exists(value, db_uri=self.db_uri):
             raise WalletError("Wallet with name '%s' already exists" % value)
         self._name = value
-        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update({DbWallet.name: value})
+        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update(
+            {DbWallet.name: value}
+        )
         self._commit()
 
     def default_network_set(self, network):
         if not isinstance(network, Network):
             network = Network(network)
         self.network = network
-        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\
-            update({DbWallet.network_name: network.name})
+        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update(
+            {DbWallet.network_name: network.name}
+        )
         self._commit()
 
-    def import_master_key(self, hdkey, name='Masterkey (imported)'):
+    def import_master_key(self, hdkey, name="Masterkey (imported)"):
         """
         Import (another) masterkey in this wallet
 
         :param hdkey: Private key
         :type hdkey: HDKey, str
         :param name: Key name of masterkey
         :type name: str
@@ -1554,54 +2070,84 @@
         :return HDKey: Main key as HDKey object
         """
 
         network, account_id, acckey = self._get_account_defaults()
         if not isinstance(hdkey, HDKey):
             hdkey = HDKey(hdkey)
         if not isinstance(self.main_key, WalletKey):
-            raise WalletError("Main wallet key is not an WalletKey instance. Type %s" % type(self.main_key))
+            raise WalletError(
+                "Main wallet key is not an WalletKey instance. Type %s"
+                % type(self.main_key)
+            )
         if not hdkey.is_private or hdkey.depth != 0:
-            raise WalletError("Please supply a valid private BIP32 master key with key depth 0")
+            raise WalletError(
+                "Please supply a valid private BIP32 master key with key depth 0"
+            )
         if self.main_key.is_private:
             raise WalletError("Main key is already a private key, cannot import key")
-        if (self.main_key.depth != 1 and self.main_key.depth != 3 and self.main_key.depth != 4) or \
-                self.main_key.key_type != 'bip32':
+        if (
+            self.main_key.depth != 1
+            and self.main_key.depth != 3
+            and self.main_key.depth != 4
+        ) or self.main_key.key_type != "bip32":
             raise WalletError("Current main key is not a valid BIP32 public master key")
         # pm = self.public_master()
         if not (self.network.name == self.main_key.network.name == hdkey.network.name):
-            raise WalletError("Network of Wallet class, main account key and the imported private key must use "
-                              "the same network")
+            raise WalletError(
+                "Network of Wallet class, main account key and the imported private key must use "
+                "the same network"
+            )
         if self.main_key.wif != hdkey.public_master().wif():
-            raise WalletError("This key does not correspond to current public master key")
-
-        hdkey.key_type = 'bip32'
-        ks = [k for k in WALLET_KEY_STRUCTURES if
-              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]
+            raise WalletError(
+                "This key does not correspond to current public master key"
+            )
+
+        hdkey.key_type = "bip32"
+        ks = [
+            k
+            for k in WALLET_KEY_STRUCTURES
+            if k["witness_type"] == self.witness_type
+            and k["multisig"] == self.multisig
+            and k["purpose"] is not None
+        ]
         if len(ks) > 1:
-            raise WalletError("Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
-                              "witness_type - multisig combination")
-        self.key_path = ks[0]['key_path']
+            raise WalletError(
+                "Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for "
+                "witness_type - multisig combination"
+            )
+        self.key_path = ks[0]["key_path"]
         self.main_key = WalletKey.from_key(
-            key=hdkey, name=name, session=self._session, wallet_id=self.wallet_id, network=network,
-            account_id=account_id, purpose=self.purpose, key_type='bip32', witness_type=self.witness_type)
+            key=hdkey,
+            name=name,
+            session=self._session,
+            wallet_id=self.wallet_id,
+            network=network,
+            account_id=account_id,
+            purpose=self.purpose,
+            key_type="bip32",
+            witness_type=self.witness_type,
+        )
         self.main_key_id = self.main_key.key_id
         self._key_objects.update({self.main_key_id: self.main_key})
-        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\
-            update({DbWallet.main_key_id: self.main_key_id})
+        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update(
+            {DbWallet.main_key_id: self.main_key_id}
+        )
 
         for key in self.keys(is_private=False):
             kp = key.path.split("/")
-            if kp and kp[0] == 'M':
-                kp = self.key_path[:self.depth_public_master+1] + kp[1:]
+            if kp and kp[0] == "M":
+                kp = self.key_path[: self.depth_public_master + 1] + kp[1:]
             self.key_for_path(kp, recreate=True)
 
         self._commit()
         return self.main_key
 
-    def import_key(self, key, account_id=0, name='', network=None, purpose=44, key_type=None):
+    def import_key(
+        self, key, account_id=0, name="", network=None, purpose=44, key_type=None
+    ):
         """
         Add new single key to wallet.
 
         :param key: Key to import
         :type key: str, bytes, int, HDKey, Address
         :param account_id: Account ID. Default is last used or created account ID.
         :type account_id: int
@@ -1613,112 +2159,185 @@
         :type purpose: int
         :param key_type: Key type of imported key, can be single. Unrelated to wallet, bip32, bip44 or master for new or extra master key import. Default is 'single'
         :type key_type: str
 
         :return WalletKey:
         """
 
-        if self.scheme not in ['bip32', 'single']:
-            raise WalletError("Keys can only be imported to a BIP32 or single type wallet, create a new wallet "
-                              "instead")
+        if self.scheme not in ["bip32", "single"]:
+            raise WalletError(
+                "Keys can only be imported to a BIP32 or single type wallet, create a new wallet "
+                "instead"
+            )
+
         if isinstance(key, (HDKey, Address)):
             network = key.network.name
             hdkey = key
             if network not in self.network_list():
                 raise WalletError("Network %s not found in this wallet" % network)
         else:
             if isinstance(key, str) and len(key.split(" ")) > 1:
                 if network is None:
                     network = self.network
                 hdkey = HDKey.from_seed(Mnemonic().to_seed(key), network=network)
             else:
                 if network is None:
-                    network = check_network_and_key(key, default_network=self.network.name)
+                    network = check_network_and_key(
+                        key, default_network=self.network.name
+                    )
                 if network not in self.network_list():
-                    raise WalletError("Network %s not available in this wallet, please create an account for this "
-                                      "network first." % network)
+                    raise WalletError(
+                        "Network %s not available in this wallet, please create an account for this "
+                        "network first." % network
+                    )
                 hdkey = HDKey(key, network=network, key_type=key_type)
 
         if not self.multisig:
-            if self.main_key and self.main_key.depth == self.depth_public_master and \
-                    not isinstance(hdkey, Address) and hdkey.is_private and hdkey.depth == 0 and self.scheme == 'bip32':
+            if (
+                self.main_key
+                and self.main_key.depth == self.depth_public_master
+                and not isinstance(hdkey, Address)
+                and hdkey.is_private
+                and hdkey.depth == 0
+                and self.scheme == "bip32"
+            ):
                 return self.import_master_key(hdkey, name)
 
             if key_type is None:
-                hdkey.key_type = 'single'
-                key_type = 'single'
+                hdkey.key_type = "single"
+                key_type = "single"
 
-            ik_path = 'm'
-            if key_type == 'single':
+            ik_path = "m"
+            if key_type == "single":
                 # Create path for unrelated import keys
                 hdkey.depth = self.key_depth
-                last_import_key = self._session.query(DbKey).filter(DbKey.path.like("import_key_%")).\
-                    order_by(DbKey.path.desc()).first()
+                last_import_key = (
+                    self._session.query(DbKey)
+                    .filter(DbKey.path.like("import_key_%"))
+                    .order_by(DbKey.path.desc())
+                    .first()
+                )
                 if last_import_key:
-                    ik_path = "import_key_" + str(int(last_import_key.path[-5:]) + 1).zfill(5)
+                    ik_path = "import_key_" + str(
+                        int(last_import_key.path[-5:]) + 1
+                    ).zfill(5)
                 else:
                     ik_path = "import_key_00001"
                 if not name:
                     name = ik_path
 
             mk = WalletKey.from_key(
-                key=hdkey, name=name, wallet_id=self.wallet_id, network=network, key_type=key_type,
-                account_id=account_id, purpose=purpose, session=self._session, path=ik_path,
-                witness_type=self.witness_type)
+                key=hdkey,
+                name=name,
+                wallet_id=self.wallet_id,
+                network=network,
+                key_type=key_type,
+                account_id=account_id,
+                purpose=purpose,
+                session=self._session,
+                path=ik_path,
+                witness_type=self.witness_type,
+            )
             self._key_objects.update({mk.key_id: mk})
             if mk.key_id == self.main_key.key_id:
                 self.main_key = mk
             return mk
         else:
-            account_key = hdkey.public_master(witness_type=self.witness_type, multisig=True).wif()
+            account_key = hdkey.public_master(
+                witness_type=self.witness_type, multisig=True
+            ).wif()
             for w in self.cosigner:
                 if w.main_key.key().wif_public() == account_key:
-                    _logger.debug("Import new private cosigner key in this multisig wallet: %s" % account_key)
+                    _logger.debug(
+                        "Import new private cosigner key in this multisig wallet: %s"
+                        % account_key
+                    )
                     return w.import_master_key(hdkey)
-            raise WalletError("Unknown key: Can only import a private key for a known public key in multisig wallets")
-
-    def _new_key_multisig(self, public_keys, name, account_id, change, cosigner_id, network, address_index):
+            raise WalletError(
+                "Unknown key: Can only import a private key for a known public key in multisig wallets"
+            )
+
+    def _new_key_multisig(
+        self, public_keys, name, account_id, change, cosigner_id, network, address_index
+    ):
         if self.sort_keys:
             public_keys.sort(key=lambda pubk: pubk.key_public)
         public_key_list = [pubk.key_public for pubk in public_keys]
         public_key_ids = [str(x.key_id) for x in public_keys]
 
         # Calculate redeemscript and address and add multisig key to database
         # redeemscript = serialize_multisig_redeemscript(public_key_list, n_required=self.multisig_n_required)
 
         # todo: pass key object, reuse key objects
-        redeemscript = Script(script_types=['multisig'], keys=public_key_list,
-                              sigs_required=self.multisig_n_required).serialize()
-        script_type = 'p2sh'
-        if self.witness_type == 'p2sh-segwit':
-            script_type = 'p2sh_p2wsh'
-        address = Address(redeemscript, encoding=self.encoding, script_type=script_type, network=network)
-        already_found_key = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id,
-                                                                 address=address.address).first()
+        redeemscript = Script(
+            script_types=["multisig"],
+            keys=public_key_list,
+            sigs_required=self.multisig_n_required,
+        ).serialize()
+        script_type = "p2sh"
+        if self.witness_type == "p2sh-segwit":
+            script_type = "p2sh_p2wsh"
+        address = Address(
+            redeemscript,
+            encoding=self.encoding,
+            script_type=script_type,
+            network=network,
+        )
+        already_found_key = (
+            self._session.query(DbKey)
+            .filter_by(wallet_id=self.wallet_id, address=address.address)
+            .first()
+        )
         if already_found_key:
             return self.key(already_found_key.id)
-        path = [pubk.path for pubk in public_keys if pubk.wallet.cosigner_id == self.cosigner_id][0]
-        depth = self.cosigner[self.cosigner_id].main_key.depth + len(path.split("/")) - 1
+        path = [
+            pubk.path
+            for pubk in public_keys
+            if pubk.wallet.cosigner_id == self.cosigner_id
+        ][0]
+        depth = (
+            self.cosigner[self.cosigner_id].main_key.depth + len(path.split("/")) - 1
+        )
         if not name:
-            name = "Multisig Key " + '/'.join(public_key_ids)
+            name = "Multisig Key " + "/".join(public_key_ids)
 
         multisig_key = DbKey(
-            name=name[:80], wallet_id=self.wallet_id, purpose=self.purpose, account_id=account_id,
-            depth=depth, change=change, address_index=address_index, parent_id=0, is_private=False, path=path,
-            public=address.hash_bytes, wif='multisig-%s' % address, address=address.address, cosigner_id=cosigner_id,
-            key_type='multisig', network_name=network)
+            name=name[:80],
+            wallet_id=self.wallet_id,
+            purpose=self.purpose,
+            account_id=account_id,
+            depth=depth,
+            change=change,
+            address_index=address_index,
+            parent_id=0,
+            is_private=False,
+            path=path,
+            public=address.hash_bytes,
+            wif="multisig-%s" % address,
+            address=address.address,
+            cosigner_id=cosigner_id,
+            key_type="multisig",
+            network_name=network,
+        )
         self._session.add(multisig_key)
         self._commit()
         for child_id in public_key_ids:
-            self._session.add(DbKeyMultisigChildren(key_order=public_key_ids.index(child_id), parent_id=multisig_key.id,
-                                                    child_id=int(child_id)))
+            self._session.add(
+                DbKeyMultisigChildren(
+                    key_order=public_key_ids.index(child_id),
+                    parent_id=multisig_key.id,
+                    child_id=int(child_id),
+                )
+            )
         self._commit()
         return self.key(multisig_key.id)
 
-    def new_key(self, name='', account_id=None, change=0, cosigner_id=None, network=None):
+    def new_key(
+        self, name="", account_id=None, change=0, cosigner_id=None, network=None
+    ):
         """
         Create a new HD Key derived from this wallet's masterkey. An account will be created for this wallet
         with index 0 if there is no account defined yet.
 
         >>> w = Wallet('create_legacy_wallet_test')
         >>> w.new_key('my key') # doctest:+ELLIPSIS
         <WalletKey(key_id=..., name=my key, wif=..., path=m/44'/0'/0'/0/...)>
@@ -1733,44 +2352,70 @@
         :type cosigner_id: int
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return WalletKey:
         """
 
-        if self.scheme == 'single':
+        if self.scheme == "single":
             return self.main_key
 
         network, account_id, _ = self._get_account_defaults(network, account_id)
         if network != self.network.name and "coin_type'" not in self.key_path:
             raise WalletError("Multiple networks not supported by wallet key structure")
         if self.multisig:
             if not self.multisig_n_required:
                 raise WalletError("Multisig_n_required not set, cannot create new key")
             if cosigner_id is None:
                 if self.cosigner_id is None:
-                    raise WalletError("Missing Cosigner ID value, cannot create new key")
+                    raise WalletError(
+                        "Missing Cosigner ID value, cannot create new key"
+                    )
                 cosigner_id = self.cosigner_id
 
         address_index = 0
-        if self.multisig and cosigner_id is not None and (len(self.cosigner) > cosigner_id and self.cosigner[cosigner_id].key_path == 'm' or self.cosigner[cosigner_id].key_path == ['m']):
+        if (
+            self.multisig
+            and cosigner_id is not None
+            and (
+                len(self.cosigner) > cosigner_id
+                and self.cosigner[cosigner_id].key_path == "m"
+                or self.cosigner[cosigner_id].key_path == ["m"]
+            )
+        ):
             req_path = []
         else:
-            prevkey = self._session.query(DbKey).\
-                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network, account_id=account_id,
-                          change=change, cosigner_id=cosigner_id, depth=self.key_depth).\
-                order_by(DbKey.address_index.desc()).first()
+            prevkey = (
+                self._session.query(DbKey)
+                .filter_by(
+                    wallet_id=self.wallet_id,
+                    purpose=self.purpose,
+                    network_name=network,
+                    account_id=account_id,
+                    change=change,
+                    cosigner_id=cosigner_id,
+                    depth=self.key_depth,
+                )
+                .order_by(DbKey.address_index.desc())
+                .first()
+            )
             if prevkey:
                 address_index = prevkey.address_index + 1
             req_path = [change, address_index]
 
-        return self.key_for_path(req_path, name=name, account_id=account_id, network=network,
-                                 cosigner_id=cosigner_id, address_index=address_index)
+        return self.key_for_path(
+            req_path,
+            name=name,
+            account_id=account_id,
+            network=network,
+            cosigner_id=cosigner_id,
+            address_index=address_index,
+        )
 
-    def new_key_change(self, name='', account_id=None, network=None):
+    def new_key_change(self, name="", account_id=None, network=None):
         """
         Create new key to receive change for a transaction. Calls :func:`new_key` method with change=1.
 
         :param name: Key name. Default name is 'Change #' with an address index
         :type name: str
         :param account_id: Account ID. Default is last used or created account ID.
         :type account_id: int
@@ -1778,42 +2423,57 @@
         :type network: str
 
         :return WalletKey:
         """
 
         return self.new_key(name=name, account_id=account_id, network=network, change=1)
 
-    def scan_key(self, key):
+    async def scan_key(self, key: int | WalletKey):
         """
         Scan for new transactions for specified wallet key and update wallet transactions
 
         :param key: The wallet key as object or index
         :type key: WalletKey, int
 
         :return bool: New transactions found?
 
         """
         if isinstance(key, int):
             key = self.key(key)
+
         txs_found = False
         should_be_finished_count = 0
+
         while True:
-            n_new = self.transactions_update(key_id=key.key_id)
+            n_new = await self.transactions_update(key_id=key.key_id)
             if n_new and n_new < MAX_TRANSACTIONS:
                 if should_be_finished_count:
-                    _logger.info("Possible recursive loop detected in scan_key(%d): retry %d/5" %
-                                 (key.key_id, should_be_finished_count))
+                    _logger.info(
+                        "Possible recursive loop detected in scan_key(%d): retry %d/5"
+                        % (key.key_id, should_be_finished_count)
+                    )
                 should_be_finished_count += 1
-            logger.info("Scanned key %d, %s Found %d new transactions" % (key.key_id, key.address, n_new))
+            _logger.info(
+                "Scanned key %d, %s Found %d new transactions"
+                % (key.key_id, key.address, n_new)
+            )
             if not n_new or should_be_finished_count > 5:
                 break
             txs_found = True
         return txs_found
 
-    def scan(self, scan_gap_limit=5, account_id=None, change=None, rescan_used=False, network=None, keys_ignore=None):
+    async def scan(
+        self,
+        scan_gap_limit=5,
+        account_id=None,
+        change=None,
+        rescan_used=False,
+        network=None,
+        keys_ignore=None,
+    ):
         """
         Generate new addresses/keys and scan for new transactions using the Service providers. Updates all UTXO's and balances.
 
         Keep scanning for new transactions until no new transactions are found for 'scan_gap_limit' addresses. Only scan keys from default network and account unless another network or account is specified.
 
         Use the faster :func:`utxos_update` method if you are only interested in unspent outputs.
         Use the :func:`transactions_update` method if you would like to manage the key creation yourself or if you want to scan a single key.
@@ -1831,90 +2491,146 @@
         :param keys_ignore: Id's of keys to ignore
         :type keys_ignore: list of int
 
         :return:
         """
 
         network, account_id, _ = self._get_account_defaults(network, account_id)
-        if self.scheme != 'bip32' and self.scheme != 'multisig' and scan_gap_limit < 2:
-            raise WalletError("The wallet scan() method is only available for BIP32 wallets")
+        if self.scheme != "bip32" and self.scheme != "multisig" and scan_gap_limit < 2:
+            raise WalletError(
+                "The wallet scan() method is only available for BIP32 wallets"
+            )
         if keys_ignore is None:
             keys_ignore = []
 
         # Rescan used addresses
         if rescan_used:
-            for key in self.keys_addresses(account_id=account_id, change=change, network=network, used=True):
+            for key in self.keys_addresses(
+                account_id=account_id, change=change, network=network, used=True
+            ):
                 self.scan_key(key.id)
 
         # Update already known transactions with known block height
-        self.transactions_update_confirmations()
+        await self.transactions_update_confirmations()
 
         # Check unconfirmed transactions
-        db_txs = self._session.query(DbTransaction). \
-            filter(DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network, DbTransaction.confirmations == 0).all()
-        for db_tx in db_txs:
-            self.transactions_update_by_txids([db_tx.txid])
+        db_txs = (
+            self._session.query(DbTransaction)
+            .filter(
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransaction.network_name == network,
+                DbTransaction.confirmations == 0,
+            )
+            .all()
+        )
+        db_txids = [x.txid for x in db_txs]
+        if db_txids:
+            await self.transactions_update_by_txids(db_txids)
 
         # Scan each key address, stop when no new transactions are found after set scan gap limit
         if change is None:
             change_range = [0, 1]
         else:
             change_range = [change]
         counter = 0
         for chg in change_range:
             while True:
-                if self.scheme == 'single':
-                    keys_to_scan = [self.key(k.id) for k in self.keys_addresses()[counter:counter+scan_gap_limit]]
+                if self.scheme == "single":
+                    keys_to_scan = [
+                        self.key(k.id)
+                        for k in self.keys_addresses()[
+                            counter : counter + scan_gap_limit
+                        ]
+                    ]
                     counter += scan_gap_limit
                 else:
-                    keys_to_scan = self.get_keys(account_id, network, number_of_keys=scan_gap_limit, change=chg)
+                    keys_to_scan = self.get_keys(
+                        account_id, network, number_of_keys=scan_gap_limit, change=chg
+                    )
                 n_highest_updated = 0
                 for key in keys_to_scan:
                     if key.key_id in keys_ignore:
                         continue
                     keys_ignore.append(key.key_id)
                     n_high_new = 0
-                    if self.scan_key(key):
+                    if await self.scan_key(key):
                         if not key.address_index:
                             key.address_index = 0
                         n_high_new = key.address_index + 1
                     if n_high_new > n_highest_updated:
                         n_highest_updated = n_high_new
                 if not n_highest_updated:
                     break
 
-    def _get_key(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0, as_list=False):
+    def _get_key(
+        self,
+        account_id=None,
+        network=None,
+        cosigner_id=None,
+        number_of_keys=1,
+        change=0,
+        as_list=False,
+    ):
         network, account_id, _ = self._get_account_defaults(network, account_id)
         if cosigner_id is None:
             cosigner_id = self.cosigner_id
         elif cosigner_id > len(self.cosigner):
-            raise WalletError("Cosigner ID (%d) can not be greater then number of cosigners for this wallet (%d)" %
-                              (cosigner_id, len(self.cosigner)))
-
-        last_used_qr = self._session.query(DbKey.id).\
-            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,
-                      used=True, change=change, depth=self.key_depth).\
-            order_by(DbKey.id.desc()).first()
+            raise WalletError(
+                "Cosigner ID (%d) can not be greater then number of cosigners for this wallet (%d)"
+                % (cosigner_id, len(self.cosigner))
+            )
+
+        last_used_qr = (
+            self._session.query(DbKey.id)
+            .filter_by(
+                wallet_id=self.wallet_id,
+                account_id=account_id,
+                network_name=network,
+                cosigner_id=cosigner_id,
+                used=True,
+                change=change,
+                depth=self.key_depth,
+            )
+            .order_by(DbKey.id.desc())
+            .first()
+        )
         last_used_key_id = 0
         if last_used_qr:
             last_used_key_id = last_used_qr.id
-        dbkey = self._session.query(DbKey).\
-            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,
-                      used=False, change=change, depth=self.key_depth).filter(DbKey.id > last_used_key_id).\
-            order_by(DbKey.id.desc()).all()
+        dbkey = (
+            self._session.query(DbKey)
+            .filter_by(
+                wallet_id=self.wallet_id,
+                account_id=account_id,
+                network_name=network,
+                cosigner_id=cosigner_id,
+                used=False,
+                change=change,
+                depth=self.key_depth,
+            )
+            .filter(DbKey.id > last_used_key_id)
+            .order_by(DbKey.id.desc())
+            .all()
+        )
         key_list = []
-        if self.scheme == 'single' and len(dbkey):
-            number_of_keys = len(dbkey) if number_of_keys > len(dbkey) else number_of_keys
+        if self.scheme == "single" and len(dbkey):
+            number_of_keys = (
+                len(dbkey) if number_of_keys > len(dbkey) else number_of_keys
+            )
         for i in range(number_of_keys):
             if dbkey:
                 dk = dbkey.pop()
                 nk = self.key(dk.id)
             else:
-                nk = self.new_key(account_id=account_id, change=change, cosigner_id=cosigner_id, network=network)
+                nk = self.new_key(
+                    account_id=account_id,
+                    change=change,
+                    cosigner_id=cosigner_id,
+                    network=network,
+                )
             key_list.append(nk)
         if as_list:
             return key_list
         else:
             return key_list[0]
 
     def get_key(self, account_id=None, network=None, cosigner_id=None, change=0):
@@ -1937,17 +2653,26 @@
         :param cosigner_id: Cosigner ID for key path
         :type cosigner_id: int
         :param change: Payment (0) or change key (1). Default is 0
         :type change: int
 
         :return WalletKey:
         """
-        return self._get_key(account_id, network, cosigner_id, change=change, as_list=False)
-
-    def get_keys(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0):
+        return self._get_key(
+            account_id, network, cosigner_id, change=change, as_list=False
+        )
+
+    def get_keys(
+        self,
+        account_id=None,
+        network=None,
+        cosigner_id=None,
+        number_of_keys=1,
+        change=0,
+    ):
         """
         Get a list of unused keys / addresses or create a new ones with :func:`new_key` if there are no unused keys.
         Returns a list of keys from this wallet which has no transactions linked to it.
 
         Use the get_key() method to get a single key.
 
         :param account_id: Account ID. Default is last used or created account ID.
@@ -1959,32 +2684,38 @@
         :param number_of_keys: Number of keys to return. Default is 1
         :type number_of_keys: int
         :param change: Payment (0) or change key (1). Default is 0
         :type change: int
 
         :return list of WalletKey:
         """
-        if self.scheme == 'single':
-            raise WalletError("Single wallet has only one (master)key. Use get_key() or main_key() method")
-        return self._get_key(account_id, network, cosigner_id, number_of_keys, change, as_list=True)
+        if self.scheme == "single":
+            raise WalletError(
+                "Single wallet has only one (master)key. Use get_key() or main_key() method"
+            )
+        return self._get_key(
+            account_id, network, cosigner_id, number_of_keys, change, as_list=True
+        )
 
     def get_key_change(self, account_id=None, network=None):
         """
         Get a unused change key or create a new one if there are no unused keys.
         Wrapper for the :func:`get_key` method
 
         :param account_id: Account ID. Default is last used or created account ID.
         :type account_id: int
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return WalletKey:
         """
 
-        return self._get_key(account_id=account_id, network=network, change=1, as_list=False)
+        return self._get_key(
+            account_id=account_id, network=network, change=1, as_list=False
+        )
 
     def get_keys_change(self, account_id=None, network=None, number_of_keys=1):
         """
         Get a unused change key or create a new one if there are no unused keys.
         Wrapper for the :func:`get_key` method
 
         :param account_id: Account ID. Default is last used or created account ID.
@@ -1993,18 +2724,23 @@
         :type network: str
         :param number_of_keys: Number of keys to return. Default is 1
         :type number_of_keys: int
 
         :return list of WalletKey:
         """
 
-        return self._get_key(account_id=account_id, network=network, change=1, number_of_keys=number_of_keys,
-                             as_list=True)
+        return self._get_key(
+            account_id=account_id,
+            network=network,
+            change=1,
+            number_of_keys=number_of_keys,
+            as_list=True,
+        )
 
-    def new_account(self, name='', account_id=None, network=None):
+    def new_account(self, name="", account_id=None, network=None):
         """
         Create a new account with a child key for payments and 1 for change.
 
         An account key can only be created if wallet contains a masterkey.
 
         :param name: Account Name. If not specified "Account #" with the account_id will be used as name
         :type name: str
@@ -2012,52 +2748,88 @@
         :type account_id: int
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return WalletKey:
         """
 
-        if self.scheme != 'bip32':
-            raise WalletError("We can only create new accounts for a wallet with a BIP32 key scheme")
-        if self.main_key and (self.main_key.depth != 0 or self.main_key.is_private is False):
-            raise WalletError("A master private key of depth 0 is needed to create new accounts (depth: %d)" %
-                              self.main_key.depth)
+        if self.scheme != "bip32":
+            raise WalletError(
+                "We can only create new accounts for a wallet with a BIP32 key scheme"
+            )
+        if self.main_key and (
+            self.main_key.depth != 0 or self.main_key.is_private is False
+        ):
+            raise WalletError(
+                "A master private key of depth 0 is needed to create new accounts (depth: %d)"
+                % self.main_key.depth
+            )
         if "account'" not in self.key_path:
-            raise WalletError("Accounts are not supported for this wallet. Account not found in key path %s" %
-                              self.key_path)
+            raise WalletError(
+                "Accounts are not supported for this wallet. Account not found in key path %s"
+                % self.key_path
+            )
         if network is None:
             network = self.network.name
         elif network != self.network.name and "coin_type'" not in self.key_path:
             raise WalletError("Multiple networks not supported by wallet key structure")
 
-        duplicate_cointypes = [Network(x).name for x in self.network_list() if Network(x).name != network and
-                               Network(x).bip44_cointype == Network(network).bip44_cointype]
+        duplicate_cointypes = [
+            Network(x).name
+            for x in self.network_list()
+            if Network(x).name != network
+            and Network(x).bip44_cointype == Network(network).bip44_cointype
+        ]
         if duplicate_cointypes:
-            raise WalletError("Can not create new account for network %s with same BIP44 cointype: %s" %
-                              (network, duplicate_cointypes))
+            raise WalletError(
+                "Can not create new account for network %s with same BIP44 cointype: %s"
+                % (network, duplicate_cointypes)
+            )
 
         # Determine account_id and name
         if account_id is None:
             account_id = 0
-            qr = self._session.query(DbKey). \
-                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network). \
-                order_by(DbKey.account_id.desc()).first()
+            qr = (
+                self._session.query(DbKey)
+                .filter_by(
+                    wallet_id=self.wallet_id, purpose=self.purpose, network_name=network
+                )
+                .order_by(DbKey.account_id.desc())
+                .first()
+            )
             if qr:
                 account_id = qr.account_id + 1
-        if self.keys(account_id=account_id, depth=self.depth_public_master, network=network):
-            raise WalletError("Account with ID %d already exists for this wallet" % account_id)
-
-        acckey = self.key_for_path([], level_offset=self.depth_public_master-self.key_depth, account_id=account_id,
-                                   name=name, network=network)
+        if self.keys(
+            account_id=account_id, depth=self.depth_public_master, network=network
+        ):
+            raise WalletError(
+                "Account with ID %d already exists for this wallet" % account_id
+            )
+
+        acckey = self.key_for_path(
+            [],
+            level_offset=self.depth_public_master - self.key_depth,
+            account_id=account_id,
+            name=name,
+            network=network,
+        )
         self.key_for_path([0, 0], network=network, account_id=account_id)
         self.key_for_path([1, 0], network=network, account_id=account_id)
         return acckey
 
-    def path_expand(self, path, level_offset=None, account_id=None, cosigner_id=0, address_index=None, change=0,
-                    network=DEFAULT_NETWORK):
+    def path_expand(
+        self,
+        path,
+        level_offset=None,
+        account_id=None,
+        cosigner_id=0,
+        address_index=None,
+        change=0,
+        network=DEFAULT_NETWORK,
+    ):
         """
         Create key path. Specify part of key path to expand to key path used in this wallet.
 
         >>> w = Wallet('create_legacy_wallet_test')
         >>> w.path_expand([0,1200])
         ['m', "44'", "0'", "0'", '0', '1200']
 
@@ -2079,20 +2851,39 @@
         :type change: int
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return list:
         """
         network, account_id, _ = self._get_account_defaults(network, account_id)
-        return path_expand(path, self.key_path, level_offset, account_id=account_id, cosigner_id=cosigner_id,
-                           address_index=address_index, change=change, purpose=self.purpose,
-                           witness_type=self.witness_type, network=network)
-
-    def key_for_path(self, path, level_offset=None, name=None, account_id=None, cosigner_id=None,
-                     address_index=0, change=0, network=None, recreate=False):
+        return path_expand(
+            path,
+            self.key_path,
+            level_offset,
+            account_id=account_id,
+            cosigner_id=cosigner_id,
+            address_index=address_index,
+            change=change,
+            purpose=self.purpose,
+            witness_type=self.witness_type,
+            network=network,
+        )
+
+    def key_for_path(
+        self,
+        path,
+        level_offset=None,
+        name=None,
+        account_id=None,
+        cosigner_id=None,
+        address_index=0,
+        change=0,
+        network=None,
+        recreate=False,
+    ):
         """
         Return key for specified path. Derive all wallet keys in path if they not already exists
 
         >>> w = wallet_create_or_open('key_for_path_example')
         >>> key = w.key_for_path([0, 0])
         >>> key.path
         "m/44'/0'/0'/0/0"
@@ -2135,82 +2926,146 @@
         network, account_id, _ = self._get_account_defaults(network, account_id)
         cosigner_id = cosigner_id if cosigner_id is not None else self.cosigner_id
         level_offset_key = level_offset
         if level_offset and self.main_key and level_offset > 0:
             level_offset_key = level_offset - self.main_key.depth
 
         key_path = self.key_path
-        if self.multisig and cosigner_id is not None and len(self.cosigner) > cosigner_id:
+        if (
+            self.multisig
+            and cosigner_id is not None
+            and len(self.cosigner) > cosigner_id
+        ):
             key_path = self.cosigner[cosigner_id].key_path
-        fullpath = path_expand(path, key_path, level_offset_key, account_id=account_id, cosigner_id=cosigner_id,
-                               purpose=self.purpose, address_index=address_index, change=change,
-                               witness_type=self.witness_type, network=network)
+        fullpath = path_expand(
+            path,
+            key_path,
+            level_offset_key,
+            account_id=account_id,
+            cosigner_id=cosigner_id,
+            purpose=self.purpose,
+            address_index=address_index,
+            change=change,
+            witness_type=self.witness_type,
+            network=network,
+        )
 
         if self.multisig and self.cosigner:
             public_keys = []
             for wlt in self.cosigner:
-                if wlt.scheme == 'single':
+                if wlt.scheme == "single":
                     wk = wlt.main_key
                 else:
-                    wk = wlt.key_for_path(path, level_offset=level_offset, account_id=account_id, name=name,
-                                          cosigner_id=cosigner_id, network=network, recreate=recreate)
+                    wk = wlt.key_for_path(
+                        path,
+                        level_offset=level_offset,
+                        account_id=account_id,
+                        name=name,
+                        cosigner_id=cosigner_id,
+                        network=network,
+                        recreate=recreate,
+                    )
                 public_keys.append(wk)
-            return self._new_key_multisig(public_keys, name, account_id, change, cosigner_id, network, address_index)
+            return self._new_key_multisig(
+                public_keys,
+                name,
+                account_id,
+                change,
+                cosigner_id,
+                network,
+                address_index,
+            )
 
         # Check for closest ancestor in wallet\
         wpath = fullpath
-        if self.main_key.depth and fullpath and fullpath[0] != 'M':
-            wpath = ["M"] + fullpath[self.main_key.depth + 1:]
+        if self.main_key.depth and fullpath and fullpath[0] != "M":
+            wpath = ["M"] + fullpath[self.main_key.depth + 1 :]
         dbkey = None
         while wpath and not dbkey:
-            qr = self._session.query(DbKey).filter_by(path=normalize_path('/'.join(wpath)), wallet_id=self.wallet_id)
+            qr = self._session.query(DbKey).filter_by(
+                path=normalize_path("/".join(wpath)), wallet_id=self.wallet_id
+            )
             if recreate:
                 qr = qr.filter_by(is_private=True)
             dbkey = qr.first()
             wpath = wpath[:-1]
         if not dbkey:
             _logger.warning("No master or public master key found in this wallet")
             return None
         else:
             topkey = self.key(dbkey.id)
 
         # Key already found in db, return key
-        if dbkey and dbkey.path == normalize_path('/'.join(fullpath)) and not recreate:
+        if dbkey and dbkey.path == normalize_path("/".join(fullpath)) and not recreate:
             return topkey
         else:
             # Create 1 or more keys add them to wallet
             nk = None
             parent_id = topkey.key_id
             ck = topkey.key()
             newpath = topkey.path
-            n_items = len(str(dbkey.path).split('/'))
+            n_items = len(str(dbkey.path).split("/"))
             for lvl in fullpath[n_items:]:
                 ck = ck.subkey_for_path(lvl, network=network)
-                newpath += '/' + lvl
+                newpath += "/" + lvl
                 if not account_id:
-                    account_id = 0 if "account'" not in self.key_path or self.key_path.index("account'") >= len(
-                        fullpath) \
+                    account_id = (
+                        0
+                        if "account'" not in self.key_path
+                        or self.key_path.index("account'") >= len(fullpath)
                         else int(fullpath[self.key_path.index("account'")][:-1])
-                change = None if "change" not in self.key_path or self.key_path.index("change") >= len(fullpath) \
+                    )
+                change = (
+                    None
+                    if "change" not in self.key_path
+                    or self.key_path.index("change") >= len(fullpath)
                     else int(fullpath[self.key_path.index("change")])
-                if name and len(fullpath) == len(newpath.split('/')):
+                )
+                if name and len(fullpath) == len(newpath.split("/")):
                     key_name = name
                 else:
-                    key_name = "%s %s" % (self.key_path[len(newpath.split('/'))-1], lvl)
+                    key_name = "%s %s" % (
+                        self.key_path[len(newpath.split("/")) - 1],
+                        lvl,
+                    )
                     key_name = key_name.replace("'", "").replace("_", " ")
-                nk = WalletKey.from_key(key=ck, name=key_name, wallet_id=self.wallet_id, account_id=account_id,
-                                        change=change, purpose=self.purpose, path=newpath, parent_id=parent_id,
-                                        encoding=self.encoding, witness_type=self.witness_type,
-                                        cosigner_id=cosigner_id, network=network, session=self._session)
+                nk = WalletKey.from_key(
+                    key=ck,
+                    name=key_name,
+                    wallet_id=self.wallet_id,
+                    account_id=account_id,
+                    change=change,
+                    purpose=self.purpose,
+                    path=newpath,
+                    parent_id=parent_id,
+                    encoding=self.encoding,
+                    witness_type=self.witness_type,
+                    cosigner_id=cosigner_id,
+                    network=network,
+                    session=self._session,
+                )
                 self._key_objects.update({nk.key_id: nk})
                 parent_id = nk.key_id
             return nk
 
-    def keys(self, account_id=None, name=None, key_id=None, change=None, depth=None, used=None, is_private=None,
-             has_balance=None, is_active=None, network=None, include_private=False, as_dict=False):
+    def keys(
+        self,
+        account_id=None,
+        name=None,
+        key_id=None,
+        change=None,
+        depth=None,
+        used=None,
+        is_private=None,
+        has_balance=None,
+        is_active=None,
+        network=None,
+        include_private=False,
+        as_dict=False,
+    ):
         """
         Search for keys in database. Include 0 or more of account_id, name, key_id, change and depth.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> all_wallet_keys = w.keys()
         >>> w.keys(depth=0) # doctest:+ELLIPSIS
         [<DbKey(id=..., name='fluxwallet_legacy_wallet_test', wif='xprv9s21ZrQH143K3cxbMVswDTYgAc9CeXABQjCD9zmXCpXw4MxN93LanEARbBmV3utHZS9Db4FX1C1RbC5KSNAjQ5WNJ1dDBJ34PjfiSgRvS8x'>]
@@ -2241,24 +3096,28 @@
         :type include_private: bool
         :param as_dict: Return keys as dictionary objects. Default is False: DbKey objects
         :type as_dict: bool
 
         :return list of DbKey: List of Keys
         """
 
-        qr = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id).order_by(DbKey.id)
+        qr = (
+            self._session.query(DbKey)
+            .filter_by(wallet_id=self.wallet_id)
+            .order_by(DbKey.id)
+        )
         if network is not None:
             qr = qr.filter(DbKey.network_name == network)
         if account_id is not None:
             qr = qr.filter(DbKey.account_id == account_id)
-            if self.scheme == 'bip32' and depth is None:
+            if self.scheme == "bip32" and depth is None:
                 qr = qr.filter(DbKey.depth >= 3)
         if change is not None:
             qr = qr.filter(DbKey.change == change)
-            if self.scheme == 'bip32' and depth is None:
+            if self.scheme == "bip32" and depth is None:
                 qr = qr.filter(DbKey.depth > self.key_depth - 1)
         if depth is not None:
             qr = qr.filter(DbKey.depth == depth)
         if name is not None:
             qr = qr.filter(DbKey.name == name)
         if key_id is not None:
             qr = qr.filter(DbKey.id == key_id)
@@ -2278,18 +3137,23 @@
             qr = qr.filter(or_(DbKey.balance != 0, DbKey.used.is_(False)))
         keys = qr.order_by(DbKey.depth).all()
         if as_dict:
             keys = [x.__dict__ for x in keys]
             keys2 = []
             private_fields = []
             if not include_private:
-                private_fields += ['private', 'wif']
+                private_fields += ["private", "wif"]
             for key in keys:
-                keys2.append({k: v for (k, v) in key.items()
-                              if k[:1] != '_' and k != 'wallet' and k not in private_fields})
+                keys2.append(
+                    {
+                        k: v
+                        for (k, v) in key.items()
+                        if k[:1] != "_" and k != "wallet" and k not in private_fields
+                    }
+                )
             return keys2
         qr.session.close()
         return keys
 
     def keys_networks(self, used=None, as_dict=False):
         """
         Get keys of defined networks for this wallet. Wrapper for the :func:`keys` method
@@ -2307,22 +3171,26 @@
         :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects
         :type as_dict: bool
 
         :return list of (DbKey, dict):
 
         """
 
-        if self.scheme != 'bip32':
-            raise WalletError("The 'keys_network' method can only be used with BIP32 type wallets")
+        if self.scheme != "bip32":
+            raise WalletError(
+                "The 'keys_network' method can only be used with BIP32 type wallets"
+            )
         try:
             depth = self.key_path.index("coin_type'")
         except ValueError:
             return []
         if self.multisig and self.cosigner:
-            _logger.warning("No network keys available for multisig wallet, use networks() method for list of networks")
+            _logger.warning(
+                "No network keys available for multisig wallet, use networks() method for list of networks"
+            )
         return self.keys(depth=depth, used=used, as_dict=as_dict)
 
     def keys_accounts(self, account_id=None, network=DEFAULT_NETWORK, as_dict=False):
         """
         Get Database records of account key(s) with for current wallet. Wrapper for the :func:`keys` method.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
@@ -2338,18 +3206,28 @@
         :type network: str
         :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects
         :type as_dict: bool
 
         :return list of (DbKey, dict):
         """
 
-        return self.keys(account_id, depth=self.depth_public_master, network=network, as_dict=as_dict)
-
-    def keys_addresses(self, account_id=None, used=None, is_active=None, change=None, network=None, depth=None,
-                       as_dict=False):
+        return self.keys(
+            account_id, depth=self.depth_public_master, network=network, as_dict=as_dict
+        )
+
+    def keys_addresses(
+        self,
+        account_id=None,
+        used=None,
+        is_active=None,
+        change=None,
+        network=None,
+        depth=None,
+        as_dict=False,
+    ):
         """
         Get address keys of specified account_id for current wallet. Wrapper for the :func:`keys` methods.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> w.keys_addresses()[0].address
         '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg'
 
@@ -2369,18 +3247,27 @@
         :type as_dict: bool
 
         :return list of (DbKey, dict)
         """
 
         if depth is None:
             depth = self.key_depth
-        return self.keys(account_id, depth=depth, used=used, change=change, is_active=is_active, network=network,
-                         as_dict=as_dict)
-
-    def keys_address_payment(self, account_id=None, used=None, network=None, as_dict=False):
+        return self.keys(
+            account_id,
+            depth=depth,
+            used=used,
+            change=change,
+            is_active=is_active,
+            network=network,
+            as_dict=as_dict,
+        )
+
+    def keys_address_payment(
+        self, account_id=None, used=None, network=None, as_dict=False
+    ):
         """
         Get payment addresses (change=0) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.
 
         :param account_id: Account ID
         :type account_id: int
         :param used: Only return used or unused keys
         :type used: bool
@@ -2388,17 +3275,26 @@
         :type network: str
         :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects
         :type as_dict: bool
 
         :return list of (DbKey, dict)
         """
 
-        return self.keys(account_id, depth=self.key_depth, change=0, used=used, network=network, as_dict=as_dict)
-
-    def keys_address_change(self, account_id=None, used=None, network=None, as_dict=False):
+        return self.keys(
+            account_id,
+            depth=self.key_depth,
+            change=0,
+            used=used,
+            network=network,
+            as_dict=as_dict,
+        )
+
+    def keys_address_change(
+        self, account_id=None, used=None, network=None, as_dict=False
+    ):
         """
         Get payment addresses (change=1) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.
 
         :param account_id: Account ID
         :type account_id: int
         :param used: Only return used or unused keys
         :type used: bool
@@ -2406,17 +3302,32 @@
         :type network: str
         :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects
         :type as_dict: bool
 
         :return list of (DbKey, dict)
         """
 
-        return self.keys(account_id, depth=self.key_depth, change=1, used=used, network=network, as_dict=as_dict)
-
-    def addresslist(self, account_id=None, used=None, network=None, change=None, depth=None, key_id=None):
+        return self.keys(
+            account_id,
+            depth=self.key_depth,
+            change=1,
+            used=used,
+            network=network,
+            as_dict=as_dict,
+        )
+
+    def addresslist(
+        self,
+        account_id=None,
+        used=None,
+        network=None,
+        change=None,
+        depth=None,
+        key_id=None,
+    ):
         """
         Get list of addresses defined in current wallet. Wrapper for the :func:`keys` methods.
 
         Use :func:`keys_addresses` method to receive full key objects
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> w.addresslist()[0]
@@ -2438,16 +3349,23 @@
         """
 
         addresslist = []
         if depth is None:
             depth = self.key_depth
         elif depth == -1:
             depth = None
-        for key in self.keys(account_id=account_id, depth=depth, used=used, network=network, change=change,
-                             key_id=key_id, is_active=False):
+        for key in self.keys(
+            account_id=account_id,
+            depth=depth,
+            used=used,
+            network=network,
+            change=change,
+            key_id=key_id,
+            is_active=False,
+        ):
             addresslist.append(key.address)
         return addresslist
 
     def key(self, term):
         """
         Return single key with given ID or name as WalletKey object
 
@@ -2494,21 +3412,33 @@
         :param account_id: ID of account. Default is 0
         :type account_id: int
 
         :return WalletKey:
         """
 
         if "account'" not in self.key_path:
-            raise WalletError("Accounts are not supported for this wallet. Account not found in key path %s" %
-                              self.key_path)
-        qr = self._session.query(DbKey).\
-            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=self.network.name,
-                      account_id=account_id, depth=3).scalar()
+            raise WalletError(
+                "Accounts are not supported for this wallet. Account not found in key path %s"
+                % self.key_path
+            )
+        qr = (
+            self._session.query(DbKey)
+            .filter_by(
+                wallet_id=self.wallet_id,
+                purpose=self.purpose,
+                network_name=self.network.name,
+                account_id=account_id,
+                depth=3,
+            )
+            .scalar()
+        )
         if not qr:
-            raise WalletError("Account with ID %d not found in this wallet" % account_id)
+            raise WalletError(
+                "Account with ID %d not found in this wallet" % account_id
+            )
         key_id = qr.id
         return self.key(key_id)
 
     def accounts(self, network=DEFAULT_NETWORK):
         """
         Get list of accounts for this wallet
 
@@ -2516,16 +3446,21 @@
         :type network: str
 
         :return list of integers: List of accounts IDs
         """
 
         if self.multisig and self.cosigner:
             if self.cosigner_id is None:
-                raise WalletError("Missing Cosigner ID value for this wallet, cannot fetch account ID")
-            accounts = [wk.account_id for wk in self.cosigner[self.cosigner_id].keys_accounts(network=network)]
+                raise WalletError(
+                    "Missing Cosigner ID value for this wallet, cannot fetch account ID"
+                )
+            accounts = [
+                wk.account_id
+                for wk in self.cosigner[self.cosigner_id].keys_accounts(network=network)
+            ]
         else:
             accounts = [wk.account_id for wk in self.keys_accounts(network=network)]
         if not accounts:
             accounts = [self.default_account_id]
         return list(dict.fromkeys(accounts))
 
     def networks(self, as_dict=False):
@@ -2536,35 +3471,38 @@
         :type as_dict: bool
 
         :return list of (Network, dict):
         """
 
         nw_list = [self.network]
         if self.multisig and self.cosigner:
-            keys_qr = self._session.query(DbKey.network_name).\
-                filter_by(wallet_id=self.wallet_id, depth=self.key_depth).\
-                group_by(DbKey.network_name).all()
+            keys_qr = (
+                self._session.query(DbKey.network_name)
+                .filter_by(wallet_id=self.wallet_id, depth=self.key_depth)
+                .group_by(DbKey.network_name)
+                .all()
+            )
             nw_list += [Network(nw[0]) for nw in keys_qr]
-        elif self.main_key.key_type != 'single':
+        elif self.main_key.key_type != "single":
             wks = self.keys_networks()
             for wk in wks:
                 nw_list.append(Network(wk.network_name))
 
         networks = []
         nw_list = list(dict.fromkeys(nw_list))
         for nw in nw_list:
             if as_dict:
                 nw = nw.__dict__
-                if '_sa_instance_state' in nw:
-                    del nw['_sa_instance_state']
+                if "_sa_instance_state" in nw:
+                    del nw["_sa_instance_state"]
             networks.append(nw)
 
         return networks
 
-    def network_list(self, field='name'):
+    def network_list(self, field="name"):
         """
         Wrapper for :func:`networks` method, returns a flat list with currently used
         networks for this wallet.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> w.network_list()
         ['bitcoin']
@@ -2587,24 +3525,28 @@
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return int: Total balance
         """
 
         network, account_id, acckey = self._get_account_defaults(network, account_id)
-        balance = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri).\
-            getbalance(self.addresslist(account_id=account_id, network=network))
+        balance = Service(
+            network=network, providers=self.providers, cache_uri=self.db_cache_uri
+        ).getbalance(self.addresslist(account_id=account_id, network=network))
         if balance:
             new_balance = {
-                'account_id': account_id,
-                'network': network,
-                'balance': balance
+                "account_id": account_id,
+                "network": network,
+                "balance": balance,
             }
-            old_balance_item = [bi for bi in self._balances if bi['network'] == network and
-                                bi['account_id'] == account_id]
+            old_balance_item = [
+                bi
+                for bi in self._balances
+                if bi["network"] == network and bi["account_id"] == account_id
+            ]
             if old_balance_item:
                 item_n = self._balances.index(old_balance_item[0])
                 self._balances[item_n] = new_balance
             else:
                 self._balances.append(new_balance)
         return balance
 
@@ -2622,23 +3564,29 @@
         :return float, str: Key balance
         """
 
         self._balance_update(account_id, network)
         network, account_id, _ = self._get_account_defaults(network, account_id)
 
         balance = 0
-        b_res = [b['balance'] for b in self._balances if b['account_id'] == account_id and b['network'] == network]
+        b_res = [
+            b["balance"]
+            for b in self._balances
+            if b["account_id"] == account_id and b["network"] == network
+        ]
         if len(b_res):
             balance = b_res[0]
         if as_string:
             return Value.from_satoshi(balance, network=network).str_unit()
         else:
-            return float(balance)
+            return float(Value.from_satoshi(balance, network=network))
 
-    def _balance_update(self, account_id=None, network=None, key_id=None, min_confirms=0):
+    def _balance_update(
+        self, account_id=None, network=None, key_id=None, min_confirms=0
+    ):
         """
         Update balance from UTXO's in database. To get most recent balance use :func:`utxos_update` first.
 
         Also updates balance of wallet and keys in this wallet for the specified account or all accounts if
         no account is specified.
 
         :param account_id: Account ID filter
@@ -2649,42 +3597,50 @@
         :type key_id: int
         :param min_confirms: Minimal confirmations needed to include in balance (default = 0)
         :type min_confirms: int
 
         :return: Updated balance
         """
 
-        qr = self._session.query(DbTransactionOutput, func.sum(DbTransactionOutput.value), DbTransaction.network_name,
-                                 DbTransaction.account_id).\
-            join(DbTransaction). \
-            filter(DbTransactionOutput.spent.is_(False),
-                   DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.confirmations >= min_confirms)
+        qr = (
+            self._session.query(
+                DbTransactionOutput,
+                func.sum(DbTransactionOutput.value),
+                DbTransaction.network_name,
+                DbTransaction.account_id,
+            )
+            .join(DbTransaction)
+            .filter(
+                DbTransactionOutput.spent.is_(False),
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransaction.confirmations >= min_confirms,
+            )
+        )
         if account_id is not None:
             qr = qr.filter(DbTransaction.account_id == account_id)
         if network is not None:
             qr = qr.filter(DbTransaction.network_name == network)
         if key_id is not None:
             qr = qr.filter(DbTransactionOutput.key_id == key_id)
         else:
             qr = qr.filter(DbTransactionOutput.key_id.isnot(None))
         utxos = qr.group_by(
             DbTransactionOutput.key_id,
             DbTransactionOutput.transaction_id,
             DbTransactionOutput.output_n,
             DbTransaction.network_name,
-            DbTransaction.account_id
+            DbTransaction.account_id,
         ).all()
 
         key_values = [
             {
-                'id': utxo[0].key_id,
-                'network': utxo[2],
-                'account_id': utxo[3],
-                'balance': utxo[1]
+                "id": utxo[0].key_id,
+                "network": utxo[2],
+                "account_id": utxo[3],
+                "balance": utxo[1],
             }
             for utxo in utxos
         ]
 
         grouper = itemgetter("id", "network", "account_id")
         key_balance_list = []
         for key, grp in groupby(sorted(key_values, key=grouper), grouper):
@@ -2698,44 +3654,63 @@
             nw_acc_dict = dict(zip(["network", "account_id"], key))
             nw_acc_dict["balance"] = sum(item["balance"] for item in grp)
             balance_list.append(nw_acc_dict)
 
         # Add keys with no UTXO's with 0 balance
         for key in self.keys(account_id=account_id, network=network, key_id=key_id):
             if key.id not in [utxo[0].key_id for utxo in utxos]:
-                key_balance_list.append({
-                    'id': key.id,
-                    'network': network,
-                    'account_id': key.account_id,
-                    'balance': 0
-                })
+                key_balance_list.append(
+                    {
+                        "id": key.id,
+                        "network": network,
+                        "account_id": key.account_id,
+                        "balance": 0,
+                    }
+                )
 
         if not key_id:
             for bl in balance_list:
-                bl_item = [b for b in self._balances if
-                           b['network'] == bl['network'] and b['account_id'] == bl['account_id']]
+                bl_item = [
+                    b
+                    for b in self._balances
+                    if b["network"] == bl["network"]
+                    and b["account_id"] == bl["account_id"]
+                ]
                 if not bl_item:
                     self._balances.append(bl)
                     continue
                 lx = self._balances.index(bl_item[0])
                 self._balances[lx].update(bl)
 
-        self._balance = sum([b['balance'] for b in balance_list if b['network'] == self.network.name])
+        self._balance = sum(
+            [b["balance"] for b in balance_list if b["network"] == self.network.name]
+        )
 
         # Bulk update database
         for kb in key_balance_list:
-            if kb['id'] in self._key_objects:
-                self._key_objects[kb['id']]._balance = kb['balance']
+            if kb["id"] in self._key_objects:
+                self._key_objects[kb["id"]]._balance = kb["balance"]
         self._session.bulk_update_mappings(DbKey, key_balance_list)
         self._commit()
         _logger.info("Got balance for %d key(s)" % len(key_balance_list))
         return self._balances
 
-    def utxos_update(self, account_id=None, used=None, networks=None, key_id=None, depth=None, change=None,
-                     utxos=None, update_balance=True, max_utxos=MAX_TRANSACTIONS, rescan_all=True):
+    async def utxos_update(
+        self,
+        account_id=None,
+        used=None,
+        networks=None,
+        key_id=None,
+        depth=None,
+        change=None,
+        utxos=None,
+        update_balance=True,
+        max_utxos=MAX_TRANSACTIONS,
+        rescan_all=True,
+    ):
         """
         Update UTXO's (Unspent Outputs) for addresses/keys in this wallet using various Service providers.
 
         This method does not import transactions: use :func:`transactions_update` function or to look for new addresses use :func:`scan`.
 
         :param account_id: Account ID
         :type account_id: int
@@ -2769,145 +3744,235 @@
         :type max_utxos: int
         :param rescan_all: Remove old utxo's and rescan wallet. Default is True. Set to False if you work with large utxo's sets. Value will be ignored if key_id is specified in your call
         :type rescan_all: bool
 
         :return int: Number of new UTXO's added
         """
 
-        _, account_id, acckey = self._get_account_defaults('', account_id, key_id)
+        # print("account_id", account_id)
+        # print("used", used)
+        # print("networks", networks)
+        # print("key_id", key_id)
+        # print("depth", depth)
+        # print("change", change)
+        # print("utxos", utxos)
+        # print("update_balance", update_balance)
+        # print("max_utxos", max_utxos)
+        # print("rescan_all", rescan_all)
+
+        _, account_id, acckey = self._get_account_defaults("", account_id, key_id)
 
         single_key = None
         if key_id:
             single_key = self._session.query(DbKey).filter_by(id=key_id).scalar()
             networks = [single_key.network_name]
             account_id = single_key.account_id
             rescan_all = False
+
         if networks is None:
             networks = self.network_list()
+
         elif not isinstance(networks, list):
             networks = [networks]
         elif len(networks) != 1 and utxos is not None:
             raise WalletError("Please specify maximum 1 network when passing utxo's")
 
         count_utxos = 0
         for network in networks:
             # Remove current UTXO's
             if rescan_all:
-                cur_utxos = self._session.query(DbTransactionOutput). \
-                    join(DbTransaction). \
-                    filter(DbTransactionOutput.spent.is_(False),
-                           DbTransaction.account_id == account_id,
-                           DbTransaction.wallet_id == self.wallet_id,
-                           DbTransaction.network_name == network).all()
+                cur_utxos = (
+                    self._session.query(DbTransactionOutput)
+                    .join(DbTransaction)
+                    .filter(
+                        DbTransactionOutput.spent.is_(False),
+                        DbTransaction.account_id == account_id,
+                        DbTransaction.wallet_id == self.wallet_id,
+                        DbTransaction.network_name == network,
+                    )
+                    .all()
+                )
                 for u in cur_utxos:
                     self._session.query(DbTransactionOutput).filter_by(
-                        transaction_id=u.transaction_id, output_n=u.output_n).update({DbTransactionOutput.spent: True})
+                        transaction_id=u.transaction_id, output_n=u.output_n
+                    ).update({DbTransactionOutput.spent: True})
                 self._commit()
 
             if account_id is None and not self.multisig:
                 accounts = self.accounts(network=network)
             else:
                 accounts = [account_id]
+
             for account_id in accounts:
                 if depth is None:
                     depth = self.key_depth
                 if utxos is None:
                     # Get all UTXO's for this wallet from default Service object
-                    addresslist = self.addresslist(account_id=account_id, used=used, network=network, key_id=key_id,
-                                                   change=change, depth=depth)
+                    addresslist = self.addresslist(
+                        account_id=account_id,
+                        used=used,
+                        network=network,
+                        key_id=key_id,
+                        change=change,
+                        depth=depth,
+                    )
                     random.shuffle(addresslist)
-                    srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)
+
+                    srv = Service(
+                        network=network,
+                        providers=self.providers,
+                        cache_uri=self.db_cache_uri,
+                    )
+
                     utxos = []
                     for address in addresslist:
                         if rescan_all:
-                            last_txid = ''
+                            last_txid = ""
                         else:
                             last_txid = self.utxo_last(address)
-                        new_utxos = srv.getutxos(address, after_txid=last_txid, limit=max_utxos)
+                            # check return type of this
+                        new_utxos = await srv.getutxos(
+                            address, after_txid=last_txid, limit=max_utxos
+                        )
+
                         if new_utxos:
-                            utxos += new_utxos
+                            utxos.extend(new_utxos)
+
                         elif new_utxos is False:
-                            raise WalletError("No response from any service provider, could not update UTXO's. "
-                                              "Errors: %s" % srv.errors)
+                            raise WalletError(
+                                "No response from any service provider, could not update UTXO's. "
+                                "Errors: %s" % srv.errors
+                            )
                     if srv.complete:
                         self.last_updated = datetime.now()
-                    elif utxos and 'date' in utxos[-1:][0]:
-                        self.last_updated = utxos[-1:][0]['date']
+                    elif utxos and "date" in utxos[-1:][0]:
+                        self.last_updated = utxos[-1:][0]["date"]
 
                 # If UTXO is new, add to database otherwise update depth (confirmation count)
                 for utxo in utxos:
                     key = single_key
+
                     if not single_key:
-                        key = self._session.query(DbKey).\
-                            filter_by(wallet_id=self.wallet_id, address=utxo['address']).scalar()
+                        key = (
+                            self._session.query(DbKey)
+                            .filter_by(
+                                wallet_id=self.wallet_id, address=utxo["address"]
+                            )
+                            .scalar()
+                        )
+
                     if not key:
-                        raise WalletError("Key with address %s not found in this wallet" % utxo['address'])
+                        raise WalletError(
+                            "Key with address %s not found in this wallet"
+                            % utxo["address"]
+                        )
+
                     key.used = True
-                    status = 'unconfirmed'
-                    if utxo['confirmations']:
-                        status = 'confirmed'
+                    status = "unconfirmed"
+                    if utxo["confirmations"]:
+                        status = "confirmed"
 
                     # Update confirmations in db if utxo was already imported
-                    transaction_in_db = self._session.query(DbTransaction).\
-                        filter_by(wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']),
-                                  network_name=network)
-                    utxo_in_db = self._session.query(DbTransactionOutput).join(DbTransaction).\
-                        filter(DbTransaction.wallet_id == self.wallet_id,
-                               DbTransaction.txid == bytes.fromhex(utxo['txid']),
-                               DbTransactionOutput.output_n == utxo['output_n'])
-                    spent_in_db = self._session.query(DbTransactionInput).join(DbTransaction).\
-                        filter(DbTransaction.wallet_id == self.wallet_id,
-                               DbTransactionInput.prev_txid == bytes.fromhex(utxo['txid']),
-                               DbTransactionInput.output_n == utxo['output_n'])
+                    transaction_in_db = self._session.query(DbTransaction).filter_by(
+                        wallet_id=self.wallet_id,
+                        txid=bytes.fromhex(utxo["txid"]),
+                        network_name=network,
+                    )
+
+                    utxo_in_db = (
+                        self._session.query(DbTransactionOutput)
+                        .join(DbTransaction)
+                        .filter(
+                            DbTransaction.wallet_id == self.wallet_id,
+                            DbTransaction.txid == bytes.fromhex(utxo["txid"]),
+                            DbTransactionOutput.output_n == utxo["output_n"],
+                        )
+                    )
+
+                    spent_in_db = (
+                        self._session.query(DbTransactionInput)
+                        .join(DbTransaction)
+                        .filter(
+                            DbTransaction.wallet_id == self.wallet_id,
+                            DbTransactionInput.prev_txid == bytes.fromhex(utxo["txid"]),
+                            DbTransactionInput.output_n == utxo["output_n"],
+                        )
+                    )
+
                     if utxo_in_db.count():
                         utxo_record = utxo_in_db.scalar()
+
                         if not utxo_record.key_id:
                             count_utxos += 1
+
                         utxo_record.key_id = key.id
                         utxo_record.spent = bool(spent_in_db.count())
+
                         if transaction_in_db.count():
                             transaction_record = transaction_in_db.scalar()
-                            transaction_record.confirmations = utxo['confirmations']
+                            transaction_record.confirmations = utxo["confirmations"]
                             transaction_record.status = status
                     else:
                         # Add transaction if not exist and then add output
                         if not transaction_in_db.count():
                             block_height = None
-                            if block_height in utxo and utxo['block_height']:
-                                block_height = utxo['block_height']
-                            version = 1
-                            if network == "flux":
-                                version = 4
+                            if block_height in utxo and utxo["block_height"]:
+                                block_height = utxo["block_height"]
+
+                            version = 4 if network == "flux" else 1
+
                             new_tx = DbTransaction(
-                                wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']), version=version, status=status,
-                                is_complete=False, block_height=block_height, account_id=account_id,
-                                confirmations=utxo['confirmations'], network_name=network)
+                                wallet_id=self.wallet_id,
+                                txid=bytes.fromhex(utxo["txid"]),
+                                version=version,
+                                status=status,
+                                is_complete=False,
+                                block_height=block_height,
+                                account_id=account_id,
+                                confirmations=utxo["confirmations"],
+                                network_name=network,
+                            )
                             self._session.add(new_tx)
                             # TODO: Get unique id before inserting to increase performance for large utxo-sets
                             self._commit()
                             tid = new_tx.id
                         else:
                             tid = transaction_in_db.scalar().id
 
-                        script_type = script_type_default(self.witness_type, multisig=self.multisig,
-                                                          locking_script=True)
-                        new_utxo = DbTransactionOutput(transaction_id=tid,  output_n=utxo['output_n'],
-                                                       value=utxo['value'], key_id=key.id, address=utxo['address'],
-                                                       script=bytes.fromhex(utxo['script']),
-                                                       script_type=script_type,
-                                                       spent=bool(spent_in_db.count()))
+                        script_type = script_type_default(
+                            self.witness_type,
+                            multisig=self.multisig,
+                            locking_script=True,
+                        )
+                        new_utxo = DbTransactionOutput(
+                            transaction_id=tid,
+                            output_n=utxo["output_n"],
+                            value=utxo["value"],
+                            key_id=key.id,
+                            address=utxo["address"],
+                            script=bytes.fromhex(utxo["script"]),
+                            script_type=script_type,
+                            spent=bool(spent_in_db.count()),
+                        )
                         self._session.add(new_utxo)
                         count_utxos += 1
 
                     self._commit()
 
-                _logger.info("Got %d new UTXOs for account %s" % (count_utxos, account_id))
+                _logger.info(
+                    "Got %d new UTXOs for account %s" % (count_utxos, account_id)
+                )
                 self._commit()
                 if update_balance:
-                    self._balance_update(account_id=account_id, network=network, key_id=key_id, min_confirms=0)
+                    self._balance_update(
+                        account_id=account_id,
+                        network=network,
+                        key_id=key_id,
+                        min_confirms=0,
+                    )
                 utxos = None
         return count_utxos
 
     def utxos(self, account_id=None, network=None, min_confirms=0, key_id=None):
         """
         Get UTXO's (Unspent Outputs) from database. Use :func:`utxos_update` method first for updated values
 
@@ -2926,42 +3991,54 @@
 
         :return list: List of transactions
         """
 
         first_key_id = key_id
         if isinstance(key_id, list):
             first_key_id = key_id[0]
-        network, account_id, acckey = self._get_account_defaults(network, account_id, first_key_id)
-
-        qr = self._session.query(DbTransactionOutput, DbKey.address, DbTransaction.confirmations, DbTransaction.txid,
-                                 DbKey.network_name).\
-            join(DbTransaction).join(DbKey). \
-            filter(DbTransactionOutput.spent.is_(False),
-                   DbTransaction.account_id == account_id,
-                   DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network,
-                   DbTransaction.confirmations >= min_confirms)
+        network, account_id, acckey = self._get_account_defaults(
+            network, account_id, first_key_id
+        )
+
+        qr = (
+            self._session.query(
+                DbTransactionOutput,
+                DbKey.address,
+                DbTransaction.confirmations,
+                DbTransaction.txid,
+                DbKey.network_name,
+            )
+            .join(DbTransaction)
+            .join(DbKey)
+            .filter(
+                DbTransactionOutput.spent.is_(False),
+                DbTransaction.account_id == account_id,
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransaction.network_name == network,
+                DbTransaction.confirmations >= min_confirms,
+            )
+        )
         if isinstance(key_id, int):
             qr = qr.filter(DbKey.id == key_id)
         elif isinstance(key_id, list):
             qr = qr.filter(DbKey.id.in_(key_id))
         utxos = qr.order_by(DbTransaction.confirmations.desc()).all()
         res = []
         for utxo in utxos:
             u = utxo[0].__dict__
-            if '_sa_instance_state' in u:
-                del u['_sa_instance_state']
-            u['address'] = utxo[1]
-            u['confirmations'] = int(utxo[2])
-            u['txid'] = utxo[3].hex()
-            u['network_name'] = utxo[4]
+            if "_sa_instance_state" in u:
+                del u["_sa_instance_state"]
+            u["address"] = utxo[1]
+            u["confirmations"] = int(utxo[2])
+            u["txid"] = utxo[3].hex()
+            u["network_name"] = utxo[4]
             res.append(u)
         return res
 
-    def utxo_add(self, address, value, txid, output_n, confirmations=1, script=''):
+    def utxo_add(self, address, value, txid, output_n, confirmations=1, script=""):
         """
         Add a single UTXO to the wallet database. To update all utxo's use :func:`utxos_update` method.
 
         Use this method for testing, offline wallets or if you wish to override standard method of retreiving UTXO's
 
         This method does not check if UTXO exists or is still spendable.
 
@@ -2978,20 +4055,20 @@
         :param script: Locking script of previous output as hex-string
         :type script: str
 
         :return int: Number of new UTXO's added, so 1 if successful
         """
 
         utxo = {
-            'address': address,
-            'script': script,
-            'confirmations': confirmations,
-            'output_n': output_n,
-            'txid': txid,
-            'value': value
+            "address": address,
+            "script": script,
+            "confirmations": confirmations,
+            "output_n": output_n,
+            "txid": txid,
+            "value": value,
         }
         return self.utxos_update(utxos=[utxo])
 
     def utxo_last(self, address):
         """
         Get transaction ID for latest utxo in database for given address
 
@@ -3000,79 +4077,118 @@
         '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4'
 
         :param address: The address
         :type address: str
 
         :return str:
         """
-        to = self._session.query(
-            DbTransaction.txid, DbTransaction.confirmations). \
-            join(DbTransactionOutput).join(DbKey). \
-            filter(DbKey.address == address, DbTransaction.wallet_id == self.wallet_id,
-                   DbTransactionOutput.spent.is_(False)). \
-            order_by(DbTransaction.confirmations).first()
-        return '' if not to else to[0].hex()
+        to = (
+            self._session.query(DbTransaction.txid, DbTransaction.confirmations)
+            .join(DbTransactionOutput)
+            .join(DbKey)
+            .filter(
+                DbKey.address == address,
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransactionOutput.spent.is_(False),
+            )
+            .order_by(DbTransaction.confirmations)
+            .first()
+        )
+        return "" if not to else to[0].hex()
 
-    def transactions_update_confirmations(self):
+    async def transactions_update_confirmations(self):
         """
         Update number of confirmations and status for transactions in database
 
         :return:
         """
         network = self.network.name
-        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)
-        blockcount = srv.blockcount()
-        db_txs = self._session.query(DbTransaction). \
-            filter(DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()
+        srv = Service(
+            network=network,
+            providers=self.providers,
+            cache_uri=self.db_cache_uri,
+        )
+        blockcount = await srv.blockcount()
+        db_txs = (
+            self._session.query(DbTransaction)
+            .filter(
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransaction.network_name == network,
+                DbTransaction.block_height > 0,
+            )
+            .all()
+        )
         for db_tx in db_txs:
-            self._session.query(DbTransaction).filter_by(id=db_tx.id). \
-                update({DbTransaction.status: 'confirmed',
-                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})
+            self._session.query(DbTransaction).filter_by(id=db_tx.id).update(
+                {
+                    DbTransaction.status: "confirmed",
+                    DbTransaction.confirmations: (
+                        blockcount - DbTransaction.block_height
+                    )
+                    + 1,
+                }
+            )
         self._commit()
 
-    def transactions_update_by_txids(self, txids):
+    async def transactions_update_by_txids(self, txids):
         """
         Update transaction or list or transaction for this wallet with provided transaction ID
 
         :param txids: Transaction ID, or list of transaction IDs
         :type txids: str, list of str, bytes, list of bytes
 
         :return:
         """
         if not isinstance(txids, list):
             txids = [txids]
         txids = list(dict.fromkeys(txids))
 
         txs = []
-        srv = Service(network=self.network.name, providers=self.providers, cache_uri=self.db_cache_uri)
-        for txid in txids:
-            tx = srv.gettransaction(to_hexstring(txid))
-            if tx:
-                txs.append(tx)
+        srv = Service(
+            network=self.network.name,
+            providers=self.providers,
+            cache_uri=self.db_cache_uri,
+        )
+        txids_hexstrings = [to_hexstring(x) for x in txids]
+        txs.extend(await srv.get_transactions(txids_hexstrings))
 
         # TODO: Avoid duplicate code in this method and transaction_update()
         utxo_set = set()
         for t in txs:
             wt = WalletTransaction.from_transaction(self, t)
             wt.store()
             utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]
             utxo_set.update(utxos)
 
         for utxo in list(utxo_set):
-            tos = self._session.query(DbTransactionOutput).join(DbTransaction). \
-                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],
-                       DbTransactionOutput.spent.is_(False)).all()
+            tos = (
+                self._session.query(DbTransactionOutput)
+                .join(DbTransaction)
+                .filter(
+                    DbTransaction.txid == bytes.fromhex(utxo[0]),
+                    DbTransactionOutput.output_n == utxo[1],
+                    DbTransactionOutput.spent.is_(False),
+                )
+                .all()
+            )
             for u in tos:
                 u.spent = True
         self._commit()
         # self._balance_update(account_id=account_id, network=network, key_id=key_id)
 
-    def transactions_update(self, account_id=None, used=None, network=None, key_id=None, depth=None, change=None,
-                            limit=MAX_TRANSACTIONS):
+    async def transactions_update(
+        self,
+        account_id=None,
+        used=None,
+        network=None,
+        key_id=None,
+        depth=None,
+        change=None,
+        limit=MAX_TRANSACTIONS,
+    ):
         """
         Update wallets transaction from service providers. Get all transactions for known keys in this wallet. The balances and unspent outputs (UTXO's) are updated as well. Only scan keys from default network and account unless another network or account is specified.
 
         Use the :func:`scan` method for automatic address generation/management, and use the :func:`utxos_update` method to only look for unspent outputs and balances.
 
         :param account_id: Account ID
         :type account_id: int
@@ -3087,63 +4203,85 @@
         :param change: Only update change or normal keys, default is both (None)
         :type change: int
         :param limit: Stop update after limit transactions to avoid timeouts with service providers. Default is MAX_TRANSACTIONS defined in config.py
         :type limit: int
 
         :return bool: True if all transactions are updated
         """
-
-        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)
+        print("TXUPDATE START")
+        network, account_id, acckey = self._get_account_defaults(
+            network, account_id, key_id
+        )
         if depth is None:
             depth = self.key_depth
-
         # Update number of confirmations and status for already known transactions
-        if not key_id:
-            self.transactions_update_confirmations()
 
-        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)
-        blockcount = srv.blockcount()
-        db_txs = self._session.query(DbTransaction).\
-            filter(DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()
-        for db_tx in db_txs:
-            self._session.query(DbTransaction).filter_by(id=db_tx.id).\
-                update({DbTransaction.status: 'confirmed',
-                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})
-        self._commit()
+        await self.transactions_update_confirmations()
+
+        srv = Service(
+            network=network,
+            providers=self.providers,
+            cache_uri=self.db_cache_uri,
+        )
 
         # Get transactions for wallet's addresses
         txs = []
         addresslist = self.addresslist(
-            account_id=account_id, used=used, network=network, key_id=key_id, change=change, depth=depth)
+            account_id=account_id,
+            used=used,
+            network=network,
+            key_id=key_id,
+            change=change,
+            depth=depth,
+        )
         last_updated = datetime.now()
         for address in addresslist:
-            txs += srv.gettransactions(address, limit=limit, after_txid=self.transaction_last(address))
+            txs.extend(
+                await srv.get_transactions_by_address(
+                    address, limit=limit, after_txid=self.transaction_last(address)
+                )
+            )
             if not srv.complete:
                 if txs and txs[-1].date and txs[-1].date < last_updated:
                     last_updated = txs[-1].date
             if txs and txs[-1].confirmations:
-                dbkey = self._session.query(DbKey).filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id)
+                dbkey = self._session.query(DbKey).filter(
+                    DbKey.address == address, DbKey.wallet_id == self.wallet_id
+                )
                 if not dbkey.update({DbKey.latest_txid: bytes.fromhex(txs[-1].txid)}):
-                    raise WalletError("Failed to update latest transaction id for key with address %s" % address)
+                    raise WalletError(
+                        "Failed to update latest transaction id for key with address %s"
+                        % address
+                    )
                 self._commit()
         if txs is False:
-            raise WalletError("No response from any service provider, could not update transactions")
+            raise WalletError(
+                "No response from any service provider, could not update transactions"
+            )
 
         # Update Transaction outputs to get list of unspent outputs (UTXO's)
         utxo_set = set()
+
         for t in txs:
             wt = WalletTransaction.from_transaction(self, t)
             wt.store()
             utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]
             utxo_set.update(utxos)
         for utxo in list(utxo_set):
-            tos = self._session.query(DbTransactionOutput).join(DbTransaction).\
-                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],
-                       DbTransactionOutput.spent.is_(False), DbTransaction.wallet_id == self.wallet_id).all()
+            tos = (
+                self._session.query(DbTransactionOutput)
+                .join(DbTransaction)
+                .filter(
+                    DbTransaction.txid == bytes.fromhex(utxo[0]),
+                    DbTransactionOutput.output_n == utxo[1],
+                    DbTransactionOutput.spent.is_(False),
+                    DbTransaction.wallet_id == self.wallet_id,
+                )
+                .all()
+            )
             for u in tos:
                 u.spent = True
 
         self.last_updated = last_updated
         self._commit()
         self._balance_update(account_id=account_id, network=network, key_id=key_id)
 
@@ -3154,19 +4292,29 @@
         Get transaction ID for latest transaction in database for given address
 
         :param address: The address
         :type address: str
 
         :return str:
         """
-        txid = self._session.query(DbKey.latest_txid).\
-            filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id).scalar()
-        return '' if not txid else txid.hex()
-
-    def transactions(self, account_id=None, network=None, include_new=False, key_id=None, as_dict=False):
+        txid = (
+            self._session.query(DbKey.latest_txid)
+            .filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id)
+            .scalar()
+        )
+        return "" if not txid else txid.hex()
+
+    def transactions(
+        self,
+        account_id=None,
+        network=None,
+        include_new=False,
+        key_id=None,
+        as_dict=False,
+    ):
         """
         Get all known transactions input and outputs for this wallet.
 
         The transaction only includes the inputs and outputs related to this wallet. To get full transactions
         use the :func:`transactions_full` method.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
@@ -3183,63 +4331,102 @@
         :type key_id: int, None
         :param as_dict: Output as dictionary or WalletTransaction object
         :type as_dict: bool
 
         :return list of WalletTransaction: List of WalletTransaction or transactions as dictionary
         """
 
-        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)
+        network, account_id, acckey = self._get_account_defaults(
+            network, account_id, key_id
+        )
+
         # Transaction inputs
-        qr = self._session.query(DbTransactionInput, DbTransactionInput.address, DbTransaction.confirmations,
-                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \
-            join(DbTransaction).join(DbKey). \
-            filter(DbTransaction.account_id == account_id,
-                   DbTransaction.wallet_id == self.wallet_id,
-                   DbKey.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network)
+        qr = (
+            self._session.query(
+                DbTransactionInput,
+                DbTransactionInput.address,
+                DbTransaction.confirmations,
+                DbTransaction.txid,
+                DbTransaction.network_name,
+                DbTransaction.status,
+            )
+            .join(DbTransaction)
+            .join(DbKey)
+            .filter(
+                DbTransaction.account_id == account_id,
+                DbTransaction.wallet_id == self.wallet_id,
+                DbKey.wallet_id == self.wallet_id,
+                DbTransaction.network_name == network,
+            )
+        )
         if key_id is not None:
             qr = qr.filter(DbTransactionInput.key_id == key_id)
         if not include_new:
-            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))
+            qr = qr.filter(
+                or_(
+                    DbTransaction.status == "confirmed",
+                    DbTransaction.status == "unconfirmed",
+                )
+            )
         txs = qr.all()
         # Transaction outputs
-        qr = self._session.query(DbTransactionOutput, DbTransactionOutput.address, DbTransaction.confirmations,
-                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \
-            join(DbTransaction).join(DbKey). \
-            filter(DbTransaction.account_id == account_id,
-                   DbTransaction.wallet_id == self.wallet_id,
-                   DbKey.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network)
+        qr = (
+            self._session.query(
+                DbTransactionOutput,
+                DbTransactionOutput.address,
+                DbTransaction.confirmations,
+                DbTransaction.txid,
+                DbTransaction.network_name,
+                DbTransaction.status,
+            )
+            .join(DbTransaction)
+            .join(DbKey)
+            .filter(
+                DbTransaction.account_id == account_id,
+                DbTransaction.wallet_id == self.wallet_id,
+                DbKey.wallet_id == self.wallet_id,
+                DbTransaction.network_name == network,
+            )
+        )
         if key_id is not None:
             qr = qr.filter(DbTransactionOutput.key_id == key_id)
         if not include_new:
-            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))
+            qr = qr.filter(
+                or_(
+                    DbTransaction.status == "confirmed",
+                    DbTransaction.status == "unconfirmed",
+                )
+            )
         txs += qr.all()
 
-        txs = sorted(txs, key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True)
+        txs = sorted(
+            txs,
+            key=lambda k: (k[2], pow(10, 20) - k[0].transaction_id, k[3]),
+            reverse=True,
+        )
         res = []
         txids = []
         for tx in txs:
             txid = tx[3].hex()
             if as_dict:
                 u = tx[0].__dict__
-                u['block_height'] = tx[0].transaction.block_height
-                u['date'] = tx[0].transaction.date
-                if '_sa_instance_state' in u:
-                    del u['_sa_instance_state']
-                u['address'] = tx[1]
-                u['confirmations'] = None if tx[2] is None else int(tx[2])
-                u['txid'] = txid
-                u['network_name'] = tx[4]
-                u['status'] = tx[5]
-                if 'index_n' in u:
-                    u['is_output'] = True
-                    u['value'] = -u['value']
+                u["block_height"] = tx[0].transaction.block_height
+                u["date"] = tx[0].transaction.date
+                if "_sa_instance_state" in u:
+                    del u["_sa_instance_state"]
+                u["address"] = tx[1]
+                u["confirmations"] = None if tx[2] is None else int(tx[2])
+                u["txid"] = txid
+                u["network_name"] = tx[4]
+                u["status"] = tx[5]
+                if "index_n" in u:
+                    u["is_output"] = True
+                    u["value"] = -u["value"]
                 else:
-                    u['is_output'] = False
+                    u["is_output"] = False
             else:
                 if txid in txids:
                     continue
                 txids.append(txid)
                 u = self.transaction(txid)
             res.append(u)
         return res
@@ -3258,29 +4445,44 @@
         :type limit: int
         :param offset: Number of transactions to skip
         :type offset: int
 
         :return list of WalletTransaction:
         """
         network, _, _ = self._get_account_defaults(network)
-        qr = self._session.query(DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \
-            filter(DbTransaction.wallet_id == self.wallet_id,
-                   DbTransaction.network_name == network)
+        qr = self._session.query(
+            DbTransaction.txid, DbTransaction.network_name, DbTransaction.status
+        ).filter(
+            DbTransaction.wallet_id == self.wallet_id,
+            DbTransaction.network_name == network,
+        )
         if not include_new:
-            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))
+            qr = qr.filter(
+                or_(
+                    DbTransaction.status == "confirmed",
+                    DbTransaction.status == "unconfirmed",
+                )
+            )
         txs = []
         if limit:
             qr = qr.limit(limit)
         if offset:
             qr = qr.offset(offset)
         for tx in qr.all():
             txs.append(self.transaction(tx[0].hex()))
         return txs
 
-    def transactions_export(self, account_id=None, network=None, include_new=False, key_id=None, skip_change=True):
+    def transactions_export(
+        self,
+        account_id=None,
+        network=None,
+        include_new=False,
+        key_id=None,
+        skip_change=True,
+    ):
         """
         Export wallets transactions as list of tuples with the following fields:
             (transaction_date, transaction_hash, in/out, addresses_in, addresses_out, value, value_cumulative, fee)
 
         :param account_id: Filter by Account ID. Leave empty for default account_id
         :type account_id: int, None
         :param network: Filter by network name. Leave empty for default network
@@ -3307,16 +4509,26 @@
             # Loop through all transaction inputs and outputs
             for tei in te:
                 # Create string with  list of inputs addresses for incoming transactions, and outputs addresses
                 # for outgoing txs
                 addr_list_in = tei[3] if isinstance(tei[3], list) else [tei[3]]
                 addr_list_out = tei[4] if isinstance(tei[4], list) else [tei[4]]
                 cumulative_value += tei[5]
-                txs_tuples.append((tei[0], tei[1], tei[2], addr_list_in, addr_list_out, tei[5], cumulative_value,
-                                   tei[6]))
+                txs_tuples.append(
+                    (
+                        tei[0],
+                        tei[1],
+                        tei[2],
+                        addr_list_in,
+                        addr_list_out,
+                        tei[5],
+                        cumulative_value,
+                        tei[6],
+                    )
+                )
         return txs_tuples
 
     def transaction(self, txid):
         """
         Get WalletTransaction object for given transaction ID (transaction hash)
 
         :param txid: Hexadecimal transaction hash
@@ -3337,40 +4549,62 @@
         :param output_n: Output n
         :type output_n: int, bytes
 
         :return str: Transaction ID
         """
         txid = to_bytes(txid)
         if isinstance(output_n, bytes):
-            output_n = int.from_bytes(output_n, 'big')
-        qr = self._session.query(DbTransactionInput, DbTransaction.confirmations,
-                                 DbTransaction.txid, DbTransaction.status). \
-            join(DbTransaction). \
-            filter(DbTransaction.wallet_id == self.wallet_id,
-                   DbTransactionInput.prev_txid == txid, DbTransactionInput.output_n == output_n).scalar()
+            output_n = int.from_bytes(output_n, "big")
+        qr = (
+            self._session.query(
+                DbTransactionInput,
+                DbTransaction.confirmations,
+                DbTransaction.txid,
+                DbTransaction.status,
+            )
+            .join(DbTransaction)
+            .filter(
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransactionInput.prev_txid == txid,
+                DbTransactionInput.output_n == output_n,
+            )
+            .scalar()
+        )
         if qr:
             return qr.transaction.txid.hex()
 
     def _objects_by_key_id(self, key_id):
         key = self._session.query(DbKey).filter_by(id=key_id).scalar()
         if not key:
             raise WalletError("Key '%s' not found in this wallet" % key_id)
-        if key.key_type == 'multisig':
-            inp_keys = [HDKey.from_wif(ck.child_key.wif, network=ck.child_key.network_name) for ck in
-                        key.multisig_children]
-        elif key.key_type in ['bip32', 'single']:
+        if key.key_type == "multisig":
+            inp_keys = [
+                HDKey.from_wif(ck.child_key.wif, network=ck.child_key.network_name)
+                for ck in key.multisig_children
+            ]
+        elif key.key_type in ["bip32", "single"]:
             if not key.wif:
                 raise WalletError("WIF of key is empty cannot create HDKey")
             inp_keys = [HDKey.from_wif(key.wif, network=key.network_name)]
         else:
             raise WalletError("Input key type %s not supported" % key.key_type)
         return inp_keys, key
 
-    def select_inputs(self, amount, variance=None, input_key_id=None, account_id=None, network=None, min_confirms=1,
-                      max_utxos=None, return_input_obj=True, skip_dust_amounts=True):
+    def select_inputs(
+        self,
+        amount,
+        variance=None,
+        input_key_id=None,
+        account_id=None,
+        network=None,
+        min_confirms=1,
+        max_utxos=None,
+        return_input_obj=True,
+        skip_dust_amounts=True,
+    ):
         """
         Select available unspent transaction outputs (UTXO's) which can be used as inputs for a transaction for
         the specified amount.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> w.select_inputs(50000000)
         [<Input(prev_txid='748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', output_n=0, address='16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', index_n=0, type='sig_pubkey')>]
@@ -3399,55 +4633,80 @@
         """
 
         network, account_id, _ = self._get_account_defaults(network, account_id)
         dust_amount = Network(network).dust_amount
         if variance is None:
             variance = dust_amount
 
-        utxo_query = self._session.query(DbTransactionOutput).join(DbTransaction).join(DbKey). \
-            filter(DbTransaction.wallet_id == self.wallet_id, DbTransaction.account_id == account_id,
-                   DbTransaction.network_name == network, DbKey.public != b'',
-                   DbTransactionOutput.spent.is_(False), DbTransaction.confirmations >= min_confirms)
+        utxo_query = (
+            self._session.query(DbTransactionOutput)
+            .join(DbTransaction)
+            .join(DbKey)
+            .filter(
+                DbTransaction.wallet_id == self.wallet_id,
+                DbTransaction.account_id == account_id,
+                DbTransaction.network_name == network,
+                DbKey.public != b"",
+                DbTransactionOutput.spent.is_(False),
+                DbTransaction.confirmations >= min_confirms,
+            )
+        )
         if input_key_id:
             if isinstance(input_key_id, int):
                 utxo_query = utxo_query.filter(DbKey.id == input_key_id)
             else:
                 utxo_query = utxo_query.filter(DbKey.id.in_(input_key_id))
         if skip_dust_amounts:
             utxo_query = utxo_query.filter(DbTransactionOutput.value > dust_amount)
         utxos = utxo_query.order_by(DbTransaction.confirmations.desc()).all()
         if not utxos:
-            raise WalletError("Create transaction: No unspent transaction outputs found or no key available for UTXO's")
+            raise WalletError(
+                "Create transaction: No unspent transaction outputs found or no key available for UTXO's"
+            )
 
         # TODO: Find 1 or 2 UTXO's with exact amount +/- self.network.dust_amount
 
         # Try to find one utxo with exact amount
-        one_utxo = utxo_query.filter(DbTransactionOutput.spent.is_(False),
-                                     DbTransactionOutput.value >= amount,
-                                     DbTransactionOutput.value <= amount + variance).first()
+        one_utxo = utxo_query.filter(
+            DbTransactionOutput.spent.is_(False),
+            DbTransactionOutput.value >= amount,
+            DbTransactionOutput.value <= amount + variance,
+        ).first()
         selected_utxos = []
         if one_utxo:
             selected_utxos = [one_utxo]
         else:
             # Try to find one utxo with higher amount
-            one_utxo = utxo_query. \
-                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value >= amount).\
-                order_by(DbTransactionOutput.value).first()
+            one_utxo = (
+                utxo_query.filter(
+                    DbTransactionOutput.spent.is_(False),
+                    DbTransactionOutput.value >= amount,
+                )
+                .order_by(DbTransactionOutput.value)
+                .first()
+            )
             if one_utxo:
                 selected_utxos = [one_utxo]
             elif max_utxos and max_utxos <= 1:
-                _logger.info("No single UTXO found with requested amount, use higher 'max_utxo' setting to use "
-                             "multiple UTXO's")
+                _logger.info(
+                    "No single UTXO found with requested amount, use higher 'max_utxo' setting to use "
+                    "multiple UTXO's"
+                )
                 return []
 
         # Otherwise compose of 2 or more lesser outputs
         if not selected_utxos:
-            lessers = utxo_query. \
-                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value < amount).\
-                order_by(DbTransactionOutput.value.desc()).all()
+            lessers = (
+                utxo_query.filter(
+                    DbTransactionOutput.spent.is_(False),
+                    DbTransactionOutput.value < amount,
+                )
+                .order_by(DbTransactionOutput.value.desc())
+                .all()
+            )
             total_amount = 0
             selected_utxos = []
             for utxo in lessers[:max_utxos]:
                 if total_amount < amount:
                     selected_utxos.append(utxo)
                     total_amount += utxo.value
             if total_amount < amount:
@@ -3456,23 +4715,48 @@
             return selected_utxos
         else:
             inputs = []
             for utxo in selected_utxos:
                 # amount_total_input += utxo.value
                 inp_keys, key = self._objects_by_key_id(utxo.key_id)
                 multisig = False if len(inp_keys) < 2 else True
-                script_type = get_unlocking_script_type(utxo.script_type, multisig=multisig)
-                inputs.append(Input(utxo.transaction.txid, utxo.output_n, keys=inp_keys, script_type=script_type,
-                              sigs_required=self.multisig_n_required, sort=self.sort_keys, address=key.address,
-                              compressed=key.compressed, value=utxo.value, network=key.network_name))
+                script_type = get_unlocking_script_type(
+                    utxo.script_type, multisig=multisig
+                )
+                inputs.append(
+                    Input(
+                        utxo.transaction.txid,
+                        utxo.output_n,
+                        keys=inp_keys,
+                        script_type=script_type,
+                        sigs_required=self.multisig_n_required,
+                        sort=self.sort_keys,
+                        address=key.address,
+                        compressed=key.compressed,
+                        value=utxo.value,
+                        network=key.network_name,
+                    )
+                )
             return inputs
 
-    def transaction_create(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,
-                           min_confirms=1, max_utxos=None, locktime=0, number_of_change_outputs=1,
-                           random_output_order=False, message=""):
+    async def transaction_create(
+        self,
+        output_arr,
+        input_arr=None,
+        input_key_id=None,
+        account_id=None,
+        network=None,
+        fee=None,
+        min_confirms=1,
+        max_utxos=None,
+        locktime=0,
+        number_of_change_outputs=1,
+        random_output_order=True,
+        message="",
+    ):
         """
         Create new transaction with specified outputs.
 
         Inputs can be specified but if not provided they will be selected from wallets utxo's with :func:`select_inputs` method.
 
         Output array is a list of 1 or more addresses and amounts.
 
@@ -3506,91 +4790,133 @@
         :param random_output_order: Shuffle order of transaction outputs to increase privacy. Default is True
         :type random_output_order: bool
 
         :return WalletTransaction: object
         """
 
         if not isinstance(output_arr, list):
-            raise WalletError("Output array must be a list of tuples with address and amount. "
-                              "Use 'send_to' method to send to one address")
+            raise WalletError(
+                "Output array must be a list of tuples with address and amount. "
+                "Use 'send_to' method to send to one address"
+            )
         if not network and output_arr:
             if isinstance(output_arr[0], Output):
                 network = output_arr[0].network.name
             elif isinstance(output_arr[0][1], str):
                 network = Value(output_arr[0][1]).network.name
         network, account_id, acckey = self._get_account_defaults(network, account_id)
 
         if input_arr and max_utxos and len(input_arr) > max_utxos:
-            raise WalletError("Input array contains %d UTXO's but max_utxos=%d parameter specified" %
-                              (len(input_arr), max_utxos))
-
-        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)
-        expiry_height = srv.blockcount() + 21
+            raise WalletError(
+                "Input array contains %d UTXO's but max_utxos=%d parameter specified"
+                % (len(input_arr), max_utxos)
+            )
+
+        srv = Service(
+            network=network,
+            providers=self.providers,
+            cache_uri=self.db_cache_uri,
+        )
+        # ToDo: maybe make this configurable?
+        expiry_height = await srv.blockcount() + 21
 
         # Create transaction and add outputs
         amount_total_output = 0
-        transaction = WalletTransaction(hdwallet=self, account_id=account_id, network=network, locktime=locktime, expiry_height=expiry_height)
+        transaction: BaseTransaction = WalletTransaction(
+            hdwallet=self,
+            account_id=account_id,
+            network=network,
+            locktime=locktime,
+            expiry_height=expiry_height,
+        )
         transaction.outgoing_tx = True
         for o in output_arr:
             if isinstance(o, Output):
                 transaction.outputs.append(o)
                 amount_total_output += o.value
             else:
                 value = value_to_satoshi(o[1], network=transaction.network)
                 amount_total_output += value
                 addr = o[0]
                 if isinstance(addr, WalletKey):
                     addr = addr.key()
                 transaction.add_output(value, addr)
 
-
         transaction.fee_per_kb = None
         if isinstance(fee, int):
             fee_estimate = fee
         else:
             n_blocks = 3
-            priority = ''
+            priority = ""
             if isinstance(fee, str):
                 priority = fee
-            transaction.fee_per_kb = srv.estimatefee(blocks=n_blocks, priority=priority)
+            transaction.fee_per_kb = await srv.estimatefee(
+                blocks=n_blocks, priority=priority
+            )
             if not input_arr:
-                fee_estimate = int(transaction.estimate_size(number_of_change_outputs=number_of_change_outputs) /
-                                   1000.0 * transaction.fee_per_kb)
+                fee_estimate = int(
+                    transaction.estimate_size(
+                        number_of_change_outputs=number_of_change_outputs
+                    )
+                    / 1000.0
+                    * transaction.fee_per_kb
+                )
             else:
                 fee_estimate = 0
             if isinstance(fee, str):
                 fee = fee_estimate
 
         # Add inputs
-        sequence = 0xffffffff
-        if 0 < transaction.locktime < 0xffffffff:
-            sequence = 0xfffffffe
+        sequence = 0xFFFFFFFF
+        if 0 < transaction.locktime < 0xFFFFFFFF:
+            sequence = 0xFFFFFFFE
         amount_total_input = 0
         if input_arr is None:
-            selected_utxos = self.select_inputs(amount_total_output + fee_estimate, transaction.network.dust_amount,
-                                                input_key_id, account_id, network, min_confirms, max_utxos, False)
+            selected_utxos = self.select_inputs(
+                amount_total_output + fee_estimate,
+                transaction.network.dust_amount,
+                input_key_id,
+                account_id,
+                network,
+                min_confirms,
+                max_utxos,
+                False,
+            )
             if not selected_utxos:
                 raise WalletError("Not enough unspent transaction outputs found")
             for utxo in selected_utxos:
                 amount_total_input += utxo.value
                 inp_keys, key = self._objects_by_key_id(utxo.key_id)
-                multisig = False if isinstance(inp_keys, list) and len(inp_keys) < 2 else True
-                unlock_script_type = get_unlocking_script_type(utxo.script_type, self.witness_type, multisig=multisig)
-                transaction.add_input(utxo.transaction.txid, utxo.output_n, keys=inp_keys,
-                                      script_type=unlock_script_type, sigs_required=self.multisig_n_required,
-                                      sort=self.sort_keys, compressed=key.compressed, value=utxo.value,
-                                      address=utxo.key.address, sequence=sequence,
-                                      key_path=utxo.key.path, witness_type=self.witness_type)
+                multisig = (
+                    False if isinstance(inp_keys, list) and len(inp_keys) < 2 else True
+                )
+                unlock_script_type = get_unlocking_script_type(
+                    utxo.script_type, self.witness_type, multisig=multisig
+                )
+                transaction.add_input(
+                    utxo.transaction.txid,
+                    utxo.output_n,
+                    keys=inp_keys,
+                    script_type=unlock_script_type,
+                    sigs_required=self.multisig_n_required,
+                    sort=self.sort_keys,
+                    compressed=key.compressed,
+                    value=utxo.value,
+                    address=utxo.key.address,
+                    sequence=sequence,
+                    key_path=utxo.key.path,
+                    witness_type=self.witness_type,
+                )
                 # FIXME: Missing locktime_cltv=locktime_cltv, locktime_csv=locktime_csv (?)
         else:
             for inp in input_arr:
                 locktime_cltv = None
                 locktime_csv = None
                 unlocking_script_unsigned = None
-                unlocking_script_type = ''
+                unlocking_script_type = ""
                 if isinstance(inp, Input):
                     prev_txid = inp.prev_txid
                     output_n = inp.output_n
                     key_id = None
                     value = inp.value
                     signatures = inp.signatures
                     unlocking_script = inp.unlocking_script
@@ -3612,152 +4938,233 @@
                 #     address = inp.key.address
                 else:
                     prev_txid = inp[0]
                     output_n = inp[1]
                     key_id = None if len(inp) <= 2 else inp[2]
                     value = 0 if len(inp) <= 3 else inp[3]
                     signatures = None if len(inp) <= 4 else inp[4]
-                    unlocking_script = b'' if len(inp) <= 5 else inp[5]
-                    address = '' if len(inp) <= 6 else inp[6]
+                    unlocking_script = b"" if len(inp) <= 5 else inp[5]
+                    address = "" if len(inp) <= 6 else inp[6]
                 # Get key_ids, value from Db if not specified
                 if not (key_id and value and unlocking_script_type):
                     if not isinstance(output_n, TYPE_INT):
-                        output_n = int.from_bytes(output_n, 'big')
-                    inp_utxo = self._session.query(DbTransactionOutput).join(DbTransaction). \
-                        filter(DbTransaction.wallet_id == self.wallet_id,
-                               DbTransaction.txid == to_bytes(prev_txid),
-                               DbTransactionOutput.output_n == output_n).first()
+                        output_n = int.from_bytes(output_n, "big")
+                    inp_utxo = (
+                        self._session.query(DbTransactionOutput)
+                        .join(DbTransaction)
+                        .filter(
+                            DbTransaction.wallet_id == self.wallet_id,
+                            DbTransaction.txid == to_bytes(prev_txid),
+                            DbTransactionOutput.output_n == output_n,
+                        )
+                        .first()
+                    )
                     if inp_utxo:
                         key_id = inp_utxo.key_id
                         value = inp_utxo.value
                         address = inp_utxo.key.address
-                        unlocking_script_type = get_unlocking_script_type(inp_utxo.script_type, multisig=self.multisig)
+                        unlocking_script_type = get_unlocking_script_type(
+                            inp_utxo.script_type, multisig=self.multisig
+                        )
                         # witness_type = inp_utxo.witness_type
                     else:
-                        _logger.info("UTXO %s not found in this wallet. Please update UTXO's if this is not an "
-                                     "offline wallet" % to_hexstring(prev_txid))
-                        key_id = self._session.query(DbKey.id).\
-                            filter(DbKey.wallet_id == self.wallet_id, DbKey.address == address).scalar()
+                        _logger.info(
+                            "UTXO %s not found in this wallet. Please update UTXO's if this is not an "
+                            "offline wallet" % to_hexstring(prev_txid)
+                        )
+                        key_id = (
+                            self._session.query(DbKey.id)
+                            .filter(
+                                DbKey.wallet_id == self.wallet_id,
+                                DbKey.address == address,
+                            )
+                            .scalar()
+                        )
                         if not key_id:
-                            raise WalletError("UTXO %s and key with address %s not found in this wallet" % (
-                                to_hexstring(prev_txid), address))
+                            raise WalletError(
+                                "UTXO %s and key with address %s not found in this wallet"
+                                % (to_hexstring(prev_txid), address)
+                            )
                         if not value:
-                            raise WalletError("Input value is zero for address %s. Import or update UTXO's first "
-                                              "or import transaction as dictionary" % address)
+                            raise WalletError(
+                                "Input value is zero for address %s. Import or update UTXO's first "
+                                "or import transaction as dictionary" % address
+                            )
 
                 amount_total_input += value
                 inp_keys, key = self._objects_by_key_id(key_id)
-                transaction.add_input(prev_txid, output_n, keys=inp_keys, script_type=unlocking_script_type,
-                                      sigs_required=self.multisig_n_required, sort=self.sort_keys,
-                                      compressed=key.compressed, value=value, signatures=signatures,
-                                      unlocking_script=unlocking_script, address=address,
-                                      unlocking_script_unsigned=unlocking_script_unsigned,
-                                      sequence=sequence, locktime_cltv=locktime_cltv, locktime_csv=locktime_csv,
-                                      witness_type=self.witness_type, key_path=key.path)
+                transaction.add_input(
+                    prev_txid,
+                    output_n,
+                    keys=inp_keys,
+                    script_type=unlocking_script_type,
+                    sigs_required=self.multisig_n_required,
+                    sort=self.sort_keys,
+                    compressed=key.compressed,
+                    value=value,
+                    signatures=signatures,
+                    unlocking_script=unlocking_script,
+                    address=address,
+                    unlocking_script_unsigned=unlocking_script_unsigned,
+                    sequence=sequence,
+                    locktime_cltv=locktime_cltv,
+                    locktime_csv=locktime_csv,
+                    witness_type=self.witness_type,
+                    key_path=key.path,
+                )
         # Calculate fees
         transaction.fee = fee
         fee_per_output = None
-        transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)
+        transaction.size = transaction.estimate_size(
+            number_of_change_outputs=number_of_change_outputs
+        )
         if fee is None:
             if not input_arr:
                 if not transaction.fee_per_kb:
-                    transaction.fee_per_kb = srv.estimatefee()
+                    transaction.fee_per_kb = await srv.estimatefee()
                 if transaction.fee_per_kb < transaction.network.fee_min:
                     transaction.fee_per_kb = transaction.network.fee_min
-                transaction.fee = int((transaction.size / 1000.0) * transaction.fee_per_kb)
+                transaction.fee = int(
+                    (transaction.size / 1000.0) * transaction.fee_per_kb
+                )
                 fee_per_output = int((50 / 1000.0) * transaction.fee_per_kb)
             else:
                 if amount_total_output and amount_total_input:
                     fee = False
                 else:
                     transaction.fee = 0
 
         if fee is False:
             transaction.change = 0
             transaction.fee = int(amount_total_input - amount_total_output)
         else:
-            transaction.change = int(amount_total_input - (amount_total_output + transaction.fee))
+            transaction.change = int(
+                amount_total_input - (amount_total_output + transaction.fee)
+            )
 
         # Skip change if amount is smaller than the dust limit or estimated fee
-        if (fee_per_output and transaction.change < fee_per_output) or transaction.change <= transaction.network.dust_amount:
+        if (
+            fee_per_output and transaction.change < fee_per_output
+        ) or transaction.change <= transaction.network.dust_amount:
             transaction.fee += transaction.change
             transaction.change = 0
         if transaction.change < 0:
-            raise WalletError("Total amount of outputs is greater then total amount of inputs")
+            raise WalletError(
+                "Total amount of outputs is greater then total amount of inputs"
+            )
         if transaction.change:
-            min_output_value = transaction.network.dust_amount * 2 + transaction.network.fee_min * 4
+            min_output_value = (
+                transaction.network.dust_amount * 2 + transaction.network.fee_min * 4
+            )
             if transaction.fee and transaction.size:
                 if not transaction.fee_per_kb:
-                    transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)
-                min_output_value = transaction.fee_per_kb + transaction.network.fee_min * 4 + \
-                                   transaction.network.dust_amount
+                    transaction.fee_per_kb = int(
+                        (transaction.fee * 1000.0) / transaction.vsize
+                    )
+                min_output_value = (
+                    transaction.fee_per_kb
+                    + transaction.network.fee_min * 4
+                    + transaction.network.dust_amount
+                )
 
             if number_of_change_outputs == 0:
-                if transaction.change < amount_total_output / 10 or transaction.change < min_output_value * 8:
+                if (
+                    transaction.change < amount_total_output / 10
+                    or transaction.change < min_output_value * 8
+                ):
                     number_of_change_outputs = 1
                 elif transaction.change / 10 > amount_total_output:
                     number_of_change_outputs = random.randint(2, 5)
                 else:
                     number_of_change_outputs = random.randint(1, 3)
                     # Prefer 1 and 2 as number of change outputs
                     if number_of_change_outputs == 3:
                         number_of_change_outputs = random.randint(3, 4)
-                transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)
+                transaction.size = transaction.estimate_size(
+                    number_of_change_outputs=number_of_change_outputs
+                )
 
             average_change = transaction.change // number_of_change_outputs
             if number_of_change_outputs > 1 and average_change < min_output_value:
-                raise WalletError("Not enough funds to create multiple change outputs. Try less change outputs "
-                                  "or lower fees")
-
-            if self.scheme == 'single':
-                change_keys = [self.get_key(account_id=account_id, network=network, change=1)]
+                raise WalletError(
+                    "Not enough funds to create multiple change outputs. Try less change outputs "
+                    "or lower fees"
+                )
+
+            if self.scheme == "single":
+                change_keys = [
+                    self.get_key(account_id=account_id, network=network, change=1)
+                ]
             else:
-                change_keys = self.get_keys(account_id=account_id, network=network, change=1,
-                                            number_of_keys=number_of_change_outputs)
+                change_keys = self.get_keys(
+                    account_id=account_id,
+                    network=network,
+                    change=1,
+                    number_of_keys=number_of_change_outputs,
+                )
 
             if number_of_change_outputs > 1:
-                rand_prop = transaction.change - number_of_change_outputs * min_output_value
-                change_amounts = list(((np.random.dirichlet(np.ones(number_of_change_outputs), size=1)[0] *
-                                        rand_prop) + min_output_value).astype(int))
+                rand_prop = (
+                    transaction.change - number_of_change_outputs * min_output_value
+                )
+                change_amounts = list(
+                    (
+                        (
+                            np.random.dirichlet(
+                                np.ones(number_of_change_outputs), size=1
+                            )[0]
+                            * rand_prop
+                        )
+                        + min_output_value
+                    ).astype(int)
+                )
                 # Fix rounding problems / small amount differences
                 diffs = transaction.change - sum(change_amounts)
                 for idx, co in enumerate(change_amounts):
                     if co - diffs > min_output_value:
                         change_amounts[idx] += change_amounts.index(co) + diffs
                         break
             else:
                 change_amounts = [transaction.change]
 
             for idx, ck in enumerate(change_keys):
-                on = transaction.add_output(change_amounts[idx], ck.address, encoding=self.encoding)
+                on = transaction.add_output(
+                    change_amounts[idx], ck.address, encoding=self.encoding
+                )
                 transaction.outputs[on].key_id = ck.key_id
 
-        if message:
-            lock_script = b'j' + varstr(bytes(message, encoding="utf-8"))
-            transaction.add_output(0, lock_script=lock_script)
-
         # Shuffle output order to increase privacy
         if random_output_order:
             transaction.shuffle()
 
+        if message:
+            lock_script = b"j" + varstr(bytes(message, encoding="utf-8"))
+            transaction.add_output(0, lock_script=lock_script)
+
         # Check tx values
         transaction.input_total = sum([i.value for i in transaction.inputs])
         transaction.output_total = sum([o.value for o in transaction.outputs])
         if transaction.input_total != transaction.fee + transaction.output_total:
-            raise WalletError("Sum of inputs values is not equal to sum of outputs values plus fees")
+            raise WalletError(
+                "Sum of inputs values is not equal to sum of outputs values plus fees"
+            )
 
         transaction.txid = transaction.signature_hash()[::-1].hex()
         if not transaction.fee_per_kb:
             transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)
         if transaction.fee_per_kb < transaction.network.fee_min:
-            raise WalletError("Fee per kB of %d is lower then minimal network fee of %d" %
-                              (transaction.fee_per_kb, transaction.network.fee_min))
+            raise WalletError(
+                "Fee per kB of %d is lower then minimal network fee of %d"
+                % (transaction.fee_per_kb, transaction.network.fee_min)
+            )
         elif transaction.fee_per_kb > transaction.network.fee_max:
-            raise WalletError("Fee per kB of %d is higher then maximum network fee of %d" %
-                              (transaction.fee_per_kb, transaction.network.fee_max))
+            raise WalletError(
+                "Fee per kB of %d is higher then maximum network fee of %d"
+                % (transaction.fee_per_kb, transaction.network.fee_max)
+            )
 
         return transaction
 
     def transaction_import(self, t):
         """
         Import a Transaction into this wallet. Link inputs to wallet keys if possible and return WalletTransaction
         object. Only imports Transaction objects or dictionaries, use
@@ -3766,16 +5173,21 @@
         :param t: A Transaction object or dictionary
         :type t: Transaction, dict
 
         :return WalletTransaction:
 
         """
         if isinstance(t, Transaction):
-            rt = self.transaction_create(t.outputs, t.inputs, fee=t.fee, network=t.network.name,
-                                         random_output_order=False)
+            rt = self.transaction_create(
+                t.outputs,
+                t.inputs,
+                fee=t.fee,
+                network=t.network.name,
+                random_output_order=False,
+            )
             rt.block_height = t.block_height
             rt.confirmations = t.confirmations
             rt.witness_type = t.witness_type
             rt.date = t.date
             rt.txid = t.txid
             rt.txhash = t.txhash
             rt.locktime = t.locktime
@@ -3790,42 +5202,56 @@
                 rt.size = len(t.raw())
             rt.vsize = t.vsize
             if not t.vsize:
                 rt.vsize = rt.size
             rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)
         elif isinstance(t, dict):
             input_arr = []
-            for i in t['inputs']:
-                signatures = [bytes.fromhex(sig) for sig in i['signatures']]
-                script = b'' if 'script' not in i else i['script']
-                address = '' if 'address' not in i else i['address']
-                input_arr.append((i['prev_txid'], i['output_n'], None, int(i['value']), signatures, script,
-                                  address))
+            for i in t["inputs"]:
+                signatures = [bytes.fromhex(sig) for sig in i["signatures"]]
+                script = b"" if "script" not in i else i["script"]
+                address = "" if "address" not in i else i["address"]
+                input_arr.append(
+                    (
+                        i["prev_txid"],
+                        i["output_n"],
+                        None,
+                        int(i["value"]),
+                        signatures,
+                        script,
+                        address,
+                    )
+                )
             output_arr = []
-            for o in t['outputs']:
-                output_arr.append((o['address'], int(o['value'])))
-            rt = self.transaction_create(output_arr, input_arr, fee=t['fee'], network=t['network'],
-                                         random_output_order=False)
-            rt.block_height = t['block_height']
-            rt.confirmations = t['confirmations']
-            rt.witness_type = t['witness_type']
-            rt.date = t['date']
-            rt.txid = t['txid']
-            rt.txhash = t['txhash']
-            rt.locktime = t['locktime']
-            rt.version = t['version'].to_bytes(4, 'big')
-            rt.version_int = t['version']
-            rt.block_hash = t['block_hash']
-            rt.rawtx = t['raw']
-            rt.coinbase = t['coinbase']
-            rt.flag = t['flag']
-            rt.size = t['size']
-            if not t['size']:
+            for o in t["outputs"]:
+                output_arr.append((o["address"], int(o["value"])))
+            rt = self.transaction_create(
+                output_arr,
+                input_arr,
+                fee=t["fee"],
+                network=t["network"],
+                random_output_order=False,
+            )
+            rt.block_height = t["block_height"]
+            rt.confirmations = t["confirmations"]
+            rt.witness_type = t["witness_type"]
+            rt.date = t["date"]
+            rt.txid = t["txid"]
+            rt.txhash = t["txhash"]
+            rt.locktime = t["locktime"]
+            rt.version = t["version"].to_bytes(4, "big")
+            rt.version_int = t["version"]
+            rt.block_hash = t["block_hash"]
+            rt.rawtx = t["raw"]
+            rt.coinbase = t["coinbase"]
+            rt.flag = t["flag"]
+            rt.size = t["size"]
+            if not t["size"]:
                 rt.size = len(rt.raw())
-            rt.vsize = t['vsize']
+            rt.vsize = t["vsize"]
             if not rt.vsize:
                 rt.vsize = rt.size
             rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)
         else:
             raise WalletError("Import transaction must be of type Transaction or dict")
         rt.verify()
         return rt
@@ -3843,26 +5269,45 @@
         """
 
         if network is None:
             network = self.network.name
         if isinstance(rawtx, str):
             rawtx = bytes.fromhex(rawtx)
         t_import = Transaction.parse_bytes(rawtx, network=network)
-        rt = self.transaction_create(t_import.outputs, t_import.inputs, network=network, locktime=t_import.locktime,
-                                     random_output_order=False)
+        rt = self.transaction_create(
+            t_import.outputs,
+            t_import.inputs,
+            network=network,
+            locktime=t_import.locktime,
+            random_output_order=False,
+        )
         rt.version_int = t_import.version_int
         rt.version = t_import.version
         rt.verify()
         rt.size = len(rawtx)
         rt.calc_weight_units()
         rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)
         return rt
 
-    def send(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,
-             min_confirms=1, priv_keys=None, max_utxos=None, locktime=0, offline=True, number_of_change_outputs=1):
+    async def send(
+        self,
+        output_arr,
+        input_arr=None,
+        input_key_id=None,
+        account_id=None,
+        network=None,
+        fee=None,
+        min_confirms=1,
+        priv_keys=None,
+        max_utxos=None,
+        locktime=0,
+        offline=True,
+        number_of_change_outputs=1,
+        message="",
+    ):
         """
         Create a new transaction with specified outputs and push it to the network.
         Inputs can be specified but if not provided they will be selected from wallets utxo's
         Output array is a list of 1 or more addresses and amounts.
 
         Uses the :func:`transaction_create` method to create a new transaction, and uses a random service client to send the transaction.
 
@@ -3898,43 +5343,88 @@
         :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount
         :type number_of_change_outputs: int
 
         :return WalletTransaction:
         """
 
         if input_arr and max_utxos and len(input_arr) > max_utxos:
-            raise WalletError("Input array contains %d UTXO's but max_utxos=%d parameter specified" %
-                              (len(input_arr), max_utxos))
-
-        transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network, fee,
-                                              min_confirms, max_utxos, locktime, number_of_change_outputs)
+            raise WalletError(
+                "Input array contains %d UTXO's but max_utxos=%d parameter specified"
+                % (len(input_arr), max_utxos)
+            )
+
+        transaction = self.transaction_create(
+            output_arr,
+            input_arr,
+            input_key_id,
+            account_id,
+            network,
+            fee,
+            min_confirms,
+            max_utxos,
+            locktime,
+            number_of_change_outputs,
+        )
         transaction.sign(priv_keys)
         # Calculate exact fees and update change output if necessary
         if fee is None and transaction.fee_per_kb and transaction.change:
             fee_exact = transaction.calculate_fee()
             # Recreate transaction if fee estimation more than 10% off
-            if fee_exact != self.network.fee_min and fee_exact != self.network.fee_max and \
-                    fee_exact and abs((float(transaction.fee) - float(fee_exact)) / float(fee_exact)) > 0.10:
-                _logger.info("Transaction fee not correctly estimated (est.: %d, real: %d). "
-                             "Recreate transaction with correct fee" % (transaction.fee, fee_exact))
-                transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network,
-                                                      fee_exact, min_confirms, max_utxos, locktime,
-                                                      number_of_change_outputs)
+            if (
+                fee_exact != self.network.fee_min
+                and fee_exact != self.network.fee_max
+                and fee_exact
+                and abs((float(transaction.fee) - float(fee_exact)) / float(fee_exact))
+                > 0.10
+            ):
+                _logger.info(
+                    "Transaction fee not correctly estimated (est.: %d, real: %d). "
+                    "Recreate transaction with correct fee"
+                    % (transaction.fee, fee_exact)
+                )
+                transaction = self.transaction_create(
+                    output_arr,
+                    input_arr,
+                    input_key_id,
+                    account_id,
+                    network,
+                    fee_exact,
+                    min_confirms,
+                    max_utxos,
+                    locktime,
+                    number_of_change_outputs,
+                    message,
+                )
                 transaction.sign(priv_keys)
 
         transaction.rawtx = transaction.raw()
         transaction.size = len(transaction.rawtx)
         transaction.calc_weight_units()
-        transaction.fee_per_kb = int(float(transaction.fee) / float(transaction.vsize) * 1000)
+        transaction.fee_per_kb = int(
+            float(transaction.fee) / float(transaction.vsize) * 1000
+        )
         transaction.txid = transaction.signature_hash()[::-1].hex()
-        transaction.send(offline)
+        await transaction.send(offline)
         return transaction
 
-    def send_to(self, to_address, amount, input_key_id=None, account_id=None, network=None, fee=None, min_confirms=1,
-                priv_keys=None, locktime=0, offline=True, number_of_change_outputs=1):
+    async def send_to(
+        self,
+        to_address,
+        amount,
+        input_key_id=None,
+        account_id=None,
+        network=None,
+        fee=None,
+        min_confirms=1,
+        priv_keys=None,
+        locktime=0,
+        offline=True,
+        number_of_change_outputs=1,
+        message="",
+    ):
         """
         Create transaction and send it with default Service objects :func:`services.sendrawtransaction` method.
 
         Wrapper for wallet :func:`send` method.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> t = w.send_to('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000, offline=True)
@@ -3966,20 +5456,41 @@
         :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount
         :type number_of_change_outputs: int
 
         :return WalletTransaction:
         """
 
         outputs = [(to_address, amount)]
-        return self.send(outputs, input_key_id=input_key_id, account_id=account_id, network=network, fee=fee,
-                         min_confirms=min_confirms, priv_keys=priv_keys, locktime=locktime, offline=offline,
-                         number_of_change_outputs=number_of_change_outputs)
-
-    def sweep(self, to_address, account_id=None, input_key_id=None, network=None, max_utxos=999, min_confirms=1,
-              fee_per_kb=None, fee=None, locktime=0, offline=True):
+        return await self.send(
+            outputs,
+            input_key_id=input_key_id,
+            account_id=account_id,
+            network=network,
+            fee=fee,
+            min_confirms=min_confirms,
+            priv_keys=priv_keys,
+            locktime=locktime,
+            offline=offline,
+            number_of_change_outputs=number_of_change_outputs,
+            message="",
+        )
+
+    async def sweep(
+        self,
+        to_address,
+        account_id=None,
+        input_key_id=None,
+        network=None,
+        max_utxos=999,
+        min_confirms=1,
+        fee_per_kb=None,
+        fee=None,
+        locktime=0,
+        offline=True,
+    ):
         """
         Sweep all unspent transaction outputs (UTXO's) and send them to one or more output addresses.
 
         Wrapper for the :func:`send` method.
 
         >>> w = Wallet('fluxwallet_legacy_wallet_test')
         >>> t = w.sweep('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb')
@@ -4016,60 +5527,86 @@
         :type offline: bool
 
         :return WalletTransaction:
         """
 
         network, account_id, acckey = self._get_account_defaults(network, account_id)
 
-        utxos = self.utxos(account_id=account_id, network=network, min_confirms=min_confirms, key_id=input_key_id)
+        utxos = self.utxos(
+            account_id=account_id,
+            network=network,
+            min_confirms=min_confirms,
+            key_id=input_key_id,
+        )
         utxos = utxos[0:max_utxos]
         input_arr = []
         total_amount = 0
         if not utxos:
             raise WalletError("Cannot sweep wallet, no UTXO's found")
         for utxo in utxos:
             # Skip dust transactions to avoid forced address reuse
-            if utxo['value'] <= self.network.dust_amount:
+            if utxo["value"] <= self.network.dust_amount:
                 continue
-            input_arr.append((utxo['txid'], utxo['output_n'], utxo['key_id'], utxo['value']))
-            total_amount += utxo['value']
-        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)
+            input_arr.append(
+                (utxo["txid"], utxo["output_n"], utxo["key_id"], utxo["value"])
+            )
+            total_amount += utxo["value"]
+        srv = Service(
+            network=network,
+            providers=self.providers,
+            cache_uri=self.db_cache_uri,
+        )
 
         if isinstance(fee, str):
             n_outputs = 1 if not isinstance(to_address, list) else len(to_address)
-            fee_per_kb = srv.estimatefee(priority=fee)
-            tr_size = 125 + (len(input_arr) * (77 + self.multisig_n_required * 72)) + n_outputs * 30
+            fee_per_kb = await srv.estimatefee(priority=fee)
+            tr_size = (
+                125
+                + (len(input_arr) * (77 + self.multisig_n_required * 72))
+                + n_outputs * 30
+            )
             fee = 100 + int((tr_size / 1000.0) * fee_per_kb)
 
         if not fee:
             if fee_per_kb is None:
-                fee_per_kb = srv.estimatefee()
+                fee_per_kb = await srv.estimatefee()
             tr_size = 125 + (len(input_arr) * 125)
             fee = int((tr_size / 1000.0) * fee_per_kb)
         if total_amount - fee <= self.network.dust_amount:
-            raise WalletError("Amount to send is smaller then dust amount: %s" % (total_amount - fee))
+            raise WalletError(
+                "Amount to send is smaller then dust amount: %s" % (total_amount - fee)
+            )
 
         if isinstance(to_address, str):
             to_list = [(to_address, total_amount - fee)]
         else:
             to_list = []
             for o in to_address:
                 if o[1] == 0:
                     o_amount = total_amount - sum([x[1] for x in to_list]) - fee
                     if o_amount > 0:
                         to_list.append((o[0], o_amount))
                 else:
                     to_list.append(o)
 
         if sum(x[1] for x in to_list) + fee != total_amount:
-            raise WalletError("Total amount of outputs does not match total input amount. If you specify a list of "
-                              "outputs, use amount value = 0 to indicate a change/rest output")
-
-        return self.send(to_list, input_arr, network=network, fee=fee, min_confirms=min_confirms, locktime=locktime,
-                         offline=offline)
+            raise WalletError(
+                "Total amount of outputs does not match total input amount. If you specify a list of "
+                "outputs, use amount value = 0 to indicate a change/rest output"
+            )
+
+        return await self.send(
+            to_list,
+            input_arr,
+            network=network,
+            fee=fee,
+            min_confirms=min_confirms,
+            locktime=locktime,
+            offline=offline,
+        )
 
     def wif(self, is_private=False, account_id=0):
         """
         Return Wallet Import Format string for master private or public key which can be used to import key and
         recreate wallet in other software.
 
         A list of keys will be exported for a multisig wallet.
@@ -4081,16 +5618,23 @@
 
         :return list, str:
         """
         if not self.multisig or not self.cosigner:
             if is_private and self.main_key:
                 return self.main_key.wif
             else:
-                return self.public_master(account_id=account_id).key().\
-                    wif(is_private=is_private, witness_type=self.witness_type, multisig=self.multisig)
+                return (
+                    self.public_master(account_id=account_id)
+                    .key()
+                    .wif(
+                        is_private=is_private,
+                        witness_type=self.witness_type,
+                        multisig=self.multisig,
+                    )
+                )
         else:
             wiflist = []
             for cs in self.cosigner:
                 wiflist.append(cs.wif(is_private=is_private))
             return wiflist
 
     def public_master(self, account_id=None, name=None, as_private=False, network=None):
@@ -4112,21 +5656,27 @@
         :param as_private: Export public or private key, default is False
         :type as_private: bool
         :param network: Network name. Leave empty for default network
         :type network: str
 
         :return list of WalletKey, WalletKey:
         """
-        if self.main_key and self.main_key.key_type == 'single':
+        if self.main_key and self.main_key.key_type == "single":
             key = self.main_key
             return key if as_private else key.public()
         elif not self.cosigner:
             depth = -self.key_depth + self.depth_public_master
-            key = self.key_for_path([], depth, name=name, account_id=account_id, network=network,
-                                    cosigner_id=self.cosigner_id)
+            key = self.key_for_path(
+                [],
+                depth,
+                name=name,
+                account_id=account_id,
+                network=network,
+                cosigner_id=self.cosigner_id,
+            )
             return key if as_private else key.public()
         else:
             pm_list = []
             for cs in self.cosigner:
                 pm_list.append(cs.public_master(account_id, name, as_private, network))
             return pm_list
 
@@ -4142,20 +5692,20 @@
         :type filename: str
 
         :return Transaction:
         """
         if not filename and not txid:
             raise WalletError("Please supply filename or txid")
         elif not filename and txid:
-            p = Path(FW_DATA_DIR, '%s.tx' % txid)
+            p = Path(FW_DATA_DIR, "%s.tx" % txid)
         else:
             p = Path(filename)
-            if not p.parent or str(p.parent) == '.':
+            if not p.parent or str(p.parent) == ".":
                 p = Path(FW_DATA_DIR, filename)
-        f = p.open('rb')
+        f = p.open("rb")
         t = pickle.load(f)
         f.close()
         return self.transaction_import(t)
 
     def info(self, detail=3):
         """
         Prints wallet information to standard output
@@ -4167,30 +5717,42 @@
         print("=== WALLET ===")
         print(" ID                             %s" % self.wallet_id)
         print(" Name                           %s" % self.name)
         print(" Owner                          %s" % self.owner)
         print(" Scheme                         %s" % self.scheme)
         print(" Multisig                       %s" % self.multisig)
         if self.multisig:
-            print(" Multisig Wallet IDs            %s" % str([w.wallet_id for w in self.cosigner]).strip('[]'))
+            print(
+                " Multisig Wallet IDs            %s"
+                % str([w.wallet_id for w in self.cosigner]).strip("[]")
+            )
             print(" Cosigner ID                    %s" % self.cosigner_id)
         print(" Witness type                   %s" % self.witness_type)
         print(" Main network                   %s" % self.network.name)
         print(" Latest update                  %s" % self.last_updated)
 
         if self.multisig:
             print("\n= Multisig Public Master Keys =")
             for cs in self.cosigner:
-                print("%5s %3s %-70s %-6s %-8s %s" %
-                      (cs.cosigner_id, cs.main_key.key_id, cs.wif(is_private=False), cs.scheme,
-                       "main" if cs.main_key.is_private else "cosigner",
-                       '*' if cs.cosigner_id == self.cosigner_id else ''))
-
-            print("For main keys a private master key is available in this wallet to sign transactions. "
-                  "* cosigner key for this wallet")
+                print(
+                    "%5s %3s %-70s %-6s %-8s %s"
+                    % (
+                        cs.cosigner_id,
+                        cs.main_key.key_id,
+                        cs.wif(is_private=False),
+                        cs.scheme,
+                        "main" if cs.main_key.is_private else "cosigner",
+                        "*" if cs.cosigner_id == self.cosigner_id else "",
+                    )
+                )
+
+            print(
+                "For main keys a private master key is available in this wallet to sign transactions. "
+                "* cosigner key for this wallet"
+            )
 
         if detail and self.main_key:
             print("\n= Wallet Master Key =")
             print(" ID                             %s" % self.main_key_id)
             print(" Private                        %s" % self.main_key.is_private)
             print(" Depth                          %s" % self.main_key.depth)
 
@@ -4209,49 +5771,81 @@
                 else:
                     ds = range(8)
                 for d in ds:
                     is_active = True
                     if detail > 3:
                         is_active = False
                     for key in self.keys(depth=d, network=nw.name, is_active=is_active):
-                        print("%5s %-28s %-45s %-25s %25s" %
-                              (key.id, key.path, key.address, key.name,
-                               Value.from_satoshi(key.balance, network=nw).str_unit(currency_repr='symbol')))
+                        print(
+                            "%5s %-28s %-45s %-25s %25s"
+                            % (
+                                key.id,
+                                key.path,
+                                key.address,
+                                key.name,
+                                Value.from_satoshi(key.balance, network=nw).str_unit(
+                                    currency_repr="symbol"
+                                ),
+                            )
+                        )
 
                 if detail > 2:
                     include_new = False
                     if detail > 3:
                         include_new = True
                     accounts = self.accounts(network=nw.name)
                     if not accounts:
                         accounts = [0]
                     for account_id in accounts:
-                        txs = self.transactions(include_new=include_new, account_id=account_id, network=nw.name,
-                                                as_dict=True)
-                        print("\n- - Transactions Account %d (%d)" % (account_id, len(txs)))
+                        txs = self.transactions(
+                            include_new=include_new,
+                            account_id=account_id,
+                            network=nw.name,
+                            as_dict=True,
+                        )
+                        print(
+                            "\n- - Transactions Account %d (%d)"
+                            % (account_id, len(txs))
+                        )
                         for tx in txs:
                             spent = " "
-                            address = tx['address']
-                            if not tx['address']:
-                                address = 'nulldata'
-                            elif 'spent' in tx and tx['spent'] is False:
+                            address = tx["address"]
+                            if not tx["address"]:
+                                address = "nulldata"
+                            elif "spent" in tx and tx["spent"] is False:
                                 spent = "U"
                             status = ""
-                            if tx['status'] not in ['confirmed', 'unconfirmed']:
-                                status = tx['status']
-                            print("%64s %43s %8d %21s %s %s" % (tx['txid'], address, tx['confirmations'],
-                                                                Value.from_satoshi(tx['value'], network=nw).str_unit(
-                                                                    currency_repr='symbol'),
-                                                                spent, status))
+                            if tx["status"] not in ["confirmed", "unconfirmed"]:
+                                status = tx["status"]
+                            print(
+                                "%64s %43s %8d %21s %s %s"
+                                % (
+                                    tx["txid"],
+                                    address,
+                                    tx["confirmations"],
+                                    Value.from_satoshi(
+                                        tx["value"], network=nw
+                                    ).str_unit(currency_repr="symbol"),
+                                    spent,
+                                    status,
+                                )
+                            )
 
         print("\n= Balance Totals (includes unconfirmed) =")
         for na_balance in balances:
-            print("%-20s %-20s %20s" % (na_balance['network'], "(Account %s)" % na_balance['account_id'],
-                                        Value.from_satoshi(na_balance['balance'], network=na_balance['network']).
-                                        str_unit(currency_repr='symbol')))
+            print(
+                "%-20s %-20s %20s"
+                % (
+                    na_balance["network"],
+                    "(Account %s)" % na_balance["account_id"],
+                    Value.from_satoshi(
+                        na_balance["balance"], network=na_balance["network"]
+                    ).str_unit(currency_repr="symbol"),
+                )
+            )
         print("\n")
 
     def as_dict(self, include_private=False):
         """
         Return wallet information in dictionary format
 
         :param include_private: Include private key information in dictionary
@@ -4259,47 +5853,55 @@
 
         :return dict:
         """
 
         keys = []
         transactions = []
         for netw in self.networks():
-            for key in self.keys(network=netw.name, include_private=include_private, as_dict=True):
+            for key in self.keys(
+                network=netw.name, include_private=include_private, as_dict=True
+            ):
                 keys.append(key)
 
             if self.multisig:
-                for t in self.transactions(include_new=True, account_id=0, network=netw.name):
+                for t in self.transactions(
+                    include_new=True, account_id=0, network=netw.name
+                ):
                     transactions.append(t.as_dict())
             else:
                 accounts = self.accounts(network=netw.name)
                 if not accounts:
                     accounts = [0]
                 for account_id in accounts:
-                    for t in self.transactions(include_new=True, account_id=account_id, network=netw.name):
+                    for t in self.transactions(
+                        include_new=True, account_id=account_id, network=netw.name
+                    ):
                         transactions.append(t.as_dict())
 
         return {
-            'wallet_id': self.wallet_id,
-            'name': self.name,
-            'owner': self._owner,
-            'scheme': self.scheme,
-            'witness_type': self.witness_type,
-            'main_network': self.network.name,
-            'main_balance': self.balance(),
-            'main_balance_str': self.balance(as_string=True),
-            'balances': self._balances,
-            'default_account_id': self.default_account_id,
-            'multisig_n_required': self.multisig_n_required,
-            'cosigner_wallet_ids': [w.wallet_id for w in self.cosigner],
-            'cosigner_public_masters': [w.public_master().key().wif() for w in self.cosigner],
-            'sort_keys': self.sort_keys,
-            'main_key_id': self.main_key_id,
-            'encoding': self.encoding,
-            'keys': keys,
-            'transactions': transactions,
+            "wallet_id": self.wallet_id,
+            "name": self.name,
+            "owner": self._owner,
+            "scheme": self.scheme,
+            "witness_type": self.witness_type,
+            "main_network": self.network.name,
+            "main_balance": self.balance(),
+            "main_balance_str": self.balance(as_string=True),
+            "balances": self._balances,
+            "default_account_id": self.default_account_id,
+            "multisig_n_required": self.multisig_n_required,
+            "cosigner_wallet_ids": [w.wallet_id for w in self.cosigner],
+            "cosigner_public_masters": [
+                w.public_master().key().wif() for w in self.cosigner
+            ],
+            "sort_keys": self.sort_keys,
+            "main_key_id": self.main_key_id,
+            "encoding": self.encoding,
+            "keys": keys,
+            "transactions": transactions,
         }
 
     def as_json(self, include_private=False):
         """
         Get current key as json formatted string
 
         :param include_private: Include private key information in JSON
```

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/chinese_simplified.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/chinese_simplified.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/chinese_traditional.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/chinese_traditional.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/dutch.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/dutch.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/english.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/english.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/french.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/french.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/italian.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/italian.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/japanese.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/japanese.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/fluxwallet/wordlist/spanish.txt` & `fluxwallet-0.1.0/fluxwallet/wordlist/spanish.txt`

 * *Files identical despite different names*

### Comparing `fluxwallet-0.0.6/PKG-INFO` & `fluxwallet-0.1.0/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,17 +1,29 @@
 Metadata-Version: 2.1
 Name: fluxwallet
-Version: 0.0.6
-Summary: A Wallet implementation for Flux (based on fluxwallet)
-License: MIT
+Version: 0.1.0
+Summary: A Wallet implementation for Flux
+License: bsd 3-clause
 Author: David White
+Author-email: dr.white.nz@gmail.com
 Requires-Python: >=3.10,<4.0
-Classifier: License :: OSI Approved :: MIT License
+Classifier: License :: Other/Proprietary License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Requires-Dist: SQLAlchemy (>=1.4.28,<2.0.0)
+Requires-Dist: aiosqlite (>=0.19.0,<0.20.0)
 Requires-Dist: ecdsa (>=0.17,<0.18) ; sys_platform == "win32"
 Requires-Dist: fastecdsa (>=2.2.1,<3.0.0) ; sys_platform != "win32"
+Requires-Dist: httpx (>=0.24.1,<0.25.0)
 Requires-Dist: numpy (>=1.21.0,<2.0.0)
 Requires-Dist: pycryptodome (>=3.14.1,<4.0.0)
-Requires-Dist: requests (>=2.25.0,<3.0.0)
+Description-Content-Type: text/markdown
+
+Fluxwallet
+======================
+
+A heavily modified bitcoinlib fork.
+
+https://github.com/1200wd/bitcoinlib
+
+Readme: ToDo
```

