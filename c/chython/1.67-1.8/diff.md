# Comparing `tmp/chython-1.67.tar.gz` & `tmp/chython-1.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "chython-1.67.tar", last modified: Sun Aug  6 17:15:58 2023, max compression
+gzip compressed data, was "chython-1.8.tar", last modified: Fri Nov 12 15:45:40 2021, max compression
```

## Comparing `chython-1.67.tar` & `chython-1.8.tar`

### file list

```diff
@@ -1,156 +1,133 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.988360 chython-1.67/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/INCHI/
--rw-r--r--   0 runner    (1001) docker     (123)  1297408 2023-08-06 17:15:40.908009 chython-1.67/INCHI/libinchi.dll
--rwxr-xr-x   0 runner    (1001) docker     (123)  1335296 2023-08-06 17:15:40.916009 chython-1.67/INCHI/libinchi.dynlib
--rw-r--r--   0 runner    (1001) docker     (123)  1353400 2023-08-06 17:15:40.928009 chython-1.67/INCHI/libinchi.so
--rw-r--r--   0 runner    (1001) docker     (123)     3228 2023-08-06 17:15:57.988360 chython-1.67/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1767 2023-08-06 17:15:40.928009 chython-1.67/README.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/
--rw-r--r--   0 runner    (1001) docker     (123)     1258 2023-08-06 17:15:40.928009 chython-1.67/chython/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2276 2023-08-06 17:15:40.928009 chython-1.67/chython/_functions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)      788 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)  1158841 2023-08-06 17:15:56.116329 chython-1.67/chython/algorithms/_isomorphism.c
--rw-r--r--   0 runner    (1001) docker     (123)     7323 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/_isomorphism.pyx
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/algorithms/aromatics/
--rw-r--r--   0 runner    (1001) docker     (123)      912 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/aromatics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2993 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/aromatics/_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)    23489 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/aromatics/kekule.py
--rw-r--r--   0 runner    (1001) docker     (123)     8838 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/aromatics/thiele.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/algorithms/calculate2d/
--rw-r--r--   0 runner    (1001) docker     (123)     6952 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/calculate2d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    92275 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/calculate2d/clean2d.js
--rw-r--r--   0 runner    (1001) docker     (123)    24779 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/depict.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/algorithms/fingerprints/
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/fingerprints/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6617 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/fingerprints/linear.py
--rw-r--r--   0 runner    (1001) docker     (123)     3874 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/fingerprints/morgan.py
--rw-r--r--   0 runner    (1001) docker     (123)    22895 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/isomorphism.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.980360 chython-1.67/chython/algorithms/mapping/
--rw-r--r--   0 runner    (1001) docker     (123)      972 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2657 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     2418 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/_reactions.py
--rw-r--r--   0 runner    (1001) docker     (123)     7403 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/attention.py
--rw-r--r--   0 runner    (1001) docker     (123)     3030 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/fixmapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     5186 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mapping/groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     7142 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/mcs.py
--rw-r--r--   0 runner    (1001) docker     (123)     2930 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/morgan.py
--rw-r--r--   0 runner    (1001) docker     (123)    20222 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/rings.py
--rw-r--r--   0 runner    (1001) docker     (123)    24339 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/smiles.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/algorithms/standardize/
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4019 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/_charged.py
--rw-r--r--   0 runner    (1001) docker     (123)    37025 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     6202 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/_metal_organics.py
--rw-r--r--   0 runner    (1001) docker     (123)     1369 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/_reagents.py
--rw-r--r--   0 runner    (1001) docker     (123)     1949 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/_salts.py
--rw-r--r--   0 runner    (1001) docker     (123)    19494 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)    15203 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/reaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     7628 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/resonance.py
--rw-r--r--   0 runner    (1001) docker     (123)     4609 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/salts.py
--rw-r--r--   0 runner    (1001) docker     (123)    15884 2023-08-06 17:15:40.928009 chython-1.67/chython/algorithms/standardize/saturation.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/algorithms/stereo/
--rw-r--r--   0 runner    (1001) docker     (123)      869 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/stereo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    17016 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/stereo/graph.py
--rw-r--r--   0 runner    (1001) docker     (123)    31820 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/stereo/molecule.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/algorithms/tautomers/
--rw-r--r--   0 runner    (1001) docker     (123)    10141 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/_acid.py
--rw-r--r--   0 runner    (1001) docker     (123)     2854 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     2538 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/_keto_enol.py
--rw-r--r--   0 runner    (1001) docker     (123)     7698 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/acid_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     3703 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/heteroarenes.py
--rw-r--r--   0 runner    (1001) docker     (123)     5776 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/keto_enol.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/algorithms/tautomers/test/
--rw-r--r--   0 runner    (1001) docker     (123)      783 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3611 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/tautomers/test/test_tautomers.py
--rw-r--r--   0 runner    (1001) docker     (123)    16555 2023-08-06 17:15:40.932009 chython-1.67/chython/algorithms/x3dom.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/containers/
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)  1067935 2023-08-06 17:15:56.680338 chython-1.67/chython/containers/_cpack.c
--rw-r--r--   0 runner    (1001) docker     (123)     7474 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/_cpack.pyx
--rw-r--r--   0 runner    (1001) docker     (123)   404790 2023-08-06 17:15:56.784340 chython-1.67/chython/containers/_pack.c
--rw-r--r--   0 runner    (1001) docker     (123)     9761 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/_pack.pyx
--rw-r--r--   0 runner    (1001) docker     (123)  1104388 2023-08-06 17:15:57.396350 chython-1.67/chython/containers/_unpack.c
--rw-r--r--   0 runner    (1001) docker     (123)    12461 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/_unpack.pyx
--rw-r--r--   0 runner    (1001) docker     (123)     8073 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/bonds.py
--rw-r--r--   0 runner    (1001) docker     (123)     5400 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/cgr.py
--rw-r--r--   0 runner    (1001) docker     (123)     9269 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/graph.py
--rw-r--r--   0 runner    (1001) docker     (123)    43829 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)    13544 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/query.py
--rw-r--r--   0 runner    (1001) docker     (123)    11839 2023-08-06 17:15:40.932009 chython-1.67/chython/containers/reaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     2454 2023-08-06 17:15:40.932009 chython-1.67/chython/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/files/
--rw-r--r--   0 runner    (1001) docker     (123)    19912 2023-08-06 17:15:40.932009 chython-1.67/chython/files/MRVrw.py
--rw-r--r--   0 runner    (1001) docker     (123)    10403 2023-08-06 17:15:40.932009 chython-1.67/chython/files/PDBrw.py
--rw-r--r--   0 runner    (1001) docker     (123)    13279 2023-08-06 17:15:40.932009 chython-1.67/chython/files/RDFrw.py
--rw-r--r--   0 runner    (1001) docker     (123)     9079 2023-08-06 17:15:40.932009 chython-1.67/chython/files/SDFrw.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-08-06 17:15:40.932009 chython-1.67/chython/files/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4175 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_convert.py
--rw-r--r--   0 runner    (1001) docker     (123)     4231 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mapping.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/files/_mdl/
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6740 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/emol.py
--rw-r--r--   0 runner    (1001) docker     (123)     2414 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/erxn.py
--rw-r--r--   0 runner    (1001) docker     (123)     6962 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/mol.py
--rw-r--r--   0 runner    (1001) docker     (123)     8100 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/read.py
--rw-r--r--   0 runner    (1001) docker     (123)     2369 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/rxn.py
--rw-r--r--   0 runner    (1001) docker     (123)     3709 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/stereo.py
--rw-r--r--   0 runner    (1001) docker     (123)     5861 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_mdl/write.py
--rw-r--r--   0 runner    (1001) docker     (123)  1001159 2023-08-06 17:15:57.964359 chython-1.67/chython/files/_xyz.c
--rw-r--r--   0 runner    (1001) docker     (123)     2480 2023-08-06 17:15:40.932009 chython-1.67/chython/files/_xyz.pyx
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/files/daylight/
--rw-r--r--   0 runner    (1001) docker     (123)      916 2023-08-06 17:15:40.932009 chython-1.67/chython/files/daylight/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6549 2023-08-06 17:15:40.932009 chython-1.67/chython/files/daylight/parser.py
--rw-r--r--   0 runner    (1001) docker     (123)     4547 2023-08-06 17:15:40.932009 chython-1.67/chython/files/daylight/smarts.py
--rw-r--r--   0 runner    (1001) docker     (123)    14284 2023-08-06 17:15:40.932009 chython-1.67/chython/files/daylight/smiles.py
--rw-r--r--   0 runner    (1001) docker     (123)    14797 2023-08-06 17:15:40.932009 chython-1.67/chython/files/daylight/tokenize.py
--rw-r--r--   0 runner    (1001) docker     (123)    23351 2023-08-06 17:15:40.932009 chython-1.67/chython/files/inchi.py
--rw-r--r--   0 runner    (1001) docker     (123)     2909 2023-08-06 17:15:40.932009 chython-1.67/chython/files/xyz.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.984360 chython-1.67/chython/periodictable/
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.988360 chython-1.67/chython/periodictable/element/
--rw-r--r--   0 runner    (1001) docker     (123)     1103 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/element/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3010 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/element/core.py
--rw-r--r--   0 runner    (1001) docker     (123)     3591 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/element/dynamic.py
--rw-r--r--   0 runner    (1001) docker     (123)    12970 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/element/element.py
--rw-r--r--   0 runner    (1001) docker     (123)    12197 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/element/query.py
--rw-r--r--   0 runner    (1001) docker     (123)     4698 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupI.py
--rw-r--r--   0 runner    (1001) docker     (123)     4882 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupII.py
--rw-r--r--   0 runner    (1001) docker     (123)    25391 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     6765 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupIV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5972 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupIX.py
--rw-r--r--   0 runner    (1001) docker     (123)     5570 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5349 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupVI.py
--rw-r--r--   0 runner    (1001) docker     (123)     3751 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupVII.py
--rw-r--r--   0 runner    (1001) docker     (123)     4166 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupVIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     4207 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupX.py
--rw-r--r--   0 runner    (1001) docker     (123)     3851 2023-08-06 17:15:40.932009 chython-1.67/chython/periodictable/groupXI.py
--rw-r--r--   0 runner    (1001) docker     (123)     3878 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5375 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5889 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXIV.py
--rw-r--r--   0 runner    (1001) docker     (123)     5847 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXV.py
--rw-r--r--   0 runner    (1001) docker     (123)    16618 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXVI.py
--rw-r--r--   0 runner    (1001) docker     (123)     8665 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXVII.py
--rw-r--r--   0 runner    (1001) docker     (123)     5795 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groupXVIII.py
--rw-r--r--   0 runner    (1001) docker     (123)     1447 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     1047 2023-08-06 17:15:40.936009 chython-1.67/chython/periodictable/periods.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.988360 chython-1.67/chython/reactor/
--rw-r--r--   0 runner    (1001) docker     (123)      989 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11323 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/base.py
--rw-r--r--   0 runner    (1001) docker     (123)    19713 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/deprotection.py
--rw-r--r--   0 runner    (1001) docker     (123)     5630 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/reactions.py
--rw-r--r--   0 runner    (1001) docker     (123)     8091 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/reactor.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.988360 chython-1.67/chython/reactor/test/
--rw-r--r--   0 runner    (1001) docker     (123)      784 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1832 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/test/test_deprotection.py
--rw-r--r--   0 runner    (1001) docker     (123)     2663 2023-08-06 17:15:40.936009 chython-1.67/chython/reactor/transformer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-08-06 17:15:57.988360 chython-1.67/chython/utils/
--rw-r--r--   0 runner    (1001) docker     (123)     1716 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3830 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/free_wilson.py
--rw-r--r--   0 runner    (1001) docker     (123)     1757 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/functional_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     4461 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/grid.py
--rw-r--r--   0 runner    (1001) docker     (123)     6369 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/rdkit.py
--rw-r--r--   0 runner    (1001) docker     (123)     5028 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/retro.py
--rw-r--r--   0 runner    (1001) docker     (123)     1907 2023-08-06 17:15:40.936009 chython-1.67/chython/utils/svg.py
--rw-r--r--   0 runner    (1001) docker     (123)     4726 2023-08-06 17:15:40.936009 chython-1.67/setup.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.351194 chython-1.8/
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.204187 chython-1.8/INCHI/
+-rw-rw-rw-   0        0        0  1297408 2021-10-01 15:03:36.041446 chython-1.8/INCHI/libinchi.dll
+-rw-rw-rw-   0        0        0  1335296 2021-10-01 15:03:36.057122 chython-1.8/INCHI/libinchi.dynlib
+-rw-rw-rw-   0        0        0  1353400 2021-10-01 15:03:36.072748 chython-1.8/INCHI/libinchi.so
+-rw-rw-rw-   0        0        0     2937 2021-11-12 15:45:40.351194 chython-1.8/PKG-INFO
+-rw-rw-rw-   0        0        0     1910 2021-10-01 15:03:36.088321 chython-1.8/README.rst
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.208188 chython-1.8/chython/
+-rw-rw-rw-   0        0        0     1379 2021-10-01 15:03:36.088321 chython-1.8/chython/__init__.py
+-rw-rw-rw-   0        0        0     2345 2021-10-01 15:03:36.088321 chython-1.8/chython/_functions.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.224188 chython-1.8/chython/algorithms/
+-rw-rw-rw-   0        0        0      806 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/__init__.py
+-rw-rw-rw-   0        0        0   932678 2021-10-18 19:02:47.667603 chython-1.8/chython/algorithms/_isomorphism.c
+-rw-rw-rw-   0        0        0     7215 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/_isomorphism.pyx
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.229187 chython-1.8/chython/algorithms/aromatics/
+-rw-rw-rw-   0        0        0      939 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/aromatics/__init__.py
+-rw-rw-rw-   0        0        0     4530 2021-10-01 15:03:36.088321 chython-1.8/chython/algorithms/aromatics/_rules.py
+-rw-rw-rw-   0        0        0    20981 2021-10-21 13:10:51.279065 chython-1.8/chython/algorithms/aromatics/kekule.py
+-rw-rw-rw-   0        0        0     8680 2021-10-11 09:51:11.184900 chython-1.8/chython/algorithms/aromatics/thiele.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.232188 chython-1.8/chython/algorithms/calculate2d/
+-rw-rw-rw-   0        0        0     8719 2021-10-08 10:55:30.023916 chython-1.8/chython/algorithms/calculate2d/__init__.py
+-rw-rw-rw-   0        0        0   106510 2021-10-01 15:03:36.119572 chython-1.8/chython/algorithms/calculate2d/clean2d.js
+-rw-rw-rw-   0        0        0    59367 2021-10-01 15:39:44.329425 chython-1.8/chython/algorithms/depict.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.235188 chython-1.8/chython/algorithms/fingerprints/
+-rw-rw-rw-   0        0        0     1067 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/__init__.py
+-rw-rw-rw-   0        0        0     7940 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/linear.py
+-rw-rw-rw-   0        0        0     5129 2021-10-01 15:03:36.126098 chython-1.8/chython/algorithms/fingerprints/morgan.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.236188 chython-1.8/chython/algorithms/fingerprints/pharmacophore/
+-rw-rw-rw-   0        0        0     3682 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/fingerprints/pharmacophore/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.237188 chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/
+-rw-rw-rw-   0        0        0      861 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/__init__.py
+-rw-rw-rw-   0        0        0     3712 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/huckel.py
+-rw-rw-rw-   0        0        0    11117 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/isomorphism.py
+-rw-rw-rw-   0        0        0     7344 2021-10-01 15:03:36.141732 chython-1.8/chython/algorithms/mcs.py
+-rw-rw-rw-   0        0        0     2970 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/morgan.py
+-rw-rw-rw-   0        0        0    20611 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/rings.py
+-rw-rw-rw-   0        0        0    18757 2021-10-25 08:03:55.083423 chython-1.8/chython/algorithms/smiles.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.251189 chython-1.8/chython/algorithms/standardize/
+-rw-rw-rw-   0        0        0     1054 2021-11-09 10:50:29.396153 chython-1.8/chython/algorithms/standardize/__init__.py
+-rw-rw-rw-   0        0        0     9094 2021-10-01 15:03:36.157358 chython-1.8/chython/algorithms/standardize/_charged.py
+-rw-rw-rw-   0        0        0    33550 2021-11-07 15:58:14.990364 chython-1.8/chython/algorithms/standardize/_groups.py
+-rw-rw-rw-   0        0        0     5521 2021-10-01 15:03:36.172982 chython-1.8/chython/algorithms/standardize/_mapping.py
+-rw-rw-rw-   0        0        0     7920 2021-10-21 13:10:51.303064 chython-1.8/chython/algorithms/standardize/_metal_organics.py
+-rw-rw-rw-   0        0        0    16775 2021-11-09 10:50:29.421143 chython-1.8/chython/algorithms/standardize/molecule.py
+-rw-rw-rw-   0        0        0    18949 2021-10-11 09:21:45.299426 chython-1.8/chython/algorithms/standardize/reaction.py
+-rw-rw-rw-   0        0        0     6851 2021-11-09 13:12:25.581393 chython-1.8/chython/algorithms/standardize/resonance.py
+-rw-rw-rw-   0        0        0    16017 2021-11-10 13:40:22.321112 chython-1.8/chython/algorithms/standardize/saturation.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.254189 chython-1.8/chython/algorithms/stereo/
+-rw-rw-rw-   0        0        0      892 2021-10-01 15:03:36.188608 chython-1.8/chython/algorithms/stereo/__init__.py
+-rw-rw-rw-   0        0        0    16935 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/stereo/graph.py
+-rw-rw-rw-   0        0        0    30479 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/stereo/molecule.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.259206 chython-1.8/chython/algorithms/tautomers/
+-rw-rw-rw-   0        0        0    24062 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/tautomers/__init__.py
+-rw-rw-rw-   0        0        0     2319 2021-10-01 15:03:36.204233 chython-1.8/chython/algorithms/tautomers/_acid.py
+-rw-rw-rw-   0        0        0     5639 2021-10-01 15:03:36.219858 chython-1.8/chython/algorithms/tautomers/_base.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.263189 chython-1.8/chython/algorithms/tautomers/test/
+-rw-rw-rw-   0        0        0      801 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/tautomers/test/__init__.py
+-rw-rw-rw-   0        0        0     3705 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/tautomers/test/test_tautomers.py
+-rw-rw-rw-   0        0        0    67036 2021-10-01 15:03:36.226363 chython-1.8/chython/algorithms/x3dom.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.274190 chython-1.8/chython/containers/
+-rw-rw-rw-   0        0        0      962 2021-10-01 15:03:36.226363 chython-1.8/chython/containers/__init__.py
+-rw-rw-rw-   0        0        0   841821 2021-11-06 12:09:30.148048 chython-1.8/chython/containers/_unpack.c
+-rw-rw-rw-   0        0        0     6572 2021-11-06 12:09:19.720644 chython-1.8/chython/containers/_unpack.pyx
+-rw-rw-rw-   0        0        0     6306 2021-10-01 15:03:36.241998 chython-1.8/chython/containers/bonds.py
+-rw-rw-rw-   0        0        0     7279 2021-10-11 09:30:21.431589 chython-1.8/chython/containers/cgr.py
+-rw-rw-rw-   0        0        0     8112 2021-10-01 15:03:36.241998 chython-1.8/chython/containers/graph.py
+-rw-rw-rw-   0        0        0    46832 2021-11-09 10:50:29.382138 chython-1.8/chython/containers/molecule.py
+-rw-rw-rw-   0        0        0    23441 2021-10-21 13:10:51.313065 chython-1.8/chython/containers/query.py
+-rw-rw-rw-   0        0        0    10122 2021-11-06 12:09:19.658135 chython-1.8/chython/containers/reaction.py
+-rw-rw-rw-   0        0        0     1794 2021-10-01 15:03:36.257623 chython-1.8/chython/exceptions.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.286191 chython-1.8/chython/files/
+-rw-rw-rw-   0        0        0    28760 2021-10-01 15:03:36.691780 chython-1.8/chython/files/INCHIrw.py
+-rw-rw-rw-   0        0        0    19149 2021-10-01 15:03:36.691780 chython-1.8/chython/files/MRVrw.py
+-rw-rw-rw-   0        0        0     9982 2021-10-01 15:03:36.706614 chython-1.8/chython/files/PDBrw.py
+-rw-rw-rw-   0        0        0    15072 2021-10-01 15:03:36.706614 chython-1.8/chython/files/RDFrw.py
+-rw-rw-rw-   0        0        0    12214 2021-10-01 15:03:36.706614 chython-1.8/chython/files/SDFrw.py
+-rw-rw-rw-   0        0        0    36198 2021-10-01 15:03:36.722209 chython-1.8/chython/files/SMILESrw.py
+-rw-rw-rw-   0        0        0    10227 2021-10-01 15:03:36.737557 chython-1.8/chython/files/XYZrw.py
+-rw-rw-rw-   0        0        0     1093 2021-10-21 13:10:51.322075 chython-1.8/chython/files/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.300191 chython-1.8/chython/files/_mdl/
+-rw-rw-rw-   0        0        0     1090 2021-10-01 15:03:36.737557 chython-1.8/chython/files/_mdl/__init__.py
+-rw-rw-rw-   0        0        0     2192 2021-10-01 15:03:36.737557 chython-1.8/chython/files/_mdl/_write.py
+-rw-rw-rw-   0        0        0     9399 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/emol.py
+-rw-rw-rw-   0        0        0     3893 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/erxn.py
+-rw-rw-rw-   0        0        0     3556 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/ewrite.py
+-rw-rw-rw-   0        0        0     7672 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/mol.py
+-rw-rw-rw-   0        0        0     8066 2021-10-01 15:03:36.753193 chython-1.8/chython/files/_mdl/parser.py
+-rw-rw-rw-   0        0        0     7260 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/read.py
+-rw-rw-rw-   0        0        0     3830 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/rxn.py
+-rw-rw-rw-   0        0        0     3185 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/stereo.py
+-rw-rw-rw-   0        0        0     4847 2021-10-01 15:03:36.768863 chython-1.8/chython/files/_mdl/write.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.302191 chython-1.8/chython/files/test/
+-rw-rw-rw-   0        0        0      801 2021-10-01 15:03:36.784485 chython-1.8/chython/files/test/__init__.py
+-rw-rw-rw-   0        0        0     2958 2021-10-01 15:03:36.784485 chython-1.8/chython/files/test/test_smilesrw.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.331193 chython-1.8/chython/periodictable/
+-rw-rw-rw-   0        0        0     2350 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/__init__.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.338193 chython-1.8/chython/periodictable/element/
+-rw-rw-rw-   0        0        0     1130 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/__init__.py
+-rw-rw-rw-   0        0        0     3899 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/core.py
+-rw-rw-rw-   0        0        0     3696 2021-10-01 15:03:36.784485 chython-1.8/chython/periodictable/element/dynamic.py
+-rw-rw-rw-   0        0        0    12481 2021-11-09 09:30:23.683866 chython-1.8/chython/periodictable/element/element.py
+-rw-rw-rw-   0        0        0    14928 2021-10-21 13:10:51.330267 chython-1.8/chython/periodictable/element/query.py
+-rw-rw-rw-   0        0        0     4918 2021-10-01 15:03:36.800069 chython-1.8/chython/periodictable/groupI.py
+-rw-rw-rw-   0        0        0     5081 2021-10-21 13:10:51.339246 chython-1.8/chython/periodictable/groupII.py
+-rw-rw-rw-   0        0        0    26418 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIII.py
+-rw-rw-rw-   0        0        0     7031 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIV.py
+-rw-rw-rw-   0        0        0     6723 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupIX.py
+-rw-rw-rw-   0        0        0     5746 2021-10-01 15:03:36.815694 chython-1.8/chython/periodictable/groupV.py
+-rw-rw-rw-   0        0        0     5516 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVI.py
+-rw-rw-rw-   0        0        0     3897 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVII.py
+-rw-rw-rw-   0        0        0     4054 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupVIII.py
+-rw-rw-rw-   0        0        0     4625 2021-10-01 15:03:36.828767 chython-1.8/chython/periodictable/groupX.py
+-rw-rw-rw-   0        0        0     4094 2021-10-21 13:10:51.347937 chython-1.8/chython/periodictable/groupXI.py
+-rw-rw-rw-   0        0        0     4801 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXII.py
+-rw-rw-rw-   0        0        0     5481 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXIII.py
+-rw-rw-rw-   0        0        0     6025 2021-10-01 15:03:36.844445 chython-1.8/chython/periodictable/groupXIV.py
+-rw-rw-rw-   0        0        0     5584 2021-11-06 16:24:23.470725 chython-1.8/chython/periodictable/groupXV.py
+-rw-rw-rw-   0        0        0    14740 2021-10-21 13:10:51.363938 chython-1.8/chython/periodictable/groupXVI.py
+-rw-rw-rw-   0        0        0     8800 2021-10-21 13:10:51.373354 chython-1.8/chython/periodictable/groupXVII.py
+-rw-rw-rw-   0        0        0     6027 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/groupXVIII.py
+-rw-rw-rw-   0        0        0     1537 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/groups.py
+-rw-rw-rw-   0        0        0     1093 2021-10-01 15:03:36.860036 chython-1.8/chython/periodictable/periods.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.345193 chython-1.8/chython/reactor/
+-rw-rw-rw-   0        0        0      911 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/__init__.py
+-rw-rw-rw-   0        0        0     8568 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/base.py
+-rw-rw-rw-   0        0        0     8392 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/reactor.py
+-rw-rw-rw-   0        0        0     2469 2021-10-01 15:03:36.875654 chython-1.8/chython/reactor/transformer.py
+drwxrwxrwx   0        0        0        0 2021-11-12 15:45:40.350194 chython-1.8/chython/utils/
+-rw-rw-rw-   0        0        0     1097 2021-10-01 15:03:36.875654 chython-1.8/chython/utils/__init__.py
+-rw-rw-rw-   0        0        0     1810 2021-10-01 15:03:36.875654 chython-1.8/chython/utils/functional_groups.py
+-rw-rw-rw-   0        0        0     2844 2021-10-01 15:03:36.891319 chython-1.8/chython/utils/grid.py
+-rw-rw-rw-   0        0        0     6071 2021-10-01 15:03:36.891319 chython-1.8/chython/utils/rdkit.py
+-rw-rw-rw-   0        0        0     4631 2021-11-09 09:58:26.156698 chython-1.8/setup.py
```

### Comparing `chython-1.67/INCHI/libinchi.dll` & `chython-1.8/INCHI/libinchi.dll`

 * *Files identical despite different names*

### Comparing `chython-1.67/INCHI/libinchi.dynlib` & `chython-1.8/INCHI/libinchi.dynlib`

 * *Files identical despite different names*

### Comparing `chython-1.67/INCHI/libinchi.so` & `chython-1.8/INCHI/libinchi.so`

 * *Files identical despite different names*

### Comparing `chython-1.67/PKG-INFO` & `chython-1.8/PKG-INFO`

 * *Files 25% similar despite different names*

```diff
@@ -1,82 +1,92 @@
-Metadata-Version: 2.1
-Name: chython
-Version: 1.67
-Summary: UNKNOWN
-Home-page: https://github.com/chython/chython
-Author: Dr. Ramil Nugmanov
-Author-email: nougmanoff@protonmail.com
-License: LGPLv3
-Description: Chython [ˈkʌɪθ(ə)n]
-        ===================
-        
-        Library for processing molecules and reactions in python way.
-        
-        Features:
-           - Read/write/convert formats: MDL .RDF (.RXN) and .SDF (.MOL), .MRV, SMILES, INCHI (inchi-trust library), .XYZ, .PDB
-           - Standardize molecules and reactions and valid structures checker
-           - Supported python-magic
-           - Tetrahedron, Allene and CIS-TRANS stereo supported
-           - Perform subgraph search
-           - Build/edit molecules and reactions with Python API
-           - Produce template based reactions and molecules
-           - Atom-to-atom mapping, checking and rule-based fixing
-           - Perform MCS search
-           - 2d coordinates generation (based on `SmilesDrawer <https://github.com/reymond-group/smilesDrawer>`_)
-           - 2d/3d depiction with Jupyter support
-           - SMARTS parser with restrictions
-           - Protective groups remover
-           - Common reaction templates collection
-        
-        Full documentation can be found `here <https://chython.readthedocs.io>`_.
-        
-        Chython is fork of `CGRtools <https://github.com/stsouko/CGRtools>`_.
-        
-        Install
-        =======
-        
-        Only python 3.8+.
-        
-        Note: for using `clean2d` install NodeJS into system.
-        
-        * **stable version available through PyPI**::
-        
-            pip install chython
-        
-        * Install chython library DEV version for features that are not well tested::
-        
-            pip install -U git+https://github.com/chython/chython.git@master#egg=chython
-        
-        Copyright
-        =========
-        
-        * 2014-2023 Ramil Nugmanov nougmanoff@protonmail.com main developer
-        
-        Contributors
-        ============
-        
-        * Adelia Fatykhova adelik21979@gmail.com
-        * Aleksandr Sizov murkyrussian@gmail.com
-        * Dinar Batyrshin batyrshin-dinar@mail.ru
-        * Dmitrij Zanadvornykh zandmitrij@gmail.com
-        * Ravil Mukhametgaleev sonic-mc@mail.ru
-        * Tagir Akhmetshin tagirshin@gmail.com
-        * Timur Gimadiev timur.gimadiev@gmail.com
-        * Zarina Ibragimova
-        
-Platform: UNKNOWN
-Classifier: Environment :: Plugins
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Chemistry
-Classifier: Topic :: Scientific/Engineering :: Information Analysis
-Classifier: Topic :: Software Development
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Requires-Python: >=3.8
-Provides-Extra: pytest
-Provides-Extra: mapping
+Metadata-Version: 2.1
+Name: chython
+Version: 1.8
+Summary: UNKNOWN
+Home-page: https://github.com/chython/chython
+Author: Dr. Ramil Nugmanov
+Author-email: nougmanoff@protonmail.com
+License: LGPLv3
+Platform: UNKNOWN
+Classifier: Environment :: Plugins
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Chemistry
+Classifier: Topic :: Scientific/Engineering :: Information Analysis
+Classifier: Topic :: Software Development
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Requires-Python: >=3.8
+Provides-Extra: pytest
+License-File: LICENSE
+
+Chython [ˈkʌɪθ(ə)n]
+===================
+
+Library for processing molecules and reactions in python way.
+
+Features:
+   - Read/write/convert formats: MDL .RDF (.RXN) and .SDF (.MOL), .MRV, SMILES, INCHI (inchi-trust library), .XYZ, .PDB
+   - Standardize molecules and reactions and valid structures checker
+   - Supported python-magic
+   - Tetrahedron, Allene and CIS-TRANS stereo supporting
+   - Perform subgraph search
+   - Build/edit molecules and reactions
+   - Produce template based reactions and molecules
+   - Atom-to-atom mapping checker and rule-based fixer
+   - Perform MCS search
+   - 2d coordinates generation (based on `SmilesDrawer <https://github.com/reymond-group/smilesDrawer>`_)
+   - 2d/3d depiction
+   - Produce CGRs (Condensed Graph of Reaction)
+
+Full documentation can be found `here <https://chython.readthedocs.io>`_.
+
+Chython is fork of `CGRtools <https://github.com/stsouko/CGRtools>`_.
+
+
+INSTALL
+=======
+
+Only python 3.8+.
+
+Note: for using `clean2d` install NodeJS into system.
+
+* **stable version available through PyPI**::
+
+    pip install chython
+
+* Install chython library DEV version for features that are not well tested::
+
+    pip install -U git+https://github.com/chython/chython.git@master#egg=chython
+
+TESTS
+=====
+
+Run unit tests::
+
+    git clone https://github.com/chython/chython.git && cd chython  # skip if already got sources
+    pip install -e .
+    pytest --pyargs chython
+
+COPYRIGHT
+=========
+
+* 2014-2021 Ramil Nugmanov nougmanoff@protonmail.com main developer
+
+CONTRIBUTORS
+============
+
+* Adelia Fatykhova adelik21979@gmail.com
+* Aleksandr Sizov murkyrussian@gmail.com
+* Dinar Batyrshin batyrshin-dinar@mail.ru
+* Dmitrij Zanadvornykh zandmitrij@gmail.com
+* Ravil Mukhametgaleev sonic-mc@mail.ru
+* Tagir Akhmetshin tagirshin@gmail.com
+* Timur Gimadiev timur.gimadiev@gmail.com
+* Zarina Ibragimova
+
+
```

### Comparing `chython-1.67/chython/__init__.py` & `chython-1.8/chython/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,31 +1,38 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2014-2019 Timur Madzhidov tmadzhidov@gmail.com features and API discussion
-#  Copyright 2014-2019 Alexandre Varnek <varnek@unistra.fr> base idea of CGR approach
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .algorithms.depict import depict_settings
-from .containers import *
-from .files import *
-from .reactor import *
-from .utils import *
-
-
-pickle_cache = False  # store cached attributes in pickle
-torch_device = 'cpu'  # AAM model device. Change before first `reset_mapping` call!
-
-__all__ = []
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2014-2019 Timur Madzhidov tmadzhidov@gmail.com features and API discussion
+#  Copyright 2014-2019 Alexandre Varnek <varnek@unistra.fr> base idea of CGR approach
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .containers import *
+from .files import *
+from .reactor import *
+from .utils import *
+
+
+smiles = SMILESRead.create_parser(ignore=True, remap=False)
+xyz = XYZRead.create_parser()
+
+
+pickle_cache = False  # store cached attributes in pickle
+
+
+__all__ = ['smiles', 'xyz', 'mdl_mol']
+
+if 'INCHIRead' in locals():
+    inchi = INCHIRead.create_parser()
+    __all__.append('inchi')
```

### Comparing `chython-1.67/chython/_functions.py` & `chython-1.8/chython/_functions.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,69 +1,69 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from itertools import product
-
-
-# lazy itertools.product with diagonal combination precedence
-def lazy_product(*args):
-    if len(args) == 1:
-        for x in args[0]:
-            yield x,
-    elif not args:
-        yield ()
-    else:
-        gens = [iter(x) for x in args]
-        empty = [False] * len(args)
-        pools = [[] for _ in range(len(args))]
-        indices = set()
-
-        reached = 0
-        while True:
-            out = []
-            ind = []
-            for n, (p, g, e) in enumerate(zip(pools, gens, empty)):
-                if e:
-                    out.append(p[-1])
-                else:
-                    try:
-                        x = next(g)
-                    except StopIteration:
-                        if not p:  # one of gens empty
-                            return
-                        reached += 1
-                        if reached == len(args):
-                            break
-                        out.append(p[-1])
-                        empty[n] = True
-                    else:
-                        p.append(x)
-                        out.append(x)
-                ind.append(len(p) - 1)
-            else:
-                yield tuple(out)
-                indices.add(tuple(ind))
-                continue
-            break
-
-        for ind in product(*(range(len(p)) for p in pools)):
-            if ind in indices:
-                continue
-            yield tuple(p[x] for x, p in zip(ind, pools))
-
-
-__all__ = ['lazy_product']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from itertools import product
+
+
+# lazy itertools.product with diagonal combination precedence
+def lazy_product(*args):
+    if len(args) == 1:
+        for x in args[0]:
+            yield x,
+    elif not args:
+        yield ()
+    else:
+        gens = [iter(x) for x in args]
+        empty = [False] * len(args)
+        pools = [[] for _ in range(len(args))]
+        indices = set()
+
+        reached = 0
+        while True:
+            out = []
+            ind = []
+            for n, (p, g, e) in enumerate(zip(pools, gens, empty)):
+                if e:
+                    out.append(p[-1])
+                else:
+                    try:
+                        x = next(g)
+                    except StopIteration:
+                        if not p:  # one of gens empty
+                            return
+                        reached += 1
+                        if reached == len(args):
+                            break
+                        out.append(p[-1])
+                        empty[n] = True
+                    else:
+                        p.append(x)
+                        out.append(x)
+                ind.append(len(p) - 1)
+            else:
+                yield tuple(out)
+                indices.add(tuple(ind))
+                continue
+            break
+
+        for ind in product(*(range(len(p)) for p in pools)):
+            if ind in indices:
+                continue
+            yield tuple(p[x] for x, p in zip(ind, pools))
+
+
+__all__ = ['lazy_product']
```

### Comparing `chython-1.67/chython/algorithms/__init__.py` & `chython-1.8/chython/algorithms/tautomers/test/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.67/chython/algorithms/_isomorphism.c` & `chython-1.8/chython/containers/_unpack.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,54 +1,42 @@
-/* Generated by Cython 3.0.0 */
+/* Generated by Cython 0.29.24 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-O3"
         ],
-        "name": "chython.algorithms._isomorphism",
+        "name": "chython.containers._unpack",
         "sources": [
-            "chython/algorithms/_isomorphism.pyx"
+            "chython/containers/_unpack.pyx"
         ]
     },
-    "module_name": "chython.algorithms._isomorphism"
+    "module_name": "chython.containers._unpack"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
-#if defined(CYTHON_LIMITED_API) && 0
-  #ifndef Py_LIMITED_API
-    #if CYTHON_LIMITED_API+0 > 0x03030000
-      #define Py_LIMITED_API CYTHON_LIMITED_API
-    #else
-      #define Py_LIMITED_API 0x03030000
-    #endif
-  #endif
-#endif
-
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02070000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
-    #error Cython requires Python 2.7+ or Python 3.3+.
+#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
+    #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "3_0_0"
-#define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
-#define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030000F0
+#define CYTHON_ABI "0_29_24"
+#define CYTHON_HEX_VERSION 0x001D18F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
-#if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
+#if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
@@ -59,90 +47,30 @@
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
 #define __PYX_COMMA ,
 #ifndef HAVE_LONG_LONG
-  #define HAVE_LONG_LONG
+  #if PY_VERSION_HEX >= 0x02070000
+    #define HAVE_LONG_LONG
+  #endif
 #endif
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
-#if defined(GRAALVM_PYTHON)
-  /* For very preliminary testing purposes. Most variables are set the same as PyPy.
-     The existence of this section does not imply that anything works or is even tested */
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 0
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 0
-  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #undef CYTHON_AVOID_BORROWED_REFS
-  #define CYTHON_AVOID_BORROWED_REFS 1
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PYPY_VERSION)
+#ifdef PYPY_VERSION
   #define CYTHON_COMPILING_IN_PYPY 1
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 0
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
@@ -159,111 +87,35 @@
   #define CYTHON_AVOID_BORROWED_REFS 1
   #undef CYTHON_ASSUME_SAFE_MACROS
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #if PY_VERSION_HEX < 0x03090000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(CYTHON_LIMITED_API)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 1
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_CLINE_IN_TRACEBACK
-  #define CYTHON_CLINE_IN_TRACEBACK 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 1
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #undef CYTHON_USE_ASYNC_SLOTS
-  #define CYTHON_USE_ASYNC_SLOTS 0
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_WRITER
-    #define CYTHON_USE_UNICODE_WRITER 0
-  #endif
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
-  #endif
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 1
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PY_NOGIL)
+#elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
+  #undef CYTHON_USE_ASYNC_SLOTS
+  #define CYTHON_USE_ASYNC_SLOTS 0
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
@@ -278,55 +130,54 @@
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
+  #undef CYTHON_PEP489_MULTI_PHASE_INIT
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_TYPE_SPECS
-    #define CYTHON_USE_TYPE_SPECS 0
-  #endif
-  #ifndef CYTHON_USE_PYTYPE_LOOKUP
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYTYPE_LOOKUP
+    #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
     #define CYTHON_USE_PYTYPE_LOOKUP 1
   #endif
   #if PY_MAJOR_VERSION < 3
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_PYLONG_INTERNALS
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
     #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
-  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
+  #if PY_VERSION_HEX < 0x030300F0
     #undef CYTHON_USE_UNICODE_WRITER
     #define CYTHON_USE_UNICODE_WRITER 0
   #elif !defined(CYTHON_USE_UNICODE_WRITER)
     #define CYTHON_USE_UNICODE_WRITER 1
   #endif
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
@@ -336,68 +187,35 @@
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
-  #ifndef CYTHON_FAST_GIL
-    #define CYTHON_FAST_GIL (PY_MAJOR_VERSION < 3 || PY_VERSION_HEX >= 0x03060000 && PY_VERSION_HEX < 0x030C00A6)
-  #endif
-  #ifndef CYTHON_METH_FASTCALL
-    #define CYTHON_METH_FASTCALL (PY_VERSION_HEX >= 0x030700A1)
-  #endif
   #ifndef CYTHON_FAST_PYCALL
     #define CYTHON_FAST_PYCALL 1
   #endif
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_MODULE_STATE
-    #define CYTHON_USE_MODULE_STATE 0
-  #endif
-  #if PY_VERSION_HEX < 0x030400a1
-    #undef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 0
-  #elif !defined(CYTHON_USE_TP_FINALIZE)
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #if PY_VERSION_HEX < 0x030600B1
-    #undef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS 0
-  #elif !defined(CYTHON_USE_DICT_VERSIONS)
-    #define CYTHON_USE_DICT_VERSIONS  (PY_VERSION_HEX < 0x030C00A5)
-  #endif
-  #if PY_VERSION_HEX < 0x030700A3
-    #undef CYTHON_USE_EXC_INFO_STACK
-    #define CYTHON_USE_EXC_INFO_STACK 0
-  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
-    #define CYTHON_USE_EXC_INFO_STACK 1
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #ifndef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+  #endif
+  #ifndef CYTHON_USE_EXC_INFO_STACK
+    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
-#if !defined(CYTHON_VECTORCALL)
-#define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
-#endif
-#define CYTHON_BACKPORT_VECTORCALL (CYTHON_METH_FASTCALL && PY_VERSION_HEX < 0x030800B1)
 #if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_MAJOR_VERSION < 3
-    #include "longintrepr.h"
-  #endif
+  #include "longintrepr.h"
   #undef SHIFT
   #undef BASE
   #undef MASK
   #ifdef SIZEOF_VOID_P
     enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
   #endif
 #endif
@@ -415,128 +233,78 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_RESTRICT restrict
   #else
     #define CYTHON_RESTRICT
   #endif
 #endif
 #ifndef CYTHON_UNUSED
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(maybe_unused) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(maybe_unused)
-        #define CYTHON_UNUSED [[maybe_unused]]
-      #endif
-    #endif
-  #endif
-#endif
-#ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
 # elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-#ifndef CYTHON_UNUSED_VAR
+#ifndef CYTHON_MAYBE_UNUSED_VAR
 #  if defined(__cplusplus)
-     template<class T> void CYTHON_UNUSED_VAR( const T& ) { }
+     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
 #  else
-#    define CYTHON_UNUSED_VAR(x) (void)(x)
+#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
 #  endif
 #endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
-  #define CYTHON_MAYBE_UNUSED_VAR(x) CYTHON_UNUSED_VAR(x)
-#endif
 #ifndef CYTHON_NCP_UNUSED
 # if CYTHON_COMPILING_IN_CPYTHON
 #  define CYTHON_NCP_UNUSED
 # else
 #  define CYTHON_NCP_UNUSED CYTHON_UNUSED
 # endif
 #endif
 #define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
 #ifdef _MSC_VER
     #ifndef _MSC_STDINT_H_
         #if _MSC_VER < 1300
-            typedef unsigned char     uint8_t;
-            typedef unsigned short    uint16_t;
-            typedef unsigned int      uint32_t;
-        #else
-            typedef unsigned __int8   uint8_t;
-            typedef unsigned __int16  uint16_t;
-            typedef unsigned __int32  uint32_t;
-        #endif
-    #endif
-    #if _MSC_VER < 1300
-        #ifdef _WIN64
-            typedef unsigned long long  __pyx_uintptr_t;
-        #else
-            typedef unsigned int        __pyx_uintptr_t;
-        #endif
-    #else
-        #ifdef _WIN64
-            typedef unsigned __int64    __pyx_uintptr_t;
+           typedef unsigned char     uint8_t;
+           typedef unsigned int      uint32_t;
         #else
-            typedef unsigned __int32    __pyx_uintptr_t;
+           typedef unsigned __int8   uint8_t;
+           typedef unsigned __int32  uint32_t;
         #endif
     #endif
 #else
-    #include <stdint.h>
-    typedef uintptr_t  __pyx_uintptr_t;
+   #include <stdint.h>
 #endif
 #ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(fallthrough) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(fallthrough)
-        #define CYTHON_FALLTHROUGH [[fallthrough]]
-      #endif
-    #endif
-    #ifndef CYTHON_FALLTHROUGH
-      #if __has_cpp_attribute(clang::fallthrough)
-        #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-      #elif __has_cpp_attribute(gnu::fallthrough)
-        #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
-      #endif
+  #if defined(__cplusplus) && __cplusplus >= 201103L
+    #if __has_cpp_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH [[fallthrough]]
+    #elif __has_cpp_attribute(clang::fallthrough)
+      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+    #elif __has_cpp_attribute(gnu::fallthrough)
+      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
     #endif
   #endif
   #ifndef CYTHON_FALLTHROUGH
     #if __has_attribute(fallthrough)
       #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
     #else
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
-  #if defined(__clang__) && defined(__apple_build_version__)
+  #if defined(__clang__ ) && defined(__apple_build_version__)
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
-#ifdef __cplusplus
-  template <typename T>
-  struct __PYX_IS_UNSIGNED_IMPL {static const bool value = T(0) < T(-1);};
-  #define __PYX_IS_UNSIGNED(type) (__PYX_IS_UNSIGNED_IMPL<type>::value)
-#else
-  #define __PYX_IS_UNSIGNED(type) (((type)-1) > 0)
-#endif
-#if CYTHON_COMPILING_IN_PYPY == 1
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x030A0000)
-#else
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000)
-#endif
-#define __PYX_REINTERPRET_FUNCION(func_pointer, other_pointer) ((func_pointer)(void(*)(void))(other_pointer))
 
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
   #elif defined(__GNUC__)
     #define CYTHON_INLINE __inline__
   #elif defined(_MSC_VER)
@@ -544,225 +312,93 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
   #else
     #define CYTHON_INLINE
   #endif
 #endif
 
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define Py_OptimizeFlag 0
+#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_DefaultClassType PyClass_Type
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+  #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject *co=NULL, *result=NULL;
-        PyObject *type, *value, *traceback;
-        PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(p))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto end;
-        if (!(empty = PyTuple_New(0))) goto end;
-        result = (PyCodeObject*) PyObject_Call(replace, empty, kwds);
-    end:
-        Py_XDECREF((PyObject*) co);
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(empty);
-        if (type) {
-            PyErr_Restore(type, value, traceback);
-        }
-        return result;
-    }
-#elif PY_VERSION_HEX >= 0x030800B2 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_NewWithPosOnlyArgs(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
-#endif
-#if PY_VERSION_HEX >= 0x030900A4 || defined(Py_IS_TYPE)
-  #define __Pyx_IS_TYPE(ob, type) Py_IS_TYPE(ob, type)
-#else
-  #define __Pyx_IS_TYPE(ob, type) (((const PyObject*)ob)->ob_type == (type))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_Is)
-  #define __Pyx_Py_Is(x, y)  Py_Is(x, y)
-#else
-  #define __Pyx_Py_Is(x, y) ((x) == (y))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsNone)
-  #define __Pyx_Py_IsNone(ob) Py_IsNone(ob)
-#else
-  #define __Pyx_Py_IsNone(ob) __Pyx_Py_Is((ob), Py_None)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsTrue)
-  #define __Pyx_Py_IsTrue(ob) Py_IsTrue(ob)
-#else
-  #define __Pyx_Py_IsTrue(ob) __Pyx_Py_Is((ob), Py_True)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsFalse)
-  #define __Pyx_Py_IsFalse(ob) Py_IsFalse(ob)
-#else
-  #define __Pyx_Py_IsFalse(ob) __Pyx_Py_Is((ob), Py_False)
-#endif
-#define __Pyx_NoneAsNull(obj)  (__Pyx_Py_IsNone(obj) ? NULL : (obj))
-#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
-#else
-  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
-#endif
-#ifndef CO_COROUTINE
-  #define CO_COROUTINE 0x80
-#endif
-#ifndef CO_ASYNC_GENERATOR
-  #define CO_ASYNC_GENERATOR 0x200
+  #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_FINALIZE
   #define Py_TPFLAGS_HAVE_FINALIZE 0
 #endif
-#ifndef Py_TPFLAGS_SEQUENCE
-  #define Py_TPFLAGS_SEQUENCE 0
-#endif
-#ifndef Py_TPFLAGS_MAPPING
-  #define Py_TPFLAGS_MAPPING 0
-#endif
 #ifndef METH_STACKLESS
   #define METH_STACKLESS 0
 #endif
 #if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
   #define __Pyx_PyCFunctionFast _PyCFunctionFast
   #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
 #endif
-#if CYTHON_METH_FASTCALL
-  #define __Pyx_METH_FASTCALL METH_FASTCALL
-  #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
-  #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
-#else
-  #define __Pyx_METH_FASTCALL METH_VARARGS
-  #define __Pyx_PyCFunction_FastCall PyCFunction
-  #define __Pyx_PyCFunction_FastCallWithKeywords PyCFunctionWithKeywords
-#endif
-#if CYTHON_VECTORCALL
-  #define __pyx_vectorcallfunc vectorcallfunc
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  PY_VECTORCALL_ARGUMENTS_OFFSET
-  #define __Pyx_PyVectorcall_NARGS(n)  PyVectorcall_NARGS((size_t)(n))
-#elif CYTHON_BACKPORT_VECTORCALL
-  typedef PyObject *(*__pyx_vectorcallfunc)(PyObject *callable, PyObject *const *args,
-                                            size_t nargsf, PyObject *kwnames);
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  ((size_t)1 << (8 * sizeof(size_t) - 1))
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(((size_t)(n)) & ~__Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET))
-#else
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  0
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(n))
-#endif
-#if PY_VERSION_HEX < 0x030900B1
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  ((void)m, PyType_FromSpecWithBases(s, b))
-  typedef PyObject *(*__Pyx_PyCMethod)(PyObject *, PyTypeObject *, PyObject *const *, size_t, PyObject *);
+#if CYTHON_FAST_PYCCALL
+#define __Pyx_PyFastCFunction_Check(func)\
+    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
 #else
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  PyType_FromModuleAndSpec(m, s, b)
-  #define __Pyx_PyCMethod  PyCMethod
-#endif
-#ifndef METH_METHOD
-  #define METH_METHOD 0x200
+#define __Pyx_PyFastCFunction_Check(func) 0
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
   #define PyObject_Malloc(s)   PyMem_Malloc(s)
   #define PyObject_Free(p)     PyMem_Free(p)
   #define PyObject_Realloc(p)  PyMem_Realloc(p)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
+  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
+  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
+  #define PyMem_RawFree(p)             PyMem_Free(p)
+#endif
+#if CYTHON_COMPILING_IN_PYSTON
+  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
 #else
   #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
   #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyThreadState_Current PyThreadState_Get()
-#elif !CYTHON_FAST_THREAD_STATE
+#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #elif PY_VERSION_HEX >= 0x03060000
   #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
 #elif PY_VERSION_HEX >= 0x03000000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #else
   #define __Pyx_PyThreadState_Current _PyThreadState_Current
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE void *__Pyx_PyModule_GetState(PyObject *op)
-{
-    void *result;
-    result = PyModule_GetState(op);
-    if (!result)
-        Py_FatalError("Couldn't find the module state");
-    return result;
-}
-#endif
-#define __Pyx_PyObject_GetSlot(obj, name, func_ctype)  __Pyx_PyType_GetSlot(Py_TYPE(obj), name, func_ctype)
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((func_ctype) PyType_GetSlot((type), Py_##name))
-#else
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((type)->name)
-#endif
 #if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
 #include "pythread.h"
 #define Py_tss_NEEDS_INIT 0
 typedef int Py_tss_t;
 static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
   *key = PyThread_create_key();
   return 0;
@@ -785,166 +421,86 @@
 static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
   return PyThread_set_key_value(*key, value);
 }
 static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
   return PyThread_get_key_value(*key);
 }
 #endif
-#if PY_MAJOR_VERSION < 3
-    #if CYTHON_COMPILING_IN_PYPY
-        #if PYPY_VERSION_NUM < 0x07030600
-            #if defined(__cplusplus) && __cplusplus >= 201402L
-                [[deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")]]
-            #elif defined(__GNUC__) || defined(__clang__)
-                __attribute__ ((__deprecated__("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")))
-            #elif defined(_MSC_VER)
-                __declspec(deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6"))
-            #endif
-            static CYTHON_INLINE int PyGILState_Check(void) {
-                return 0;
-            }
-        #else  // PYPY_VERSION_NUM < 0x07030600
-        #endif  // PYPY_VERSION_NUM < 0x07030600
-    #else
-        static CYTHON_INLINE int PyGILState_Check(void) {
-            PyThreadState * tstate = _PyThreadState_Current;
-            return tstate && (tstate == PyGILState_GetThisThreadState());
-        }
-    #endif
-#endif
 #if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
 #define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
 #else
 #define __Pyx_PyDict_NewPresized(n)  PyDict_New()
 #endif
 #if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
 #else
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX > 0x030600B4 && CYTHON_USE_UNICODE_INTERNALS
-#define __Pyx_PyDict_GetItemStrWithError(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStr(PyObject *dict, PyObject *name) {
-    PyObject *res = __Pyx_PyDict_GetItemStrWithError(dict, name);
-    if (res == NULL) PyErr_Clear();
-    return res;
-}
-#elif PY_MAJOR_VERSION >= 3 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07020000)
-#define __Pyx_PyDict_GetItemStrWithError  PyDict_GetItemWithError
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#else
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStrWithError(PyObject *dict, PyObject *name) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyDict_GetItem(dict, name);
-#else
-    PyDictEntry *ep;
-    PyDictObject *mp = (PyDictObject*) dict;
-    long hash = ((PyStringObject *) name)->ob_shash;
-    assert(hash != -1);
-    ep = (mp->ma_lookup)(mp, name, hash);
-    if (ep == NULL) {
-        return NULL;
-    }
-    return ep->me_value;
-#endif
-}
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#endif
-#if CYTHON_USE_TYPE_SLOTS
-  #define __Pyx_PyType_GetFlags(tp)   (((PyTypeObject *)tp)->tp_flags)
-  #define __Pyx_PyType_HasFeature(type, feature)  ((__Pyx_PyType_GetFlags(type) & (feature)) != 0)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  (Py_TYPE(obj)->tp_iternext)
-#else
-  #define __Pyx_PyType_GetFlags(tp)   (PyType_GetFlags((PyTypeObject *)tp))
-  #define __Pyx_PyType_HasFeature(type, feature)  PyType_HasFeature(type, feature)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  PyIter_Next
-#endif
-#if CYTHON_USE_TYPE_SPECS && PY_VERSION_HEX >= 0x03080000
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  {\
-    PyTypeObject *type = Py_TYPE(obj);\
-    assert(__Pyx_PyType_HasFeature(type, Py_TPFLAGS_HEAPTYPE));\
-    PyObject_GC_Del(obj);\
-    Py_DECREF(type);\
-}
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
 #else
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  PyObject_GC_Del(obj)
+#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GetLength(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_ReadChar(u, i)
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((void)u, 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((void)u, (0))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)k, PyUnicode_ReadChar((PyObject*)(d), i))
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GetLength(u))
-#elif PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
-  #define CYTHON_PEP393_ENABLED 1
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_READY(op)       (0)
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
   #else
-    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                                0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_READY(op)       (0)
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)PyUnicode_KIND(u))
+  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, (Py_UCS4) ch)
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
   #else
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-    #else
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-    #endif
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535U : 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)sizeof(Py_UNICODE))
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
+  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
   #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
   #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = (Py_UNICODE) ch)
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
   #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
 #endif
 #if CYTHON_COMPILING_IN_PYPY
   #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
 #else
   #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
       PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
 #endif
-#if CYTHON_COMPILING_IN_PYPY
-  #if !defined(PyUnicode_DecodeUnicodeEscape)
-    #define PyUnicode_DecodeUnicodeEscape(s, size, errors)  PyUnicode_Decode(s, size, "unicode_escape", errors)
-  #endif
-  #if !defined(PyUnicode_Contains) || (PY_MAJOR_VERSION == 2 && PYPY_VERSION_NUM < 0x07030500)
-    #undef PyUnicode_Contains
-    #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
-  #endif
-  #if !defined(PyByteArray_Check)
-    #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
-  #endif
-  #if !defined(PyObject_Format)
-    #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
-  #endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
+  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
+  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
+  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
 #endif
 #define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
 #define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
 #else
   #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
@@ -965,22 +521,16 @@
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
   #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
 #else
   #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
   #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
-  #define __Pyx_PySequence_ListKeepNew(obj)\
-    (likely(PyList_CheckExact(obj) && Py_REFCNT(obj) == 1) ? __Pyx_NewRef(obj) : PySequence_List(obj))
-#else
-  #define __Pyx_PySequence_ListKeepNew(obj)  PySequence_List(obj)
-#endif
 #ifndef PySet_CheckExact
-  #define PySet_CheckExact(obj)        __Pyx_IS_TYPE(obj, &PySet_Type)
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
 #if PY_VERSION_HEX >= 0x030900A4
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
 #else
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
@@ -991,46 +541,46 @@
   #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
-  #define __Pyx_Py3Int_Check(op)       PyLong_Check(op)
-  #define __Pyx_Py3Int_CheckExact(op)  PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
   #define PyInt_FromLong               PyLong_FromLong
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
   #define PyNumber_Int                 PyNumber_Long
-#else
-  #define __Pyx_Py3Int_Check(op)       (PyLong_Check(op) || PyInt_Check(op))
-  #define __Pyx_Py3Int_CheckExact(op)  (PyLong_CheckExact(op) || PyInt_CheckExact(op))
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
 #if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
   #endif
 #endif
 #if PY_VERSION_HEX < 0x030200A4
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
+#else
+  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
 #if CYTHON_USE_ASYNC_SLOTS
   #if PY_VERSION_HEX >= 0x030500B1
     #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
     #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
   #else
     #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
@@ -1042,18 +592,16 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
+#if defined(WIN32) || defined(MS_WINDOWS)
+  #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -1068,37 +616,31 @@
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
     { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
-#ifdef CYTHON_EXTERN_C
-    #undef __PYX_EXTERN_C
-    #define __PYX_EXTERN_C CYTHON_EXTERN_C
-#elif defined(__PYX_EXTERN_C)
-    #ifdef _MSC_VER
-    #pragma message ("Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.")
-    #else
-    #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
-    #endif
-#else
+#ifndef __PYX_EXTERN_C
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__chython__algorithms___isomorphism
-#define __PYX_HAVE_API__chython__algorithms___isomorphism
+#define __PYX_HAVE__chython__containers___unpack
+#define __PYX_HAVE_API__chython__containers___unpack
 /* Early includes */
-#include <string.h>
+#include <math.h>
 #include "pythread.h"
+#include <string.h>
 #include <stdlib.h>
+#include <stdio.h>
+#include "pystate.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
@@ -1159,111 +701,54 @@
 #endif
 #define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyObject_AsWritableString(s)    ((char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
     const Py_UNICODE *u_end = u;
     while (*u_end++) ;
     return (size_t)(u_end - u - 1);
 }
-#endif
-#define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
 #define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
 #define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
 #else
 #define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
 #else
 #define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
 #endif
-#if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_VERSION_HEX >= 0x030C00A7
-  #ifndef _PyLong_SIGN_MASK
-    #define _PyLong_SIGN_MASK 3
-  #endif
-  #ifndef _PyLong_NON_SIZE_BITS
-    #define _PyLong_NON_SIZE_BITS 3
-  #endif
-  #define __Pyx_PyLong_Sign(x)  (((PyLongObject*)x)->long_value.lv_tag & _PyLong_SIGN_MASK)
-  #define __Pyx_PyLong_IsNeg(x)  ((__Pyx_PyLong_Sign(x) & 2) != 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (!__Pyx_PyLong_IsNeg(x))
-  #define __Pyx_PyLong_IsZero(x)  (__Pyx_PyLong_Sign(x) & 1)
-  #define __Pyx_PyLong_IsPos(x)  (__Pyx_PyLong_Sign(x) == 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  (__Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  ((Py_ssize_t) (((PyLongObject*)x)->long_value.lv_tag >> _PyLong_NON_SIZE_BITS))
-  #define __Pyx_PyLong_SignedDigitCount(x)\
-        ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * __Pyx_PyLong_DigitCount(x))
-  #if defined(PyUnstable_Long_IsCompact) && defined(PyUnstable_Long_CompactValue)
-    #define __Pyx_PyLong_IsCompact(x)     PyUnstable_Long_IsCompact((PyLongObject*) x)
-    #define __Pyx_PyLong_CompactValue(x)  PyUnstable_Long_CompactValue((PyLongObject*) x)
-  #else
-    #define __Pyx_PyLong_IsCompact(x)     (((PyLongObject*)x)->long_value.lv_tag < (2 << _PyLong_NON_SIZE_BITS))
-    #define __Pyx_PyLong_CompactValue(x)  ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * (Py_ssize_t) __Pyx_PyLong_Digits(x)[0])
-  #endif
-  typedef Py_ssize_t  __Pyx_compact_pylong;
-  typedef size_t  __Pyx_compact_upylong;
-  #else  // Py < 3.12
-  #define __Pyx_PyLong_IsNeg(x)  (Py_SIZE(x) < 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (Py_SIZE(x) >= 0)
-  #define __Pyx_PyLong_IsZero(x)  (Py_SIZE(x) == 0)
-  #define __Pyx_PyLong_IsPos(x)  (Py_SIZE(x) > 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  ((Py_SIZE(x) == 0) ? 0 : __Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  __Pyx_sst_abs(Py_SIZE(x))
-  #define __Pyx_PyLong_SignedDigitCount(x)  Py_SIZE(x)
-  #define __Pyx_PyLong_IsCompact(x)  (Py_SIZE(x) == 0 || Py_SIZE(x) == 1 || Py_SIZE(x) == -1)
-  #define __Pyx_PyLong_CompactValue(x)\
-        ((Py_SIZE(x) == 0) ? (sdigit) 0 : ((Py_SIZE(x) < 0) ? -(sdigit)__Pyx_PyLong_Digits(x)[0] : (sdigit)__Pyx_PyLong_Digits(x)[0]))
-  typedef sdigit  __Pyx_compact_pylong;
-  typedef digit  __Pyx_compact_upylong;
-  #endif
-  #if PY_VERSION_HEX >= 0x030C00A5
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->long_value.ob_digit)
-  #else
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->ob_digit)
-  #endif
-#endif
+#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
 static int __Pyx_sys_getdefaultencoding_not_ascii;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     PyObject* ascii_chars_u = NULL;
     PyObject* ascii_chars_b = NULL;
@@ -1277,15 +762,15 @@
     if (!default_encoding_c) goto bad;
     if (strcmp(default_encoding_c, "ascii") == 0) {
         __Pyx_sys_getdefaultencoding_not_ascii = 0;
     } else {
         char ascii_chars[128];
         int c;
         for (c = 0; c < 128; c++) {
-            ascii_chars[c] = (char) c;
+            ascii_chars[c] = c;
         }
         __Pyx_sys_getdefaultencoding_not_ascii = 1;
         ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
         if (!ascii_chars_u) goto bad;
         ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
         if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
             PyErr_Format(
@@ -1342,42 +827,105 @@
   #define unlikely(x) __builtin_expect(!!(x), 0)
 #else /* !__GNUC__ or GCC < 2.95 */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
 static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
 
-#if !CYTHON_USE_MODULE_STATE
 static PyObject *__pyx_m = NULL;
-#endif
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_cython_runtime = NULL;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static PyObject *__pyx_empty_unicode;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
-static const char * __pyx_cfilenm = __FILE__;
+static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
-/* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "chython/algorithms/_isomorphism.pyx",
-  "<stringsource>",
+  "chython\\containers\\_unpack.pyx",
+  "stringsource",
 };
-/* #### Code section: utility_code_proto_before_types ### */
+/* MemviewSliceStruct.proto */
+struct __pyx_memoryview_obj;
+typedef struct {
+  struct __pyx_memoryview_obj *memview;
+  char *data;
+  Py_ssize_t shape[8];
+  Py_ssize_t strides[8];
+  Py_ssize_t suboffsets[8];
+} __Pyx_memviewslice;
+#define __Pyx_MemoryView_Len(m)  (m.shape[0])
+
+/* Atomics.proto */
+#include <pythread.h>
+#ifndef CYTHON_ATOMICS
+    #define CYTHON_ATOMICS 1
+#endif
+#define __pyx_atomic_int_type int
+#if CYTHON_ATOMICS && __GNUC__ >= 4 && (__GNUC_MINOR__ > 1 ||\
+                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL >= 2)) &&\
+                    !defined(__i386__)
+    #define __pyx_atomic_incr_aligned(value, lock) __sync_fetch_and_add(value, 1)
+    #define __pyx_atomic_decr_aligned(value, lock) __sync_fetch_and_sub(value, 1)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using GNU atomics"
+    #endif
+#elif CYTHON_ATOMICS && defined(_MSC_VER) && 0
+    #include <Windows.h>
+    #undef __pyx_atomic_int_type
+    #define __pyx_atomic_int_type LONG
+    #define __pyx_atomic_incr_aligned(value, lock) InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #pragma message ("Using MSVC atomics")
+    #endif
+#elif CYTHON_ATOMICS && (defined(__ICC) || defined(__INTEL_COMPILER)) && 0
+    #define __pyx_atomic_incr_aligned(value, lock) _InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) _InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using Intel atomics"
+    #endif
+#else
+    #undef CYTHON_ATOMICS
+    #define CYTHON_ATOMICS 0
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Not using atomics"
+    #endif
+#endif
+typedef volatile __pyx_atomic_int_type __pyx_atomic_int;
+#if CYTHON_ATOMICS
+    #define __pyx_add_acquisition_count(memview)\
+             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
+    #define __pyx_sub_acquisition_count(memview)\
+            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
+#else
+    #define __pyx_add_acquisition_count(memview)\
+            __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
+    #define __pyx_sub_acquisition_count(memview)\
+            __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
+#endif
+
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
 #endif
 
 /* NoFastGil.proto */
 #define __Pyx_PyGILState_Ensure PyGILState_Ensure
 #define __Pyx_PyGILState_Release PyGILState_Release
 #define __Pyx_FastGIL_Remember()
 #define __Pyx_FastGIL_Forget()
 #define __Pyx_FastGilFuncInit()
 
 /* BufferFormatStructs.proto */
+#define IS_UNSIGNED(type) (((type) -1) > 0)
 struct __Pyx_StructField_;
 #define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
 typedef struct {
   const char* name;
   struct __Pyx_StructField_* fields;
   size_t size;
   size_t arraysize[8];
@@ -1404,180 +952,23 @@
   int is_complex;
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
-/* Atomics.proto */
-#include <pythread.h>
-#ifndef CYTHON_ATOMICS
-    #define CYTHON_ATOMICS 1
-#endif
-#define __PYX_CYTHON_ATOMICS_ENABLED() CYTHON_ATOMICS
-#define __pyx_atomic_int_type int
-#define __pyx_nonatomic_int_type int
-#if CYTHON_ATOMICS && (defined(__STDC_VERSION__) &&\
-                        (__STDC_VERSION__ >= 201112L) &&\
-                        !defined(__STDC_NO_ATOMICS__))
-    #include <stdatomic.h>
-#elif CYTHON_ATOMICS && (defined(__cplusplus) && (\
-                    (__cplusplus >= 201103L) ||\
-                    (defined(_MSC_VER) && _MSC_VER >= 1700)))
-    #include <atomic>
-#endif
-#if CYTHON_ATOMICS && (defined(__STDC_VERSION__) &&\
-                        (__STDC_VERSION__ >= 201112L) &&\
-                        !defined(__STDC_NO_ATOMICS__) &&\
-                       ATOMIC_INT_LOCK_FREE == 2)
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type atomic_int
-    #define __pyx_atomic_incr_aligned(value) atomic_fetch_add_explicit(value, 1, memory_order_relaxed)
-    #define __pyx_atomic_decr_aligned(value) atomic_fetch_sub_explicit(value, 1, memory_order_acq_rel)
-    #if defined(__PYX_DEBUG_ATOMICS) && defined(_MSC_VER)
-        #pragma message ("Using standard C atomics")
-    #elif defined(__PYX_DEBUG_ATOMICS)
-        #warning "Using standard C atomics"
-    #endif
-#elif CYTHON_ATOMICS && (defined(__cplusplus) && (\
-                    (__cplusplus >= 201103L) ||\
-\
-                    (defined(_MSC_VER) && _MSC_VER >= 1700)) &&\
-                    ATOMIC_INT_LOCK_FREE == 2)
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type std::atomic_int
-    #define __pyx_atomic_incr_aligned(value) std::atomic_fetch_add_explicit(value, 1, std::memory_order_relaxed)
-    #define __pyx_atomic_decr_aligned(value) std::atomic_fetch_sub_explicit(value, 1, std::memory_order_acq_rel)
-    #if defined(__PYX_DEBUG_ATOMICS) && defined(_MSC_VER)
-        #pragma message ("Using standard C++ atomics")
-    #elif defined(__PYX_DEBUG_ATOMICS)
-        #warning "Using standard C++ atomics"
-    #endif
-#elif CYTHON_ATOMICS && (__GNUC__ >= 5 || (__GNUC__ == 4 &&\
-                    (__GNUC_MINOR__ > 1 ||\
-                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ >= 2))))
-    #define __pyx_atomic_incr_aligned(value) __sync_fetch_and_add(value, 1)
-    #define __pyx_atomic_decr_aligned(value) __sync_fetch_and_sub(value, 1)
-    #ifdef __PYX_DEBUG_ATOMICS
-        #warning "Using GNU atomics"
-    #endif
-#elif CYTHON_ATOMICS && defined(_MSC_VER)
-    #include <intrin.h>
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type long
-    #define __pyx_nonatomic_int_type long
-    #pragma intrinsic (_InterlockedExchangeAdd)
-    #define __pyx_atomic_incr_aligned(value) _InterlockedExchangeAdd(value, 1)
-    #define __pyx_atomic_decr_aligned(value) _InterlockedExchangeAdd(value, -1)
-    #ifdef __PYX_DEBUG_ATOMICS
-        #pragma message ("Using MSVC atomics")
-    #endif
-#else
-    #undef CYTHON_ATOMICS
-    #define CYTHON_ATOMICS 0
-    #ifdef __PYX_DEBUG_ATOMICS
-        #warning "Not using atomics"
-    #endif
-#endif
-#if CYTHON_ATOMICS
-    #define __pyx_add_acquisition_count(memview)\
-             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview))
-    #define __pyx_sub_acquisition_count(memview)\
-            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview))
-#else
-    #define __pyx_add_acquisition_count(memview)\
-            __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
-    #define __pyx_sub_acquisition_count(memview)\
-            __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
-#endif
-
-/* MemviewSliceStruct.proto */
-struct __pyx_memoryview_obj;
-typedef struct {
-  struct __pyx_memoryview_obj *memview;
-  char *data;
-  Py_ssize_t shape[8];
-  Py_ssize_t strides[8];
-  Py_ssize_t suboffsets[8];
-} __Pyx_memviewslice;
-#define __Pyx_MemoryView_Len(m)  (m.shape[0])
-
-/* #### Code section: numeric_typedefs ### */
-/* #### Code section: complex_type_declarations ### */
-/* #### Code section: type_declarations ### */
 
 /*--- Type declarations ---*/
-struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "chython/algorithms/_isomorphism.pyx":28
+/* "View.MemoryView":105
  * 
- * 
- * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
- * @cython.wraparound(False)
- * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
- */
-struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping {
-  PyObject_HEAD
-  unsigned int __pyx_v_back;
-  unsigned PY_LONG_LONG __pyx_v_c_bond;
-  unsigned int __pyx_v_closures_counter;
-  unsigned int __pyx_v_closures_num;
-  unsigned int __pyx_v_depth;
-  unsigned int __pyx_v_front;
-  unsigned int __pyx_v_i;
-  unsigned int __pyx_v_j;
-  unsigned int __pyx_v_m;
-  PyObject *__pyx_v_mapping;
-  int *__pyx_v_matched;
-  unsigned int __pyx_v_n;
-  unsigned int __pyx_v_o;
-  __Pyx_memviewslice __pyx_v_o_bits1;
-  __Pyx_memviewslice __pyx_v_o_bits2;
-  __Pyx_memviewslice __pyx_v_o_bits3;
-  __Pyx_memviewslice __pyx_v_o_bits4;
-  unsigned PY_LONG_LONG __pyx_v_o_bond;
-  __Pyx_memviewslice __pyx_v_o_bonds;
-  unsigned PY_LONG_LONG *__pyx_v_o_closures;
-  __Pyx_memviewslice __pyx_v_o_from;
-  __Pyx_memviewslice __pyx_v_o_indices;
-  __Pyx_memviewslice __pyx_v_o_numbers;
-  unsigned int __pyx_v_o_size;
-  __Pyx_memviewslice __pyx_v_o_to;
-  unsigned int *__pyx_v_path;
-  unsigned int __pyx_v_path_size;
-  __Pyx_memviewslice __pyx_v_q_back;
-  __Pyx_memviewslice __pyx_v_q_bonds;
-  __Pyx_memviewslice __pyx_v_q_closures;
-  __Pyx_memviewslice __pyx_v_q_from;
-  __Pyx_memviewslice __pyx_v_q_indices;
-  unsigned PY_LONG_LONG __pyx_v_q_mask1;
-  unsigned PY_LONG_LONG __pyx_v_q_mask2;
-  unsigned PY_LONG_LONG __pyx_v_q_mask3;
-  unsigned PY_LONG_LONG __pyx_v_q_mask4;
-  __Pyx_memviewslice __pyx_v_q_masks1;
-  __Pyx_memviewslice __pyx_v_q_masks2;
-  __Pyx_memviewslice __pyx_v_q_masks3;
-  __Pyx_memviewslice __pyx_v_q_masks4;
-  __Pyx_memviewslice __pyx_v_q_numbers;
-  unsigned int __pyx_v_q_size;
-  unsigned int __pyx_v_q_size_dec;
-  __Pyx_memviewslice __pyx_v_q_to;
-  __Pyx_memviewslice __pyx_v_scope;
-  unsigned int __pyx_v_stack;
-  unsigned int *__pyx_v_stack_depth;
-  unsigned int *__pyx_v_stack_index;
-};
-
-
-/* "View.MemoryView":114
- * @cython.collection_type("sequence")
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 struct __pyx_array_obj {
   PyObject_HEAD
@@ -1593,51 +984,52 @@
   PyObject *_format;
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
-/* "View.MemoryView":302
+/* "View.MemoryView":279
  * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
-/* "View.MemoryView":337
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
- * cdef class memoryview:             # <<<<<<<<<<<<<<
+ * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
   PyObject_HEAD
   struct __pyx_vtabstruct_memoryview *__pyx_vtab;
   PyObject *obj;
   PyObject *_size;
   PyObject *_array_interface;
   PyThread_type_lock lock;
-  __pyx_atomic_int_type acquisition_count;
+  __pyx_atomic_int acquisition_count[2];
+  __pyx_atomic_int *acquisition_count_aligned_p;
   Py_buffer view;
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
-/* "View.MemoryView":952
- * @cython.collection_type("sequence")
+/* "View.MemoryView":965
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 struct __pyx_memoryviewslice_obj {
   struct __pyx_memoryview_obj __pyx_base;
@@ -1645,378 +1037,169 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "View.MemoryView":114
- * @cython.collection_type("sequence")
+/* "View.MemoryView":105
+ * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
-/* "View.MemoryView":337
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
- * cdef class memoryview:             # <<<<<<<<<<<<<<
+ * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 
 struct __pyx_vtabstruct_memoryview {
   char *(*get_item_pointer)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*is_slice)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*setitem_slice_assignment)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*setitem_slice_assign_scalar)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*setitem_indexed)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
-  PyObject *(*_get_base)(struct __pyx_memoryview_obj *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
-/* "View.MemoryView":952
- * @cython.collection_type("sequence")
+/* "View.MemoryView":965
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 
 struct __pyx_vtabstruct__memoryviewslice {
   struct __pyx_vtabstruct_memoryview __pyx_base;
 };
 static struct __pyx_vtabstruct__memoryviewslice *__pyx_vtabptr__memoryviewslice;
-/* #### Code section: utility_code_proto ### */
 
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
-    void (*INCREF)(void*, PyObject*, Py_ssize_t);
-    void (*DECREF)(void*, PyObject*, Py_ssize_t);
-    void (*GOTREF)(void*, PyObject*, Py_ssize_t);
-    void (*GIVEREF)(void*, PyObject*, Py_ssize_t);
-    void* (*SetupContext)(const char*, Py_ssize_t, const char*);
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
 #ifdef WITH_THREAD
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
           if (acquire_gil) {\
               PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
               PyGILState_Release(__pyx_gilstate_save);\
           } else {\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
-          }
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
           }
 #else
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__))
-  #define __Pyx_RefNannyFinishContextNogil() __Pyx_RefNannyFinishContext()
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
 #endif
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
-          }
   #define __Pyx_RefNannyFinishContext()\
           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
-  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_XINCREF(r)  do { if((r) == NULL); else {__Pyx_INCREF(r); }} while(0)
-  #define __Pyx_XDECREF(r)  do { if((r) == NULL); else {__Pyx_DECREF(r); }} while(0)
-  #define __Pyx_XGOTREF(r)  do { if((r) == NULL); else {__Pyx_GOTREF(r); }} while(0)
-  #define __Pyx_XGIVEREF(r) do { if((r) == NULL); else {__Pyx_GIVEREF(r);}} while(0)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
   #define __Pyx_RefNannySetupContext(name, acquire_gil)
-  #define __Pyx_RefNannyFinishContextNogil()
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif
-#define __Pyx_Py_XDECREF_SET(r, v) do {\
-        PyObject *tmp = (PyObject *) r;\
-        r = v; Py_XDECREF(tmp);\
-    } while (0)
 #define __Pyx_XDECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_XDECREF(tmp);\
     } while (0)
 #define __Pyx_DECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_DECREF(tmp);\
     } while (0)
 #define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
 #define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
-
-/* PyThreadStateGet.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
-#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
-#if PY_VERSION_HEX >= 0x030C00A6
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->current_exception != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->current_exception ? (PyObject*) Py_TYPE(__pyx_tstate->current_exception) : (PyObject*) NULL)
-#else
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->curexc_type != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->curexc_type)
-#endif
-#else
-#define __Pyx_PyThreadState_declare
-#define __Pyx_PyThreadState_assign
-#define __Pyx_PyErr_Occurred()  (PyErr_Occurred() != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  PyErr_Occurred()
-#endif
-
-/* PyErrFetchRestore.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A6
-#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
-#else
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#endif
-#else
-#define __Pyx_PyErr_Clear() PyErr_Clear()
-#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
-#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
-#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
-#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
-#endif
-
 /* PyObjectGetAttrStr.proto */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
-/* PyObjectGetAttrStrNoError.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
-
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
-/* TupleAndListFromArray.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n);
-static CYTHON_INLINE PyObject* __Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n);
-#endif
-
-/* IncludeStringH.proto */
-#include <string.h>
-
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* UnicodeEquals.proto */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* fastcall.proto */
-#define __Pyx_Arg_VARARGS(args, i) PyTuple_GET_ITEM(args, i)
-#define __Pyx_NumKwargs_VARARGS(kwds) PyDict_Size(kwds)
-#define __Pyx_KwValues_VARARGS(args, nargs) NULL
-#define __Pyx_GetKwValue_VARARGS(kw, kwvalues, s) __Pyx_PyDict_GetItemStrWithError(kw, s)
-#define __Pyx_KwargsAsDict_VARARGS(kw, kwvalues) PyDict_Copy(kw)
-#if CYTHON_METH_FASTCALL
-    #define __Pyx_Arg_FASTCALL(args, i) args[i]
-    #define __Pyx_NumKwargs_FASTCALL(kwds) PyTuple_GET_SIZE(kwds)
-    #define __Pyx_KwValues_FASTCALL(args, nargs) ((args) + (nargs))
-    static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s);
-    #define __Pyx_KwargsAsDict_FASTCALL(kw, kwvalues) _PyStack_AsDict(kwvalues, kw)
-#else
-    #define __Pyx_Arg_FASTCALL __Pyx_Arg_VARARGS
-    #define __Pyx_NumKwargs_FASTCALL __Pyx_NumKwargs_VARARGS
-    #define __Pyx_KwValues_FASTCALL __Pyx_KwValues_VARARGS
-    #define __Pyx_GetKwValue_FASTCALL __Pyx_GetKwValue_VARARGS
-    #define __Pyx_KwargsAsDict_FASTCALL __Pyx_KwargsAsDict_VARARGS
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_VARARGS(args, start), stop - start)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_FASTCALL(args, start), stop - start)
-#else
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) PyTuple_GetSlice(args, start, stop)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) PyTuple_GetSlice(args, start, stop)
-#endif
-
-/* RaiseArgTupleInvalid.proto */
-static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
-    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
-
-/* RaiseDoubleKeywords.proto */
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
-
-/* ParseKeywords.proto */
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject *const *kwvalues,
-    PyObject **argnames[],
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,
-    const char* function_name);
-
-/* ArgTypeTest.proto */
-#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
-    ((likely(__Pyx_IS_TYPE(obj, type) | (none_allowed && (obj == Py_None)))) ? 1 :\
-        __Pyx__ArgTypeTest(obj, type, name, exact))
-static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
-
-/* RaiseException.proto */
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+/* None.proto */
+static CYTHON_INLINE long __Pyx_div_long(long, long);
 
-/* PyFunctionFastCall.proto */
-#if CYTHON_FAST_PYCALL
-#if !CYTHON_VECTORCALL
-#define __Pyx_PyFunction_FastCall(func, args, nargs)\
-    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
-#endif
-#define __Pyx_BUILD_ASSERT_EXPR(cond)\
-    (sizeof(char [1 - 2*!(cond)]) - 1)
-#ifndef Py_MEMBER_SIZE
-#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
-#endif
-#if !CYTHON_VECTORCALL
-#if PY_VERSION_HEX >= 0x03080000
-  #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-  #define __Pxy_PyFrame_Initialize_Offsets()
-  #define __Pyx_PyFrame_GetLocalsplus(frame)  ((frame)->f_localsplus)
-#else
-  static size_t __pyx_pyframe_localsplus_offset = 0;
-  #include "frameobject.h"
-  #define __Pxy_PyFrame_Initialize_Offsets()\
-    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
-     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
-  #define __Pyx_PyFrame_GetLocalsplus(frame)\
-    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
-#endif
-#endif
-#endif
+/* None.proto */
+static CYTHON_INLINE long __Pyx_mod_long(long, long);
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+/* ListAppend.proto */
+#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
+static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
+        Py_INCREF(x);
+        PyList_SET_ITEM(list, len, x);
+        __Pyx_SET_SIZE(list, len + 1);
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
 #else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* PyObjectCallMethO.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
-#endif
-
-/* PyObjectFastCall.proto */
-#define __Pyx_PyObject_FastCall(func, args, nargs)  __Pyx_PyObject_FastCallDict(func, args, (size_t)(nargs), NULL)
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs);
-
-/* RaiseUnexpectedTypeError.proto */
-static int __Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj);
-
-/* GCCDiagnostics.proto */
-#if !defined(__INTEL_COMPILER) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
-#define __Pyx_HAS_GCC_DIAGNOSTIC
-#endif
-
-/* BuildPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char);
-
-/* CIntToPyUnicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_int(int value, Py_ssize_t width, char padding_char, char format_char);
-
-/* CIntToPyUnicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char);
-
-/* JoinPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char);
-
-/* StrEquals.proto */
-#if PY_MAJOR_VERSION >= 3
-#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
+/* DictGetItem.proto */
+#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
+#define __Pyx_PyObject_Dict_GetItem(obj, name)\
+    (likely(PyDict_CheckExact(obj)) ?\
+     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
 #else
-#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
-#endif
-
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_repr(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_repr(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
+#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
+#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
 #endif
 
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
-/* GetAttr.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
-
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
     __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
     (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
                __Pyx_GetItemInt_Generic(o, to_py_func(i))))
 #define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
@@ -2031,37 +1214,14 @@
     (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                               int wraparound, int boundscheck);
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                      int is_list, int wraparound, int boundscheck);
 
-/* PyObjectCallOneArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
-
-/* ObjectGetItem.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key);
-#else
-#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
-#endif
-
-/* KeywordStringCheck.proto */
-static int __Pyx_CheckKeywordStrings(PyObject *kw, const char* function_name, int kw_allowed);
-
-/* DivInt[Py_ssize_t].proto */
-static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
-
-/* UnaryNegOverflows.proto */
-#define __Pyx_UNARY_NEG_WOULD_OVERFLOW(x)\
-        (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
-
-/* GetAttr3.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
-
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
     (cache_var) = (value);
@@ -2082,64 +1242,253 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
+#define __Pyx_GetModuleGlobalName(var, name)  {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
+}
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
-/* AssertionsEnabled.proto */
-#define __Pyx_init_assertions_enabled()
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define __pyx_assertions_enabled() (1)
-#elif PY_VERSION_HEX < 0x03080000  ||  CYTHON_COMPILING_IN_PYPY  ||  defined(Py_LIMITED_API)
-  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
-#elif CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030900A6
-  static int __pyx_assertions_enabled_flag;
-  #define __pyx_assertions_enabled() (__pyx_assertions_enabled_flag)
-  #undef __Pyx_init_assertions_enabled
-  static void __Pyx_init_assertions_enabled(void) {
-    __pyx_assertions_enabled_flag = ! _PyInterpreterState_GetConfig(__Pyx_PyThreadState_Current->interp)->optimization_level;
-  }
+/* PyCFunctionFastCall.proto */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+#else
+#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#endif
+
+/* PyFunctionFastCall.proto */
+#if CYTHON_FAST_PYCALL
+#define __Pyx_PyFunction_FastCall(func, args, nargs)\
+    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
+#else
+#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
+#endif
+#define __Pyx_BUILD_ASSERT_EXPR(cond)\
+    (sizeof(char [1 - 2*!(cond)]) - 1)
+#ifndef Py_MEMBER_SIZE
+#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
+#endif
+  static size_t __pyx_pyframe_localsplus_offset = 0;
+  #include "frameobject.h"
+  #define __Pxy_PyFrame_Initialize_Offsets()\
+    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
+     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
+  #define __Pyx_PyFrame_GetLocalsplus(frame)\
+    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
+#endif
+
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
+/* PyObjectCall2Args.proto */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
+
+/* PyObjectCallMethO.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
+#endif
+
+/* PyObjectCallOneArg.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
+
+/* PyObjectSetAttrStr.proto */
+#if CYTHON_USE_TYPE_SLOTS
+#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
+static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
+#else
+#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
+#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
+#endif
+
+/* MemviewSliceInit.proto */
+#define __Pyx_BUF_MAX_NDIMS %(BUF_MAX_NDIMS)d
+#define __Pyx_MEMVIEW_DIRECT   1
+#define __Pyx_MEMVIEW_PTR      2
+#define __Pyx_MEMVIEW_FULL     4
+#define __Pyx_MEMVIEW_CONTIG   8
+#define __Pyx_MEMVIEW_STRIDED  16
+#define __Pyx_MEMVIEW_FOLLOW   32
+#define __Pyx_IS_C_CONTIG 1
+#define __Pyx_IS_F_CONTIG 2
+static int __Pyx_init_memviewslice(
+                struct __pyx_memoryview_obj *memview,
+                int ndim,
+                __Pyx_memviewslice *memviewslice,
+                int memview_is_new_reference);
+static CYTHON_INLINE int __pyx_add_acquisition_count_locked(
+    __pyx_atomic_int *acquisition_count, PyThread_type_lock lock);
+static CYTHON_INLINE int __pyx_sub_acquisition_count_locked(
+    __pyx_atomic_int *acquisition_count, PyThread_type_lock lock);
+#define __pyx_get_slice_count_pointer(memview) (memview->acquisition_count_aligned_p)
+#define __pyx_get_slice_count(memview) (*__pyx_get_slice_count_pointer(memview))
+#define __PYX_INC_MEMVIEW(slice, have_gil) __Pyx_INC_MEMVIEW(slice, have_gil, __LINE__)
+#define __PYX_XDEC_MEMVIEW(slice, have_gil) __Pyx_XDEC_MEMVIEW(slice, have_gil, __LINE__)
+static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
+static CYTHON_INLINE void __Pyx_XDEC_MEMVIEW(__Pyx_memviewslice *, int, int);
+
+/* RaiseArgTupleInvalid.proto */
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+
+/* RaiseDoubleKeywords.proto */
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
+
+/* ParseKeywords.proto */
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
+    const char* function_name);
+
+/* ArgTypeTest.proto */
+#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
+    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
+        __Pyx__ArgTypeTest(obj, type, name, exact))
+static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
+
+/* PyThreadStateGet.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
+#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
+#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
+#else
+#define __Pyx_PyThreadState_declare
+#define __Pyx_PyThreadState_assign
+#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
+#endif
+
+/* PyErrFetchRestore.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
+#else
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#endif
+#else
+#define __Pyx_PyErr_Clear() PyErr_Clear()
+#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
+#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
+#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
+#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
+#endif
+
+/* RaiseException.proto */
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
+
+/* IncludeStringH.proto */
+#include <string.h>
+
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* UnicodeEquals.proto */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* StrEquals.proto */
+#if PY_MAJOR_VERSION >= 3
+#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
+#else
+#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
+#endif
+
+/* None.proto */
+static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
+
+/* UnaryNegOverflows.proto */
+#define UNARY_NEG_WOULD_OVERFLOW(x)\
+        (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
+
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
+/* GetAttr.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
+
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
+/* decode_c_string_utf16.proto */
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 0;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = -1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+
+/* decode_c_string.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
+
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
 #else
-  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
 #endif
 
+/* GetAttr3.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
+
 /* RaiseTooManyValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
 /* RaiseNeedMoreValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
 /* RaiseNoneIterError.proto */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
 /* ExtTypeTest.proto */
 static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
 
 /* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+#if CYTHON_USE_EXC_INFO_STACK
 static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
 #endif
 
 /* SaveResetException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
@@ -2165,41 +1514,28 @@
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
-/* ImportDottedModule.proto */
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple);
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple);
-#endif
-
-/* ssize_strlen.proto */
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s);
-
 /* FastTypeChecks.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 #define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) __Pyx_IsAnySubtype2(Py_TYPE(obj), (PyTypeObject *)type1, (PyTypeObject *)type2)
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
 #else
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) (PyObject_TypeCheck(obj, (PyTypeObject *)type1) || PyObject_TypeCheck(obj, (PyTypeObject *)type2))
 #define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
 #define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
 #endif
-#define __Pyx_PyErr_ExceptionMatches2(err1, err2)  __Pyx_PyErr_GivenExceptionMatches2(__Pyx_PyErr_CurrentExceptionType(), err1, err2)
 #define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
 
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 /* ListCompAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len)) {
         Py_INCREF(x);
@@ -2209,245 +1545,88 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* PySequenceMultiply.proto */
-#define __Pyx_PySequence_Multiply_Left(mul, seq)  __Pyx_PySequence_Multiply(seq, mul)
-static CYTHON_INLINE PyObject* __Pyx_PySequence_Multiply(PyObject *seq, Py_ssize_t mul);
+/* PyIntBinop.proto */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
+#else
+#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
+    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
+#endif
 
-/* SetItemInt.proto */
-#define __Pyx_SetItemInt(o, i, v, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
-               __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
-static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
-                                               int is_list, int wraparound, int boundscheck);
+/* ListExtend.proto */
+static CYTHON_INLINE int __Pyx_PyList_Extend(PyObject* L, PyObject* v) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject* none = _PyList_Extend((PyListObject*)L, v);
+    if (unlikely(!none))
+        return -1;
+    Py_DECREF(none);
+    return 0;
+#else
+    return PyList_SetSlice(L, PY_SSIZE_T_MAX, PY_SSIZE_T_MAX, v);
+#endif
+}
 
-/* RaiseUnboundLocalError.proto */
+/* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-/* DivInt[long].proto */
-static CYTHON_INLINE long __Pyx_div_long(long, long);
-
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
-/* pep479.proto */
-static void __Pyx_Generator_Replace_StopIteration(int in_async_gen);
-
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
 
 /* PyObject_GenericGetAttr.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
 #endif
 
-/* IncludeStructmemberH.proto */
-#include <structmember.h>
-
-/* FixUpExtensionType.proto */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
-#endif
-
-/* PyObjectCallNoArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
-
-/* PyObjectGetMethod.proto */
-static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
-
-/* PyObjectCallMethod0.proto */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
-
-/* ValidateBasesTuple.proto */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases);
-#endif
-
-/* PyType_Ready.proto */
-CYTHON_UNUSED static int __Pyx_PyType_Ready(PyTypeObject *t);
-
 /* SetVTable.proto */
-static int __Pyx_SetVtable(PyTypeObject* typeptr , void* vtable);
+static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
-/* GetVTable.proto */
-static void* __Pyx_GetVtable(PyTypeObject *type);
-
-/* MergeVTables.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type);
-#endif
+/* PyObjectGetAttrStrNoError.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce(PyObject* type_obj);
-#endif
-
-/* FetchSharedCythonModule.proto */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void);
-
-/* FetchCommonType.proto */
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
-#else
-static PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases);
-#endif
-
-/* PyMethodNew.proto */
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
-    CYTHON_UNUSED_VAR(typ);
-    if (!self)
-        return __Pyx_NewRef(func);
-    return PyMethod_New(func, self);
-}
-#else
-    #define __Pyx_PyMethod_New PyMethod_New
-#endif
-
-/* PyVectorcallFastCallDict.proto */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw);
-#endif
-
-/* CythonFunctionShared.proto */
-#define __Pyx_CyFunction_USED
-#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
-#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
-#define __Pyx_CYFUNCTION_CCLASS        0x04
-#define __Pyx_CYFUNCTION_COROUTINE     0x08
-#define __Pyx_CyFunction_GetClosure(f)\
-    (((__pyx_CyFunctionObject *) (f))->func_closure)
-#if PY_VERSION_HEX < 0x030900B1
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      (((__pyx_CyFunctionObject *) (f))->func_classobj)
-#else
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      ((PyObject*) ((PyCMethodObject *) (f))->mm_class)
-#endif
-#define __Pyx_CyFunction_SetClassObj(f, classobj)\
-    __Pyx__CyFunction_SetClassObj((__pyx_CyFunctionObject *) (f), (classobj))
-#define __Pyx_CyFunction_Defaults(type, f)\
-    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
-#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
-    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
-typedef struct {
-#if PY_VERSION_HEX < 0x030900B1
-    PyCFunctionObject func;
-#else
-    PyCMethodObject func;
-#endif
-#if CYTHON_BACKPORT_VECTORCALL
-    __pyx_vectorcallfunc func_vectorcall;
-#endif
-#if PY_VERSION_HEX < 0x030500A0
-    PyObject *func_weakreflist;
-#endif
-    PyObject *func_dict;
-    PyObject *func_name;
-    PyObject *func_qualname;
-    PyObject *func_doc;
-    PyObject *func_globals;
-    PyObject *func_code;
-    PyObject *func_closure;
-#if PY_VERSION_HEX < 0x030900B1
-    PyObject *func_classobj;
-#endif
-    void *defaults;
-    int defaults_pyobjects;
-    size_t defaults_size;  // used by FusedFunction for copying defaults
-    int flags;
-    PyObject *defaults_tuple;
-    PyObject *defaults_kwdict;
-    PyObject *(*defaults_getter)(PyObject *);
-    PyObject *func_annotations;
-    PyObject *func_is_coroutine;
-} __pyx_CyFunctionObject;
-#define __Pyx_CyFunction_Check(obj)  __Pyx_TypeCheck(obj, __pyx_CyFunctionType)
-#define __Pyx_IsCyOrPyCFunction(obj)  __Pyx_TypeCheck2(obj, __pyx_CyFunctionType, &PyCFunction_Type)
-#define __Pyx_CyFunction_CheckExact(obj)  __Pyx_IS_TYPE(obj, __pyx_CyFunctionType)
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj);
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
-                                                         size_t size,
-                                                         int pyobjects);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
-                                                            PyObject *tuple);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
-                                                             PyObject *dict);
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
-                                                              PyObject *dict);
-static int __pyx_CyFunction_init(PyObject *module);
-#if CYTHON_METH_FASTCALL
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-#if CYTHON_BACKPORT_VECTORCALL
-#define __Pyx_CyFunction_func_vectorcall(f) (((__pyx_CyFunctionObject*)f)->func_vectorcall)
-#else
-#define __Pyx_CyFunction_func_vectorcall(f) (((PyCFunctionObject*)f)->vectorcall)
-#endif
-#endif
-
-/* CythonFunction.proto */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
 /* CodeObjectCache.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 typedef struct {
     PyCodeObject* code_object;
     int code_line;
 } __Pyx_CodeObjectCacheEntry;
 struct __Pyx_CodeObjectCache {
     int count;
     int max_count;
     __Pyx_CodeObjectCacheEntry* entries;
 };
 static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
 static PyCodeObject *__pyx_find_code_object(int code_line);
 static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
-#endif
 
 /* AddTraceback.proto */
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename);
 
 #if PY_MAJOR_VERSION < 3
     static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
@@ -2476,14 +1655,17 @@
 static int __pyx_memviewslice_is_contig(const __Pyx_memviewslice mvs, char order, int ndim);
 
 /* OverlappingSlices.proto */
 static int __pyx_slices_overlap(__Pyx_memviewslice *slice1,
                                 __Pyx_memviewslice *slice2,
                                 int ndim, size_t itemsize);
 
+/* Capsule.proto */
+static CYTHON_INLINE PyObject *__pyx_capsule_create(void *p, const char *sig);
+
 /* IsLittleEndian.proto */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
 
 /* BufferFormatCheck.proto */
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
 static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
                               __Pyx_BufFmt_StackElem* stack,
@@ -2500,228 +1682,92 @@
                 int ndim,
                 __Pyx_TypeInfo *dtype,
                 __Pyx_BufFmt_StackElem stack[],
                 __Pyx_memviewslice *memviewslice,
                 PyObject *original_obj);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(PyObject *, int writable_flag);
-
-/* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(PyObject *, int writable_flag);
 
-/* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(PyObject *, int writable_flag);
-
-/* MemviewDtypeToObject.proto */
-static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_long(const char *itemp);
-static CYTHON_INLINE int __pyx_memview_set_unsigned_long(const char *itemp, PyObject *obj);
+/* GCCDiagnostics.proto */
+#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define __Pyx_HAS_GCC_DIAGNOSTIC
+#endif
 
 /* MemviewSliceCopyTemplate.proto */
 static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object);
 
-/* MemviewSliceInit.proto */
-#define __Pyx_BUF_MAX_NDIMS %(BUF_MAX_NDIMS)d
-#define __Pyx_MEMVIEW_DIRECT   1
-#define __Pyx_MEMVIEW_PTR      2
-#define __Pyx_MEMVIEW_FULL     4
-#define __Pyx_MEMVIEW_CONTIG   8
-#define __Pyx_MEMVIEW_STRIDED  16
-#define __Pyx_MEMVIEW_FOLLOW   32
-#define __Pyx_IS_C_CONTIG 1
-#define __Pyx_IS_F_CONTIG 2
-static int __Pyx_init_memviewslice(
-                struct __pyx_memoryview_obj *memview,
-                int ndim,
-                __Pyx_memviewslice *memviewslice,
-                int memview_is_new_reference);
-static CYTHON_INLINE int __pyx_add_acquisition_count_locked(
-    __pyx_atomic_int_type *acquisition_count, PyThread_type_lock lock);
-static CYTHON_INLINE int __pyx_sub_acquisition_count_locked(
-    __pyx_atomic_int_type *acquisition_count, PyThread_type_lock lock);
-#define __pyx_get_slice_count_pointer(memview) (&memview->acquisition_count)
-#define __PYX_INC_MEMVIEW(slice, have_gil) __Pyx_INC_MEMVIEW(slice, have_gil, __LINE__)
-#define __PYX_XCLEAR_MEMVIEW(slice, have_gil) __Pyx_XCLEAR_MEMVIEW(slice, have_gil, __LINE__)
-static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
-static CYTHON_INLINE void __Pyx_XCLEAR_MEMVIEW(__Pyx_memviewslice *, int, int);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value);
-
-/* CIntFromPy.proto */
-static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *);
-
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
-/* FormatTypeName.proto */
-#if CYTHON_COMPILING_IN_LIMITED_API
-typedef PyObject *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%U"
-static __Pyx_TypeName __Pyx_PyType_GetName(PyTypeObject* tp);
-#define __Pyx_DECREF_TypeName(obj) Py_XDECREF(obj)
-#else
-typedef const char *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%.200s"
-#define __Pyx_PyType_GetName(tp) ((tp)->tp_name)
-#define __Pyx_DECREF_TypeName(obj)
-#endif
-
-/* PyObjectCall2Args.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
-
-/* PyObjectCallMethod1.proto */
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);
-
-/* CoroutineBase.proto */
-struct __pyx_CoroutineObject;
-typedef PyObject *(*__pyx_coroutine_body_t)(struct __pyx_CoroutineObject *, PyThreadState *, PyObject *);
-#if CYTHON_USE_EXC_INFO_STACK
-#define __Pyx_ExcInfoStruct  _PyErr_StackItem
-#else
-typedef struct {
-    PyObject *exc_type;
-    PyObject *exc_value;
-    PyObject *exc_traceback;
-} __Pyx_ExcInfoStruct;
-#endif
-typedef struct __pyx_CoroutineObject {
-    PyObject_HEAD
-    __pyx_coroutine_body_t body;
-    PyObject *closure;
-    __Pyx_ExcInfoStruct gi_exc_state;
-    PyObject *gi_weakreflist;
-    PyObject *classobj;
-    PyObject *yieldfrom;
-    PyObject *gi_name;
-    PyObject *gi_qualname;
-    PyObject *gi_modulename;
-    PyObject *gi_code;
-    PyObject *gi_frame;
-    int resume_label;
-    char is_running;
-} __pyx_CoroutineObject;
-static __pyx_CoroutineObject *__Pyx__Coroutine_New(
-    PyTypeObject *type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
-    PyObject *name, PyObject *qualname, PyObject *module_name);
-static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
-            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
-            PyObject *name, PyObject *qualname, PyObject *module_name);
-static CYTHON_INLINE void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *self);
-static int __Pyx_Coroutine_clear(PyObject *self);
-static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
-static PyObject *__Pyx_Coroutine_Close(PyObject *self);
-static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
-#if CYTHON_USE_EXC_INFO_STACK
-#define __Pyx_Coroutine_SwapException(self)
-#define __Pyx_Coroutine_ResetAndClearException(self)  __Pyx_Coroutine_ExceptionClear(&(self)->gi_exc_state)
-#else
-#define __Pyx_Coroutine_SwapException(self) {\
-    __Pyx_ExceptionSwap(&(self)->gi_exc_state.exc_type, &(self)->gi_exc_state.exc_value, &(self)->gi_exc_state.exc_traceback);\
-    __Pyx_Coroutine_ResetFrameBackpointer(&(self)->gi_exc_state);\
-    }
-#define __Pyx_Coroutine_ResetAndClearException(self) {\
-    __Pyx_ExceptionReset((self)->gi_exc_state.exc_type, (self)->gi_exc_state.exc_value, (self)->gi_exc_state.exc_traceback);\
-    (self)->gi_exc_state.exc_type = (self)->gi_exc_state.exc_value = (self)->gi_exc_state.exc_traceback = NULL;\
-    }
-#endif
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
-    __Pyx_PyGen__FetchStopIterationValue(__pyx_tstate, pvalue)
-#else
-#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
-    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, pvalue)
-#endif
-static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *tstate, PyObject **pvalue);
-static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state);
-
-/* PatchModuleWithCoroutine.proto */
-static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);
-
-/* PatchGeneratorABC.proto */
-static int __Pyx_patch_abc(void);
-
-/* Generator.proto */
-#define __Pyx_Generator_USED
-#define __Pyx_Generator_CheckExact(obj) __Pyx_IS_TYPE(obj, __pyx_GeneratorType)
-#define __Pyx_Generator_New(body, code, closure, name, qualname, module_name)\
-    __Pyx__Coroutine_New(__pyx_GeneratorType, body, code, closure, name, qualname, module_name)
-static PyObject *__Pyx_Generator_Next(PyObject *self);
-static int __pyx_Generator_init(PyObject *module);
-
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
-/* #### Code section: module_declarations ### */
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *__pyx_v_self); /* proto*/
 static char *__pyx_memoryview_get_item_pointer(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index); /* proto*/
 static PyObject *__pyx_memoryview_is_slice(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj); /* proto*/
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src); /* proto*/
 static PyObject *__pyx_memoryview_setitem_slice_assign_scalar(struct __pyx_memoryview_obj *__pyx_v_self, struct __pyx_memoryview_obj *__pyx_v_dst, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_setitem_indexed(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_convert_item_to_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryview_assign_item_from_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
-static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self); /* proto*/
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
-static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto*/
-
-/* Module declarations from "cython.view" */
-
-/* Module declarations from "cython.dataclasses" */
 
-/* Module declarations from "cython" */
+/* Module declarations from 'cython.view' */
 
-/* Module declarations from "cpython.mem" */
+/* Module declarations from 'cython' */
 
-/* Module declarations from "libc.string" */
+/* Module declarations from 'libc.math' */
 
-/* Module declarations from "chython.algorithms._isomorphism" */
-static PyObject *__pyx_collections_abc_Sequence = 0;
+/* Module declarations from 'chython.containers._unpack' */
+static PyTypeObject *__pyx_array_type = 0;
+static PyTypeObject *__pyx_MemviewEnum_type = 0;
+static PyTypeObject *__pyx_memoryview_type = 0;
+static PyTypeObject *__pyx_memoryviewslice_type = 0;
+static int __pyx_v_7chython_10containers_7_unpack_common_isotopes[0x77];
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
-static int __pyx_array_allocate_buffer(struct __pyx_array_obj *); /*proto*/
+static double __pyx_f_7chython_10containers_7_unpack_double_from2bytes(unsigned char, unsigned char); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
+static void *__pyx_align_pointer(void *, size_t); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
-static int assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
+static PyObject *assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
 static int __pyx_memoryview_slice_memviewslice(__Pyx_memviewslice *, Py_ssize_t, Py_ssize_t, Py_ssize_t, int, int, int *, Py_ssize_t, Py_ssize_t, Py_ssize_t, int, int, int, int); /*proto*/
 static char *__pyx_pybuffer_index(Py_buffer *, char *, Py_ssize_t, Py_ssize_t); /*proto*/
 static int __pyx_memslice_transpose(__Pyx_memviewslice *); /*proto*/
 static PyObject *__pyx_memoryview_fromslice(__Pyx_memviewslice, int, PyObject *(*)(char *), int (*)(char *, PyObject *), int); /*proto*/
 static __Pyx_memviewslice *__pyx_memoryview_get_slice_from_memoryview(struct __pyx_memoryview_obj *, __Pyx_memviewslice *); /*proto*/
 static void __pyx_memoryview_slice_copy(struct __pyx_memoryview_obj *, __Pyx_memviewslice *); /*proto*/
@@ -2731,218 +1777,316 @@
 static char __pyx_get_best_slice_order(__Pyx_memviewslice *, int); /*proto*/
 static void _copy_strided_to_strided(char *, Py_ssize_t *, char *, Py_ssize_t *, Py_ssize_t *, Py_ssize_t *, int, size_t); /*proto*/
 static void copy_strided_to_strided(__Pyx_memviewslice *, __Pyx_memviewslice *, int, size_t); /*proto*/
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *, int); /*proto*/
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *, Py_ssize_t *, Py_ssize_t, int, char); /*proto*/
 static void *__pyx_memoryview_copy_data_to_temp(__Pyx_memviewslice *, __Pyx_memviewslice *, char, int); /*proto*/
 static int __pyx_memoryview_err_extents(int, Py_ssize_t, Py_ssize_t); /*proto*/
-static int __pyx_memoryview_err_dim(PyObject *, PyObject *, int); /*proto*/
-static int __pyx_memoryview_err(PyObject *, PyObject *); /*proto*/
-static int __pyx_memoryview_err_no_memory(void); /*proto*/
+static int __pyx_memoryview_err_dim(PyObject *, char *, int); /*proto*/
+static int __pyx_memoryview_err(PyObject *, char *); /*proto*/
 static int __pyx_memoryview_copy_contents(__Pyx_memviewslice, __Pyx_memviewslice, int, int, int); /*proto*/
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *, int, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
-/* #### Code section: typeinfo ### */
-static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_long = { "unsigned long", NULL, sizeof(unsigned long), { 0 }, 0, __PYX_IS_UNSIGNED(unsigned long) ? 'U' : 'I', __PYX_IS_UNSIGNED(unsigned long), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_int = { "unsigned int", NULL, sizeof(unsigned int), { 0 }, 0, __PYX_IS_UNSIGNED(unsigned int) ? 'U' : 'I', __PYX_IS_UNSIGNED(unsigned int), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_PY_LONG_LONG = { "unsigned long long", NULL, sizeof(unsigned PY_LONG_LONG), { 0 }, 0, __PYX_IS_UNSIGNED(unsigned PY_LONG_LONG) ? 'U' : 'I', __PYX_IS_UNSIGNED(unsigned PY_LONG_LONG), 0 };
-/* #### Code section: before_global_var ### */
-#define __Pyx_MODULE_NAME "chython.algorithms._isomorphism"
-extern int __pyx_module_is_main_chython__algorithms___isomorphism;
-int __pyx_module_is_main_chython__algorithms___isomorphism = 0;
+static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_char__const__ = { "const unsigned char", NULL, sizeof(unsigned char const ), { 0 }, 0, IS_UNSIGNED(unsigned char const ) ? 'U' : 'I', IS_UNSIGNED(unsigned char const ), 0 };
+#define __Pyx_MODULE_NAME "chython.containers._unpack"
+extern int __pyx_module_is_main_chython__containers___unpack;
+int __pyx_module_is_main_chython__containers___unpack = 0;
 
-/* Implementation of "chython.algorithms._isomorphism" */
-/* #### Code section: global_var ### */
-static PyObject *__pyx_builtin_MemoryError;
+/* Implementation of 'chython.containers._unpack' */
 static PyObject *__pyx_builtin_range;
-static PyObject *__pyx_builtin___import__;
+static PyObject *__pyx_builtin_object;
 static PyObject *__pyx_builtin_ValueError;
+static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_TypeError;
-static PyObject *__pyx_builtin_AssertionError;
 static PyObject *__pyx_builtin_Ellipsis;
 static PyObject *__pyx_builtin_id;
 static PyObject *__pyx_builtin_IndexError;
-/* #### Code section: string_decls ### */
-static const char __pyx_k_[] = ": ";
 static const char __pyx_k_O[] = "O";
+static const char __pyx_k_a[] = "a";
+static const char __pyx_k_b[] = "b";
 static const char __pyx_k_c[] = "c";
+static const char __pyx_k_d[] = "d";
 static const char __pyx_k_i[] = "i";
 static const char __pyx_k_j[] = "j";
 static const char __pyx_k_m[] = "m";
 static const char __pyx_k_n[] = "n";
-static const char __pyx_k_o[] = "o";
-static const char __pyx_k__2[] = ".";
-static const char __pyx_k__3[] = "*";
-static const char __pyx_k__6[] = "'";
-static const char __pyx_k__7[] = ")";
-static const char __pyx_k_gc[] = "gc";
+static const char __pyx_k_x[] = "x";
+static const char __pyx_k_y[] = "y";
 static const char __pyx_k_id[] = "id";
-static const char __pyx_k__22[] = "?";
-static const char __pyx_k_abc[] = "abc";
-static const char __pyx_k_and[] = " and ";
-static const char __pyx_k_got[] = " (got ";
+static const char __pyx_k_na[] = "na";
+static const char __pyx_k_nb[] = "nb";
+static const char __pyx_k_nct[] = "nct";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
-static const char __pyx_k_sys[] = "sys";
-static const char __pyx_k_args[] = "args";
-static const char __pyx_k_back[] = "back";
+static const char __pyx_k_tmp[] = "tmp";
+static const char __pyx_k_Bond[] = "Bond";
+static const char __pyx_k_atom[] = "atom";
 static const char __pyx_k_base[] = "base";
+static const char __pyx_k_bond[] = "bond";
+static const char __pyx_k_data[] = "data";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
-static const char __pyx_k_o_to[] = "o_to";
 static const char __pyx_k_pack[] = "pack";
-static const char __pyx_k_path[] = "path";
-static const char __pyx_k_q_to[] = "q_to";
-static const char __pyx_k_send[] = "send";
+static const char __pyx_k_seen[] = "seen";
 static const char __pyx_k_size[] = "size";
-static const char __pyx_k_spec[] = "__spec__";
 static const char __pyx_k_step[] = "step";
 static const char __pyx_k_stop[] = "stop";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_ASCII[] = "ASCII";
 static const char __pyx_k_class[] = "__class__";
-static const char __pyx_k_close[] = "close";
-static const char __pyx_k_count[] = "count";
-static const char __pyx_k_depth[] = "depth";
 static const char __pyx_k_error[] = "error";
 static const char __pyx_k_flags[] = "flags";
-static const char __pyx_k_front[] = "front";
-static const char __pyx_k_index[] = "index";
 static const char __pyx_k_range[] = "range";
-static const char __pyx_k_scope[] = "scope";
 static const char __pyx_k_shape[] = "shape";
-static const char __pyx_k_stack[] = "stack";
+static const char __pyx_k_shift[] = "shift";
 static const char __pyx_k_start[] = "start";
-static const char __pyx_k_throw[] = "throw";
-static const char __pyx_k_c_bond[] = "c_bond";
-static const char __pyx_k_enable[] = "enable";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
+static const char __pyx_k_is_all[] = "is_all";
+static const char __pyx_k_is_tet[] = "is_tet";
 static const char __pyx_k_name_2[] = "__name__";
-static const char __pyx_k_o_bond[] = "o_bond";
-static const char __pyx_k_o_from[] = "o_from";
-static const char __pyx_k_o_size[] = "o_size";
+static const char __pyx_k_object[] = "object";
+static const char __pyx_k_orders[] = "orders";
 static const char __pyx_k_pickle[] = "pickle";
-static const char __pyx_k_q_back[] = "q_back";
-static const char __pyx_k_q_from[] = "q_from";
-static const char __pyx_k_q_size[] = "q_size";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
-static const char __pyx_k_disable[] = "disable";
+static const char __pyx_k_charges[] = "charges";
+static const char __pyx_k_ct_sign[] = "ct_sign";
 static const char __pyx_k_fortran[] = "fortran";
 static const char __pyx_k_mapping[] = "mapping";
-static const char __pyx_k_matched[] = "matched";
 static const char __pyx_k_memview[] = "memview";
-static const char __pyx_k_o_bits1[] = "o_bits1";
-static const char __pyx_k_o_bits2[] = "o_bits2";
-static const char __pyx_k_o_bits3[] = "o_bits3";
-static const char __pyx_k_o_bits4[] = "o_bits4";
-static const char __pyx_k_o_bonds[] = "o_bonds";
-static const char __pyx_k_q_bonds[] = "q_bonds";
-static const char __pyx_k_q_mask1[] = "q_mask1";
-static const char __pyx_k_q_mask2[] = "q_mask2";
-static const char __pyx_k_q_mask3[] = "q_mask3";
-static const char __pyx_k_q_mask4[] = "q_mask4";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
-static const char __pyx_k_Sequence[] = "Sequence";
+static const char __pyx_k_all_sign[] = "all_sign";
 static const char __pyx_k_getstate[] = "__getstate__";
+static const char __pyx_k_isotopes[] = "isotopes";
 static const char __pyx_k_itemsize[] = "itemsize";
+static const char __pyx_k_py_atoms[] = "py_atoms";
+static const char __pyx_k_py_bonds[] = "py_bonds";
+static const char __pyx_k_py_plane[] = "py_plane";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
-static const char __pyx_k_q_masks1[] = "q_masks1";
-static const char __pyx_k_q_masks2[] = "q_masks2";
-static const char __pyx_k_q_masks3[] = "q_masks3";
-static const char __pyx_k_q_masks4[] = "q_masks4";
-static const char __pyx_k_register[] = "register";
+static const char __pyx_k_radicals[] = "radicals";
 static const char __pyx_k_setstate[] = "__setstate__";
+static const char __pyx_k_tet_sign[] = "tet_sign";
 static const char __pyx_k_TypeError[] = "TypeError";
 static const char __pyx_k_enumerate[] = "enumerate";
-static const char __pyx_k_isenabled[] = "isenabled";
-static const char __pyx_k_o_indices[] = "o_indices";
-static const char __pyx_k_o_numbers[] = "o_numbers";
-static const char __pyx_k_path_size[] = "path_size";
+static const char __pyx_k_hydrogens[] = "hydrogens";
+static const char __pyx_k_neighbors[] = "neighbors";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
-static const char __pyx_k_q_indices[] = "q_indices";
-static const char __pyx_k_q_numbers[] = "q_numbers";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_IndexError[] = "IndexError";
 static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_o_closures[] = "o_closures";
+static const char __pyx_k_py_charges[] = "py_charges";
+static const char __pyx_k_py_mapping[] = "py_mapping";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
-static const char __pyx_k_q_closures[] = "q_closures";
-static const char __pyx_k_q_size_dec[] = "q_size_dec";
+static const char __pyx_k_Bond__order[] = "_Bond__order";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
-static const char __pyx_k_collections[] = "collections";
-static const char __pyx_k_get_mapping[] = "get_mapping";
-static const char __pyx_k_stack_depth[] = "stack_depth";
-static const char __pyx_k_stack_index[] = "stack_index";
-static const char __pyx_k_closures_num[] = "closures_num";
-static const char __pyx_k_initializing[] = "_initializing";
-static const char __pyx_k_is_coroutine[] = "_is_coroutine";
+static const char __pyx_k_cis_trans_1[] = "cis_trans_1";
+static const char __pyx_k_cis_trans_2[] = "cis_trans_2";
+static const char __pyx_k_connections[] = "connections";
+static const char __pyx_k_order_shift[] = "order_shift";
+static const char __pyx_k_pack_length[] = "pack_length";
+static const char __pyx_k_py_isotopes[] = "py_isotopes";
+static const char __pyx_k_py_radicals[] = "py_radicals";
+static const char __pyx_k_py_hydrogens[] = "py_hydrogens";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
-static const char __pyx_k_stringsource[] = "<stringsource>";
-static const char __pyx_k_version_info[] = "version_info";
-static const char __pyx_k_class_getitem[] = "__class_getitem__";
+static const char __pyx_k_stringsource[] = "stringsource";
+static const char __pyx_k_isotope_shift[] = "isotope_shift";
+static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
-static const char __pyx_k_AssertionError[] = "AssertionError";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
-static const char __pyx_k_collections_abc[] = "collections.abc";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
+static const char __pyx_k_py_atoms_stereo[] = "py_atoms_stereo";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
-static const char __pyx_k_closures_counter[] = "closures_counter";
+static const char __pyx_k_py_allenes_stereo[] = "py_allenes_stereo";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
-static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
+static const char __pyx_k_py_cis_trans_stereo[] = "py_cis_trans_stereo";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
-static const char __pyx_k_Invalid_shape_in_axis[] = "Invalid shape in axis ";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
-static const char __pyx_k_Cannot_index_with_type[] = "Cannot index with type '";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
-static const char __pyx_k_Dimension_d_is_not_direct[] = "Dimension %d is not direct";
-static const char __pyx_k_Index_out_of_bounds_axis_d[] = "Index out of bounds (axis %d)";
-static const char __pyx_k_Step_may_not_be_zero_axis_d[] = "Step may not be zero (axis %d)";
+static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
+static const char __pyx_k_chython_containers_bonds[] = "chython.containers.bonds";
+static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
+static const char __pyx_k_chython_containers__unpack[] = "chython.containers._unpack";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
+static const char __pyx_k_chython_containers__unpack_pyx[] = "chython\\containers\\_unpack.pyx";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
-static const char __pyx_k_chython_algorithms__isomorphism[] = "chython.algorithms._isomorphism";
-static const char __pyx_k_All_dimensions_preceding_dimensi[] = "All dimensions preceding dimension %d must be indexed and not sliced";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
-static const char __pyx_k_Cannot_transpose_memoryview_with[] = "Cannot transpose memoryview with indirect dimensions";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))";
+static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
-static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got ";
-static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis ";
+static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
+static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
-static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension ";
+static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
-static const char __pyx_k_chython_algorithms__isomorphism_2[] = "chython/algorithms/_isomorphism.pyx";
-/* #### Code section: decls ### */
+static PyObject *__pyx_n_s_ASCII;
+static PyObject *__pyx_n_s_Bond;
+static PyObject *__pyx_n_s_Bond__order;
+static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
+static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
+static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
+static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
+static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
+static PyObject *__pyx_n_s_Ellipsis;
+static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
+static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
+static PyObject *__pyx_n_s_IndexError;
+static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
+static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
+static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
+static PyObject *__pyx_n_s_MemoryError;
+static PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
+static PyObject *__pyx_kp_s_MemoryView_of_r_object;
+static PyObject *__pyx_n_b_O;
+static PyObject *__pyx_kp_s_Out_of_bounds_on_buffer_access_a;
+static PyObject *__pyx_n_s_PickleError;
+static PyObject *__pyx_n_s_TypeError;
+static PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
+static PyObject *__pyx_n_s_ValueError;
+static PyObject *__pyx_n_s_View_MemoryView;
+static PyObject *__pyx_n_s_a;
+static PyObject *__pyx_n_s_all_sign;
+static PyObject *__pyx_n_s_allocate_buffer;
+static PyObject *__pyx_n_s_atom;
+static PyObject *__pyx_n_s_b;
+static PyObject *__pyx_n_s_base;
+static PyObject *__pyx_n_s_bond;
+static PyObject *__pyx_n_s_c;
+static PyObject *__pyx_n_u_c;
+static PyObject *__pyx_n_s_charges;
+static PyObject *__pyx_n_s_chython_containers__unpack;
+static PyObject *__pyx_kp_s_chython_containers__unpack_pyx;
+static PyObject *__pyx_n_s_chython_containers_bonds;
+static PyObject *__pyx_n_s_cis_trans_1;
+static PyObject *__pyx_n_s_cis_trans_2;
+static PyObject *__pyx_n_s_class;
+static PyObject *__pyx_n_s_cline_in_traceback;
+static PyObject *__pyx_n_s_connections;
+static PyObject *__pyx_kp_s_contiguous_and_direct;
+static PyObject *__pyx_kp_s_contiguous_and_indirect;
+static PyObject *__pyx_n_s_ct_sign;
+static PyObject *__pyx_n_s_d;
+static PyObject *__pyx_n_s_data;
+static PyObject *__pyx_n_s_dict;
+static PyObject *__pyx_n_s_dtype_is_object;
+static PyObject *__pyx_n_s_encode;
+static PyObject *__pyx_n_s_enumerate;
+static PyObject *__pyx_n_s_error;
+static PyObject *__pyx_n_s_flags;
+static PyObject *__pyx_n_s_format;
+static PyObject *__pyx_n_s_fortran;
+static PyObject *__pyx_n_u_fortran;
+static PyObject *__pyx_n_s_getstate;
+static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
+static PyObject *__pyx_n_s_hydrogens;
+static PyObject *__pyx_n_s_i;
+static PyObject *__pyx_n_s_id;
+static PyObject *__pyx_n_s_import;
+static PyObject *__pyx_n_s_is_all;
+static PyObject *__pyx_n_s_is_tet;
+static PyObject *__pyx_n_s_isotope_shift;
+static PyObject *__pyx_n_s_isotopes;
+static PyObject *__pyx_n_s_itemsize;
+static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
+static PyObject *__pyx_n_s_j;
+static PyObject *__pyx_n_s_m;
+static PyObject *__pyx_n_s_main;
+static PyObject *__pyx_n_s_mapping;
+static PyObject *__pyx_n_s_memview;
+static PyObject *__pyx_n_s_mode;
+static PyObject *__pyx_n_s_n;
+static PyObject *__pyx_n_s_na;
+static PyObject *__pyx_n_s_name;
+static PyObject *__pyx_n_s_name_2;
+static PyObject *__pyx_n_s_nb;
+static PyObject *__pyx_n_s_nct;
+static PyObject *__pyx_n_s_ndim;
+static PyObject *__pyx_n_s_neighbors;
+static PyObject *__pyx_n_s_new;
+static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
+static PyObject *__pyx_n_s_obj;
+static PyObject *__pyx_n_s_object;
+static PyObject *__pyx_n_s_order_shift;
+static PyObject *__pyx_n_s_orders;
+static PyObject *__pyx_n_s_pack;
+static PyObject *__pyx_n_s_pack_length;
+static PyObject *__pyx_n_s_pickle;
+static PyObject *__pyx_n_s_py_allenes_stereo;
+static PyObject *__pyx_n_s_py_atoms;
+static PyObject *__pyx_n_s_py_atoms_stereo;
+static PyObject *__pyx_n_s_py_bonds;
+static PyObject *__pyx_n_s_py_charges;
+static PyObject *__pyx_n_s_py_cis_trans_stereo;
+static PyObject *__pyx_n_s_py_hydrogens;
+static PyObject *__pyx_n_s_py_isotopes;
+static PyObject *__pyx_n_s_py_mapping;
+static PyObject *__pyx_n_s_py_plane;
+static PyObject *__pyx_n_s_py_radicals;
+static PyObject *__pyx_n_s_pyx_PickleError;
+static PyObject *__pyx_n_s_pyx_checksum;
+static PyObject *__pyx_n_s_pyx_getbuffer;
+static PyObject *__pyx_n_s_pyx_result;
+static PyObject *__pyx_n_s_pyx_state;
+static PyObject *__pyx_n_s_pyx_type;
+static PyObject *__pyx_n_s_pyx_unpickle_Enum;
+static PyObject *__pyx_n_s_pyx_vtable;
+static PyObject *__pyx_n_s_radicals;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_reduce;
+static PyObject *__pyx_n_s_reduce_cython;
+static PyObject *__pyx_n_s_reduce_ex;
+static PyObject *__pyx_n_s_seen;
+static PyObject *__pyx_n_s_setstate;
+static PyObject *__pyx_n_s_setstate_cython;
+static PyObject *__pyx_n_s_shape;
+static PyObject *__pyx_n_s_shift;
+static PyObject *__pyx_n_s_size;
+static PyObject *__pyx_n_s_start;
+static PyObject *__pyx_n_s_step;
+static PyObject *__pyx_n_s_stop;
+static PyObject *__pyx_kp_s_strided_and_direct;
+static PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
+static PyObject *__pyx_kp_s_strided_and_indirect;
+static PyObject *__pyx_kp_s_stringsource;
+static PyObject *__pyx_n_s_struct;
+static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_n_s_tet_sign;
+static PyObject *__pyx_n_s_tmp;
+static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
+static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
+static PyObject *__pyx_n_s_unpack;
+static PyObject *__pyx_n_s_update;
+static PyObject *__pyx_n_s_x;
+static PyObject *__pyx_n_s_y;
+static PyObject *__pyx_pf_7chython_10containers_7_unpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item); /* proto */
@@ -2973,987 +2117,1652 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_16is_c_contig(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_18is_f_contig(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_20copy(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
-static PyObject *__pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_q_numbers, __Pyx_memviewslice __pyx_v_q_back, __Pyx_memviewslice __pyx_v_q_masks1, __Pyx_memviewslice __pyx_v_q_masks2, __Pyx_memviewslice __pyx_v_q_masks3, __Pyx_memviewslice __pyx_v_q_masks4, __Pyx_memviewslice __pyx_v_q_closures, __Pyx_memviewslice __pyx_v_q_from, __Pyx_memviewslice __pyx_v_q_to, __Pyx_memviewslice __pyx_v_q_indices, __Pyx_memviewslice __pyx_v_q_bonds, __Pyx_memviewslice __pyx_v_o_numbers, __Pyx_memviewslice __pyx_v_o_bits1, __Pyx_memviewslice __pyx_v_o_bits2, __Pyx_memviewslice __pyx_v_o_bits3, __Pyx_memviewslice __pyx_v_o_bits4, __Pyx_memviewslice __pyx_v_o_bonds, __Pyx_memviewslice __pyx_v_o_from, __Pyx_memviewslice __pyx_v_o_to, __Pyx_memviewslice __pyx_v_o_indices, __Pyx_memviewslice __pyx_v_scope); /* proto */
-static PyObject *__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-/* #### Code section: late_includes ### */
-/* #### Code section: module_state ### */
-typedef struct {
-  PyObject *__pyx_d;
-  PyObject *__pyx_b;
-  PyObject *__pyx_cython_runtime;
-  PyObject *__pyx_empty_tuple;
-  PyObject *__pyx_empty_bytes;
-  PyObject *__pyx_empty_unicode;
-  #ifdef __Pyx_CyFunction_USED
-  PyTypeObject *__pyx_CyFunctionType;
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  PyTypeObject *__pyx_FusedFunctionType;
-  #endif
-  #ifdef __Pyx_Generator_USED
-  PyTypeObject *__pyx_GeneratorType;
-  #endif
-  #ifdef __Pyx_IterableCoroutine_USED
-  PyTypeObject *__pyx_IterableCoroutineType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineAwaitType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineType;
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  PyObject *__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
-  PyObject *__pyx_type___pyx_array;
-  PyObject *__pyx_type___pyx_MemviewEnum;
-  PyObject *__pyx_type___pyx_memoryview;
-  PyObject *__pyx_type___pyx_memoryviewslice;
-  #endif
-  PyTypeObject *__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
-  PyTypeObject *__pyx_array_type;
-  PyTypeObject *__pyx_MemviewEnum_type;
-  PyTypeObject *__pyx_memoryview_type;
-  PyTypeObject *__pyx_memoryviewslice_type;
-  PyObject *__pyx_kp_u_;
-  PyObject *__pyx_n_s_ASCII;
-  PyObject *__pyx_kp_s_All_dimensions_preceding_dimensi;
-  PyObject *__pyx_n_s_AssertionError;
-  PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
-  PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
-  PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
-  PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
-  PyObject *__pyx_kp_u_Cannot_index_with_type;
-  PyObject *__pyx_kp_s_Cannot_transpose_memoryview_with;
-  PyObject *__pyx_kp_s_Dimension_d_is_not_direct;
-  PyObject *__pyx_n_s_Ellipsis;
-  PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
-  PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
-  PyObject *__pyx_n_s_IndexError;
-  PyObject *__pyx_kp_s_Index_out_of_bounds_axis_d;
-  PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
-  PyObject *__pyx_kp_u_Invalid_mode_expected_c_or_fortr;
-  PyObject *__pyx_kp_u_Invalid_shape_in_axis;
-  PyObject *__pyx_n_s_MemoryError;
-  PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
-  PyObject *__pyx_kp_s_MemoryView_of_r_object;
-  PyObject *__pyx_n_b_O;
-  PyObject *__pyx_kp_u_Out_of_bounds_on_buffer_access_a;
-  PyObject *__pyx_n_s_PickleError;
-  PyObject *__pyx_n_s_Sequence;
-  PyObject *__pyx_kp_s_Step_may_not_be_zero_axis_d;
-  PyObject *__pyx_n_s_TypeError;
-  PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
-  PyObject *__pyx_n_s_ValueError;
-  PyObject *__pyx_n_s_View_MemoryView;
-  PyObject *__pyx_kp_u__2;
-  PyObject *__pyx_n_s__22;
-  PyObject *__pyx_n_s__3;
-  PyObject *__pyx_kp_u__6;
-  PyObject *__pyx_kp_u__7;
-  PyObject *__pyx_n_s_abc;
-  PyObject *__pyx_n_s_allocate_buffer;
-  PyObject *__pyx_kp_u_and;
-  PyObject *__pyx_n_s_args;
-  PyObject *__pyx_n_s_asyncio_coroutines;
-  PyObject *__pyx_n_s_back;
-  PyObject *__pyx_n_s_base;
-  PyObject *__pyx_n_s_c;
-  PyObject *__pyx_n_u_c;
-  PyObject *__pyx_n_s_c_bond;
-  PyObject *__pyx_n_s_chython_algorithms__isomorphism;
-  PyObject *__pyx_kp_s_chython_algorithms__isomorphism_2;
-  PyObject *__pyx_n_s_class;
-  PyObject *__pyx_n_s_class_getitem;
-  PyObject *__pyx_n_s_cline_in_traceback;
-  PyObject *__pyx_n_s_close;
-  PyObject *__pyx_n_s_closures_counter;
-  PyObject *__pyx_n_s_closures_num;
-  PyObject *__pyx_n_s_collections;
-  PyObject *__pyx_kp_s_collections_abc;
-  PyObject *__pyx_kp_s_contiguous_and_direct;
-  PyObject *__pyx_kp_s_contiguous_and_indirect;
-  PyObject *__pyx_n_s_count;
-  PyObject *__pyx_n_s_depth;
-  PyObject *__pyx_n_s_dict;
-  PyObject *__pyx_kp_u_disable;
-  PyObject *__pyx_n_s_dtype_is_object;
-  PyObject *__pyx_kp_u_enable;
-  PyObject *__pyx_n_s_encode;
-  PyObject *__pyx_n_s_enumerate;
-  PyObject *__pyx_n_s_error;
-  PyObject *__pyx_n_s_flags;
-  PyObject *__pyx_n_s_format;
-  PyObject *__pyx_n_s_fortran;
-  PyObject *__pyx_n_u_fortran;
-  PyObject *__pyx_n_s_front;
-  PyObject *__pyx_kp_u_gc;
-  PyObject *__pyx_n_s_get_mapping;
-  PyObject *__pyx_n_s_getstate;
-  PyObject *__pyx_kp_u_got;
-  PyObject *__pyx_kp_u_got_differing_extents_in_dimensi;
-  PyObject *__pyx_n_s_i;
-  PyObject *__pyx_n_s_id;
-  PyObject *__pyx_n_s_import;
-  PyObject *__pyx_n_s_index;
-  PyObject *__pyx_n_s_initializing;
-  PyObject *__pyx_n_s_is_coroutine;
-  PyObject *__pyx_kp_u_isenabled;
-  PyObject *__pyx_n_s_itemsize;
-  PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
-  PyObject *__pyx_n_s_j;
-  PyObject *__pyx_n_s_m;
-  PyObject *__pyx_n_s_main;
-  PyObject *__pyx_n_s_mapping;
-  PyObject *__pyx_n_s_matched;
-  PyObject *__pyx_n_s_memview;
-  PyObject *__pyx_n_s_mode;
-  PyObject *__pyx_n_s_n;
-  PyObject *__pyx_n_s_name;
-  PyObject *__pyx_n_s_name_2;
-  PyObject *__pyx_n_s_ndim;
-  PyObject *__pyx_n_s_new;
-  PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
-  PyObject *__pyx_n_s_o;
-  PyObject *__pyx_n_s_o_bits1;
-  PyObject *__pyx_n_s_o_bits2;
-  PyObject *__pyx_n_s_o_bits3;
-  PyObject *__pyx_n_s_o_bits4;
-  PyObject *__pyx_n_s_o_bond;
-  PyObject *__pyx_n_s_o_bonds;
-  PyObject *__pyx_n_s_o_closures;
-  PyObject *__pyx_n_s_o_from;
-  PyObject *__pyx_n_s_o_indices;
-  PyObject *__pyx_n_s_o_numbers;
-  PyObject *__pyx_n_s_o_size;
-  PyObject *__pyx_n_s_o_to;
-  PyObject *__pyx_n_s_obj;
-  PyObject *__pyx_n_s_pack;
-  PyObject *__pyx_n_s_path;
-  PyObject *__pyx_n_s_path_size;
-  PyObject *__pyx_n_s_pickle;
-  PyObject *__pyx_n_s_pyx_PickleError;
-  PyObject *__pyx_n_s_pyx_checksum;
-  PyObject *__pyx_n_s_pyx_result;
-  PyObject *__pyx_n_s_pyx_state;
-  PyObject *__pyx_n_s_pyx_type;
-  PyObject *__pyx_n_s_pyx_unpickle_Enum;
-  PyObject *__pyx_n_s_pyx_vtable;
-  PyObject *__pyx_n_s_q_back;
-  PyObject *__pyx_n_s_q_bonds;
-  PyObject *__pyx_n_s_q_closures;
-  PyObject *__pyx_n_s_q_from;
-  PyObject *__pyx_n_s_q_indices;
-  PyObject *__pyx_n_s_q_mask1;
-  PyObject *__pyx_n_s_q_mask2;
-  PyObject *__pyx_n_s_q_mask3;
-  PyObject *__pyx_n_s_q_mask4;
-  PyObject *__pyx_n_s_q_masks1;
-  PyObject *__pyx_n_s_q_masks2;
-  PyObject *__pyx_n_s_q_masks3;
-  PyObject *__pyx_n_s_q_masks4;
-  PyObject *__pyx_n_s_q_numbers;
-  PyObject *__pyx_n_s_q_size;
-  PyObject *__pyx_n_s_q_size_dec;
-  PyObject *__pyx_n_s_q_to;
-  PyObject *__pyx_n_s_range;
-  PyObject *__pyx_n_s_reduce;
-  PyObject *__pyx_n_s_reduce_cython;
-  PyObject *__pyx_n_s_reduce_ex;
-  PyObject *__pyx_n_s_register;
-  PyObject *__pyx_n_s_scope;
-  PyObject *__pyx_n_s_send;
-  PyObject *__pyx_n_s_setstate;
-  PyObject *__pyx_n_s_setstate_cython;
-  PyObject *__pyx_n_s_shape;
-  PyObject *__pyx_n_s_size;
-  PyObject *__pyx_n_s_spec;
-  PyObject *__pyx_n_s_stack;
-  PyObject *__pyx_n_s_stack_depth;
-  PyObject *__pyx_n_s_stack_index;
-  PyObject *__pyx_n_s_start;
-  PyObject *__pyx_n_s_step;
-  PyObject *__pyx_n_s_stop;
-  PyObject *__pyx_kp_s_strided_and_direct;
-  PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
-  PyObject *__pyx_kp_s_strided_and_indirect;
-  PyObject *__pyx_kp_s_stringsource;
-  PyObject *__pyx_n_s_struct;
-  PyObject *__pyx_n_s_sys;
-  PyObject *__pyx_n_s_test;
-  PyObject *__pyx_n_s_throw;
-  PyObject *__pyx_kp_s_unable_to_allocate_array_data;
-  PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
-  PyObject *__pyx_n_s_unpack;
-  PyObject *__pyx_n_s_update;
-  PyObject *__pyx_n_s_version_info;
-  PyObject *__pyx_int_0;
-  PyObject *__pyx_int_1;
-  PyObject *__pyx_int_3;
-  PyObject *__pyx_int_112105877;
-  PyObject *__pyx_int_136983863;
-  PyObject *__pyx_int_184977713;
-  PyObject *__pyx_int_neg_1;
-  PyObject *__pyx_slice__5;
-  PyObject *__pyx_tuple__4;
-  PyObject *__pyx_tuple__8;
-  PyObject *__pyx_tuple__10;
-  PyObject *__pyx_tuple__11;
-  PyObject *__pyx_tuple__12;
-  PyObject *__pyx_tuple__13;
-  PyObject *__pyx_tuple__14;
-  PyObject *__pyx_tuple__15;
-  PyObject *__pyx_tuple__16;
-  PyObject *__pyx_tuple__17;
-  PyObject *__pyx_tuple__18;
-  PyObject *__pyx_tuple__19;
-  PyObject *__pyx_tuple__21;
-  PyObject *__pyx_codeobj__9;
-  PyObject *__pyx_codeobj__20;
-} __pyx_mstate;
+static PyObject *__pyx_int_0;
+static PyObject *__pyx_int_1;
+static PyObject *__pyx_int_184977713;
+static PyObject *__pyx_int_neg_1;
+static PyObject *__pyx_tuple_;
+static PyObject *__pyx_tuple__2;
+static PyObject *__pyx_tuple__3;
+static PyObject *__pyx_tuple__4;
+static PyObject *__pyx_tuple__5;
+static PyObject *__pyx_tuple__6;
+static PyObject *__pyx_tuple__7;
+static PyObject *__pyx_tuple__8;
+static PyObject *__pyx_tuple__9;
+static PyObject *__pyx_slice__15;
+static PyObject *__pyx_tuple__10;
+static PyObject *__pyx_tuple__11;
+static PyObject *__pyx_tuple__12;
+static PyObject *__pyx_tuple__13;
+static PyObject *__pyx_tuple__14;
+static PyObject *__pyx_tuple__16;
+static PyObject *__pyx_tuple__17;
+static PyObject *__pyx_tuple__18;
+static PyObject *__pyx_tuple__19;
+static PyObject *__pyx_tuple__21;
+static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
+static PyObject *__pyx_tuple__24;
+static PyObject *__pyx_tuple__25;
+static PyObject *__pyx_tuple__26;
+static PyObject *__pyx_codeobj__20;
+static PyObject *__pyx_codeobj__27;
+/* Late includes */
+
+/* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
+ * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
+ */
 
-#if CYTHON_USE_MODULE_STATE
-#ifdef __cplusplus
-namespace {
-  extern struct PyModuleDef __pyx_moduledef;
-} /* anonymous namespace */
-#else
-static struct PyModuleDef __pyx_moduledef;
-#endif
+/* Python wrapper */
+static PyObject *__pyx_pw_7chython_10containers_7_unpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data); /*proto*/
+static PyMethodDef __pyx_mdef_7chython_10containers_7_unpack_1unpack = {"unpack", (PyCFunction)__pyx_pw_7chython_10containers_7_unpack_1unpack, METH_O, 0};
+static PyObject *__pyx_pw_7chython_10containers_7_unpack_1unpack(PyObject *__pyx_self, PyObject *__pyx_arg_data) {
+  __Pyx_memviewslice __pyx_v_data = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("unpack (wrapper)", 0);
+  assert(__pyx_arg_data); {
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(__pyx_arg_data, 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 25, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("chython.containers._unpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(((PyObject *)__pyx_v_data.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "data"); __PYX_ERR(0, 25, __pyx_L1_error)
+  }
+  __pyx_r = __pyx_pf_7chython_10containers_7_unpack_unpack(__pyx_self, __pyx_v_data);
 
-#define __pyx_mstate(o) ((__pyx_mstate *)__Pyx_PyModule_GetState(o))
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-#define __pyx_mstate_global (__pyx_mstate(PyState_FindModule(&__pyx_moduledef)))
+static PyObject *__pyx_pf_7chython_10containers_7_unpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data) {
+  int __pyx_v_isotope_shift;
+  unsigned char __pyx_v_a;
+  unsigned char __pyx_v_b;
+  unsigned char __pyx_v_c;
+  unsigned char __pyx_v_d;
+  unsigned int __pyx_v_na;
+  unsigned int __pyx_v_nct;
+  unsigned int __pyx_v_i;
+  unsigned int __pyx_v_j;
+  unsigned int __pyx_v_n;
+  unsigned int __pyx_v_m;
+  unsigned int __pyx_v_pack_length;
+  unsigned int __pyx_v_shift;
+  unsigned int __pyx_v_order_shift;
+  unsigned int __pyx_v_nb;
+  unsigned int __pyx_v_mapping[0xFFF];
+  unsigned int __pyx_v_atom[0xFFF];
+  unsigned int __pyx_v_isotopes[0xFFF];
+  unsigned int __pyx_v_hydrogens[0xFFF];
+  unsigned int __pyx_v_neighbors[0xFFF];
+  unsigned int __pyx_v_orders[0xFFF];
+  unsigned int __pyx_v_cis_trans_1[0xFFF];
+  unsigned int __pyx_v_cis_trans_2[0xFFF];
+  unsigned int __pyx_v_connections[0x1FFE];
+  int __pyx_v_charges[0xFFF];
+  int __pyx_v_radicals[0xFFF];
+  int __pyx_v_is_tet[0xFFF];
+  int __pyx_v_is_all[0xFFF];
+  int __pyx_v_tet_sign[0xFFF];
+  int __pyx_v_all_sign[0xFFF];
+  int __pyx_v_ct_sign[0xFFF];
+  double __pyx_v_x[0xFFF];
+  double __pyx_v_y[0xFFF];
+  int __pyx_v_seen[0x1000];
+  PyObject *__pyx_v_bond = 0;
+  PyObject *__pyx_v_py_charges = 0;
+  PyObject *__pyx_v_py_radicals = 0;
+  PyObject *__pyx_v_py_hydrogens = 0;
+  PyObject *__pyx_v_py_plane = 0;
+  PyObject *__pyx_v_py_bonds = 0;
+  PyObject *__pyx_v_tmp = 0;
+  PyObject *__pyx_v_py_atoms_stereo = 0;
+  PyObject *__pyx_v_py_allenes_stereo = 0;
+  PyObject *__pyx_v_py_cis_trans_stereo = 0;
+  PyObject *__pyx_v_py_mapping = 0;
+  PyObject *__pyx_v_py_atoms = 0;
+  PyObject *__pyx_v_py_isotopes = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  Py_ssize_t __pyx_t_1;
+  unsigned char __pyx_t_2;
+  unsigned char __pyx_t_3;
+  unsigned char __pyx_t_4;
+  unsigned int __pyx_t_5;
+  unsigned int __pyx_t_6;
+  unsigned int __pyx_t_7;
+  size_t __pyx_t_8;
+  long __pyx_t_9;
+  int __pyx_t_10;
+  long __pyx_t_11;
+  unsigned char __pyx_t_12;
+  PyObject *__pyx_t_13 = NULL;
+  int __pyx_t_14;
+  PyObject *__pyx_t_15 = NULL;
+  PyObject *__pyx_t_16 = NULL;
+  unsigned int __pyx_t_17;
+  unsigned int __pyx_t_18;
+  unsigned int __pyx_t_19;
+  PyObject *__pyx_t_20 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("unpack", 0);
 
-#define __pyx_m (PyState_FindModule(&__pyx_moduledef))
-#else
-static __pyx_mstate __pyx_mstate_global_static =
-#ifdef __cplusplus
-    {};
-#else
-    {0};
-#endif
-static __pyx_mstate *__pyx_mstate_global = &__pyx_mstate_global_static;
-#endif
-/* #### Code section: module_state_clear ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_clear(PyObject *m) {
-  __pyx_mstate *clear_module_state = __pyx_mstate(m);
-  if (!clear_module_state) return 0;
-  Py_CLEAR(clear_module_state->__pyx_d);
-  Py_CLEAR(clear_module_state->__pyx_b);
-  Py_CLEAR(clear_module_state->__pyx_cython_runtime);
-  Py_CLEAR(clear_module_state->__pyx_empty_tuple);
-  Py_CLEAR(clear_module_state->__pyx_empty_bytes);
-  Py_CLEAR(clear_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_FusedFunctionType);
-  #endif
-  Py_CLEAR(clear_module_state->__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping);
-  Py_CLEAR(clear_module_state->__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping);
-  Py_CLEAR(clear_module_state->__pyx_array_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_array);
-  Py_CLEAR(clear_module_state->__pyx_MemviewEnum_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_MemviewEnum);
-  Py_CLEAR(clear_module_state->__pyx_memoryview_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryview);
-  Py_CLEAR(clear_module_state->__pyx_memoryviewslice_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryviewslice);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ASCII);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_AssertionError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Cannot_index_with_type);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Ellipsis);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
-  Py_CLEAR(clear_module_state->__pyx_n_s_IndexError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_shape_in_axis);
-  Py_CLEAR(clear_module_state->__pyx_n_s_MemoryError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_CLEAR(clear_module_state->__pyx_n_b_O);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-  Py_CLEAR(clear_module_state->__pyx_n_s_PickleError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Sequence);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_CLEAR(clear_module_state->__pyx_n_s_TypeError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ValueError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_View_MemoryView);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__2);
-  Py_CLEAR(clear_module_state->__pyx_n_s__22);
-  Py_CLEAR(clear_module_state->__pyx_n_s__3);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__6);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__7);
-  Py_CLEAR(clear_module_state->__pyx_n_s_abc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_allocate_buffer);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_and);
-  Py_CLEAR(clear_module_state->__pyx_n_s_args);
-  Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_CLEAR(clear_module_state->__pyx_n_s_back);
-  Py_CLEAR(clear_module_state->__pyx_n_s_base);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c);
-  Py_CLEAR(clear_module_state->__pyx_n_u_c);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c_bond);
-  Py_CLEAR(clear_module_state->__pyx_n_s_chython_algorithms__isomorphism);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_chython_algorithms__isomorphism_2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_class);
-  Py_CLEAR(clear_module_state->__pyx_n_s_class_getitem);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
-  Py_CLEAR(clear_module_state->__pyx_n_s_close);
-  Py_CLEAR(clear_module_state->__pyx_n_s_closures_counter);
-  Py_CLEAR(clear_module_state->__pyx_n_s_closures_num);
-  Py_CLEAR(clear_module_state->__pyx_n_s_collections);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_collections_abc);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_direct);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_indirect);
-  Py_CLEAR(clear_module_state->__pyx_n_s_count);
-  Py_CLEAR(clear_module_state->__pyx_n_s_depth);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dict);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dtype_is_object);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_encode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_enumerate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_error);
-  Py_CLEAR(clear_module_state->__pyx_n_s_flags);
-  Py_CLEAR(clear_module_state->__pyx_n_s_format);
-  Py_CLEAR(clear_module_state->__pyx_n_s_fortran);
-  Py_CLEAR(clear_module_state->__pyx_n_u_fortran);
-  Py_CLEAR(clear_module_state->__pyx_n_s_front);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_gc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_get_mapping);
-  Py_CLEAR(clear_module_state->__pyx_n_s_getstate);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_got);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_i);
-  Py_CLEAR(clear_module_state->__pyx_n_s_id);
-  Py_CLEAR(clear_module_state->__pyx_n_s_import);
-  Py_CLEAR(clear_module_state->__pyx_n_s_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_initializing);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_coroutine);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_isenabled);
-  Py_CLEAR(clear_module_state->__pyx_n_s_itemsize);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
-  Py_CLEAR(clear_module_state->__pyx_n_s_j);
-  Py_CLEAR(clear_module_state->__pyx_n_s_m);
-  Py_CLEAR(clear_module_state->__pyx_n_s_main);
-  Py_CLEAR(clear_module_state->__pyx_n_s_mapping);
-  Py_CLEAR(clear_module_state->__pyx_n_s_matched);
-  Py_CLEAR(clear_module_state->__pyx_n_s_memview);
-  Py_CLEAR(clear_module_state->__pyx_n_s_mode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n);
-  Py_CLEAR(clear_module_state->__pyx_n_s_name);
-  Py_CLEAR(clear_module_state->__pyx_n_s_name_2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ndim);
-  Py_CLEAR(clear_module_state->__pyx_n_s_new);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bits1);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bits2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bits3);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bits4);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bond);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_bonds);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_closures);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_from);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_indices);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_numbers);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_o_to);
-  Py_CLEAR(clear_module_state->__pyx_n_s_obj);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_path);
-  Py_CLEAR(clear_module_state->__pyx_n_s_path_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pickle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_PickleError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_checksum);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_result);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_state);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_type);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_unpickle_Enum);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_vtable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_back);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_bonds);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_closures);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_from);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_indices);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_mask1);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_mask2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_mask3);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_mask4);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_masks1);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_masks2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_masks3);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_masks4);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_numbers);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_size_dec);
-  Py_CLEAR(clear_module_state->__pyx_n_s_q_to);
-  Py_CLEAR(clear_module_state->__pyx_n_s_range);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_ex);
-  Py_CLEAR(clear_module_state->__pyx_n_s_register);
-  Py_CLEAR(clear_module_state->__pyx_n_s_scope);
-  Py_CLEAR(clear_module_state->__pyx_n_s_send);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_shape);
-  Py_CLEAR(clear_module_state->__pyx_n_s_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_spec);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stack_depth);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stack_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_start);
-  Py_CLEAR(clear_module_state->__pyx_n_s_step);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stop);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_indirect);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_stringsource);
-  Py_CLEAR(clear_module_state->__pyx_n_s_struct);
-  Py_CLEAR(clear_module_state->__pyx_n_s_sys);
-  Py_CLEAR(clear_module_state->__pyx_n_s_test);
-  Py_CLEAR(clear_module_state->__pyx_n_s_throw);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_array_data);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
-  Py_CLEAR(clear_module_state->__pyx_n_s_unpack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_update);
-  Py_CLEAR(clear_module_state->__pyx_n_s_version_info);
-  Py_CLEAR(clear_module_state->__pyx_int_0);
-  Py_CLEAR(clear_module_state->__pyx_int_1);
-  Py_CLEAR(clear_module_state->__pyx_int_3);
-  Py_CLEAR(clear_module_state->__pyx_int_112105877);
-  Py_CLEAR(clear_module_state->__pyx_int_136983863);
-  Py_CLEAR(clear_module_state->__pyx_int_184977713);
-  Py_CLEAR(clear_module_state->__pyx_int_neg_1);
-  Py_CLEAR(clear_module_state->__pyx_slice__5);
-  Py_CLEAR(clear_module_state->__pyx_tuple__4);
-  Py_CLEAR(clear_module_state->__pyx_tuple__8);
-  Py_CLEAR(clear_module_state->__pyx_tuple__10);
-  Py_CLEAR(clear_module_state->__pyx_tuple__11);
-  Py_CLEAR(clear_module_state->__pyx_tuple__12);
-  Py_CLEAR(clear_module_state->__pyx_tuple__13);
-  Py_CLEAR(clear_module_state->__pyx_tuple__14);
-  Py_CLEAR(clear_module_state->__pyx_tuple__15);
-  Py_CLEAR(clear_module_state->__pyx_tuple__16);
-  Py_CLEAR(clear_module_state->__pyx_tuple__17);
-  Py_CLEAR(clear_module_state->__pyx_tuple__18);
-  Py_CLEAR(clear_module_state->__pyx_tuple__19);
-  Py_CLEAR(clear_module_state->__pyx_tuple__21);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__9);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__20);
-  return 0;
+  /* "chython/containers/_unpack.pyx":28
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
+ *     cdef unsigned int na, nct, i, j, n, m, pack_length, shift = 4, order_shift = 0, nb = 0             # <<<<<<<<<<<<<<
+ * 
+ *     cdef unsigned int[4095] mapping, atom, isotopes, hydrogens, neighbors, orders, cis_trans_1, cis_trans_2
+ */
+  __pyx_v_shift = 4;
+  __pyx_v_order_shift = 0;
+  __pyx_v_nb = 0;
+
+  /* "chython/containers/_unpack.pyx":43
+ * 
+ *     # lets extract data
+ *     a, b, c = data[1], data[2], data[3]             # <<<<<<<<<<<<<<
+ *     na = a << 4| (b & 0xf0) >> 4
+ *     nct = (b & 0x0f) << 8 | c
+ */
+  __pyx_t_1 = 1;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_t_1 = 2;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_t_1 = 3;
+  if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+  __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+  __pyx_v_a = __pyx_t_2;
+  __pyx_v_b = __pyx_t_3;
+  __pyx_v_c = __pyx_t_4;
+
+  /* "chython/containers/_unpack.pyx":44
+ *     # lets extract data
+ *     a, b, c = data[1], data[2], data[3]
+ *     na = a << 4| (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *     nct = (b & 0x0f) << 8 | c
+ * 
+ */
+  __pyx_v_na = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+
+  /* "chython/containers/_unpack.pyx":45
+ *     a, b, c = data[1], data[2], data[3]
+ *     na = a << 4| (b & 0xf0) >> 4
+ *     nct = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(na):
+ */
+  __pyx_v_nct = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
+
+  /* "chython/containers/_unpack.pyx":47
+ *     nct = (b & 0x0f) << 8 | c
+ * 
+ *     for i in range(na):             # <<<<<<<<<<<<<<
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ */
+  __pyx_t_5 = __pyx_v_na;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":48
+ * 
+ *     for i in range(na):
+ *         a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":49
+ *     for i in range(na):
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f
+ */
+    __pyx_t_9 = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+    (__pyx_v_mapping[__pyx_v_i]) = __pyx_t_9;
+    __pyx_v_n = __pyx_t_9;
+
+    /* "chython/containers/_unpack.pyx":50
+ *         a, b = data[shift], data[shift + 1]
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False             # <<<<<<<<<<<<<<
+ *         neighbors[i] = b & 0x0f
+ *         nb += b & 0x0f
+ */
+    (__pyx_v_seen[__pyx_v_n]) = 0;
+
+    /* "chython/containers/_unpack.pyx":51
+ *         mapping[i] = n = a << 4 | (b & 0xf0) >> 4
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f             # <<<<<<<<<<<<<<
+ *         nb += b & 0x0f
+ * 
+ */
+    (__pyx_v_neighbors[__pyx_v_i]) = (__pyx_v_b & 0x0f);
+
+    /* "chython/containers/_unpack.pyx":52
+ *         seen[n] = False
+ *         neighbors[i] = b & 0x0f
+ *         nb += b & 0x0f             # <<<<<<<<<<<<<<
+ * 
+ *         a, b = data[shift + 2], data[shift + 3]
+ */
+    __pyx_v_nb = (__pyx_v_nb + (__pyx_v_b & 0x0f));
+
+    /* "chython/containers/_unpack.pyx":54
+ *         nb += b & 0x0f
+ * 
+ *         a, b = data[shift + 2], data[shift + 3]             # <<<<<<<<<<<<<<
+ *         if a & 0x80:
+ *             is_tet[i] = True
+ */
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 3);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_4;
+
+    /* "chython/containers/_unpack.pyx":55
+ * 
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:             # <<<<<<<<<<<<<<
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40
+ */
+    __pyx_t_10 = ((__pyx_v_a & 0x80) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":56
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:
+ *             is_tet[i] = True             # <<<<<<<<<<<<<<
+ *             tet_sign[i] = a & 0x40
+ *         else:
+ */
+      (__pyx_v_is_tet[__pyx_v_i]) = 1;
+
+      /* "chython/containers/_unpack.pyx":57
+ *         if a & 0x80:
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40             # <<<<<<<<<<<<<<
+ *         else:
+ *             is_tet[i] = False
+ */
+      (__pyx_v_tet_sign[__pyx_v_i]) = (__pyx_v_a & 0x40);
+
+      /* "chython/containers/_unpack.pyx":55
+ * 
+ *         a, b = data[shift + 2], data[shift + 3]
+ *         if a & 0x80:             # <<<<<<<<<<<<<<
+ *             is_tet[i] = True
+ *             tet_sign[i] = a & 0x40
+ */
+      goto __pyx_L5;
+    }
+
+    /* "chython/containers/_unpack.pyx":59
+ *             tet_sign[i] = a & 0x40
+ *         else:
+ *             is_tet[i] = False             # <<<<<<<<<<<<<<
+ *         if a & 0x20:
+ *             is_all[i] = True
+ */
+    /*else*/ {
+      (__pyx_v_is_tet[__pyx_v_i]) = 0;
+    }
+    __pyx_L5:;
+
+    /* "chython/containers/_unpack.pyx":60
+ *         else:
+ *             is_tet[i] = False
+ *         if a & 0x20:             # <<<<<<<<<<<<<<
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10
+ */
+    __pyx_t_10 = ((__pyx_v_a & 0x20) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":61
+ *             is_tet[i] = False
+ *         if a & 0x20:
+ *             is_all[i] = True             # <<<<<<<<<<<<<<
+ *             all_sign[i] = a & 0x10
+ *         else:
+ */
+      (__pyx_v_is_all[__pyx_v_i]) = 1;
+
+      /* "chython/containers/_unpack.pyx":62
+ *         if a & 0x20:
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10             # <<<<<<<<<<<<<<
+ *         else:
+ *             is_all[i] = False
+ */
+      (__pyx_v_all_sign[__pyx_v_i]) = (__pyx_v_a & 0x10);
+
+      /* "chython/containers/_unpack.pyx":60
+ *         else:
+ *             is_tet[i] = False
+ *         if a & 0x20:             # <<<<<<<<<<<<<<
+ *             is_all[i] = True
+ *             all_sign[i] = a & 0x10
+ */
+      goto __pyx_L6;
+    }
+
+    /* "chython/containers/_unpack.pyx":64
+ *             all_sign[i] = a & 0x10
+ *         else:
+ *             is_all[i] = False             # <<<<<<<<<<<<<<
+ * 
+ *         atom[i] = b & 0x7f
+ */
+    /*else*/ {
+      (__pyx_v_is_all[__pyx_v_i]) = 0;
+    }
+    __pyx_L6:;
+
+    /* "chython/containers/_unpack.pyx":66
+ *             is_all[i] = False
+ * 
+ *         atom[i] = b & 0x7f             # <<<<<<<<<<<<<<
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:
+ */
+    (__pyx_v_atom[__pyx_v_i]) = (__pyx_v_b & 0x7f);
+
+    /* "chython/containers/_unpack.pyx":67
+ * 
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7             # <<<<<<<<<<<<<<
+ *         if isotope_shift:
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
+ */
+    __pyx_v_isotope_shift = (((__pyx_v_a & 0x0f) << 1) | (__pyx_v_b >> 7));
+
+    /* "chython/containers/_unpack.pyx":68
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:             # <<<<<<<<<<<<<<
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
+ *         else:
+ */
+    __pyx_t_10 = (__pyx_v_isotope_shift != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":69
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift             # <<<<<<<<<<<<<<
+ *         else:
+ *             isotopes[i] = 0
+ */
+      (__pyx_v_isotopes[__pyx_v_i]) = ((__pyx_v_7chython_10containers_7_unpack_common_isotopes[(__pyx_v_b & 0x7f)]) + __pyx_v_isotope_shift);
+
+      /* "chython/containers/_unpack.pyx":68
+ *         atom[i] = b & 0x7f
+ *         isotope_shift = (a & 0x0f) << 1 | b >> 7
+ *         if isotope_shift:             # <<<<<<<<<<<<<<
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
+ *         else:
+ */
+      goto __pyx_L7;
+    }
+
+    /* "chython/containers/_unpack.pyx":71
+ *             isotopes[i] = common_isotopes[b & 0x7f] + isotope_shift
+ *         else:
+ *             isotopes[i] = 0             # <<<<<<<<<<<<<<
+ * 
+ *         a, b = data[shift + 4], data[shift + 5]
+ */
+    /*else*/ {
+      (__pyx_v_isotopes[__pyx_v_i]) = 0;
+    }
+    __pyx_L7:;
+
+    /* "chython/containers/_unpack.pyx":73
+ *             isotopes[i] = 0
+ * 
+ *         a, b = data[shift + 4], data[shift + 5]             # <<<<<<<<<<<<<<
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]
+ */
+    __pyx_t_1 = (__pyx_v_shift + 4);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 5);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":74
+ * 
+ *         a, b = data[shift + 4], data[shift + 5]
+ *         x[i] = double_from2bytes(a, b)             # <<<<<<<<<<<<<<
+ *         a, b = data[shift + 6], data[shift + 7]
+ *         y[i] = double_from2bytes(a, b)
+ */
+    (__pyx_v_x[__pyx_v_i]) = __pyx_f_7chython_10containers_7_unpack_double_from2bytes(__pyx_v_a, __pyx_v_b);
+
+    /* "chython/containers/_unpack.pyx":75
+ *         a, b = data[shift + 4], data[shift + 5]
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]             # <<<<<<<<<<<<<<
+ *         y[i] = double_from2bytes(a, b)
+ * 
+ */
+    __pyx_t_1 = (__pyx_v_shift + 6);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 7);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_4;
+
+    /* "chython/containers/_unpack.pyx":76
+ *         x[i] = double_from2bytes(a, b)
+ *         a, b = data[shift + 6], data[shift + 7]
+ *         y[i] = double_from2bytes(a, b)             # <<<<<<<<<<<<<<
+ * 
+ *         a = data[shift + 8]
+ */
+    (__pyx_v_y[__pyx_v_i]) = __pyx_f_7chython_10containers_7_unpack_double_from2bytes(__pyx_v_a, __pyx_v_b);
+
+    /* "chython/containers/_unpack.pyx":78
+ *         y[i] = double_from2bytes(a, b)
+ * 
+ *         a = data[shift + 8]             # <<<<<<<<<<<<<<
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
+ */
+    __pyx_t_1 = (__pyx_v_shift + 8);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+
+    /* "chython/containers/_unpack.pyx":79
+ * 
+ *         a = data[shift + 8]
+ *         hydrogens[i] = a >> 5             # <<<<<<<<<<<<<<
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
+ *         radicals[i] = a & 0x01
+ */
+    (__pyx_v_hydrogens[__pyx_v_i]) = (__pyx_v_a >> 5);
+
+    /* "chython/containers/_unpack.pyx":80
+ *         a = data[shift + 8]
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4             # <<<<<<<<<<<<<<
+ *         radicals[i] = a & 0x01
+ * 
+ */
+    (__pyx_v_charges[__pyx_v_i]) = (((__pyx_v_a >> 1) & 0x0f) - 4);
+
+    /* "chython/containers/_unpack.pyx":81
+ *         hydrogens[i] = a >> 5
+ *         charges[i] = ((a >> 1) & 0x0f) - 4
+ *         radicals[i] = a & 0x01             # <<<<<<<<<<<<<<
+ * 
+ *         shift += 9
+ */
+    (__pyx_v_radicals[__pyx_v_i]) = (__pyx_v_a & 0x01);
+
+    /* "chython/containers/_unpack.pyx":83
+ *         radicals[i] = a & 0x01
+ * 
+ *         shift += 9             # <<<<<<<<<<<<<<
+ * 
+ *     nb //= 2
+ */
+    __pyx_v_shift = (__pyx_v_shift + 9);
+  }
+
+  /* "chython/containers/_unpack.pyx":85
+ *         shift += 9
+ * 
+ *     nb //= 2             # <<<<<<<<<<<<<<
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ */
+  __pyx_v_nb = __Pyx_div_long(__pyx_v_nb, 2);
+
+  /* "chython/containers/_unpack.pyx":86
+ * 
+ *     nb //= 2
+ *     for i in range(nb):             # <<<<<<<<<<<<<<
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ */
+  __pyx_t_5 = __pyx_v_nb;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":87
+ *     nb //= 2
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]             # <<<<<<<<<<<<<<
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_4;
+    __pyx_v_b = __pyx_t_3;
+    __pyx_v_c = __pyx_t_2;
+
+    /* "chython/containers/_unpack.pyx":88
+ *     for i in range(nb):
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
+ *         shift += 3
+ */
+    (__pyx_v_connections[(__pyx_v_i * 2)]) = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+
+    /* "chython/containers/_unpack.pyx":89
+ *         a, b, c = data[shift], data[shift + 1], data[shift + 2]
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ *         shift += 3
+ * 
+ */
+    (__pyx_v_connections[((__pyx_v_i * 2) + 1)]) = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
+
+    /* "chython/containers/_unpack.pyx":90
+ *         connections[i * 2] = a << 4| (b & 0xf0) >> 4
+ *         connections[i * 2 + 1] = (b & 0x0f) << 8 | c
+ *         shift += 3             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
+ */
+    __pyx_v_shift = (__pyx_v_shift + 3);
+  }
+
+  /* "chython/containers/_unpack.pyx":92
+ *         shift += 3
+ * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):             # <<<<<<<<<<<<<<
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1
+ */
+  if ((__Pyx_mod_long(__pyx_v_nb, 5) != 0)) {
+    __pyx_t_9 = (__Pyx_div_long(__pyx_v_nb, 5) + 1);
+  } else {
+    __pyx_t_9 = __Pyx_div_long(__pyx_v_nb, 5);
+  }
+  __pyx_t_11 = __pyx_t_9;
+  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_11; __pyx_t_5+=1) {
+    __pyx_v_i = __pyx_t_5;
+
+    /* "chython/containers/_unpack.pyx":93
+ * 
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
+ *         a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_2;
+    __pyx_v_b = __pyx_t_3;
+
+    /* "chython/containers/_unpack.pyx":94
+ *     for i in range((nb // 5 + 1) if nb % 5 else (nb // 5)):
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ */
+    (__pyx_v_orders[(__pyx_v_i * 5)]) = ((__pyx_v_a >> 4) + 1);
+
+    /* "chython/containers/_unpack.pyx":95
+ *         a, b = data[shift], data[shift + 1]
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 1)]) = (((__pyx_v_a >> 1) & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":96
+ *         orders[i * 5] = (a >> 4) + 1
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 2)]) = ((((__pyx_v_a & 0x01) << 2) | (__pyx_v_b >> 6)) + 1);
+
+    /* "chython/containers/_unpack.pyx":97
+ *         orders[i * 5 + 1] = ((a >> 1) & 0x07) + 1
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ *         shift += 2
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 3)]) = (((__pyx_v_b >> 3) & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":98
+ *         orders[i * 5 + 2] = ((a & 0x01) << 2 | b >> 6) + 1
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1             # <<<<<<<<<<<<<<
+ *         shift += 2
+ * 
+ */
+    (__pyx_v_orders[((__pyx_v_i * 5) + 4)]) = ((__pyx_v_b & 0x07) + 1);
+
+    /* "chython/containers/_unpack.pyx":99
+ *         orders[i * 5 + 3] = ((b >> 3) & 0x07) + 1
+ *         orders[i * 5 + 4] = (b & 0x07) + 1
+ *         shift += 2             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(nct):
+ */
+    __pyx_v_shift = (__pyx_v_shift + 2);
+  }
+
+  /* "chython/containers/_unpack.pyx":101
+ *         shift += 2
+ * 
+ *     for i in range(nct):             # <<<<<<<<<<<<<<
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ */
+  __pyx_t_5 = __pyx_v_nct;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":102
+ * 
+ *     for i in range(nct):
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]             # <<<<<<<<<<<<<<
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ */
+    __pyx_t_8 = __pyx_v_shift;
+    __pyx_t_3 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_8)) )));
+    __pyx_t_1 = (__pyx_v_shift + 1);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_2 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 2);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_4 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_t_1 = (__pyx_v_shift + 3);
+    if (__pyx_t_1 < 0) __pyx_t_1 += __pyx_v_data.shape[0];
+    __pyx_t_12 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_1)) )));
+    __pyx_v_a = __pyx_t_3;
+    __pyx_v_b = __pyx_t_2;
+    __pyx_v_c = __pyx_t_4;
+    __pyx_v_d = __pyx_t_12;
+
+    /* "chython/containers/_unpack.pyx":103
+ *     for i in range(nct):
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4             # <<<<<<<<<<<<<<
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01
+ */
+    (__pyx_v_cis_trans_1[__pyx_v_i]) = ((__pyx_v_a << 4) | ((__pyx_v_b & 0xf0) >> 4));
+
+    /* "chython/containers/_unpack.pyx":104
+ *         a, b, c, d = data[shift], data[shift + 1], data[shift + 2], data[shift + 3]
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c             # <<<<<<<<<<<<<<
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4
+ */
+    (__pyx_v_cis_trans_2[__pyx_v_i]) = (((__pyx_v_b & 0x0f) << 8) | __pyx_v_c);
+
+    /* "chython/containers/_unpack.pyx":105
+ *         cis_trans_1[i] = a << 4 | (b & 0xf0) >> 4
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01             # <<<<<<<<<<<<<<
+ *         shift += 4
+ *     pack_length = shift
+ */
+    (__pyx_v_ct_sign[__pyx_v_i]) = (__pyx_v_d & 0x01);
+
+    /* "chython/containers/_unpack.pyx":106
+ *         cis_trans_2[i] = (b & 0x0f) << 8 | c
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4             # <<<<<<<<<<<<<<
+ *     pack_length = shift
+ * 
+ */
+    __pyx_v_shift = (__pyx_v_shift + 4);
+  }
+
+  /* "chython/containers/_unpack.pyx":107
+ *         ct_sign[i] = d & 0x01
+ *         shift += 4
+ *     pack_length = shift             # <<<<<<<<<<<<<<
+ * 
+ *     # define returned data
+ */
+  __pyx_v_pack_length = __pyx_v_shift;
+
+  /* "chython/containers/_unpack.pyx":110
+ * 
+ *     # define returned data
+ *     py_mapping = []             # <<<<<<<<<<<<<<
+ *     py_atoms = []
+ *     py_isotopes = []
+ */
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 110, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_mapping = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":111
+ *     # define returned data
+ *     py_mapping = []
+ *     py_atoms = []             # <<<<<<<<<<<<<<
+ *     py_isotopes = []
+ *     py_bonds = {}
+ */
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 111, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_atoms = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":112
+ *     py_mapping = []
+ *     py_atoms = []
+ *     py_isotopes = []             # <<<<<<<<<<<<<<
+ *     py_bonds = {}
+ *     py_charges = {}
+ */
+  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 112, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_isotopes = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":113
+ *     py_atoms = []
+ *     py_isotopes = []
+ *     py_bonds = {}             # <<<<<<<<<<<<<<
+ *     py_charges = {}
+ *     py_radicals = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 113, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_bonds = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":114
+ *     py_isotopes = []
+ *     py_bonds = {}
+ *     py_charges = {}             # <<<<<<<<<<<<<<
+ *     py_radicals = {}
+ *     py_hydrogens = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 114, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_charges = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":115
+ *     py_bonds = {}
+ *     py_charges = {}
+ *     py_radicals = {}             # <<<<<<<<<<<<<<
+ *     py_hydrogens = {}
+ *     py_plane = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 115, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_radicals = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":116
+ *     py_charges = {}
+ *     py_radicals = {}
+ *     py_hydrogens = {}             # <<<<<<<<<<<<<<
+ *     py_plane = {}
+ *     py_atoms_stereo = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 116, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_hydrogens = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":117
+ *     py_radicals = {}
+ *     py_hydrogens = {}
+ *     py_plane = {}             # <<<<<<<<<<<<<<
+ *     py_atoms_stereo = {}
+ *     py_allenes_stereo = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 117, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_plane = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":118
+ *     py_hydrogens = {}
+ *     py_plane = {}
+ *     py_atoms_stereo = {}             # <<<<<<<<<<<<<<
+ *     py_allenes_stereo = {}
+ *     py_cis_trans_stereo = {}
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_atoms_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":119
+ *     py_plane = {}
+ *     py_atoms_stereo = {}
+ *     py_allenes_stereo = {}             # <<<<<<<<<<<<<<
+ *     py_cis_trans_stereo = {}
+ * 
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 119, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_allenes_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":120
+ *     py_atoms_stereo = {}
+ *     py_allenes_stereo = {}
+ *     py_cis_trans_stereo = {}             # <<<<<<<<<<<<<<
+ * 
+ *     shift = 0
+ */
+  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_13);
+  __pyx_v_py_cis_trans_stereo = ((PyObject*)__pyx_t_13);
+  __pyx_t_13 = 0;
+
+  /* "chython/containers/_unpack.pyx":122
+ *     py_cis_trans_stereo = {}
+ * 
+ *     shift = 0             # <<<<<<<<<<<<<<
+ *     for i in range(na):
+ *         n = mapping[i]
+ */
+  __pyx_v_shift = 0;
+
+  /* "chython/containers/_unpack.pyx":123
+ * 
+ *     shift = 0
+ *     for i in range(na):             # <<<<<<<<<<<<<<
+ *         n = mapping[i]
+ * 
+ */
+  __pyx_t_5 = __pyx_v_na;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":124
+ *     shift = 0
+ *     for i in range(na):
+ *         n = mapping[i]             # <<<<<<<<<<<<<<
+ * 
+ *         # fill intermediate data
+ */
+    __pyx_v_n = (__pyx_v_mapping[__pyx_v_i]);
+
+    /* "chython/containers/_unpack.pyx":127
+ * 
+ *         # fill intermediate data
+ *         py_mapping.append(n)             # <<<<<<<<<<<<<<
+ *         py_atoms.append(atom[i])
+ *         py_isotopes.append(isotopes[i] or None)
+ */
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 127, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_mapping, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 127, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":128
+ *         # fill intermediate data
+ *         py_mapping.append(n)
+ *         py_atoms.append(atom[i])             # <<<<<<<<<<<<<<
+ *         py_isotopes.append(isotopes[i] or None)
+ * 
+ */
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_atom[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 128, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_atoms, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 128, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":129
+ *         py_mapping.append(n)
+ *         py_atoms.append(atom[i])
+ *         py_isotopes.append(isotopes[i] or None)             # <<<<<<<<<<<<<<
+ * 
+ *         py_charges[n] = charges[i]
+ */
+    if (!(__pyx_v_isotopes[__pyx_v_i])) {
+    } else {
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int((__pyx_v_isotopes[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      __pyx_t_13 = __pyx_t_15;
+      __pyx_t_15 = 0;
+      goto __pyx_L16_bool_binop_done;
+    }
+    __Pyx_INCREF(Py_None);
+    __pyx_t_13 = Py_None;
+    __pyx_L16_bool_binop_done:;
+    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_isotopes, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":131
+ *         py_isotopes.append(isotopes[i] or None)
+ * 
+ *         py_charges[n] = charges[i]             # <<<<<<<<<<<<<<
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:
+ */
+    __pyx_t_13 = __Pyx_PyInt_From_int((__pyx_v_charges[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_charges, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 131, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":132
+ * 
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]             # <<<<<<<<<<<<<<
+ *         if hydrogens[i] == 7:
+ *             py_hydrogens[n] = None
+ */
+    __pyx_t_13 = __Pyx_PyBool_FromLong((__pyx_v_radicals[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_radicals, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+    /* "chython/containers/_unpack.pyx":133
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:             # <<<<<<<<<<<<<<
+ *             py_hydrogens[n] = None
+ *         else:
+ */
+    __pyx_t_10 = (((__pyx_v_hydrogens[__pyx_v_i]) == 7) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":134
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:
+ *             py_hydrogens[n] = None             # <<<<<<<<<<<<<<
+ *         else:
+ *             py_hydrogens[n] = hydrogens[i]
+ */
+      __pyx_t_13 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 134, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_13);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_t_13, Py_None) < 0)) __PYX_ERR(0, 134, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+
+      /* "chython/containers/_unpack.pyx":133
+ *         py_charges[n] = charges[i]
+ *         py_radicals[n] = radicals[i]
+ *         if hydrogens[i] == 7:             # <<<<<<<<<<<<<<
+ *             py_hydrogens[n] = None
+ *         else:
+ */
+      goto __pyx_L18;
+    }
+
+    /* "chython/containers/_unpack.pyx":136
+ *             py_hydrogens[n] = None
+ *         else:
+ *             py_hydrogens[n] = hydrogens[i]             # <<<<<<<<<<<<<<
+ *         py_plane[n] = (x[i], y[i])
+ * 
+ */
+    /*else*/ {
+      __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_hydrogens[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_13);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_t_15, __pyx_t_13) < 0)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+    }
+    __pyx_L18:;
+
+    /* "chython/containers/_unpack.pyx":137
+ *         else:
+ *             py_hydrogens[n] = hydrogens[i]
+ *         py_plane[n] = (x[i], y[i])             # <<<<<<<<<<<<<<
+ * 
+ *         if is_tet[i]:
+ */
+    __pyx_t_13 = PyFloat_FromDouble((__pyx_v_x[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_15 = PyFloat_FromDouble((__pyx_v_y[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_16 = PyTuple_New(2); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_GIVEREF(__pyx_t_13);
+    PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_13);
+    __Pyx_GIVEREF(__pyx_t_15);
+    PyTuple_SET_ITEM(__pyx_t_16, 1, __pyx_t_15);
+    __pyx_t_13 = 0;
+    __pyx_t_15 = 0;
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_plane, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 137, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+    /* "chython/containers/_unpack.pyx":139
+ *         py_plane[n] = (x[i], y[i])
+ * 
+ *         if is_tet[i]:             # <<<<<<<<<<<<<<
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
+ */
+    __pyx_t_10 = ((__pyx_v_is_tet[__pyx_v_i]) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":140
+ * 
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]             # <<<<<<<<<<<<<<
+ *         if is_all[i]:
+ *             py_allenes_stereo[n] = all_sign[i]
+ */
+      __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_tet_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_16);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_atoms_stereo, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 140, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+      /* "chython/containers/_unpack.pyx":139
+ *         py_plane[n] = (x[i], y[i])
+ * 
+ *         if is_tet[i]:             # <<<<<<<<<<<<<<
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
+ */
+    }
+
+    /* "chython/containers/_unpack.pyx":141
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:             # <<<<<<<<<<<<<<
+ *             py_allenes_stereo[n] = all_sign[i]
+ * 
+ */
+    __pyx_t_10 = ((__pyx_v_is_all[__pyx_v_i]) != 0);
+    if (__pyx_t_10) {
+
+      /* "chython/containers/_unpack.pyx":142
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:
+ *             py_allenes_stereo[n] = all_sign[i]             # <<<<<<<<<<<<<<
+ * 
+ *         tmp = {}
+ */
+      __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_all_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_16);
+      __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_15);
+      if (unlikely(PyDict_SetItem(__pyx_v_py_allenes_stereo, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 142, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+      __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+      /* "chython/containers/_unpack.pyx":141
+ *         if is_tet[i]:
+ *             py_atoms_stereo[n] = tet_sign[i]
+ *         if is_all[i]:             # <<<<<<<<<<<<<<
+ *             py_allenes_stereo[n] = all_sign[i]
+ * 
+ */
+    }
+
+    /* "chython/containers/_unpack.pyx":144
+ *             py_allenes_stereo[n] = all_sign[i]
+ * 
+ *         tmp = {}             # <<<<<<<<<<<<<<
+ *         py_bonds[n] = tmp
+ *         seen[n] = True
+ */
+    __pyx_t_16 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 144, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __Pyx_XDECREF_SET(__pyx_v_tmp, ((PyObject*)__pyx_t_16));
+    __pyx_t_16 = 0;
+
+    /* "chython/containers/_unpack.pyx":145
+ * 
+ *         tmp = {}
+ *         py_bonds[n] = tmp             # <<<<<<<<<<<<<<
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):
+ */
+    __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_n); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    if (unlikely(PyDict_SetItem(__pyx_v_py_bonds, __pyx_t_16, __pyx_v_tmp) < 0)) __PYX_ERR(0, 145, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+    /* "chython/containers/_unpack.pyx":146
+ *         tmp = {}
+ *         py_bonds[n] = tmp
+ *         seen[n] = True             # <<<<<<<<<<<<<<
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
+ */
+    (__pyx_v_seen[__pyx_v_n]) = 1;
+
+    /* "chython/containers/_unpack.pyx":147
+ *         py_bonds[n] = tmp
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):             # <<<<<<<<<<<<<<
+ *             m = connections[j]
+ *             if seen[m]:  # bond partially exists. need back-connection.
+ */
+    __pyx_t_17 = (__pyx_v_shift + (__pyx_v_neighbors[__pyx_v_i]));
+    __pyx_t_18 = __pyx_t_17;
+    for (__pyx_t_19 = __pyx_v_shift; __pyx_t_19 < __pyx_t_18; __pyx_t_19+=1) {
+      __pyx_v_j = __pyx_t_19;
+
+      /* "chython/containers/_unpack.pyx":148
+ *         seen[n] = True
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]             # <<<<<<<<<<<<<<
+ *             if seen[m]:  # bond partially exists. need back-connection.
+ *                 tmp[m] = py_bonds[m][n]
+ */
+      __pyx_v_m = (__pyx_v_connections[__pyx_v_j]);
+
+      /* "chython/containers/_unpack.pyx":149
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
+ *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
+ *                 tmp[m] = py_bonds[m][n]
+ *             else:
+ */
+      __pyx_t_10 = ((__pyx_v_seen[__pyx_v_m]) != 0);
+      if (__pyx_t_10) {
+
+        /* "chython/containers/_unpack.pyx":150
+ *             m = connections[j]
+ *             if seen[m]:  # bond partially exists. need back-connection.
+ *                 tmp[m] = py_bonds[m][n]             # <<<<<<<<<<<<<<
+ *             else:
+ *                 bond = object.__new__(Bond)
+ */
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        __pyx_t_15 = __Pyx_PyDict_GetItem(__pyx_v_py_bonds, __pyx_t_16); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_15);
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+        __pyx_t_16 = __Pyx_GetItemInt(__pyx_t_15, __pyx_v_n, unsigned int, 0, __Pyx_PyInt_From_unsigned_int, 0, 0, 0); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+        __pyx_t_15 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_15);
+        if (unlikely(PyDict_SetItem(__pyx_v_tmp, __pyx_t_15, __pyx_t_16) < 0)) __PYX_ERR(0, 150, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+        /* "chython/containers/_unpack.pyx":149
+ *         for j in range(shift, shift + neighbors[i]):
+ *             m = connections[j]
+ *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
+ *                 tmp[m] = py_bonds[m][n]
+ *             else:
+ */
+        goto __pyx_L23;
+      }
+
+      /* "chython/containers/_unpack.pyx":152
+ *                 tmp[m] = py_bonds[m][n]
+ *             else:
+ *                 bond = object.__new__(Bond)             # <<<<<<<<<<<<<<
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond
+ */
+      /*else*/ {
+        __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_builtin_object, __pyx_n_s_new); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 152, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_15);
+        __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_Bond); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 152, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_13);
+        __pyx_t_20 = NULL;
+        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_15))) {
+          __pyx_t_20 = PyMethod_GET_SELF(__pyx_t_15);
+          if (likely(__pyx_t_20)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
+            __Pyx_INCREF(__pyx_t_20);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_15, function);
+          }
+        }
+        __pyx_t_16 = (__pyx_t_20) ? __Pyx_PyObject_Call2Args(__pyx_t_15, __pyx_t_20, __pyx_t_13) : __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_t_13);
+        __Pyx_XDECREF(__pyx_t_20); __pyx_t_20 = 0;
+        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+        if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 152, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
+        __Pyx_XDECREF_SET(__pyx_v_bond, __pyx_t_16);
+        __pyx_t_16 = 0;
+
+        /* "chython/containers/_unpack.pyx":153
+ *             else:
+ *                 bond = object.__new__(Bond)
+ *                 bond._Bond__order = orders[order_shift]             # <<<<<<<<<<<<<<
+ *                 tmp[m] = bond
+ *                 order_shift += 1
+ */
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int((__pyx_v_orders[__pyx_v_order_shift])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 153, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__order, __pyx_t_16) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+        /* "chython/containers/_unpack.pyx":154
+ *                 bond = object.__new__(Bond)
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond             # <<<<<<<<<<<<<<
+ *                 order_shift += 1
+ * 
+ */
+        __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_m); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 154, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_16);
+        if (unlikely(PyDict_SetItem(__pyx_v_tmp, __pyx_t_16, __pyx_v_bond) < 0)) __PYX_ERR(0, 154, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+
+        /* "chython/containers/_unpack.pyx":155
+ *                 bond._Bond__order = orders[order_shift]
+ *                 tmp[m] = bond
+ *                 order_shift += 1             # <<<<<<<<<<<<<<
+ * 
+ *         shift += neighbors[i]
+ */
+        __pyx_v_order_shift = (__pyx_v_order_shift + 1);
+      }
+      __pyx_L23:;
+    }
+
+    /* "chython/containers/_unpack.pyx":157
+ *                 order_shift += 1
+ * 
+ *         shift += neighbors[i]             # <<<<<<<<<<<<<<
+ * 
+ *     for i in range(nct):
+ */
+    __pyx_v_shift = (__pyx_v_shift + (__pyx_v_neighbors[__pyx_v_i]));
+  }
+
+  /* "chython/containers/_unpack.pyx":159
+ *         shift += neighbors[i]
+ * 
+ *     for i in range(nct):             # <<<<<<<<<<<<<<
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
+ * 
+ */
+  __pyx_t_5 = __pyx_v_nct;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_v_i = __pyx_t_7;
+
+    /* "chython/containers/_unpack.pyx":160
+ * 
+ *     for i in range(nct):
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]             # <<<<<<<<<<<<<<
+ * 
+ *     return (py_mapping, py_atoms, py_isotopes,
+ */
+    __pyx_t_16 = __Pyx_PyBool_FromLong((__pyx_v_ct_sign[__pyx_v_i])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_16);
+    __pyx_t_15 = __Pyx_PyInt_From_unsigned_int((__pyx_v_cis_trans_1[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_15);
+    __pyx_t_13 = __Pyx_PyInt_From_unsigned_int((__pyx_v_cis_trans_2[__pyx_v_i])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_13);
+    __pyx_t_20 = PyTuple_New(2); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_20);
+    __Pyx_GIVEREF(__pyx_t_15);
+    PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_t_15);
+    __Pyx_GIVEREF(__pyx_t_13);
+    PyTuple_SET_ITEM(__pyx_t_20, 1, __pyx_t_13);
+    __pyx_t_15 = 0;
+    __pyx_t_13 = 0;
+    if (unlikely(PyDict_SetItem(__pyx_v_py_cis_trans_stereo, __pyx_t_20, __pyx_t_16) < 0)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+    __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
+  }
+
+  /* "chython/containers/_unpack.pyx":162
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
+ * 
+ *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
+ *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)
+ */
+  __Pyx_XDECREF(__pyx_r);
+
+  /* "chython/containers/_unpack.pyx":164
+ *     return (py_mapping, py_atoms, py_isotopes,
+ *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_t_16 = __Pyx_PyInt_From_unsigned_int(__pyx_v_pack_length); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_16);
+
+  /* "chython/containers/_unpack.pyx":162
+ *         py_cis_trans_stereo[(cis_trans_1[i], cis_trans_2[i])] = ct_sign[i]
+ * 
+ *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
+ *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
+ *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, pack_length)
+ */
+  __pyx_t_20 = PyTuple_New(12); if (unlikely(!__pyx_t_20)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_20);
+  __Pyx_INCREF(__pyx_v_py_mapping);
+  __Pyx_GIVEREF(__pyx_v_py_mapping);
+  PyTuple_SET_ITEM(__pyx_t_20, 0, __pyx_v_py_mapping);
+  __Pyx_INCREF(__pyx_v_py_atoms);
+  __Pyx_GIVEREF(__pyx_v_py_atoms);
+  PyTuple_SET_ITEM(__pyx_t_20, 1, __pyx_v_py_atoms);
+  __Pyx_INCREF(__pyx_v_py_isotopes);
+  __Pyx_GIVEREF(__pyx_v_py_isotopes);
+  PyTuple_SET_ITEM(__pyx_t_20, 2, __pyx_v_py_isotopes);
+  __Pyx_INCREF(__pyx_v_py_charges);
+  __Pyx_GIVEREF(__pyx_v_py_charges);
+  PyTuple_SET_ITEM(__pyx_t_20, 3, __pyx_v_py_charges);
+  __Pyx_INCREF(__pyx_v_py_radicals);
+  __Pyx_GIVEREF(__pyx_v_py_radicals);
+  PyTuple_SET_ITEM(__pyx_t_20, 4, __pyx_v_py_radicals);
+  __Pyx_INCREF(__pyx_v_py_hydrogens);
+  __Pyx_GIVEREF(__pyx_v_py_hydrogens);
+  PyTuple_SET_ITEM(__pyx_t_20, 5, __pyx_v_py_hydrogens);
+  __Pyx_INCREF(__pyx_v_py_plane);
+  __Pyx_GIVEREF(__pyx_v_py_plane);
+  PyTuple_SET_ITEM(__pyx_t_20, 6, __pyx_v_py_plane);
+  __Pyx_INCREF(__pyx_v_py_bonds);
+  __Pyx_GIVEREF(__pyx_v_py_bonds);
+  PyTuple_SET_ITEM(__pyx_t_20, 7, __pyx_v_py_bonds);
+  __Pyx_INCREF(__pyx_v_py_atoms_stereo);
+  __Pyx_GIVEREF(__pyx_v_py_atoms_stereo);
+  PyTuple_SET_ITEM(__pyx_t_20, 8, __pyx_v_py_atoms_stereo);
+  __Pyx_INCREF(__pyx_v_py_allenes_stereo);
+  __Pyx_GIVEREF(__pyx_v_py_allenes_stereo);
+  PyTuple_SET_ITEM(__pyx_t_20, 9, __pyx_v_py_allenes_stereo);
+  __Pyx_INCREF(__pyx_v_py_cis_trans_stereo);
+  __Pyx_GIVEREF(__pyx_v_py_cis_trans_stereo);
+  PyTuple_SET_ITEM(__pyx_t_20, 10, __pyx_v_py_cis_trans_stereo);
+  __Pyx_GIVEREF(__pyx_t_16);
+  PyTuple_SET_ITEM(__pyx_t_20, 11, __pyx_t_16);
+  __pyx_t_16 = 0;
+  __pyx_r = __pyx_t_20;
+  __pyx_t_20 = 0;
+  goto __pyx_L0;
+
+  /* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
+ * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_13);
+  __Pyx_XDECREF(__pyx_t_15);
+  __Pyx_XDECREF(__pyx_t_16);
+  __Pyx_XDECREF(__pyx_t_20);
+  __Pyx_AddTraceback("chython.containers._unpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __PYX_XDEC_MEMVIEW(&__pyx_v_data, 1);
+  __Pyx_XDECREF(__pyx_v_bond);
+  __Pyx_XDECREF(__pyx_v_py_charges);
+  __Pyx_XDECREF(__pyx_v_py_radicals);
+  __Pyx_XDECREF(__pyx_v_py_hydrogens);
+  __Pyx_XDECREF(__pyx_v_py_plane);
+  __Pyx_XDECREF(__pyx_v_py_bonds);
+  __Pyx_XDECREF(__pyx_v_tmp);
+  __Pyx_XDECREF(__pyx_v_py_atoms_stereo);
+  __Pyx_XDECREF(__pyx_v_py_allenes_stereo);
+  __Pyx_XDECREF(__pyx_v_py_cis_trans_stereo);
+  __Pyx_XDECREF(__pyx_v_py_mapping);
+  __Pyx_XDECREF(__pyx_v_py_atoms);
+  __Pyx_XDECREF(__pyx_v_py_isotopes);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
 }
-#endif
-/* #### Code section: module_state_traverse ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
-  __pyx_mstate *traverse_module_state = __pyx_mstate(m);
-  if (!traverse_module_state) return 0;
-  Py_VISIT(traverse_module_state->__pyx_d);
-  Py_VISIT(traverse_module_state->__pyx_b);
-  Py_VISIT(traverse_module_state->__pyx_cython_runtime);
-  Py_VISIT(traverse_module_state->__pyx_empty_tuple);
-  Py_VISIT(traverse_module_state->__pyx_empty_bytes);
-  Py_VISIT(traverse_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_FusedFunctionType);
-  #endif
-  Py_VISIT(traverse_module_state->__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping);
-  Py_VISIT(traverse_module_state->__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping);
-  Py_VISIT(traverse_module_state->__pyx_array_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_array);
-  Py_VISIT(traverse_module_state->__pyx_MemviewEnum_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_MemviewEnum);
-  Py_VISIT(traverse_module_state->__pyx_memoryview_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryview);
-  Py_VISIT(traverse_module_state->__pyx_memoryviewslice_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryviewslice);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ASCII);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_AssertionError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Cannot_index_with_type);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Ellipsis);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
-  Py_VISIT(traverse_module_state->__pyx_n_s_IndexError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_shape_in_axis);
-  Py_VISIT(traverse_module_state->__pyx_n_s_MemoryError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_VISIT(traverse_module_state->__pyx_n_b_O);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-  Py_VISIT(traverse_module_state->__pyx_n_s_PickleError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Sequence);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_VISIT(traverse_module_state->__pyx_n_s_TypeError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ValueError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_View_MemoryView);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__2);
-  Py_VISIT(traverse_module_state->__pyx_n_s__22);
-  Py_VISIT(traverse_module_state->__pyx_n_s__3);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__6);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__7);
-  Py_VISIT(traverse_module_state->__pyx_n_s_abc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_allocate_buffer);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_and);
-  Py_VISIT(traverse_module_state->__pyx_n_s_args);
-  Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_VISIT(traverse_module_state->__pyx_n_s_back);
-  Py_VISIT(traverse_module_state->__pyx_n_s_base);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c);
-  Py_VISIT(traverse_module_state->__pyx_n_u_c);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c_bond);
-  Py_VISIT(traverse_module_state->__pyx_n_s_chython_algorithms__isomorphism);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_chython_algorithms__isomorphism_2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_class);
-  Py_VISIT(traverse_module_state->__pyx_n_s_class_getitem);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
-  Py_VISIT(traverse_module_state->__pyx_n_s_close);
-  Py_VISIT(traverse_module_state->__pyx_n_s_closures_counter);
-  Py_VISIT(traverse_module_state->__pyx_n_s_closures_num);
-  Py_VISIT(traverse_module_state->__pyx_n_s_collections);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_collections_abc);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_direct);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_indirect);
-  Py_VISIT(traverse_module_state->__pyx_n_s_count);
-  Py_VISIT(traverse_module_state->__pyx_n_s_depth);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dict);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dtype_is_object);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_encode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_enumerate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_error);
-  Py_VISIT(traverse_module_state->__pyx_n_s_flags);
-  Py_VISIT(traverse_module_state->__pyx_n_s_format);
-  Py_VISIT(traverse_module_state->__pyx_n_s_fortran);
-  Py_VISIT(traverse_module_state->__pyx_n_u_fortran);
-  Py_VISIT(traverse_module_state->__pyx_n_s_front);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_gc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_get_mapping);
-  Py_VISIT(traverse_module_state->__pyx_n_s_getstate);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_got);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_i);
-  Py_VISIT(traverse_module_state->__pyx_n_s_id);
-  Py_VISIT(traverse_module_state->__pyx_n_s_import);
-  Py_VISIT(traverse_module_state->__pyx_n_s_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_initializing);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_coroutine);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_isenabled);
-  Py_VISIT(traverse_module_state->__pyx_n_s_itemsize);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
-  Py_VISIT(traverse_module_state->__pyx_n_s_j);
-  Py_VISIT(traverse_module_state->__pyx_n_s_m);
-  Py_VISIT(traverse_module_state->__pyx_n_s_main);
-  Py_VISIT(traverse_module_state->__pyx_n_s_mapping);
-  Py_VISIT(traverse_module_state->__pyx_n_s_matched);
-  Py_VISIT(traverse_module_state->__pyx_n_s_memview);
-  Py_VISIT(traverse_module_state->__pyx_n_s_mode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n);
-  Py_VISIT(traverse_module_state->__pyx_n_s_name);
-  Py_VISIT(traverse_module_state->__pyx_n_s_name_2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ndim);
-  Py_VISIT(traverse_module_state->__pyx_n_s_new);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bits1);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bits2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bits3);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bits4);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bond);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_bonds);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_closures);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_from);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_indices);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_numbers);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_o_to);
-  Py_VISIT(traverse_module_state->__pyx_n_s_obj);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_path);
-  Py_VISIT(traverse_module_state->__pyx_n_s_path_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pickle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_PickleError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_checksum);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_result);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_state);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_type);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_unpickle_Enum);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_vtable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_back);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_bonds);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_closures);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_from);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_indices);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_mask1);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_mask2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_mask3);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_mask4);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_masks1);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_masks2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_masks3);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_masks4);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_numbers);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_size_dec);
-  Py_VISIT(traverse_module_state->__pyx_n_s_q_to);
-  Py_VISIT(traverse_module_state->__pyx_n_s_range);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_ex);
-  Py_VISIT(traverse_module_state->__pyx_n_s_register);
-  Py_VISIT(traverse_module_state->__pyx_n_s_scope);
-  Py_VISIT(traverse_module_state->__pyx_n_s_send);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_shape);
-  Py_VISIT(traverse_module_state->__pyx_n_s_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_spec);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stack_depth);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stack_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_start);
-  Py_VISIT(traverse_module_state->__pyx_n_s_step);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stop);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_indirect);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_stringsource);
-  Py_VISIT(traverse_module_state->__pyx_n_s_struct);
-  Py_VISIT(traverse_module_state->__pyx_n_s_sys);
-  Py_VISIT(traverse_module_state->__pyx_n_s_test);
-  Py_VISIT(traverse_module_state->__pyx_n_s_throw);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_array_data);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
-  Py_VISIT(traverse_module_state->__pyx_n_s_unpack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_update);
-  Py_VISIT(traverse_module_state->__pyx_n_s_version_info);
-  Py_VISIT(traverse_module_state->__pyx_int_0);
-  Py_VISIT(traverse_module_state->__pyx_int_1);
-  Py_VISIT(traverse_module_state->__pyx_int_3);
-  Py_VISIT(traverse_module_state->__pyx_int_112105877);
-  Py_VISIT(traverse_module_state->__pyx_int_136983863);
-  Py_VISIT(traverse_module_state->__pyx_int_184977713);
-  Py_VISIT(traverse_module_state->__pyx_int_neg_1);
-  Py_VISIT(traverse_module_state->__pyx_slice__5);
-  Py_VISIT(traverse_module_state->__pyx_tuple__4);
-  Py_VISIT(traverse_module_state->__pyx_tuple__8);
-  Py_VISIT(traverse_module_state->__pyx_tuple__10);
-  Py_VISIT(traverse_module_state->__pyx_tuple__11);
-  Py_VISIT(traverse_module_state->__pyx_tuple__12);
-  Py_VISIT(traverse_module_state->__pyx_tuple__13);
-  Py_VISIT(traverse_module_state->__pyx_tuple__14);
-  Py_VISIT(traverse_module_state->__pyx_tuple__15);
-  Py_VISIT(traverse_module_state->__pyx_tuple__16);
-  Py_VISIT(traverse_module_state->__pyx_tuple__17);
-  Py_VISIT(traverse_module_state->__pyx_tuple__18);
-  Py_VISIT(traverse_module_state->__pyx_tuple__19);
-  Py_VISIT(traverse_module_state->__pyx_tuple__21);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__9);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__20);
-  return 0;
+
+/* "chython/containers/_unpack.pyx":177
+ * 
+ * 
+ * cdef double double_from2bytes(unsigned char a, unsigned char b):             # <<<<<<<<<<<<<<
+ *     cdef bint sign
+ *     cdef int e
+ */
+
+static double __pyx_f_7chython_10containers_7_unpack_double_from2bytes(unsigned char __pyx_v_a, unsigned char __pyx_v_b) {
+  int __pyx_v_sign;
+  int __pyx_v_e;
+  unsigned int __pyx_v_f;
+  double __pyx_v_x;
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("double_from2bytes", 0);
+
+  /* "chython/containers/_unpack.pyx":183
+ *     cdef double x
+ * 
+ *     sign = a >> 7             # <<<<<<<<<<<<<<
+ *     e = (a >> 2) & 0x1f
+ *     f = ((a & 0x03) << 8) | b
+ */
+  __pyx_v_sign = (__pyx_v_a >> 7);
+
+  /* "chython/containers/_unpack.pyx":184
+ * 
+ *     sign = a >> 7
+ *     e = (a >> 2) & 0x1f             # <<<<<<<<<<<<<<
+ *     f = ((a & 0x03) << 8) | b
+ * 
+ */
+  __pyx_v_e = ((__pyx_v_a >> 2) & 0x1f);
+
+  /* "chython/containers/_unpack.pyx":185
+ *     sign = a >> 7
+ *     e = (a >> 2) & 0x1f
+ *     f = ((a & 0x03) << 8) | b             # <<<<<<<<<<<<<<
+ * 
+ *     x = f / 1024.
+ */
+  __pyx_v_f = (((__pyx_v_a & 0x03) << 8) | __pyx_v_b);
+
+  /* "chython/containers/_unpack.pyx":187
+ *     f = ((a & 0x03) << 8) | b
+ * 
+ *     x = f / 1024.             # <<<<<<<<<<<<<<
+ *     if e:
+ *         x += 1.
+ */
+  __pyx_v_x = (((double)__pyx_v_f) / 1024.);
+
+  /* "chython/containers/_unpack.pyx":188
+ * 
+ *     x = f / 1024.
+ *     if e:             # <<<<<<<<<<<<<<
+ *         x += 1.
+ *         e -= 15
+ */
+  __pyx_t_1 = (__pyx_v_e != 0);
+  if (__pyx_t_1) {
+
+    /* "chython/containers/_unpack.pyx":189
+ *     x = f / 1024.
+ *     if e:
+ *         x += 1.             # <<<<<<<<<<<<<<
+ *         e -= 15
+ *     else:
+ */
+    __pyx_v_x = (__pyx_v_x + 1.);
+
+    /* "chython/containers/_unpack.pyx":190
+ *     if e:
+ *         x += 1.
+ *         e -= 15             # <<<<<<<<<<<<<<
+ *     else:
+ *         e = -14
+ */
+    __pyx_v_e = (__pyx_v_e - 15);
+
+    /* "chython/containers/_unpack.pyx":188
+ * 
+ *     x = f / 1024.
+ *     if e:             # <<<<<<<<<<<<<<
+ *         x += 1.
+ *         e -= 15
+ */
+    goto __pyx_L3;
+  }
+
+  /* "chython/containers/_unpack.pyx":192
+ *         e -= 15
+ *     else:
+ *         e = -14             # <<<<<<<<<<<<<<
+ * 
+ *     x = ldexp(x, e)
+ */
+  /*else*/ {
+    __pyx_v_e = -14;
+  }
+  __pyx_L3:;
+
+  /* "chython/containers/_unpack.pyx":194
+ *         e = -14
+ * 
+ *     x = ldexp(x, e)             # <<<<<<<<<<<<<<
+ *     if sign:
+ *         return -x
+ */
+  __pyx_v_x = ldexp(__pyx_v_x, __pyx_v_e);
+
+  /* "chython/containers/_unpack.pyx":195
+ * 
+ *     x = ldexp(x, e)
+ *     if sign:             # <<<<<<<<<<<<<<
+ *         return -x
+ *     return x
+ */
+  __pyx_t_1 = (__pyx_v_sign != 0);
+  if (__pyx_t_1) {
+
+    /* "chython/containers/_unpack.pyx":196
+ *     x = ldexp(x, e)
+ *     if sign:
+ *         return -x             # <<<<<<<<<<<<<<
+ *     return x
+ */
+    __pyx_r = (-__pyx_v_x);
+    goto __pyx_L0;
+
+    /* "chython/containers/_unpack.pyx":195
+ * 
+ *     x = ldexp(x, e)
+ *     if sign:             # <<<<<<<<<<<<<<
+ *         return -x
+ *     return x
+ */
+  }
+
+  /* "chython/containers/_unpack.pyx":197
+ *     if sign:
+ *         return -x
+ *     return x             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = __pyx_v_x;
+  goto __pyx_L0;
+
+  /* "chython/containers/_unpack.pyx":177
+ * 
+ * 
+ * cdef double double_from2bytes(unsigned char a, unsigned char b):             # <<<<<<<<<<<<<<
+ *     cdef bint sign
+ *     cdef int e
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
 }
-#endif
-/* #### Code section: module_state_defines ### */
-#define __pyx_d __pyx_mstate_global->__pyx_d
-#define __pyx_b __pyx_mstate_global->__pyx_b
-#define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
-#define __pyx_empty_tuple __pyx_mstate_global->__pyx_empty_tuple
-#define __pyx_empty_bytes __pyx_mstate_global->__pyx_empty_bytes
-#define __pyx_empty_unicode __pyx_mstate_global->__pyx_empty_unicode
-#ifdef __Pyx_CyFunction_USED
-#define __pyx_CyFunctionType __pyx_mstate_global->__pyx_CyFunctionType
-#endif
-#ifdef __Pyx_FusedFunction_USED
-#define __pyx_FusedFunctionType __pyx_mstate_global->__pyx_FusedFunctionType
-#endif
-#ifdef __Pyx_Generator_USED
-#define __pyx_GeneratorType __pyx_mstate_global->__pyx_GeneratorType
-#endif
-#ifdef __Pyx_IterableCoroutine_USED
-#define __pyx_IterableCoroutineType __pyx_mstate_global->__pyx_IterableCoroutineType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineAwaitType __pyx_mstate_global->__pyx_CoroutineAwaitType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineType __pyx_mstate_global->__pyx_CoroutineType
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#define __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping __pyx_mstate_global->__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping
-#define __pyx_type___pyx_array __pyx_mstate_global->__pyx_type___pyx_array
-#define __pyx_type___pyx_MemviewEnum __pyx_mstate_global->__pyx_type___pyx_MemviewEnum
-#define __pyx_type___pyx_memoryview __pyx_mstate_global->__pyx_type___pyx_memoryview
-#define __pyx_type___pyx_memoryviewslice __pyx_mstate_global->__pyx_type___pyx_memoryviewslice
-#endif
-#define __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping __pyx_mstate_global->__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping
-#define __pyx_array_type __pyx_mstate_global->__pyx_array_type
-#define __pyx_MemviewEnum_type __pyx_mstate_global->__pyx_MemviewEnum_type
-#define __pyx_memoryview_type __pyx_mstate_global->__pyx_memoryview_type
-#define __pyx_memoryviewslice_type __pyx_mstate_global->__pyx_memoryviewslice_type
-#define __pyx_kp_u_ __pyx_mstate_global->__pyx_kp_u_
-#define __pyx_n_s_ASCII __pyx_mstate_global->__pyx_n_s_ASCII
-#define __pyx_kp_s_All_dimensions_preceding_dimensi __pyx_mstate_global->__pyx_kp_s_All_dimensions_preceding_dimensi
-#define __pyx_n_s_AssertionError __pyx_mstate_global->__pyx_n_s_AssertionError
-#define __pyx_kp_s_Buffer_view_does_not_expose_stri __pyx_mstate_global->__pyx_kp_s_Buffer_view_does_not_expose_stri
-#define __pyx_kp_s_Can_only_create_a_buffer_that_is __pyx_mstate_global->__pyx_kp_s_Can_only_create_a_buffer_that_is
-#define __pyx_kp_s_Cannot_assign_to_read_only_memor __pyx_mstate_global->__pyx_kp_s_Cannot_assign_to_read_only_memor
-#define __pyx_kp_s_Cannot_create_writable_memory_vi __pyx_mstate_global->__pyx_kp_s_Cannot_create_writable_memory_vi
-#define __pyx_kp_u_Cannot_index_with_type __pyx_mstate_global->__pyx_kp_u_Cannot_index_with_type
-#define __pyx_kp_s_Cannot_transpose_memoryview_with __pyx_mstate_global->__pyx_kp_s_Cannot_transpose_memoryview_with
-#define __pyx_kp_s_Dimension_d_is_not_direct __pyx_mstate_global->__pyx_kp_s_Dimension_d_is_not_direct
-#define __pyx_n_s_Ellipsis __pyx_mstate_global->__pyx_n_s_Ellipsis
-#define __pyx_kp_s_Empty_shape_tuple_for_cython_arr __pyx_mstate_global->__pyx_kp_s_Empty_shape_tuple_for_cython_arr
-#define __pyx_kp_s_Incompatible_checksums_0x_x_vs_0 __pyx_mstate_global->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0
-#define __pyx_n_s_IndexError __pyx_mstate_global->__pyx_n_s_IndexError
-#define __pyx_kp_s_Index_out_of_bounds_axis_d __pyx_mstate_global->__pyx_kp_s_Index_out_of_bounds_axis_d
-#define __pyx_kp_s_Indirect_dimensions_not_supporte __pyx_mstate_global->__pyx_kp_s_Indirect_dimensions_not_supporte
-#define __pyx_kp_u_Invalid_mode_expected_c_or_fortr __pyx_mstate_global->__pyx_kp_u_Invalid_mode_expected_c_or_fortr
-#define __pyx_kp_u_Invalid_shape_in_axis __pyx_mstate_global->__pyx_kp_u_Invalid_shape_in_axis
-#define __pyx_n_s_MemoryError __pyx_mstate_global->__pyx_n_s_MemoryError
-#define __pyx_kp_s_MemoryView_of_r_at_0x_x __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_at_0x_x
-#define __pyx_kp_s_MemoryView_of_r_object __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_object
-#define __pyx_n_b_O __pyx_mstate_global->__pyx_n_b_O
-#define __pyx_kp_u_Out_of_bounds_on_buffer_access_a __pyx_mstate_global->__pyx_kp_u_Out_of_bounds_on_buffer_access_a
-#define __pyx_n_s_PickleError __pyx_mstate_global->__pyx_n_s_PickleError
-#define __pyx_n_s_Sequence __pyx_mstate_global->__pyx_n_s_Sequence
-#define __pyx_kp_s_Step_may_not_be_zero_axis_d __pyx_mstate_global->__pyx_kp_s_Step_may_not_be_zero_axis_d
-#define __pyx_n_s_TypeError __pyx_mstate_global->__pyx_n_s_TypeError
-#define __pyx_kp_s_Unable_to_convert_item_to_object __pyx_mstate_global->__pyx_kp_s_Unable_to_convert_item_to_object
-#define __pyx_n_s_ValueError __pyx_mstate_global->__pyx_n_s_ValueError
-#define __pyx_n_s_View_MemoryView __pyx_mstate_global->__pyx_n_s_View_MemoryView
-#define __pyx_kp_u__2 __pyx_mstate_global->__pyx_kp_u__2
-#define __pyx_n_s__22 __pyx_mstate_global->__pyx_n_s__22
-#define __pyx_n_s__3 __pyx_mstate_global->__pyx_n_s__3
-#define __pyx_kp_u__6 __pyx_mstate_global->__pyx_kp_u__6
-#define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
-#define __pyx_n_s_abc __pyx_mstate_global->__pyx_n_s_abc
-#define __pyx_n_s_allocate_buffer __pyx_mstate_global->__pyx_n_s_allocate_buffer
-#define __pyx_kp_u_and __pyx_mstate_global->__pyx_kp_u_and
-#define __pyx_n_s_args __pyx_mstate_global->__pyx_n_s_args
-#define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
-#define __pyx_n_s_back __pyx_mstate_global->__pyx_n_s_back
-#define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
-#define __pyx_n_s_c __pyx_mstate_global->__pyx_n_s_c
-#define __pyx_n_u_c __pyx_mstate_global->__pyx_n_u_c
-#define __pyx_n_s_c_bond __pyx_mstate_global->__pyx_n_s_c_bond
-#define __pyx_n_s_chython_algorithms__isomorphism __pyx_mstate_global->__pyx_n_s_chython_algorithms__isomorphism
-#define __pyx_kp_s_chython_algorithms__isomorphism_2 __pyx_mstate_global->__pyx_kp_s_chython_algorithms__isomorphism_2
-#define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
-#define __pyx_n_s_class_getitem __pyx_mstate_global->__pyx_n_s_class_getitem
-#define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
-#define __pyx_n_s_close __pyx_mstate_global->__pyx_n_s_close
-#define __pyx_n_s_closures_counter __pyx_mstate_global->__pyx_n_s_closures_counter
-#define __pyx_n_s_closures_num __pyx_mstate_global->__pyx_n_s_closures_num
-#define __pyx_n_s_collections __pyx_mstate_global->__pyx_n_s_collections
-#define __pyx_kp_s_collections_abc __pyx_mstate_global->__pyx_kp_s_collections_abc
-#define __pyx_kp_s_contiguous_and_direct __pyx_mstate_global->__pyx_kp_s_contiguous_and_direct
-#define __pyx_kp_s_contiguous_and_indirect __pyx_mstate_global->__pyx_kp_s_contiguous_and_indirect
-#define __pyx_n_s_count __pyx_mstate_global->__pyx_n_s_count
-#define __pyx_n_s_depth __pyx_mstate_global->__pyx_n_s_depth
-#define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
-#define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
-#define __pyx_n_s_dtype_is_object __pyx_mstate_global->__pyx_n_s_dtype_is_object
-#define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
-#define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
-#define __pyx_n_s_enumerate __pyx_mstate_global->__pyx_n_s_enumerate
-#define __pyx_n_s_error __pyx_mstate_global->__pyx_n_s_error
-#define __pyx_n_s_flags __pyx_mstate_global->__pyx_n_s_flags
-#define __pyx_n_s_format __pyx_mstate_global->__pyx_n_s_format
-#define __pyx_n_s_fortran __pyx_mstate_global->__pyx_n_s_fortran
-#define __pyx_n_u_fortran __pyx_mstate_global->__pyx_n_u_fortran
-#define __pyx_n_s_front __pyx_mstate_global->__pyx_n_s_front
-#define __pyx_kp_u_gc __pyx_mstate_global->__pyx_kp_u_gc
-#define __pyx_n_s_get_mapping __pyx_mstate_global->__pyx_n_s_get_mapping
-#define __pyx_n_s_getstate __pyx_mstate_global->__pyx_n_s_getstate
-#define __pyx_kp_u_got __pyx_mstate_global->__pyx_kp_u_got
-#define __pyx_kp_u_got_differing_extents_in_dimensi __pyx_mstate_global->__pyx_kp_u_got_differing_extents_in_dimensi
-#define __pyx_n_s_i __pyx_mstate_global->__pyx_n_s_i
-#define __pyx_n_s_id __pyx_mstate_global->__pyx_n_s_id
-#define __pyx_n_s_import __pyx_mstate_global->__pyx_n_s_import
-#define __pyx_n_s_index __pyx_mstate_global->__pyx_n_s_index
-#define __pyx_n_s_initializing __pyx_mstate_global->__pyx_n_s_initializing
-#define __pyx_n_s_is_coroutine __pyx_mstate_global->__pyx_n_s_is_coroutine
-#define __pyx_kp_u_isenabled __pyx_mstate_global->__pyx_kp_u_isenabled
-#define __pyx_n_s_itemsize __pyx_mstate_global->__pyx_n_s_itemsize
-#define __pyx_kp_s_itemsize_0_for_cython_array __pyx_mstate_global->__pyx_kp_s_itemsize_0_for_cython_array
-#define __pyx_n_s_j __pyx_mstate_global->__pyx_n_s_j
-#define __pyx_n_s_m __pyx_mstate_global->__pyx_n_s_m
-#define __pyx_n_s_main __pyx_mstate_global->__pyx_n_s_main
-#define __pyx_n_s_mapping __pyx_mstate_global->__pyx_n_s_mapping
-#define __pyx_n_s_matched __pyx_mstate_global->__pyx_n_s_matched
-#define __pyx_n_s_memview __pyx_mstate_global->__pyx_n_s_memview
-#define __pyx_n_s_mode __pyx_mstate_global->__pyx_n_s_mode
-#define __pyx_n_s_n __pyx_mstate_global->__pyx_n_s_n
-#define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
-#define __pyx_n_s_name_2 __pyx_mstate_global->__pyx_n_s_name_2
-#define __pyx_n_s_ndim __pyx_mstate_global->__pyx_n_s_ndim
-#define __pyx_n_s_new __pyx_mstate_global->__pyx_n_s_new
-#define __pyx_kp_s_no_default___reduce___due_to_non __pyx_mstate_global->__pyx_kp_s_no_default___reduce___due_to_non
-#define __pyx_n_s_o __pyx_mstate_global->__pyx_n_s_o
-#define __pyx_n_s_o_bits1 __pyx_mstate_global->__pyx_n_s_o_bits1
-#define __pyx_n_s_o_bits2 __pyx_mstate_global->__pyx_n_s_o_bits2
-#define __pyx_n_s_o_bits3 __pyx_mstate_global->__pyx_n_s_o_bits3
-#define __pyx_n_s_o_bits4 __pyx_mstate_global->__pyx_n_s_o_bits4
-#define __pyx_n_s_o_bond __pyx_mstate_global->__pyx_n_s_o_bond
-#define __pyx_n_s_o_bonds __pyx_mstate_global->__pyx_n_s_o_bonds
-#define __pyx_n_s_o_closures __pyx_mstate_global->__pyx_n_s_o_closures
-#define __pyx_n_s_o_from __pyx_mstate_global->__pyx_n_s_o_from
-#define __pyx_n_s_o_indices __pyx_mstate_global->__pyx_n_s_o_indices
-#define __pyx_n_s_o_numbers __pyx_mstate_global->__pyx_n_s_o_numbers
-#define __pyx_n_s_o_size __pyx_mstate_global->__pyx_n_s_o_size
-#define __pyx_n_s_o_to __pyx_mstate_global->__pyx_n_s_o_to
-#define __pyx_n_s_obj __pyx_mstate_global->__pyx_n_s_obj
-#define __pyx_n_s_pack __pyx_mstate_global->__pyx_n_s_pack
-#define __pyx_n_s_path __pyx_mstate_global->__pyx_n_s_path
-#define __pyx_n_s_path_size __pyx_mstate_global->__pyx_n_s_path_size
-#define __pyx_n_s_pickle __pyx_mstate_global->__pyx_n_s_pickle
-#define __pyx_n_s_pyx_PickleError __pyx_mstate_global->__pyx_n_s_pyx_PickleError
-#define __pyx_n_s_pyx_checksum __pyx_mstate_global->__pyx_n_s_pyx_checksum
-#define __pyx_n_s_pyx_result __pyx_mstate_global->__pyx_n_s_pyx_result
-#define __pyx_n_s_pyx_state __pyx_mstate_global->__pyx_n_s_pyx_state
-#define __pyx_n_s_pyx_type __pyx_mstate_global->__pyx_n_s_pyx_type
-#define __pyx_n_s_pyx_unpickle_Enum __pyx_mstate_global->__pyx_n_s_pyx_unpickle_Enum
-#define __pyx_n_s_pyx_vtable __pyx_mstate_global->__pyx_n_s_pyx_vtable
-#define __pyx_n_s_q_back __pyx_mstate_global->__pyx_n_s_q_back
-#define __pyx_n_s_q_bonds __pyx_mstate_global->__pyx_n_s_q_bonds
-#define __pyx_n_s_q_closures __pyx_mstate_global->__pyx_n_s_q_closures
-#define __pyx_n_s_q_from __pyx_mstate_global->__pyx_n_s_q_from
-#define __pyx_n_s_q_indices __pyx_mstate_global->__pyx_n_s_q_indices
-#define __pyx_n_s_q_mask1 __pyx_mstate_global->__pyx_n_s_q_mask1
-#define __pyx_n_s_q_mask2 __pyx_mstate_global->__pyx_n_s_q_mask2
-#define __pyx_n_s_q_mask3 __pyx_mstate_global->__pyx_n_s_q_mask3
-#define __pyx_n_s_q_mask4 __pyx_mstate_global->__pyx_n_s_q_mask4
-#define __pyx_n_s_q_masks1 __pyx_mstate_global->__pyx_n_s_q_masks1
-#define __pyx_n_s_q_masks2 __pyx_mstate_global->__pyx_n_s_q_masks2
-#define __pyx_n_s_q_masks3 __pyx_mstate_global->__pyx_n_s_q_masks3
-#define __pyx_n_s_q_masks4 __pyx_mstate_global->__pyx_n_s_q_masks4
-#define __pyx_n_s_q_numbers __pyx_mstate_global->__pyx_n_s_q_numbers
-#define __pyx_n_s_q_size __pyx_mstate_global->__pyx_n_s_q_size
-#define __pyx_n_s_q_size_dec __pyx_mstate_global->__pyx_n_s_q_size_dec
-#define __pyx_n_s_q_to __pyx_mstate_global->__pyx_n_s_q_to
-#define __pyx_n_s_range __pyx_mstate_global->__pyx_n_s_range
-#define __pyx_n_s_reduce __pyx_mstate_global->__pyx_n_s_reduce
-#define __pyx_n_s_reduce_cython __pyx_mstate_global->__pyx_n_s_reduce_cython
-#define __pyx_n_s_reduce_ex __pyx_mstate_global->__pyx_n_s_reduce_ex
-#define __pyx_n_s_register __pyx_mstate_global->__pyx_n_s_register
-#define __pyx_n_s_scope __pyx_mstate_global->__pyx_n_s_scope
-#define __pyx_n_s_send __pyx_mstate_global->__pyx_n_s_send
-#define __pyx_n_s_setstate __pyx_mstate_global->__pyx_n_s_setstate
-#define __pyx_n_s_setstate_cython __pyx_mstate_global->__pyx_n_s_setstate_cython
-#define __pyx_n_s_shape __pyx_mstate_global->__pyx_n_s_shape
-#define __pyx_n_s_size __pyx_mstate_global->__pyx_n_s_size
-#define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
-#define __pyx_n_s_stack __pyx_mstate_global->__pyx_n_s_stack
-#define __pyx_n_s_stack_depth __pyx_mstate_global->__pyx_n_s_stack_depth
-#define __pyx_n_s_stack_index __pyx_mstate_global->__pyx_n_s_stack_index
-#define __pyx_n_s_start __pyx_mstate_global->__pyx_n_s_start
-#define __pyx_n_s_step __pyx_mstate_global->__pyx_n_s_step
-#define __pyx_n_s_stop __pyx_mstate_global->__pyx_n_s_stop
-#define __pyx_kp_s_strided_and_direct __pyx_mstate_global->__pyx_kp_s_strided_and_direct
-#define __pyx_kp_s_strided_and_direct_or_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_direct_or_indirect
-#define __pyx_kp_s_strided_and_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_indirect
-#define __pyx_kp_s_stringsource __pyx_mstate_global->__pyx_kp_s_stringsource
-#define __pyx_n_s_struct __pyx_mstate_global->__pyx_n_s_struct
-#define __pyx_n_s_sys __pyx_mstate_global->__pyx_n_s_sys
-#define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
-#define __pyx_n_s_throw __pyx_mstate_global->__pyx_n_s_throw
-#define __pyx_kp_s_unable_to_allocate_array_data __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_array_data
-#define __pyx_kp_s_unable_to_allocate_shape_and_str __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_shape_and_str
-#define __pyx_n_s_unpack __pyx_mstate_global->__pyx_n_s_unpack
-#define __pyx_n_s_update __pyx_mstate_global->__pyx_n_s_update
-#define __pyx_n_s_version_info __pyx_mstate_global->__pyx_n_s_version_info
-#define __pyx_int_0 __pyx_mstate_global->__pyx_int_0
-#define __pyx_int_1 __pyx_mstate_global->__pyx_int_1
-#define __pyx_int_3 __pyx_mstate_global->__pyx_int_3
-#define __pyx_int_112105877 __pyx_mstate_global->__pyx_int_112105877
-#define __pyx_int_136983863 __pyx_mstate_global->__pyx_int_136983863
-#define __pyx_int_184977713 __pyx_mstate_global->__pyx_int_184977713
-#define __pyx_int_neg_1 __pyx_mstate_global->__pyx_int_neg_1
-#define __pyx_slice__5 __pyx_mstate_global->__pyx_slice__5
-#define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
-#define __pyx_tuple__8 __pyx_mstate_global->__pyx_tuple__8
-#define __pyx_tuple__10 __pyx_mstate_global->__pyx_tuple__10
-#define __pyx_tuple__11 __pyx_mstate_global->__pyx_tuple__11
-#define __pyx_tuple__12 __pyx_mstate_global->__pyx_tuple__12
-#define __pyx_tuple__13 __pyx_mstate_global->__pyx_tuple__13
-#define __pyx_tuple__14 __pyx_mstate_global->__pyx_tuple__14
-#define __pyx_tuple__15 __pyx_mstate_global->__pyx_tuple__15
-#define __pyx_tuple__16 __pyx_mstate_global->__pyx_tuple__16
-#define __pyx_tuple__17 __pyx_mstate_global->__pyx_tuple__17
-#define __pyx_tuple__18 __pyx_mstate_global->__pyx_tuple__18
-#define __pyx_tuple__19 __pyx_mstate_global->__pyx_tuple__19
-#define __pyx_tuple__21 __pyx_mstate_global->__pyx_tuple__21
-#define __pyx_codeobj__9 __pyx_mstate_global->__pyx_codeobj__9
-#define __pyx_codeobj__20 __pyx_mstate_global->__pyx_codeobj__20
-/* #### Code section: module_code ### */
 
-/* "View.MemoryView":131
+/* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -3961,127 +3770,120 @@
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_shape = 0;
   Py_ssize_t __pyx_v_itemsize;
   PyObject *__pyx_v_format = 0;
   PyObject *__pyx_v_mode = 0;
   int __pyx_v_allocate_buffer;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_shape,&__pyx_n_s_itemsize,&__pyx_n_s_format,&__pyx_n_s_mode,&__pyx_n_s_allocate_buffer,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_shape,&__pyx_n_s_itemsize,&__pyx_n_s_format,&__pyx_n_s_mode,&__pyx_n_s_allocate_buffer,0};
     PyObject* values[5] = {0,0,0,0,0};
     values[3] = ((PyObject *)__pyx_n_s_c);
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  5: values[4] = __Pyx_Arg_VARARGS(__pyx_args, 4);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_VARARGS(__pyx_args, 3);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_shape)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_itemsize)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 131, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_format)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 131, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_mode);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_allocate_buffer);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 122, __pyx_L3_error)
       }
     } else {
-      switch (__pyx_nargs) {
-        case  5: values[4] = __Pyx_Arg_VARARGS(__pyx_args, 4);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_VARARGS(__pyx_args, 3);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
-        values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-        values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 132, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
     } else {
 
-      /* "View.MemoryView":132
+      /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, __pyx_nargs); __PYX_ERR(1, 131, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 131, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 131, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -4092,542 +3894,636 @@
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer) {
   int __pyx_v_idx;
+  Py_ssize_t __pyx_v_i;
   Py_ssize_t __pyx_v_dim;
+  PyObject **__pyx_v_p;
   char __pyx_v_order;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  char *__pyx_t_8;
+  char *__pyx_t_7;
+  int __pyx_t_8;
   Py_ssize_t __pyx_t_9;
-  Py_UCS4 __pyx_t_10;
+  PyObject *__pyx_t_10 = NULL;
+  Py_ssize_t __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
-  /* "View.MemoryView":137
- *         cdef Py_ssize_t dim
+  /* "View.MemoryView":129
+ *         cdef PyObject **p
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 137, __pyx_L1_error)
+    __PYX_ERR(1, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 137, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
-  /* "View.MemoryView":138
+  /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
-  /* "View.MemoryView":140
+  /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Empty shape tuple for cython.array"
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
-  __pyx_t_2 = (!(__pyx_v_self->ndim != 0));
+  __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":141
+    /* "View.MemoryView":133
  * 
  *         if not self.ndim:
- *             raise ValueError, "Empty shape tuple for cython.array"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Empty_shape_tuple_for_cython_arr, 0, 0);
-    __PYX_ERR(1, 141, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 133, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 133, __pyx_L1_error)
 
-    /* "View.MemoryView":140
+    /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Empty shape tuple for cython.array"
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":143
- *             raise ValueError, "Empty shape tuple for cython.array"
+  /* "View.MemoryView":135
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "itemsize <= 0 for cython.array"
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
-  __pyx_t_2 = (__pyx_v_itemsize <= 0);
+  __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":144
+    /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
- *             raise ValueError, "itemsize <= 0 for cython.array"             # <<<<<<<<<<<<<<
+ *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_itemsize_0_for_cython_array, 0, 0);
-    __PYX_ERR(1, 144, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 136, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 136, __pyx_L1_error)
 
-    /* "View.MemoryView":143
- *             raise ValueError, "Empty shape tuple for cython.array"
+    /* "View.MemoryView":135
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "itemsize <= 0 for cython.array"
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":146
- *             raise ValueError, "itemsize <= 0 for cython.array"
+  /* "View.MemoryView":138
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
-  __pyx_t_3 = (!__pyx_t_2);
-  if (__pyx_t_3) {
+  __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":147
+    /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 147, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
-    __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_7 = 1;
       }
     }
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_n_s_ASCII};
-      __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
-      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 147, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_4);
-    __pyx_t_4 = 0;
+    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 139, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "View.MemoryView":146
- *             raise ValueError, "itemsize <= 0 for cython.array"
+    /* "View.MemoryView":138
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
-  /* "View.MemoryView":148
+  /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_v_format))) __PYX_ERR(1, 148, __pyx_L1_error)
-  __pyx_t_4 = __pyx_v_format;
-  __Pyx_INCREF(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 140, __pyx_L1_error)
+  __pyx_t_3 = __pyx_v_format;
+  __Pyx_INCREF(__pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
-  __pyx_v_self->_format = ((PyObject*)__pyx_t_4);
-  __pyx_t_4 = 0;
+  __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
-  /* "View.MemoryView":149
+  /* "View.MemoryView":141
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(1, 149, __pyx_L1_error)
+    __PYX_ERR(1, 141, __pyx_L1_error)
   }
-  __pyx_t_8 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(1, 149, __pyx_L1_error)
-  __pyx_v_self->format = __pyx_t_8;
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 141, __pyx_L1_error)
+  __pyx_v_self->format = __pyx_t_7;
 
-  /* "View.MemoryView":152
+  /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
  * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
-  /* "View.MemoryView":153
+  /* "View.MemoryView":145
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
  * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
-  /* "View.MemoryView":155
+  /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
- *             raise MemoryError, "unable to allocate shape and strides."
+ *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
-  __pyx_t_3 = (!(__pyx_v_self->_shape != 0));
-  if (unlikely(__pyx_t_3)) {
+  __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
+  if (unlikely(__pyx_t_4)) {
 
-    /* "View.MemoryView":156
+    /* "View.MemoryView":148
  * 
  *         if not self._shape:
- *             raise MemoryError, "unable to allocate shape and strides."             # <<<<<<<<<<<<<<
+ *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_Raise(__pyx_builtin_MemoryError, __pyx_kp_s_unable_to_allocate_shape_and_str, 0, 0);
-    __PYX_ERR(1, 156, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 148, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 148, __pyx_L1_error)
 
-    /* "View.MemoryView":155
+    /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
- *             raise MemoryError, "unable to allocate shape and strides."
+ *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   }
 
-  /* "View.MemoryView":159
+  /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
-  __pyx_t_7 = 0;
-  __pyx_t_4 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_4); __pyx_t_1 = 0;
+  __pyx_t_8 = 0;
+  __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
-    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely((0 < 0))) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 151, __pyx_L1_error)
     #else
-    __pyx_t_5 = PySequence_ITEM(__pyx_t_4, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
-    __pyx_v_idx = __pyx_t_7;
-    __pyx_t_7 = (__pyx_t_7 + 1);
+    __pyx_v_idx = __pyx_t_8;
+    __pyx_t_8 = (__pyx_t_8 + 1);
 
-    /* "View.MemoryView":160
+    /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
-    __pyx_t_3 = (__pyx_v_dim <= 0);
-    if (unlikely(__pyx_t_3)) {
+    __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
+    if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":161
+      /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_9 = 0;
-      __pyx_t_10 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Invalid_shape_in_axis);
-      __pyx_t_9 += 22;
-      __Pyx_GIVEREF(__pyx_kp_u_Invalid_shape_in_axis);
-      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Invalid_shape_in_axis);
-      __pyx_t_6 = __Pyx_PyUnicode_From_int(__pyx_v_idx, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
-      __Pyx_GIVEREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_6);
-      __pyx_t_6 = 0;
-      __Pyx_INCREF(__pyx_kp_u_);
-      __pyx_t_9 += 2;
-      __Pyx_GIVEREF(__pyx_kp_u_);
-      PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_);
-      __pyx_t_6 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_GIVEREF(__pyx_t_5);
+      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
       __Pyx_GIVEREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
+      __pyx_t_5 = 0;
       __pyx_t_6 = 0;
-      __Pyx_INCREF(__pyx_kp_u__2);
-      __pyx_t_9 += 1;
-      __Pyx_GIVEREF(__pyx_kp_u__2);
-      PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_kp_u__2);
-      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_5, 5, __pyx_t_9, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_6, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 161, __pyx_L1_error)
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __PYX_ERR(1, 153, __pyx_L1_error)
 
-      /* "View.MemoryView":160
+      /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
-    /* "View.MemoryView":162
+    /* "View.MemoryView":154
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
  * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
-    /* "View.MemoryView":159
+    /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":165
+  /* "View.MemoryView":157
  * 
  *         cdef char order
- *         if mode == 'c':             # <<<<<<<<<<<<<<
- *             order = b'C'
- *             self.mode = u'c'
+ *         if mode == 'fortran':             # <<<<<<<<<<<<<<
+ *             order = b'F'
+ *             self.mode = u'fortran'
  */
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(1, 165, __pyx_L1_error)
-  if (__pyx_t_3) {
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 157, __pyx_L1_error)
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":166
+    /* "View.MemoryView":158
  *         cdef char order
- *         if mode == 'c':
- *             order = b'C'             # <<<<<<<<<<<<<<
- *             self.mode = u'c'
- *         elif mode == 'fortran':
+ *         if mode == 'fortran':
+ *             order = b'F'             # <<<<<<<<<<<<<<
+ *             self.mode = u'fortran'
+ *         elif mode == 'c':
  */
-    __pyx_v_order = 'C';
+    __pyx_v_order = 'F';
 
-    /* "View.MemoryView":167
- *         if mode == 'c':
- *             order = b'C'
- *             self.mode = u'c'             # <<<<<<<<<<<<<<
- *         elif mode == 'fortran':
+    /* "View.MemoryView":159
+ *         if mode == 'fortran':
  *             order = b'F'
+ *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
+ *         elif mode == 'c':
+ *             order = b'C'
  */
-    __Pyx_INCREF(__pyx_n_u_c);
-    __Pyx_GIVEREF(__pyx_n_u_c);
+    __Pyx_INCREF(__pyx_n_u_fortran);
+    __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
-    __pyx_v_self->mode = __pyx_n_u_c;
+    __pyx_v_self->mode = __pyx_n_u_fortran;
 
-    /* "View.MemoryView":165
+    /* "View.MemoryView":157
  * 
  *         cdef char order
- *         if mode == 'c':             # <<<<<<<<<<<<<<
- *             order = b'C'
- *             self.mode = u'c'
+ *         if mode == 'fortran':             # <<<<<<<<<<<<<<
+ *             order = b'F'
+ *             self.mode = u'fortran'
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":168
- *             order = b'C'
- *             self.mode = u'c'
- *         elif mode == 'fortran':             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
+ *         elif mode == 'c':             # <<<<<<<<<<<<<<
+ *             order = b'C'
+ *             self.mode = u'c'
  */
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(1, 168, __pyx_L1_error)
-  if (likely(__pyx_t_3)) {
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 160, __pyx_L1_error)
+  if (likely(__pyx_t_4)) {
 
-    /* "View.MemoryView":169
- *             self.mode = u'c'
- *         elif mode == 'fortran':
- *             order = b'F'             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":161
  *             self.mode = u'fortran'
+ *         elif mode == 'c':
+ *             order = b'C'             # <<<<<<<<<<<<<<
+ *             self.mode = u'c'
  *         else:
  */
-    __pyx_v_order = 'F';
+    __pyx_v_order = 'C';
 
-    /* "View.MemoryView":170
- *         elif mode == 'fortran':
- *             order = b'F'
- *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":162
+ *         elif mode == 'c':
+ *             order = b'C'
+ *             self.mode = u'c'             # <<<<<<<<<<<<<<
  *         else:
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  */
-    __Pyx_INCREF(__pyx_n_u_fortran);
-    __Pyx_GIVEREF(__pyx_n_u_fortran);
+    __Pyx_INCREF(__pyx_n_u_c);
+    __Pyx_GIVEREF(__pyx_n_u_c);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
-    __pyx_v_self->mode = __pyx_n_u_fortran;
+    __pyx_v_self->mode = __pyx_n_u_c;
 
-    /* "View.MemoryView":168
- *             order = b'C'
- *             self.mode = u'c'
- *         elif mode == 'fortran':             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
+ *         elif mode == 'c':             # <<<<<<<<<<<<<<
+ *             order = b'C'
+ *             self.mode = u'c'
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":172
- *             self.mode = u'fortran'
+  /* "View.MemoryView":164
+ *             self.mode = u'c'
  *         else:
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)
+ *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_mode, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_6, 0, 0);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __PYX_ERR(1, 172, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __PYX_ERR(1, 164, __pyx_L1_error)
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":174
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"
+  /* "View.MemoryView":166
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)             # <<<<<<<<<<<<<<
+ *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
+ *                                              itemsize, self.ndim, order)
  * 
- *         self.free_data = allocate_buffer
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
-  /* "View.MemoryView":176
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)
+  /* "View.MemoryView":169
+ *                                              itemsize, self.ndim, order)
  * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
- * 
+ *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
-  /* "View.MemoryView":177
+  /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
- * 
  *         if allocate_buffer:
+ * 
  */
-  __pyx_t_6 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 177, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 177, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_v_self->dtype_is_object = __pyx_t_3;
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  __pyx_v_self->dtype_is_object = __pyx_t_4;
 
-  /* "View.MemoryView":179
+  /* "View.MemoryView":171
+ *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
- * 
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *             _allocate_buffer(self)
+ * 
  * 
  */
-  if (__pyx_v_allocate_buffer) {
+  __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":180
+    /* "View.MemoryView":174
  * 
- *         if allocate_buffer:
- *             _allocate_buffer(self)             # <<<<<<<<<<<<<<
+ * 
+ *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")
+ */
+    __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
+
+    /* "View.MemoryView":175
+ * 
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ */
+    __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
+    if (unlikely(__pyx_t_4)) {
+
+      /* "View.MemoryView":176
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
+ * 
+ *             if self.dtype_is_object:
+ */
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 176, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __PYX_ERR(1, 176, __pyx_L1_error)
+
+      /* "View.MemoryView":175
+ * 
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ */
+    }
+
+    /* "View.MemoryView":178
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ */
+    __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_4) {
+
+      /* "View.MemoryView":179
+ * 
+ *             if self.dtype_is_object:
+ *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None
+ */
+      __pyx_v_p = ((PyObject **)__pyx_v_self->data);
+
+      /* "View.MemoryView":180
+ *             if self.dtype_is_object:
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
+ *                     p[i] = Py_None
+ *                     Py_INCREF(Py_None)
+ */
+      if (unlikely(__pyx_v_itemsize == 0)) {
+        PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
+        __PYX_ERR(1, 180, __pyx_L1_error)
+      }
+      else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
+        PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
+        __PYX_ERR(1, 180, __pyx_L1_error)
+      }
+      __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
+      __pyx_t_9 = __pyx_t_1;
+      for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
+        __pyx_v_i = __pyx_t_11;
+
+        /* "View.MemoryView":181
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None             # <<<<<<<<<<<<<<
+ *                     Py_INCREF(Py_None)
+ * 
+ */
+        (__pyx_v_p[__pyx_v_i]) = Py_None;
+
+        /* "View.MemoryView":182
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None
+ *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
-    __pyx_t_7 = __pyx_array_allocate_buffer(__pyx_v_self); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(1, 180, __pyx_L1_error)
+        Py_INCREF(Py_None);
+      }
 
-    /* "View.MemoryView":179
- *         self.dtype_is_object = format == b'O'
+      /* "View.MemoryView":178
+ *                 raise MemoryError("unable to allocate array data.")
  * 
+ *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ */
+    }
+
+    /* "View.MemoryView":171
+ *         self.free_data = allocate_buffer
+ *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *             _allocate_buffer(self)
+ * 
  * 
  */
   }
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_10);
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":182
- *             _allocate_buffer(self)
+/* "View.MemoryView":185
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
+ *         if self.mode == u"c":
  */
 
 /* Python wrapper */
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(((struct __pyx_array_obj *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -4635,316 +4531,278 @@
 }
 
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_v_bufmode;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  char *__pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  int __pyx_t_4;
-  Py_ssize_t *__pyx_t_5;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  char *__pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  Py_ssize_t *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  if (unlikely(__pyx_v_info == NULL)) {
+  if (__pyx_v_info == NULL) {
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":184
+  /* "View.MemoryView":186
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1             # <<<<<<<<<<<<<<
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
   __pyx_v_bufmode = -1;
 
-  /* "View.MemoryView":185
+  /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):             # <<<<<<<<<<<<<<
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if self.mode == u"c":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = ((__pyx_v_flags & ((PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS) | PyBUF_ANY_CONTIGUOUS)) != 0);
-  if (__pyx_t_1) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 187, __pyx_L1_error)
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":186
+    /* "View.MemoryView":188
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
-    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 186, __pyx_L1_error)
-    if (__pyx_t_1) {
+    __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-      /* "View.MemoryView":187
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- */
-      __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
-
-      /* "View.MemoryView":186
+    /* "View.MemoryView":187
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
+ *         if self.mode == u"c":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
  */
-      goto __pyx_L4;
-    }
+    goto __pyx_L3;
+  }
 
-    /* "View.MemoryView":188
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
+  /* "View.MemoryView":189
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
  */
-    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 188, __pyx_L1_error)
-    if (__pyx_t_1) {
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 189, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_2 != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":189
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
- */
-      __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
-
-      /* "View.MemoryView":188
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
+    /* "View.MemoryView":190
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
+ */
+    __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
+
+    /* "View.MemoryView":189
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
  */
-    }
-    __pyx_L4:;
+  }
+  __pyx_L3:;
 
-    /* "View.MemoryView":190
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):             # <<<<<<<<<<<<<<
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":191
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
-    __pyx_t_1 = (!((__pyx_v_flags & __pyx_v_bufmode) != 0));
-    if (unlikely(__pyx_t_1)) {
+  __pyx_t_1 = ((!((__pyx_v_flags & __pyx_v_bufmode) != 0)) != 0);
+  if (unlikely(__pyx_t_1)) {
 
-      /* "View.MemoryView":191
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":192
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Can_only_create_a_buffer_that_is, 0, 0);
-      __PYX_ERR(1, 191, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 192, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 192, __pyx_L1_error)
 
-      /* "View.MemoryView":190
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):             # <<<<<<<<<<<<<<
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+    /* "View.MemoryView":191
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
-    }
-
-    /* "View.MemoryView":185
- *     def __getbuffer__(self, Py_buffer *info, int flags):
- *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):             # <<<<<<<<<<<<<<
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- */
   }
 
-  /* "View.MemoryView":192
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":193
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data             # <<<<<<<<<<<<<<
  *         info.len = self.len
- * 
+ *         info.ndim = self.ndim
  */
-  __pyx_t_2 = __pyx_v_self->data;
-  __pyx_v_info->buf = __pyx_t_2;
+  __pyx_t_4 = __pyx_v_self->data;
+  __pyx_v_info->buf = __pyx_t_4;
 
-  /* "View.MemoryView":193
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":194
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  *         info.len = self.len             # <<<<<<<<<<<<<<
- * 
- *         if flags & PyBUF_STRIDES:
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape
  */
-  __pyx_t_3 = __pyx_v_self->len;
-  __pyx_v_info->len = __pyx_t_3;
+  __pyx_t_5 = __pyx_v_self->len;
+  __pyx_v_info->len = __pyx_t_5;
 
   /* "View.MemoryView":195
+ *         info.buf = self.data
  *         info.len = self.len
- * 
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
- *             info.ndim = self.ndim
- *             info.shape = self._shape
- */
-  __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
-  if (__pyx_t_1) {
-
-    /* "View.MemoryView":196
- * 
- *         if flags & PyBUF_STRIDES:
- *             info.ndim = self.ndim             # <<<<<<<<<<<<<<
- *             info.shape = self._shape
- *             info.strides = self._strides
+ *         info.ndim = self.ndim             # <<<<<<<<<<<<<<
+ *         info.shape = self._shape
+ *         info.strides = self._strides
  */
-    __pyx_t_4 = __pyx_v_self->ndim;
-    __pyx_v_info->ndim = __pyx_t_4;
-
-    /* "View.MemoryView":197
- *         if flags & PyBUF_STRIDES:
- *             info.ndim = self.ndim
- *             info.shape = self._shape             # <<<<<<<<<<<<<<
- *             info.strides = self._strides
- *         else:
- */
-    __pyx_t_5 = __pyx_v_self->_shape;
-    __pyx_v_info->shape = __pyx_t_5;
-
-    /* "View.MemoryView":198
- *             info.ndim = self.ndim
- *             info.shape = self._shape
- *             info.strides = self._strides             # <<<<<<<<<<<<<<
- *         else:
- *             info.ndim = 1
- */
-    __pyx_t_5 = __pyx_v_self->_strides;
-    __pyx_v_info->strides = __pyx_t_5;
+  __pyx_t_6 = __pyx_v_self->ndim;
+  __pyx_v_info->ndim = __pyx_t_6;
 
-    /* "View.MemoryView":195
+  /* "View.MemoryView":196
  *         info.len = self.len
- * 
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
- *             info.ndim = self.ndim
- *             info.shape = self._shape
- */
-    goto __pyx_L6;
-  }
-
-  /* "View.MemoryView":200
- *             info.strides = self._strides
- *         else:
- *             info.ndim = 1             # <<<<<<<<<<<<<<
- *             info.shape = &self.len if flags & PyBUF_ND else NULL
- *             info.strides = NULL
- */
-  /*else*/ {
-    __pyx_v_info->ndim = 1;
-
-    /* "View.MemoryView":201
- *         else:
- *             info.ndim = 1
- *             info.shape = &self.len if flags & PyBUF_ND else NULL             # <<<<<<<<<<<<<<
- *             info.strides = NULL
- * 
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape             # <<<<<<<<<<<<<<
+ *         info.strides = self._strides
+ *         info.suboffsets = NULL
  */
-    if (((__pyx_v_flags & PyBUF_ND) != 0)) {
-      __pyx_t_5 = (&__pyx_v_self->len);
-    } else {
-      __pyx_t_5 = NULL;
-    }
-    __pyx_v_info->shape = __pyx_t_5;
+  __pyx_t_7 = __pyx_v_self->_shape;
+  __pyx_v_info->shape = __pyx_t_7;
 
-    /* "View.MemoryView":202
- *             info.ndim = 1
- *             info.shape = &self.len if flags & PyBUF_ND else NULL
- *             info.strides = NULL             # <<<<<<<<<<<<<<
- * 
+  /* "View.MemoryView":197
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape
+ *         info.strides = self._strides             # <<<<<<<<<<<<<<
  *         info.suboffsets = NULL
+ *         info.itemsize = self.itemsize
  */
-    __pyx_v_info->strides = NULL;
-  }
-  __pyx_L6:;
+  __pyx_t_7 = __pyx_v_self->_strides;
+  __pyx_v_info->strides = __pyx_t_7;
 
-  /* "View.MemoryView":204
- *             info.strides = NULL
- * 
+  /* "View.MemoryView":198
+ *         info.shape = self._shape
+ *         info.strides = self._strides
  *         info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *         info.itemsize = self.itemsize
  *         info.readonly = 0
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "View.MemoryView":205
- * 
+  /* "View.MemoryView":199
+ *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
+ * 
  */
-  __pyx_t_3 = __pyx_v_self->itemsize;
-  __pyx_v_info->itemsize = __pyx_t_3;
+  __pyx_t_5 = __pyx_v_self->itemsize;
+  __pyx_v_info->itemsize = __pyx_t_5;
 
-  /* "View.MemoryView":206
+  /* "View.MemoryView":200
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
- *         info.obj = self
+ * 
+ *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
-  /* "View.MemoryView":207
- *         info.itemsize = self.itemsize
+  /* "View.MemoryView":202
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL             # <<<<<<<<<<<<<<
- *         info.obj = self
  * 
+ *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
+ *             info.format = self.format
+ *         else:
  */
-  if (((__pyx_v_flags & PyBUF_FORMAT) != 0)) {
-    __pyx_t_2 = __pyx_v_self->format;
-  } else {
-    __pyx_t_2 = NULL;
-  }
-  __pyx_v_info->format = __pyx_t_2;
+  __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
+  if (__pyx_t_1) {
 
-  /* "View.MemoryView":208
+    /* "View.MemoryView":203
+ * 
+ *         if flags & PyBUF_FORMAT:
+ *             info.format = self.format             # <<<<<<<<<<<<<<
+ *         else:
+ *             info.format = NULL
+ */
+    __pyx_t_4 = __pyx_v_self->format;
+    __pyx_v_info->format = __pyx_t_4;
+
+    /* "View.MemoryView":202
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
+ * 
+ *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
+ *             info.format = self.format
+ *         else:
+ */
+    goto __pyx_L5;
+  }
+
+  /* "View.MemoryView":205
+ *             info.format = self.format
+ *         else:
+ *             info.format = NULL             # <<<<<<<<<<<<<<
+ * 
+ *         info.obj = self
+ */
+  /*else*/ {
+    __pyx_v_info->format = NULL;
+  }
+  __pyx_L5:;
+
+  /* "View.MemoryView":207
+ *             info.format = NULL
+ * 
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
- *     def __dealloc__(array self):
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":182
- *             _allocate_buffer(self)
+  /* "View.MemoryView":185
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
+ *         if self.mode == u"c":
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
@@ -4954,165 +4812,156 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":210
- *         info.obj = self
+/* "View.MemoryView":211
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
 /* Python wrapper */
 static void __pyx_array___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_array___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  int __pyx_t_2;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":211
+  /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  */
-  __pyx_t_1 = (__pyx_v_self->callback_free_data != NULL);
+  __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":212
+    /* "View.MemoryView":213
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
-    /* "View.MemoryView":211
+    /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":213
+  /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:             # <<<<<<<<<<<<<<
+ *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+ *                 refcount_objects_in_slice(self.data, self._shape,
  */
-  if (__pyx_v_self->free_data) {
-  } else {
-    __pyx_t_1 = __pyx_v_self->free_data;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_2 = (__pyx_v_self->data != NULL);
-  __pyx_t_1 = __pyx_t_2;
-  __pyx_L4_bool_binop_done:;
+  __pyx_t_1 = (__pyx_v_self->free_data != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":214
+    /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
- *             free(self.data)
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  */
-    if (__pyx_v_self->dtype_is_object) {
+    __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":215
- *         elif self.free_data and self.data is not NULL:
+      /* "View.MemoryView":216
+ *         elif self.free_data:
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)             # <<<<<<<<<<<<<<
+ *                 refcount_objects_in_slice(self.data, self._shape,             # <<<<<<<<<<<<<<
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)
- *         PyObject_Free(self._shape)
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_self->data, __pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_self->ndim, 0);
 
-      /* "View.MemoryView":214
+      /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
- *             free(self.data)
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  */
     }
 
-    /* "View.MemoryView":216
- *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+    /* "View.MemoryView":218
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
  * 
  */
     free(__pyx_v_self->data);
 
-    /* "View.MemoryView":213
+    /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:             # <<<<<<<<<<<<<<
+ *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+ *                 refcount_objects_in_slice(self.data, self._shape,
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":217
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+  /* "View.MemoryView":219
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
-  /* "View.MemoryView":210
- *         info.obj = self
+  /* "View.MemoryView":211
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":219
- *         PyObject_Free(self._shape)
+/* "View.MemoryView":222
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def memview(self):
+ *     @property
+ *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_5array_7memview___get__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5124,48 +4973,48 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":221
+  /* "View.MemoryView":223
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 221, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":219
- *         PyObject_Free(self._shape)
+  /* "View.MemoryView":222
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def memview(self):
+ *     @property
+ *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.memview.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":224
+/* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5177,54 +5026,54 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_memview", 0);
 
-  /* "View.MemoryView":225
+  /* "View.MemoryView":227
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
-  /* "View.MemoryView":226
+  /* "View.MemoryView":228
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":224
+  /* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5237,26 +5086,25 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":228
+/* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self); /*proto*/
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5264,50 +5112,49 @@
 }
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":229
+  /* "View.MemoryView":231
  * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
-  /* "View.MemoryView":228
+  /* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":231
+/* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr); /*proto*/
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getattr__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_attr));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5320,32 +5167,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
-  /* "View.MemoryView":232
+  /* "View.MemoryView":234
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 232, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 232, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":231
+  /* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5357,26 +5204,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":234
+/* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item); /*proto*/
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_item));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5389,32 +5235,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":235
+  /* "View.MemoryView":237
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":234
+  /* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5426,26 +5272,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":237
+/* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
 /* Python wrapper */
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_12__setitem__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_item), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5457,27 +5302,27 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
-  /* "View.MemoryView":238
+  /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely((PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0))) __PYX_ERR(1, 238, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":237
+  /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5491,577 +5336,349 @@
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_array___reduce_cython__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_array___reduce_cython__(CYTHON_UNUSED struct __pyx_array_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_array_2__setstate_cython__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_array_2__setstate_cython__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_array_2__setstate_cython__(CYTHON_UNUSED struct __pyx_array_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":248
- * 
- * @cname("__pyx_array_allocate_buffer")
- * cdef int _allocate_buffer(array self) except -1:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-
-static int __pyx_array_allocate_buffer(struct __pyx_array_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_v_i;
-  PyObject **__pyx_v_p;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  Py_ssize_t __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_allocate_buffer", 0);
-
-  /* "View.MemoryView":254
- *     cdef PyObject **p
- * 
- *     self.free_data = True             # <<<<<<<<<<<<<<
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:
- */
-  __pyx_v_self->free_data = 1;
-
-  /* "View.MemoryView":255
- * 
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
- *     if not self.data:
- *         raise MemoryError, "unable to allocate array data."
- */
-  __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
-
-  /* "View.MemoryView":256
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:             # <<<<<<<<<<<<<<
- *         raise MemoryError, "unable to allocate array data."
- * 
- */
-  __pyx_t_1 = (!(__pyx_v_self->data != 0));
-  if (unlikely(__pyx_t_1)) {
-
-    /* "View.MemoryView":257
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:
- *         raise MemoryError, "unable to allocate array data."             # <<<<<<<<<<<<<<
- * 
- *     if self.dtype_is_object:
- */
-    __Pyx_Raise(__pyx_builtin_MemoryError, __pyx_kp_s_unable_to_allocate_array_data, 0, 0);
-    __PYX_ERR(1, 257, __pyx_L1_error)
-
-    /* "View.MemoryView":256
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:             # <<<<<<<<<<<<<<
- *         raise MemoryError, "unable to allocate array data."
- * 
- */
-  }
-
-  /* "View.MemoryView":259
- *         raise MemoryError, "unable to allocate array data."
- * 
- *     if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- */
-  if (__pyx_v_self->dtype_is_object) {
-
-    /* "View.MemoryView":260
- * 
- *     if self.dtype_is_object:
- *         p = <PyObject **> self.data             # <<<<<<<<<<<<<<
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None
- */
-    __pyx_v_p = ((PyObject **)__pyx_v_self->data);
-
-    /* "View.MemoryView":261
- *     if self.dtype_is_object:
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):             # <<<<<<<<<<<<<<
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)
- */
-    if (unlikely(__pyx_v_self->itemsize == 0)) {
-      PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 261, __pyx_L1_error)
-    }
-    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_self->itemsize == (Py_ssize_t)-1)  && unlikely(__Pyx_UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
-      PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 261, __pyx_L1_error)
-    }
-    __pyx_t_2 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_self->itemsize);
-    __pyx_t_3 = __pyx_t_2;
-    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-      __pyx_v_i = __pyx_t_4;
-
-      /* "View.MemoryView":262
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None             # <<<<<<<<<<<<<<
- *             Py_INCREF(Py_None)
- *     return 0
- */
-      (__pyx_v_p[__pyx_v_i]) = Py_None;
-
-      /* "View.MemoryView":263
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
- *     return 0
- * 
- */
-      Py_INCREF(Py_None);
-    }
-
-    /* "View.MemoryView":259
- *         raise MemoryError, "unable to allocate array data."
- * 
- *     if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- */
-  }
-
-  /* "View.MemoryView":264
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)
- *     return 0             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = 0;
-  goto __pyx_L0;
-
-  /* "View.MemoryView":248
- * 
- * @cname("__pyx_array_allocate_buffer")
- * cdef int _allocate_buffer(array self) except -1:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._allocate_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "View.MemoryView":268
+/* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):             # <<<<<<<<<<<<<<
+ * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
+ *                           char *mode, char *buf):
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
  */
 
-static struct __pyx_array_obj *__pyx_array_new(PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, char *__pyx_v_format, char *__pyx_v_c_mode, char *__pyx_v_buf) {
+static struct __pyx_array_obj *__pyx_array_new(PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, char *__pyx_v_format, char *__pyx_v_mode, char *__pyx_v_buf) {
   struct __pyx_array_obj *__pyx_v_result = 0;
-  PyObject *__pyx_v_mode = 0;
   struct __pyx_array_obj *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
-  /* "View.MemoryView":270
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):
+  /* "View.MemoryView":248
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.             # <<<<<<<<<<<<<<
  * 
- *     if buf is NULL:
- */
-  if (((__pyx_v_c_mode[0]) == 'f')) {
-    __Pyx_INCREF(__pyx_n_s_fortran);
-    __pyx_t_1 = __pyx_n_s_fortran;
-  } else {
-    __Pyx_INCREF(__pyx_n_s_c);
-    __pyx_t_1 = __pyx_n_s_c;
-  }
-  __pyx_v_mode = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "View.MemoryView":272
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
- * 
- *     if buf is NULL:             # <<<<<<<<<<<<<<
- *         result = array.__new__(array, shape, itemsize, format, mode)
+ *     if buf == NULL:             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
-  __pyx_t_2 = (__pyx_v_buf == NULL);
-  if (__pyx_t_2) {
+  __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":273
+    /* "View.MemoryView":249
  * 
- *     if buf is NULL:
- *         result = array.__new__(array, shape, itemsize, format, mode)             # <<<<<<<<<<<<<<
+ *     if buf == NULL:
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 273, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 273, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 273, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_shape);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
-    __Pyx_INCREF(__pyx_v_mode);
-    __Pyx_GIVEREF(__pyx_v_mode);
-    PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_v_mode);
-    __pyx_t_1 = 0;
-    __pyx_t_3 = 0;
-    __pyx_t_3 = ((PyObject *)__pyx_tp_new_array(((PyTypeObject *)__pyx_array_type), __pyx_t_4, NULL)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 273, __pyx_L1_error)
-    __Pyx_GOTREF((PyObject *)__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
+    __pyx_t_2 = 0;
     __pyx_t_3 = 0;
+    __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
+    __pyx_t_4 = 0;
 
-    /* "View.MemoryView":272
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
+    /* "View.MemoryView":248
+ *     cdef array result
  * 
- *     if buf is NULL:             # <<<<<<<<<<<<<<
- *         result = array.__new__(array, shape, itemsize, format, mode)
+ *     if buf == NULL:             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":275
- *         result = array.__new__(array, shape, itemsize, format, mode)
+  /* "View.MemoryView":251
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
+ *                        allocate_buffer=False)
  *         result.data = buf
- * 
  */
   /*else*/ {
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 275, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_shape);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_4);
-    __Pyx_INCREF(__pyx_v_mode);
-    __Pyx_GIVEREF(__pyx_v_mode);
-    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_v_mode);
-    __pyx_t_3 = 0;
+    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_3);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 275, __pyx_L1_error)
-    __pyx_t_3 = ((PyObject *)__pyx_tp_new_array(((PyTypeObject *)__pyx_array_type), __pyx_t_1, __pyx_t_4)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF((PyObject *)__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_3);
+    __pyx_t_5 = 0;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":276
+    /* "View.MemoryView":252
+ *     else:
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
+ *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
+ *         result.data = buf
+ * 
+ */
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 252, __pyx_L1_error)
+
+    /* "View.MemoryView":251
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
+ *                        allocate_buffer=False)
+ *         result.data = buf
+ */
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
+    __pyx_t_5 = 0;
+
+    /* "View.MemoryView":253
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
+ *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":278
+  /* "View.MemoryView":255
  *         result.data = buf
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_XDECREF((PyObject *)__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":268
+  /* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):             # <<<<<<<<<<<<<<
+ * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
+ *                           char *mode, char *buf):
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.array_cwrapper", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
-  __Pyx_XDECREF(__pyx_v_mode);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":304
+/* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
 /* Python wrapper */
 static int __pyx_MemviewEnum___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_MemviewEnum___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_name = 0;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,0};
     PyObject* values[1] = {0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_name)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 304, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 304, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 281, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 1)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 304, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -6071,53 +5688,52 @@
 }
 
 static int __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v_name) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "View.MemoryView":305
+  /* "View.MemoryView":282
  *     cdef object name
  *     def __init__(self, name):
  *         self.name = name             # <<<<<<<<<<<<<<
  *     def __repr__(self):
  *         return self.name
  */
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   __Pyx_GOTREF(__pyx_v_self->name);
   __Pyx_DECREF(__pyx_v_self->name);
   __pyx_v_self->name = __pyx_v_name;
 
-  /* "View.MemoryView":304
+  /* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":306
+/* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -6125,27 +5741,27 @@
 }
 
 static PyObject *__pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":307
+  /* "View.MemoryView":284
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
-  /* "View.MemoryView":306
+  /* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -6159,38 +5775,19 @@
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_MemviewEnum___reduce_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -6198,16 +5795,17 @@
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":5
  *     cdef object _dict
@@ -6240,33 +5838,34 @@
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
   __pyx_t_2 = (__pyx_v__dict != Py_None);
-  if (__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
     __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v__dict);
-    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_3));
-    __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_4));
+    __pyx_t_4 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
  *         use_setstate = self.name is not None
@@ -6284,203 +5883,147 @@
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
  *         use_setstate = self.name is not None             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  */
   /*else*/ {
-    __pyx_t_2 = (__pyx_v_self->name != Py_None);
-    __pyx_v_use_setstate = __pyx_t_2;
+    __pyx_t_3 = (__pyx_v_self->name != Py_None);
+    __pyx_v_use_setstate = __pyx_t_3;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
-  if (__pyx_v_use_setstate) {
+  __pyx_t_3 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":13
  *         use_setstate = self.name is not None
  *     if use_setstate:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_136983863);
-    __Pyx_GIVEREF(__pyx_int_136983863);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_136983863);
+    __Pyx_INCREF(__pyx_int_184977713);
+    __Pyx_GIVEREF(__pyx_int_184977713);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_1, 2, Py_None);
-    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_state);
-    __pyx_t_3 = 0;
-    __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_4;
+    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
     __pyx_t_4 = 0;
+    __pyx_t_1 = 0;
+    __pyx_r = __pyx_t_5;
+    __pyx_t_5 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_136983863);
-    __Pyx_GIVEREF(__pyx_int_136983863);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_136983863);
+    __Pyx_INCREF(__pyx_int_184977713);
+    __Pyx_GIVEREF(__pyx_int_184977713);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
     PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
-    __pyx_t_4 = 0;
+    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    __pyx_t_5 = 0;
     __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_4;
+    __pyx_t_4 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.Enum.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 16, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 16, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 16, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.Enum.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_MemviewEnum_2__setstate_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_MemviewEnum_2__setstate_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_MemviewEnum_2__setstate_cython__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
@@ -6489,26 +6032,26 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None) || __Pyx_RaiseUnexpectedTypeError("tuple", __pyx_v___pyx_state))) __PYX_ERR(1, 17, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
@@ -6518,97 +6061,175 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":349
+/* "View.MemoryView":298
+ * 
+ * @cname('__pyx_align_pointer')
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
+ */
+
+static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
+  Py_intptr_t __pyx_v_aligned_p;
+  size_t __pyx_v_offset;
+  void *__pyx_r;
+  int __pyx_t_1;
+
+  /* "View.MemoryView":300
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
+ *     cdef size_t offset
+ * 
+ */
+  __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
+
+  /* "View.MemoryView":304
+ * 
+ *     with cython.cdivision(True):
+ *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
+ * 
+ *     if offset > 0:
+ */
+  __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
+
+  /* "View.MemoryView":306
+ *         offset = aligned_p % alignment
+ * 
+ *     if offset > 0:             # <<<<<<<<<<<<<<
+ *         aligned_p += alignment - offset
+ * 
+ */
+  __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":307
+ * 
+ *     if offset > 0:
+ *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
+ * 
+ *     return <void *> aligned_p
+ */
+    __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
+
+    /* "View.MemoryView":306
+ *         offset = aligned_p % alignment
+ * 
+ *     if offset > 0:             # <<<<<<<<<<<<<<
+ *         aligned_p += alignment - offset
+ * 
+ */
+  }
+
+  /* "View.MemoryView":309
+ *         aligned_p += alignment - offset
+ * 
+ *     return <void *> aligned_p             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = ((void *)__pyx_v_aligned_p);
+  goto __pyx_L0;
+
+  /* "View.MemoryView":298
+ * 
+ * @cname('__pyx_align_pointer')
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_memoryview___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_obj = 0;
   int __pyx_v_flags;
   int __pyx_v_dtype_is_object;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_flags,&__pyx_n_s_dtype_is_object,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_flags,&__pyx_n_s_dtype_is_object,0};
     PyObject* values[3] = {0,0,0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_obj)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flags)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 349, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dtype_is_object);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 345, __pyx_L3_error)
       }
     } else {
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-        values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, __pyx_nargs); __PYX_ERR(1, 349, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -6619,313 +6240,279 @@
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj, int __pyx_v_flags, int __pyx_v_dtype_is_object) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  Py_intptr_t __pyx_t_4;
-  size_t __pyx_t_5;
+  int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "View.MemoryView":350
+  /* "View.MemoryView":346
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
   __Pyx_GOTREF(__pyx_v_self->obj);
   __Pyx_DECREF(__pyx_v_self->obj);
   __pyx_v_self->obj = __pyx_v_obj;
 
-  /* "View.MemoryView":351
+  /* "View.MemoryView":347
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj
  *         self.flags = flags             # <<<<<<<<<<<<<<
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  */
   __pyx_v_self->flags = __pyx_v_flags;
 
-  /* "View.MemoryView":352
+  /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   __pyx_t_2 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)__pyx_memoryview_type));
-  if (!__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (!__pyx_t_3) {
   } else {
-    __pyx_t_1 = __pyx_t_2;
+    __pyx_t_1 = __pyx_t_3;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_2 = (__pyx_v_obj != Py_None);
+  __pyx_t_3 = (__pyx_v_obj != Py_None);
+  __pyx_t_2 = (__pyx_t_3 != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":353
+    /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_3 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 353, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 349, __pyx_L1_error)
 
-    /* "View.MemoryView":354
+    /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
-    __pyx_t_1 = (((PyObject *)__pyx_v_self->view.obj) == NULL);
+    __pyx_t_1 = ((((PyObject *)__pyx_v_self->view.obj) == NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":355
+      /* "View.MemoryView":351
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
  * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
-      /* "View.MemoryView":356
+      /* "View.MemoryView":352
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
+ *         global __pyx_memoryview_thread_locks_used
  */
       Py_INCREF(Py_None);
 
-      /* "View.MemoryView":354
+      /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     }
 
-    /* "View.MemoryView":352
+    /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
-  /* "View.MemoryView":358
- *                 Py_INCREF(Py_None)
+  /* "View.MemoryView":355
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-  __pyx_t_1 = (!__PYX_CYTHON_ATOMICS_ENABLED());
+  __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":360
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
- */
-    __pyx_t_1 = (__pyx_memoryview_thread_locks_used < 8);
-    if (__pyx_t_1) {
-
-      /* "View.MemoryView":361
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
- */
-      __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
-
-      /* "View.MemoryView":362
- *             if __pyx_memoryview_thread_locks_used < 8:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
+    /* "View.MemoryView":356
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ */
+    __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+
+    /* "View.MemoryView":357
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  */
-      __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
+    __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
 
-      /* "View.MemoryView":360
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
- */
-    }
-
-    /* "View.MemoryView":363
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+    /* "View.MemoryView":355
+ * 
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-    __pyx_t_1 = (__pyx_v_self->lock == NULL);
-    if (__pyx_t_1) {
+  }
 
-      /* "View.MemoryView":364
- *                 __pyx_memoryview_thread_locks_used += 1
+  /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
- *                 if self.lock is NULL:
- *                     raise MemoryError
  */
-      __pyx_v_self->lock = PyThread_allocate_lock();
+  __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":365
+    /* "View.MemoryView":359
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
+ *                 raise MemoryError
  */
-      __pyx_t_1 = (__pyx_v_self->lock == NULL);
-      if (unlikely(__pyx_t_1)) {
+    __pyx_v_self->lock = PyThread_allocate_lock();
 
-        /* "View.MemoryView":366
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
- *                     raise MemoryError             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":360
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError
  * 
- *         if flags & PyBUF_FORMAT:
  */
-        PyErr_NoMemory(); __PYX_ERR(1, 366, __pyx_L1_error)
+    __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+    if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":365
+      /* "View.MemoryView":361
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
+ *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
+ *         if flags & PyBUF_FORMAT:
  */
-      }
+      PyErr_NoMemory(); __PYX_ERR(1, 361, __pyx_L1_error)
 
-      /* "View.MemoryView":363
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+      /* "View.MemoryView":360
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     }
 
     /* "View.MemoryView":358
- *                 Py_INCREF(Py_None)
- * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:
  */
   }
 
-  /* "View.MemoryView":368
- *                     raise MemoryError
+  /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":369
+    /* "View.MemoryView":364
  * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
-    __pyx_t_2 = ((__pyx_v_self->view.format[0]) == 'O');
+    __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L12_bool_binop_done;
+      goto __pyx_L11_bool_binop_done;
     }
-    __pyx_t_2 = ((__pyx_v_self->view.format[1]) == '\x00');
+    __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
-    __pyx_L12_bool_binop_done:;
+    __pyx_L11_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
-    /* "View.MemoryView":368
- *                     raise MemoryError
+    /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":371
+  /* "View.MemoryView":366
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
  * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":373
+  /* "View.MemoryView":368
  *             self.dtype_is_object = dtype_is_object
  * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0             # <<<<<<<<<<<<<<
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
+ *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
- * 
  */
-  #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_4 = ((Py_intptr_t)((void *)(&__pyx_v_self->acquisition_count)));
-    __pyx_t_5 = (sizeof(__pyx_atomic_int_type));
-    if (unlikely(__pyx_t_5 == 0)) {
-      PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 373, __pyx_L1_error)
-    }
-    __pyx_t_1 = ((__pyx_t_4 % __pyx_t_5) == 0);
-    if (unlikely(!__pyx_t_1)) {
-      __Pyx_Raise(__pyx_builtin_AssertionError, 0, 0, 0);
-      __PYX_ERR(1, 373, __pyx_L1_error)
-    }
-  }
-  #else
-  if ((1)); else __PYX_ERR(1, 373, __pyx_L1_error)
-  #endif
+  __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
-  /* "View.MemoryView":374
- * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0
+  /* "View.MemoryView":370
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
+ *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
-  /* "View.MemoryView":349
+  /* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6936,26 +6523,25 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":376
+/* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
 /* Python wrapper */
 static void __pyx_memoryview___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_memoryview___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_2__dealloc__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
@@ -6963,218 +6549,220 @@
 static void __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_2__dealloc__(struct __pyx_memoryview_obj *__pyx_v_self) {
   int __pyx_v_i;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
-  PyThread_type_lock __pyx_t_5;
+  int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
+  PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":377
+  /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":378
+    /* "View.MemoryView":374
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
-    /* "View.MemoryView":377
+    /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":379
+  /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
-  __pyx_t_1 = (((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = ((((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None) != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":381
+    /* "View.MemoryView":377
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL             # <<<<<<<<<<<<<<
  *             Py_DECREF(Py_None)
  * 
  */
     ((Py_buffer *)(&__pyx_v_self->view))->obj = NULL;
 
-    /* "View.MemoryView":382
+    /* "View.MemoryView":378
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  *             Py_DECREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *         cdef int i
  */
     Py_DECREF(Py_None);
 
-    /* "View.MemoryView":379
+    /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":386
+  /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
-  __pyx_t_1 = (__pyx_v_self->lock != NULL);
-  if (__pyx_t_1) {
+  __pyx_t_2 = ((__pyx_v_self->lock != NULL) != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":387
+    /* "View.MemoryView":383
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):             # <<<<<<<<<<<<<<
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  */
-    __pyx_t_2 = __pyx_memoryview_thread_locks_used;
-    __pyx_t_3 = __pyx_t_2;
-    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-      __pyx_v_i = __pyx_t_4;
+    __pyx_t_3 = __pyx_memoryview_thread_locks_used;
+    __pyx_t_4 = __pyx_t_3;
+    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
+      __pyx_v_i = __pyx_t_5;
 
-      /* "View.MemoryView":388
+      /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
-      __pyx_t_1 = ((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock);
-      if (__pyx_t_1) {
+      __pyx_t_2 = (((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock) != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":389
+        /* "View.MemoryView":385
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1             # <<<<<<<<<<<<<<
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  */
         __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used - 1);
 
-        /* "View.MemoryView":390
+        /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
-        __pyx_t_1 = (__pyx_v_i != __pyx_memoryview_thread_locks_used);
-        if (__pyx_t_1) {
+        __pyx_t_2 = ((__pyx_v_i != __pyx_memoryview_thread_locks_used) != 0);
+        if (__pyx_t_2) {
 
-          /* "View.MemoryView":392
+          /* "View.MemoryView":388
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])             # <<<<<<<<<<<<<<
  *                     break
  *             else:
  */
-          __pyx_t_5 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
-          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
+          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+          __pyx_t_7 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
 
-          /* "View.MemoryView":391
+          /* "View.MemoryView":387
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (             # <<<<<<<<<<<<<<
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break
  */
-          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_5;
-          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_7;
 
-          /* "View.MemoryView":390
+          /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         }
 
-        /* "View.MemoryView":393
+        /* "View.MemoryView":389
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break             # <<<<<<<<<<<<<<
  *             else:
  *                 PyThread_free_lock(self.lock)
  */
         goto __pyx_L6_break;
 
-        /* "View.MemoryView":388
+        /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       }
     }
     /*else*/ {
 
-      /* "View.MemoryView":395
+      /* "View.MemoryView":391
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
-    /* "View.MemoryView":386
+    /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
-  /* "View.MemoryView":376
+  /* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":397
+/* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7192,107 +6780,107 @@
   Py_ssize_t __pyx_t_6;
   char *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
-  /* "View.MemoryView":399
+  /* "View.MemoryView":395
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
  * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
-  /* "View.MemoryView":401
+  /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 401, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 397, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 401, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 397, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely((0 < 0))) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely((0 < 0))) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 401, __pyx_L1_error)
+          else __PYX_ERR(1, 397, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
-    /* "View.MemoryView":402
+    /* "View.MemoryView":398
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 402, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 402, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 398, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 398, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
-    /* "View.MemoryView":401
+    /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":404
+  /* "View.MemoryView":400
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  *         return itemp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":397
+  /* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7304,26 +6892,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":407
+/* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index); /*proto*/
 static PyObject *__pyx_memoryview___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_4__getitem__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v_index));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -7333,185 +6920,186 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_4__getitem__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index) {
   PyObject *__pyx_v_have_slices = NULL;
   PyObject *__pyx_v_indices = NULL;
   char *__pyx_v_itemp;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  char *__pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
+  char *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":408
+  /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":409
+    /* "View.MemoryView":405
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF((PyObject *)__pyx_v_self);
+    __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
-    /* "View.MemoryView":408
+    /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   }
 
-  /* "View.MemoryView":411
+  /* "View.MemoryView":407
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 411, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (likely(__pyx_t_2 != Py_None)) {
-    PyObject* sequence = __pyx_t_2;
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 407, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (likely(__pyx_t_3 != Py_None)) {
+    PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 411, __pyx_L1_error)
+      __PYX_ERR(1, 407, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
-    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
-    __Pyx_INCREF(__pyx_t_3);
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
+    __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 411, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 407, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 411, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 407, __pyx_L1_error)
   }
-  __pyx_v_have_slices = __pyx_t_3;
-  __pyx_t_3 = 0;
-  __pyx_v_indices = __pyx_t_4;
+  __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
+  __pyx_v_indices = __pyx_t_5;
+  __pyx_t_5 = 0;
 
-  /* "View.MemoryView":414
+  /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 414, __pyx_L1_error)
-  if (__pyx_t_1) {
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 410, __pyx_L1_error)
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":415
+    /* "View.MemoryView":411
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 415, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":414
+    /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
-  /* "View.MemoryView":417
+  /* "View.MemoryView":413
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_5 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_5 == ((char *)NULL))) __PYX_ERR(1, 417, __pyx_L1_error)
-    __pyx_v_itemp = __pyx_t_5;
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 413, __pyx_L1_error)
+    __pyx_v_itemp = __pyx_t_6;
 
-    /* "View.MemoryView":418
+    /* "View.MemoryView":414
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 414, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":407
+  /* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_indices);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":420
+/* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_6__setitem__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v_index), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -7519,213 +7107,217 @@
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_6__setitem__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
   PyObject *__pyx_v_have_slices = NULL;
   PyObject *__pyx_v_obj = NULL;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
-  /* "View.MemoryView":421
+  /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
-  if (unlikely(__pyx_v_self->view.readonly)) {
+  __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
+  if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":422
+    /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"             # <<<<<<<<<<<<<<
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_Cannot_assign_to_read_only_memor, 0, 0);
-    __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 418, __pyx_L1_error)
 
-    /* "View.MemoryView":421
+    /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":424
- *             raise TypeError, "Cannot assign to read-only memoryview"
+  /* "View.MemoryView":420
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_1 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 424, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (likely(__pyx_t_1 != Py_None)) {
-    PyObject* sequence = __pyx_t_1;
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (likely(__pyx_t_2 != Py_None)) {
+    PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 424, __pyx_L1_error)
+      __PYX_ERR(1, 420, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    __Pyx_INCREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 424, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 424, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     #endif
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 424, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 420, __pyx_L1_error)
   }
-  __pyx_v_have_slices = __pyx_t_2;
-  __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_3);
+  __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
+  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "View.MemoryView":426
+  /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely((__pyx_t_4 < 0))) __PYX_ERR(1, 426, __pyx_L1_error)
-  if (__pyx_t_4) {
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 422, __pyx_L1_error)
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":427
+    /* "View.MemoryView":423
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 427, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_v_obj = __pyx_t_1;
-    __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 423, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_obj = __pyx_t_2;
+    __pyx_t_2 = 0;
 
-    /* "View.MemoryView":428
+    /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely((__pyx_t_4 < 0))) __PYX_ERR(1, 428, __pyx_L1_error)
-    if (__pyx_t_4) {
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":429
+      /* "View.MemoryView":425
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 429, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_1, __pyx_v_obj); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 429, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "View.MemoryView":428
+      /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":431
+    /* "View.MemoryView":427
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_3 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 431, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 431, __pyx_L1_error)
-      __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_3), __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 431, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":426
+    /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":433
+  /* "View.MemoryView":429
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 433, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":420
+  /* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":435
+/* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7743,26 +7335,26 @@
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
-  /* "View.MemoryView":436
+  /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
-  __pyx_t_2 = (!__pyx_t_1);
+  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":437
+    /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
     {
@@ -7770,59 +7362,59 @@
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_3);
       __Pyx_XGOTREF(__pyx_t_4);
       __Pyx_XGOTREF(__pyx_t_5);
       /*try:*/ {
 
-        /* "View.MemoryView":438
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":439
+        /* "View.MemoryView":435
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 439, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 435, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
-        /* "View.MemoryView":438
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
-        /* "View.MemoryView":437
+        /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       }
@@ -7831,89 +7423,89 @@
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       goto __pyx_L9_try_end;
       __pyx_L4_error:;
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-      /* "View.MemoryView":440
+      /* "View.MemoryView":436
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 440, __pyx_L6_except_error)
-        __Pyx_XGOTREF(__pyx_t_7);
-        __Pyx_XGOTREF(__pyx_t_8);
-        __Pyx_XGOTREF(__pyx_t_6);
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 436, __pyx_L6_except_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __Pyx_GOTREF(__pyx_t_8);
+        __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":441
+        /* "View.MemoryView":437
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
  * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_r = Py_None; __Pyx_INCREF(Py_None);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         goto __pyx_L7_except_return;
       }
       goto __pyx_L6_except_error;
+      __pyx_L6_except_error:;
 
-      /* "View.MemoryView":437
+      /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
-      __pyx_L6_except_error:;
       __Pyx_XGIVEREF(__pyx_t_3);
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L1_error;
       __pyx_L7_except_return:;
       __Pyx_XGIVEREF(__pyx_t_3);
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
-    /* "View.MemoryView":436
+    /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
-  /* "View.MemoryView":443
+  /* "View.MemoryView":439
  *                 return None
  * 
  *         return obj             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":435
+  /* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7927,101 +7519,106 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":445
+/* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src) {
   __Pyx_memviewslice __pyx_v_dst_slice;
   __Pyx_memviewslice __pyx_v_src_slice;
-  __Pyx_memviewslice __pyx_v_msrc;
-  __Pyx_memviewslice __pyx_v_mdst;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_memviewslice *__pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_t_3;
+  __Pyx_memviewslice *__pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
-  /* "View.MemoryView":448
- *         cdef __Pyx_memviewslice dst_slice
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
- *         cdef __Pyx_memviewslice msrc = get_slice_from_memview(src, &src_slice)[0]             # <<<<<<<<<<<<<<
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]
  * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_v_msrc = (__pyx_t_1[0]);
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 445, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":449
- *         cdef __Pyx_memviewslice src_slice
- *         cdef __Pyx_memviewslice msrc = get_slice_from_memview(src, &src_slice)[0]
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":446
+ * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 449, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 449, __pyx_L1_error)
-  __pyx_v_mdst = (__pyx_t_1[0]);
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 446, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 446, __pyx_L1_error)
 
-  /* "View.MemoryView":451
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]
- * 
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":447
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_5 = __pyx_memoryview_copy_contents(__pyx_v_msrc, __pyx_v_mdst, __pyx_t_3, __pyx_t_4, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 451, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":445
+ *         cdef __Pyx_memviewslice src_slice
+ * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
+ */
+  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 445, __pyx_L1_error)
+
+  /* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.setitem_slice_assignment", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":453
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
+/* "View.MemoryView":449
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assign_scalar(struct __pyx_memoryview_obj *__pyx_v_self, struct __pyx_memoryview_obj *__pyx_v_dst, PyObject *__pyx_v_value) {
@@ -8045,201 +7642,204 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
-  /* "View.MemoryView":455
+  /* "View.MemoryView":451
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
  * 
  */
   __pyx_v_tmp = NULL;
 
-  /* "View.MemoryView":460
+  /* "View.MemoryView":456
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 460, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 456, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
-  /* "View.MemoryView":462
+  /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
-  __pyx_t_2 = (((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array)));
+  __pyx_t_2 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":463
+    /* "View.MemoryView":459
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
-    /* "View.MemoryView":464
+    /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
-    __pyx_t_2 = (__pyx_v_tmp == NULL);
+    __pyx_t_2 = ((__pyx_v_tmp == NULL) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":465
+      /* "View.MemoryView":461
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 465, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(1, 461, __pyx_L1_error)
 
-      /* "View.MemoryView":464
+      /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     }
 
-    /* "View.MemoryView":466
+    /* "View.MemoryView":462
  *             if tmp == NULL:
  *                 raise MemoryError
  *             item = tmp             # <<<<<<<<<<<<<<
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
-    /* "View.MemoryView":462
+    /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":468
+  /* "View.MemoryView":464
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
  * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":470
+  /* "View.MemoryView":466
  *             item = <void *> array
  * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
-    /* "View.MemoryView":471
+    /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
-    if (__pyx_v_self->dtype_is_object) {
+    __pyx_t_2 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":472
+      /* "View.MemoryView":468
  *         try:
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
-      /* "View.MemoryView":471
+      /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
-    /* "View.MemoryView":474
+    /* "View.MemoryView":470
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 474, __pyx_L6_error)
+      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 470, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
-    /* "View.MemoryView":478
+    /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
-    __pyx_t_2 = (__pyx_v_self->view.suboffsets != NULL);
+    __pyx_t_2 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":479
+      /* "View.MemoryView":475
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_4 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 479, __pyx_L6_error)
+      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 475, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "View.MemoryView":478
+      /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
-    /* "View.MemoryView":480
+    /* "View.MemoryView":476
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,             # <<<<<<<<<<<<<<
  *                                 item, self.dtype_is_object)
  *         finally:
  */
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
-  /* "View.MemoryView":483
+  /* "View.MemoryView":479
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
@@ -8278,16 +7878,16 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "View.MemoryView":453
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
+  /* "View.MemoryView":449
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
   /* function exit code */
@@ -8299,15 +7899,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":485
+/* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8318,36 +7918,36 @@
   char *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
-  /* "View.MemoryView":486
+  /* "View.MemoryView":482
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 486, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 482, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
-  /* "View.MemoryView":487
+  /* "View.MemoryView":483
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 487, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 483, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":485
+  /* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8360,15 +7960,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":489
+/* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8382,46 +7982,47 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   int __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  int __pyx_t_10;
+  PyObject *__pyx_t_9 = NULL;
+  size_t __pyx_t_10;
+  int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":492
+  /* "View.MemoryView":488
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_ImportDottedModule(__pyx_n_s_struct, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 492, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 488, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":495
+  /* "View.MemoryView":491
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 491, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":496
+  /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
@@ -8429,94 +8030,120 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "View.MemoryView":497
+      /* "View.MemoryView":493
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
- *             raise ValueError, "Unable to convert item to object"
+ *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 497, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_7);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
-      {
-        PyObject *__pyx_callargs[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_8, 2+__pyx_t_8);
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_5)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 497, __pyx_L3_error)
+      } else
+      #endif
+      {
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        if (__pyx_t_7) {
+          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
+        }
+        __Pyx_GIVEREF(__pyx_t_6);
+        PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
+        __Pyx_INCREF(__pyx_v_bytesitem);
+        __Pyx_GIVEREF(__pyx_v_bytesitem);
+        PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
+        __pyx_t_6 = 0;
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "View.MemoryView":496
+      /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
-    /* "View.MemoryView":501
- *             raise ValueError, "Unable to convert item to object"
+    /* "View.MemoryView":497
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
-      __pyx_t_9 = __Pyx_ssize_strlen(__pyx_v_self->view.format); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(1, 501, __pyx_L5_except_error)
-      __pyx_t_10 = (__pyx_t_9 == 1);
-      if (__pyx_t_10) {
+      __pyx_t_10 = strlen(__pyx_v_self->view.format); 
+      __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
+      if (__pyx_t_11) {
 
-        /* "View.MemoryView":502
+        /* "View.MemoryView":498
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 502, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 498, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
-        /* "View.MemoryView":501
- *             raise ValueError, "Unable to convert item to object"
+        /* "View.MemoryView":497
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
       }
 
-      /* "View.MemoryView":503
+      /* "View.MemoryView":499
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -8525,95 +8152,100 @@
       goto __pyx_L6_except_return;
     }
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-    /* "View.MemoryView":498
+    /* "View.MemoryView":494
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Unable to convert item to object"
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  */
-    __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 498, __pyx_L5_except_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_7);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_6);
-    __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_6 = 0;
+    __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 494, __pyx_L5_except_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
+    __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 498, __pyx_L5_except_error)
-      __Pyx_XGOTREF(__pyx_t_6);
-      __Pyx_XGOTREF(__pyx_t_5);
-      __Pyx_XGOTREF(__pyx_t_1);
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 494, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_1);
 
-      /* "View.MemoryView":499
+      /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
- *             raise ValueError, "Unable to convert item to object"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Unable_to_convert_item_to_object, 0, 0);
-      __PYX_ERR(1, 499, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __PYX_ERR(1, 495, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
+    __pyx_L5_except_error:;
 
-    /* "View.MemoryView":496
+    /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
-    __pyx_L5_except_error:;
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L1_error;
     __pyx_L6_except_return:;
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":489
+  /* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesitem);
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":505
+/* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8622,218 +8254,247 @@
   char __pyx_v_c;
   PyObject *__pyx_v_bytesvalue = 0;
   Py_ssize_t __pyx_v_i;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
-  char *__pyx_t_9;
-  char *__pyx_t_10;
+  Py_ssize_t __pyx_t_9;
+  PyObject *__pyx_t_10 = NULL;
   char *__pyx_t_11;
   char *__pyx_t_12;
+  char *__pyx_t_13;
+  char *__pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":508
+  /* "View.MemoryView":504
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_ImportDottedModule(__pyx_n_s_struct, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 508, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 504, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":513
+  /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
   __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
-  if (__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
-    /* "View.MemoryView":514
+    /* "View.MemoryView":510
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
+    __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_3))) __PYX_ERR(1, 514, __pyx_L1_error)
-    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_3);
-    __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
+    __pyx_t_4 = 0;
 
-    /* "View.MemoryView":513
+    /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":516
+  /* "View.MemoryView":512
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 516, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 516, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = NULL;
-    __pyx_t_6 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_4)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_4);
+    __pyx_t_5 = NULL;
+    __pyx_t_7 = 0;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_6 = 1;
+        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __pyx_t_7 = 1;
       }
     }
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_4, __pyx_t_1, __pyx_v_value};
-      __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 516, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_5) {
+        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_1);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
+      __Pyx_INCREF(__pyx_v_value);
+      __Pyx_GIVEREF(__pyx_v_value);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
+      __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
-    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_3))) __PYX_ERR(1, 516, __pyx_L1_error)
-    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_3);
-    __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
+    __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":518
+  /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
-  __pyx_t_7 = 0;
+  __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(1, 518, __pyx_L1_error)
+    __PYX_ERR(1, 514, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
-  __pyx_t_8 = __pyx_v_bytesvalue;
-  __pyx_t_10 = PyBytes_AS_STRING(__pyx_t_8);
-  __pyx_t_11 = (__pyx_t_10 + PyBytes_GET_SIZE(__pyx_t_8));
-  for (__pyx_t_12 = __pyx_t_10; __pyx_t_12 < __pyx_t_11; __pyx_t_12++) {
-    __pyx_t_9 = __pyx_t_12;
-    __pyx_v_c = (__pyx_t_9[0]);
+  __pyx_t_10 = __pyx_v_bytesvalue;
+  __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
+  __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
+  for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
+    __pyx_t_11 = __pyx_t_14;
+    __pyx_v_c = (__pyx_t_11[0]);
 
-    /* "View.MemoryView":519
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
-    __pyx_v_i = __pyx_t_7;
+    __pyx_v_i = __pyx_t_9;
 
-    /* "View.MemoryView":518
+    /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
-    __pyx_t_7 = (__pyx_t_7 + 1);
+    __pyx_t_9 = (__pyx_t_9 + 1);
 
-    /* "View.MemoryView":519
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "View.MemoryView":505
+  /* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_10);
   __Pyx_AddTraceback("View.MemoryView.memoryview.assign_item_from_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":521
- *             itemp[i] = c
+/* "View.MemoryView":518
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
 /* Python wrapper */
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_8__getbuffer__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -8841,309 +8502,315 @@
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_8__getbuffer__(struct __pyx_memoryview_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
-  Py_ssize_t *__pyx_t_3;
-  char *__pyx_t_4;
-  void *__pyx_t_5;
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t *__pyx_t_4;
+  char *__pyx_t_5;
+  void *__pyx_t_6;
+  int __pyx_t_7;
+  Py_ssize_t __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  if (unlikely(__pyx_v_info == NULL)) {
+  if (__pyx_v_info == NULL) {
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":523
+  /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_2) {
   } else {
     __pyx_t_1 = __pyx_t_2;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = __pyx_v_self->view.readonly;
+  __pyx_t_2 = (__pyx_v_self->view.readonly != 0);
+  __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":524
+    /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Cannot_create_writable_memory_vi, 0, 0);
-    __PYX_ERR(1, 524, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 520, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 520, __pyx_L1_error)
 
-    /* "View.MemoryView":523
+    /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":526
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+  /* "View.MemoryView":522
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":527
+    /* "View.MemoryView":523
  * 
  *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.shape;
-    __pyx_v_info->shape = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.shape;
+    __pyx_v_info->shape = __pyx_t_4;
 
-    /* "View.MemoryView":526
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+    /* "View.MemoryView":522
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
     goto __pyx_L6;
   }
 
-  /* "View.MemoryView":529
+  /* "View.MemoryView":525
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
   __pyx_L6:;
 
-  /* "View.MemoryView":531
+  /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":532
+    /* "View.MemoryView":528
  * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.strides;
-    __pyx_v_info->strides = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.strides;
+    __pyx_v_info->strides = __pyx_t_4;
 
-    /* "View.MemoryView":531
+    /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
     goto __pyx_L7;
   }
 
-  /* "View.MemoryView":534
+  /* "View.MemoryView":530
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
   __pyx_L7:;
 
-  /* "View.MemoryView":536
+  /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":537
+    /* "View.MemoryView":533
  * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.suboffsets;
-    __pyx_v_info->suboffsets = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.suboffsets;
+    __pyx_v_info->suboffsets = __pyx_t_4;
 
-    /* "View.MemoryView":536
+    /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
     goto __pyx_L8;
   }
 
-  /* "View.MemoryView":539
+  /* "View.MemoryView":535
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
   __pyx_L8:;
 
-  /* "View.MemoryView":541
+  /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":542
+    /* "View.MemoryView":538
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
-    __pyx_t_4 = __pyx_v_self->view.format;
-    __pyx_v_info->format = __pyx_t_4;
+    __pyx_t_5 = __pyx_v_self->view.format;
+    __pyx_v_info->format = __pyx_t_5;
 
-    /* "View.MemoryView":541
+    /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":544
+  /* "View.MemoryView":540
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":546
+  /* "View.MemoryView":542
  *             info.format = NULL
  * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
-  __pyx_t_5 = __pyx_v_self->view.buf;
-  __pyx_v_info->buf = __pyx_t_5;
+  __pyx_t_6 = __pyx_v_self->view.buf;
+  __pyx_v_info->buf = __pyx_t_6;
 
-  /* "View.MemoryView":547
+  /* "View.MemoryView":543
  * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
-  __pyx_t_6 = __pyx_v_self->view.ndim;
-  __pyx_v_info->ndim = __pyx_t_6;
+  __pyx_t_7 = __pyx_v_self->view.ndim;
+  __pyx_v_info->ndim = __pyx_t_7;
 
-  /* "View.MemoryView":548
+  /* "View.MemoryView":544
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize             # <<<<<<<<<<<<<<
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  */
-  __pyx_t_7 = __pyx_v_self->view.itemsize;
-  __pyx_v_info->itemsize = __pyx_t_7;
+  __pyx_t_8 = __pyx_v_self->view.itemsize;
+  __pyx_v_info->itemsize = __pyx_t_8;
 
-  /* "View.MemoryView":549
+  /* "View.MemoryView":545
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len             # <<<<<<<<<<<<<<
  *         info.readonly = self.view.readonly
  *         info.obj = self
  */
-  __pyx_t_7 = __pyx_v_self->view.len;
-  __pyx_v_info->len = __pyx_t_7;
+  __pyx_t_8 = __pyx_v_self->view.len;
+  __pyx_v_info->len = __pyx_t_8;
 
-  /* "View.MemoryView":550
+  /* "View.MemoryView":546
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
  * 
  */
   __pyx_t_1 = __pyx_v_self->view.readonly;
   __pyx_v_info->readonly = __pyx_t_1;
 
-  /* "View.MemoryView":551
+  /* "View.MemoryView":547
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
- * 
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":521
- *             itemp[i] = c
+  /* "View.MemoryView":518
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
@@ -9153,26 +8820,25 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":554
- * 
+/* "View.MemoryView":553
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def T(self):
+ *     @property
+ *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
+ *         transpose_memslice(&result.from_slice)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_1T___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9186,500 +8852,445 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":556
+  /* "View.MemoryView":554
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 556, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 554, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 556, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 554, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":557
+  /* "View.MemoryView":555
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(1, 557, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 555, __pyx_L1_error)
 
-  /* "View.MemoryView":558
+  /* "View.MemoryView":556
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":554
- * 
+  /* "View.MemoryView":553
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def T(self):
+ *     @property
+ *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
+ *         transpose_memslice(&result.from_slice)
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.T.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":560
- *         return result
+/* "View.MemoryView":559
+ * 
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
+ *         return self.obj
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def base(self):
- *         return self._get_base()
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":562
- *     @property
- *     def base(self):
- *         return self._get_base()             # <<<<<<<<<<<<<<
- * 
- *     cdef _get_base(self):
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->_get_base(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 562, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
   /* "View.MemoryView":560
- *         return result
- * 
- *     @property             # <<<<<<<<<<<<<<
+ *     @property
  *     def base(self):
- *         return self._get_base()
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("View.MemoryView.memoryview.base.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "View.MemoryView":564
- *         return self._get_base()
- * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
- *         return self.obj
- * 
- */
-
-static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_get_base", 0);
-
-  /* "View.MemoryView":565
- * 
- *     cdef _get_base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":564
- *         return self._get_base()
+  /* "View.MemoryView":559
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":567
- *         return self.obj
+/* "View.MemoryView":563
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def shape(self):
+ *     @property
+ *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_5shape___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_5shape___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_7genexpr__pyx_v_length;
+  Py_ssize_t __pyx_v_length;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":569
+  /* "View.MemoryView":564
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 569, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
-    for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
-      __pyx_t_2 = __pyx_t_4;
-      __pyx_7genexpr__pyx_v_length = (__pyx_t_2[0]);
-      __pyx_t_5 = PyInt_FromSsize_t(__pyx_7genexpr__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 569, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 569, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 569, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 564, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
+  for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
+    __pyx_t_2 = __pyx_t_4;
+    __pyx_v_length = (__pyx_t_2[0]);
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 564, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":567
- *         return self.obj
+  /* "View.MemoryView":563
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def shape(self):
+ *     @property
+ *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview.shape.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":571
- *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+/* "View.MemoryView":567
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def strides(self):
+ *     @property
+ *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_7strides___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_7strides___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_8genexpr1__pyx_v_stride;
+  Py_ssize_t __pyx_v_stride;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":573
+  /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
- *             raise ValueError, "Buffer view does not expose strides"
+ *             raise ValueError("Buffer view does not expose strides")
  */
-  __pyx_t_1 = (__pyx_v_self->view.strides == NULL);
+  __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":575
+    /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
- *             raise ValueError, "Buffer view does not expose strides"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Buffer_view_does_not_expose_stri, 0, 0);
-    __PYX_ERR(1, 575, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 570, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 570, __pyx_L1_error)
 
-    /* "View.MemoryView":573
+    /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
- *             raise ValueError, "Buffer view does not expose strides"
+ *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
-  /* "View.MemoryView":577
- *             raise ValueError, "Buffer view does not expose strides"
+  /* "View.MemoryView":572
+ *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
-    for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
-      __pyx_t_3 = __pyx_t_5;
-      __pyx_8genexpr1__pyx_v_stride = (__pyx_t_3[0]);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_8genexpr1__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 577, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 577, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 577, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
+  for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
+    __pyx_t_3 = __pyx_t_5;
+    __pyx_v_stride = (__pyx_t_3[0]);
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 572, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  }
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":571
- *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+  /* "View.MemoryView":567
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def strides(self):
+ *     @property
+ *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.memoryview.strides.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":579
- *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
+/* "View.MemoryView":575
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def suboffsets(self):
+ *     @property
+ *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_10suboffsets_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_10suboffsets_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_10suboffsets___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_10suboffsets___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_8genexpr2__pyx_v_suboffset;
+  Py_ssize_t __pyx_v_suboffset;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t *__pyx_t_3;
+  PyObject *__pyx_t_3 = NULL;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
+  Py_ssize_t *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":581
+  /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->view.suboffsets == NULL);
+  __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":582
+    /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PySequence_Multiply(__pyx_tuple__4, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 582, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__12, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 577, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":581
+    /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   }
 
-  /* "View.MemoryView":584
+  /* "View.MemoryView":579
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 584, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
+  for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
+    __pyx_t_4 = __pyx_t_6;
+    __pyx_v_suboffset = (__pyx_t_4[0]);
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
-    for (__pyx_t_5 = __pyx_v_self->view.suboffsets; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
-      __pyx_t_3 = __pyx_t_5;
-      __pyx_8genexpr2__pyx_v_suboffset = (__pyx_t_3[0]);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_8genexpr2__pyx_v_suboffset); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 584, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 584, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 584, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_r = __pyx_t_6;
-  __pyx_t_6 = 0;
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 579, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  }
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":579
- *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
+  /* "View.MemoryView":575
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def suboffsets(self):
+ *     @property
+ *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.suboffsets.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":586
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+/* "View.MemoryView":582
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def ndim(self):
+ *     @property
+ *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4ndim___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9691,59 +9302,58 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":588
+  /* "View.MemoryView":583
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 588, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":586
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+  /* "View.MemoryView":582
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def ndim(self):
+ *     @property
+ *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.ndim.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":590
- *         return self.view.ndim
+/* "View.MemoryView":586
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def itemsize(self):
+ *     @property
+ *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_8itemsize___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9755,59 +9365,58 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":592
+  /* "View.MemoryView":587
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 592, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":590
- *         return self.view.ndim
+  /* "View.MemoryView":586
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def itemsize(self):
+ *     @property
+ *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.itemsize.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":594
- *         return self.view.itemsize
+/* "View.MemoryView":590
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def nbytes(self):
+ *     @property
+ *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_6nbytes___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9821,40 +9430,40 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":596
+  /* "View.MemoryView":591
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":594
- *         return self.view.itemsize
+  /* "View.MemoryView":590
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def nbytes(self):
+ *     @property
+ *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -9862,26 +9471,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":598
- *         return self.size * self.view.itemsize
+/* "View.MemoryView":594
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def size(self):
+ *     @property
+ *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
+ *             result = 1
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4size___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9890,138 +9498,139 @@
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4size___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_v_result = NULL;
   PyObject *__pyx_v_length = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  Py_ssize_t *__pyx_t_2;
+  int __pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  Py_ssize_t *__pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":600
+  /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":601
+    /* "View.MemoryView":596
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
-    /* "View.MemoryView":603
+    /* "View.MemoryView":598
  *             result = 1
  * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
-    __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
-    for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
-      __pyx_t_2 = __pyx_t_4;
-      __pyx_t_5 = PyInt_FromSsize_t((__pyx_t_2[0])); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 603, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_5);
-      __pyx_t_5 = 0;
+    __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
+    for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
+      __pyx_t_3 = __pyx_t_5;
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 598, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
+      __pyx_t_6 = 0;
 
-      /* "View.MemoryView":604
+      /* "View.MemoryView":599
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_5 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 604, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_5);
-      __pyx_t_5 = 0;
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 599, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
+      __pyx_t_6 = 0;
     }
 
-    /* "View.MemoryView":606
+    /* "View.MemoryView":601
  *                 result *= length
  * 
  *             self._size = result             # <<<<<<<<<<<<<<
  * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
-    /* "View.MemoryView":600
+    /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   }
 
-  /* "View.MemoryView":608
+  /* "View.MemoryView":603
  *             self._size = result
  * 
  *         return self._size             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":598
- *         return self.size * self.view.itemsize
+  /* "View.MemoryView":594
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def size(self):
+ *     @property
+ *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
+ *             result = 1
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.memoryview.size.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":610
+/* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_memoryview___len__(PyObject *__pyx_v_self); /*proto*/
 static Py_ssize_t __pyx_memoryview___len__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -10030,79 +9639,78 @@
 
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":611
+  /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->view.ndim >= 1);
+  __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":612
+    /* "View.MemoryView":607
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
  * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
-    /* "View.MemoryView":611
+    /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   }
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":609
  *             return self.view.shape[0]
  * 
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":610
+  /* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":616
+/* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___repr__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_memoryview___repr__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_12__repr__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -10116,64 +9724,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":618
+  /* "View.MemoryView":613
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 613, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":616
+  /* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -10186,26 +9794,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":620
+/* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_14__str__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -10218,43 +9825,43 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__str__", 0);
 
-  /* "View.MemoryView":621
+  /* "View.MemoryView":616
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":620
+  /* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -10266,47 +9873,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":624
+/* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_c_contig (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("is_c_contig", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "is_c_contig", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_16is_c_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10318,39 +9906,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
-  /* "View.MemoryView":627
+  /* "View.MemoryView":622
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 627, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 622, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":628
+  /* "View.MemoryView":623
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 628, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":624
+  /* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10361,47 +9949,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":630
+/* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_f_contig (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("is_f_contig", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "is_f_contig", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_18is_f_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10413,39 +9982,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
-  /* "View.MemoryView":633
+  /* "View.MemoryView":628
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 633, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 628, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":634
+  /* "View.MemoryView":629
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 634, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 629, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":630
+  /* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10456,47 +10025,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":636
+/* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("copy", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "copy", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_20copy(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10508,57 +10058,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy", 0);
 
-  /* "View.MemoryView":638
+  /* "View.MemoryView":633
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
-  /* "View.MemoryView":640
+  /* "View.MemoryView":635
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
-  /* "View.MemoryView":641
+  /* "View.MemoryView":636
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 641, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 636, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":646
+  /* "View.MemoryView":641
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 646, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":636
+  /* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10569,47 +10119,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":648
+/* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy_fortran (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("copy_fortran", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "copy_fortran", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10622,57 +10153,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
-  /* "View.MemoryView":650
+  /* "View.MemoryView":645
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
-  /* "View.MemoryView":652
+  /* "View.MemoryView":647
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
-  /* "View.MemoryView":653
+  /* "View.MemoryView":648
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 653, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 648, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
-  /* "View.MemoryView":658
+  /* "View.MemoryView":653
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":648
+  /* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10685,192 +10216,126 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_memoryview___reduce_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_memoryview_2__setstate_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_memoryview_2__setstate_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":662
+/* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10882,64 +10347,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_cwrapper", 0);
 
-  /* "View.MemoryView":663
+  /* "View.MemoryView":658
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":664
+  /* "View.MemoryView":659
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
  * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
-  /* "View.MemoryView":665
+  /* "View.MemoryView":660
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":662
+  /* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10953,518 +10418,599 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":668
+/* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:             # <<<<<<<<<<<<<<
+ * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
-  /* "View.MemoryView":669
+  /* "View.MemoryView":664
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:
+ * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
  * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":668
+  /* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:             # <<<<<<<<<<<<<<
+ * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":671
+/* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
 static PyObject *_unellipsify(PyObject *__pyx_v_index, int __pyx_v_ndim) {
-  Py_ssize_t __pyx_v_idx;
   PyObject *__pyx_v_tup = NULL;
   PyObject *__pyx_v_result = NULL;
   int __pyx_v_have_slices;
   int __pyx_v_seen_ellipsis;
+  CYTHON_UNUSED PyObject *__pyx_v_idx = NULL;
   PyObject *__pyx_v_item = NULL;
   Py_ssize_t __pyx_v_nslices;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  Py_ssize_t __pyx_t_4;
+  PyObject *__pyx_t_4 = NULL;
   Py_ssize_t __pyx_t_5;
-  Py_UCS4 __pyx_t_6;
+  PyObject *(*__pyx_t_6)(PyObject *);
   PyObject *__pyx_t_7 = NULL;
+  Py_ssize_t __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_unellipsify", 0);
 
-  /* "View.MemoryView":677
+  /* "View.MemoryView":671
+ *     full slices.
  *     """
- *     cdef Py_ssize_t idx
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)             # <<<<<<<<<<<<<<
- * 
- *     result = [slice(None)] * ndim
+ *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
+ *         tup = (index,)
+ *     else:
  */
-  __pyx_t_2 = PyTuple_Check(__pyx_v_index); 
+  __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
+  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
-    __Pyx_INCREF(((PyObject*)__pyx_v_index));
-    __pyx_t_1 = __pyx_v_index;
-  } else {
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 677, __pyx_L1_error)
+
+    /* "View.MemoryView":672
+ *     """
+ *     if not isinstance(index, tuple):
+ *         tup = (index,)             # <<<<<<<<<<<<<<
+ *     else:
+ *         tup = index
+ */
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
-    __pyx_t_1 = __pyx_t_3;
+    __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
+
+    /* "View.MemoryView":671
+ *     full slices.
+ *     """
+ *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
+ *         tup = (index,)
+ *     else:
+ */
+    goto __pyx_L3;
   }
-  __pyx_v_tup = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":679
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)
+  /* "View.MemoryView":674
+ *         tup = (index,)
+ *     else:
+ *         tup = index             # <<<<<<<<<<<<<<
  * 
- *     result = [slice(None)] * ndim             # <<<<<<<<<<<<<<
+ *     result = []
+ */
+  /*else*/ {
+    __Pyx_INCREF(__pyx_v_index);
+    __pyx_v_tup = __pyx_v_index;
+  }
+  __pyx_L3:;
+
+  /* "View.MemoryView":676
+ *         tup = index
+ * 
+ *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_1 = PyList_New(1 * ((__pyx_v_ndim<0) ? 0:__pyx_v_ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 679, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  { Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < __pyx_v_ndim; __pyx_temp++) {
-      __Pyx_INCREF(__pyx_slice__5);
-      __Pyx_GIVEREF(__pyx_slice__5);
-      PyList_SET_ITEM(__pyx_t_1, __pyx_temp, __pyx_slice__5);
-    }
-  }
-  __pyx_v_result = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 676, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_v_result = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
-  /* "View.MemoryView":680
+  /* "View.MemoryView":677
  * 
- *     result = [slice(None)] * ndim
+ *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
- *     idx = 0
+ *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
-  /* "View.MemoryView":681
- *     result = [slice(None)] * ndim
+  /* "View.MemoryView":678
+ *     result = []
  *     have_slices = False
  *     seen_ellipsis = False             # <<<<<<<<<<<<<<
- *     idx = 0
- *     for item in tup:
+ *     for idx, item in enumerate(tup):
+ *         if item is Ellipsis:
  */
   __pyx_v_seen_ellipsis = 0;
 
-  /* "View.MemoryView":682
+  /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
- *     idx = 0             # <<<<<<<<<<<<<<
- *     for item in tup:
- *         if item is Ellipsis:
- */
-  __pyx_v_idx = 0;
-
-  /* "View.MemoryView":683
- *     seen_ellipsis = False
- *     idx = 0
- *     for item in tup:             # <<<<<<<<<<<<<<
+ *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
-  if (unlikely(__pyx_v_tup == Py_None)) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(1, 683, __pyx_L1_error)
+  __Pyx_INCREF(__pyx_int_0);
+  __pyx_t_3 = __pyx_int_0;
+  if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
+    __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+    __pyx_t_6 = NULL;
+  } else {
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 679, __pyx_L1_error)
   }
-  __pyx_t_1 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   for (;;) {
-    if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely((0 < 0))) __PYX_ERR(1, 683, __pyx_L1_error)
-    #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 683, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_3);
-    __pyx_t_3 = 0;
+    if (likely(!__pyx_t_6)) {
+      if (likely(PyList_CheckExact(__pyx_t_4))) {
+        if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      } else {
+        if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      }
+    } else {
+      __pyx_t_7 = __pyx_t_6(__pyx_t_4);
+      if (unlikely(!__pyx_t_7)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(1, 679, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_7);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
+    __pyx_t_7 = 0;
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_3);
+    __pyx_t_3 = __pyx_t_7;
+    __pyx_t_7 = 0;
 
-    /* "View.MemoryView":684
- *     idx = 0
- *     for item in tup:
+    /* "View.MemoryView":680
+ *     seen_ellipsis = False
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
     __pyx_t_2 = (__pyx_v_item == __pyx_builtin_Ellipsis);
-    if (__pyx_t_2) {
+    __pyx_t_1 = (__pyx_t_2 != 0);
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":685
- *     for item in tup:
+      /* "View.MemoryView":681
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
-      __pyx_t_2 = (!__pyx_v_seen_ellipsis);
-      if (__pyx_t_2) {
+      __pyx_t_1 = ((!(__pyx_v_seen_ellipsis != 0)) != 0);
+      if (__pyx_t_1) {
 
-        /* "View.MemoryView":686
+        /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)             # <<<<<<<<<<<<<<
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
- *             have_slices = True
+ *             else:
  */
-        if (unlikely(__pyx_v_tup == Py_None)) {
-          PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-          __PYX_ERR(1, 686, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 682, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        { Py_ssize_t __pyx_temp;
+          for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
+            __Pyx_INCREF(__pyx_slice__15);
+            __Pyx_GIVEREF(__pyx_slice__15);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__15);
+          }
         }
-        __pyx_t_5 = PyTuple_GET_SIZE(__pyx_v_tup); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 686, __pyx_L1_error)
-        __pyx_v_idx = (__pyx_v_idx + (__pyx_v_ndim - __pyx_t_5));
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-        /* "View.MemoryView":687
+        /* "View.MemoryView":683
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
- *             have_slices = True
- *         else:
+ *             else:
+ *                 result.append(slice(None))
  */
         __pyx_v_seen_ellipsis = 1;
 
-        /* "View.MemoryView":685
- *     for item in tup:
+        /* "View.MemoryView":681
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
+        goto __pyx_L7;
       }
 
-      /* "View.MemoryView":688
- *                 idx += ndim - len(tup)
+      /* "View.MemoryView":685
  *                 seen_ellipsis = True
+ *             else:
+ *                 result.append(slice(None))             # <<<<<<<<<<<<<<
+ *             have_slices = True
+ *         else:
+ */
+      /*else*/ {
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__15); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 685, __pyx_L1_error)
+      }
+      __pyx_L7:;
+
+      /* "View.MemoryView":686
+ *             else:
+ *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
  *         else:
- *             if isinstance(item, slice):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):
  */
       __pyx_v_have_slices = 1;
 
-      /* "View.MemoryView":684
- *     idx = 0
- *     for item in tup:
+      /* "View.MemoryView":680
+ *     seen_ellipsis = False
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
-      goto __pyx_L5;
+      goto __pyx_L6;
     }
 
-    /* "View.MemoryView":690
+    /* "View.MemoryView":688
  *             have_slices = True
  *         else:
- *             if isinstance(item, slice):             # <<<<<<<<<<<<<<
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
  */
     /*else*/ {
       __pyx_t_2 = PySlice_Check(__pyx_v_item); 
-      if (__pyx_t_2) {
+      __pyx_t_10 = ((!(__pyx_t_2 != 0)) != 0);
+      if (__pyx_t_10) {
+      } else {
+        __pyx_t_1 = __pyx_t_10;
+        goto __pyx_L9_bool_binop_done;
+      }
+      __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
+      __pyx_t_1 = __pyx_t_10;
+      __pyx_L9_bool_binop_done:;
+      if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":691
+        /* "View.MemoryView":689
  *         else:
- *             if isinstance(item, slice):
- *                 have_slices = True             # <<<<<<<<<<<<<<
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
+ * 
+ *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_v_have_slices = 1;
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_11);
+        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_Raise(__pyx_t_11, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __PYX_ERR(1, 689, __pyx_L1_error)
 
-        /* "View.MemoryView":690
+        /* "View.MemoryView":688
  *             have_slices = True
  *         else:
- *             if isinstance(item, slice):             # <<<<<<<<<<<<<<
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
  */
-        goto __pyx_L7;
       }
 
-      /* "View.MemoryView":692
- *             if isinstance(item, slice):
- *                 have_slices = True
- *             elif not PyIndex_Check(item):             # <<<<<<<<<<<<<<
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
- */
-      __pyx_t_2 = (!(PyIndex_Check(__pyx_v_item) != 0));
-      if (unlikely(__pyx_t_2)) {
-
-        /* "View.MemoryView":693
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"             # <<<<<<<<<<<<<<
- *             result[idx] = item
- *         idx += 1
- */
-        __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_5 = 0;
-        __pyx_t_6 = 127;
-        __Pyx_INCREF(__pyx_kp_u_Cannot_index_with_type);
-        __pyx_t_5 += 24;
-        __Pyx_GIVEREF(__pyx_kp_u_Cannot_index_with_type);
-        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Cannot_index_with_type);
-        __pyx_t_7 = __Pyx_PyObject_FormatSimple(((PyObject *)Py_TYPE(__pyx_v_item)), __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
-        __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
-        __Pyx_GIVEREF(__pyx_t_7);
-        PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_7);
-        __pyx_t_7 = 0;
-        __Pyx_INCREF(__pyx_kp_u__6);
-        __pyx_t_5 += 1;
-        __Pyx_GIVEREF(__pyx_kp_u__6);
-        PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u__6);
-        __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_Raise(__pyx_builtin_TypeError, __pyx_t_7, 0, 0);
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __PYX_ERR(1, 693, __pyx_L1_error)
-
-        /* "View.MemoryView":692
- *             if isinstance(item, slice):
- *                 have_slices = True
- *             elif not PyIndex_Check(item):             # <<<<<<<<<<<<<<
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
+      /* "View.MemoryView":691
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
+ *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
+ *             result.append(item)
+ * 
  */
+      __pyx_t_10 = (__pyx_v_have_slices != 0);
+      if (!__pyx_t_10) {
+      } else {
+        __pyx_t_1 = __pyx_t_10;
+        goto __pyx_L11_bool_binop_done;
       }
-      __pyx_L7:;
+      __pyx_t_10 = PySlice_Check(__pyx_v_item); 
+      __pyx_t_2 = (__pyx_t_10 != 0);
+      __pyx_t_1 = __pyx_t_2;
+      __pyx_L11_bool_binop_done:;
+      __pyx_v_have_slices = __pyx_t_1;
 
-      /* "View.MemoryView":694
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item             # <<<<<<<<<<<<<<
- *         idx += 1
+      /* "View.MemoryView":692
  * 
- */
-      if (unlikely((__Pyx_SetItemInt(__pyx_v_result, __pyx_v_idx, __pyx_v_item, Py_ssize_t, 1, PyInt_FromSsize_t, 1, 1, 1) < 0))) __PYX_ERR(1, 694, __pyx_L1_error)
-    }
-    __pyx_L5:;
-
-    /* "View.MemoryView":695
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
- *         idx += 1             # <<<<<<<<<<<<<<
+ *             have_slices = have_slices or isinstance(item, slice)
+ *             result.append(item)             # <<<<<<<<<<<<<<
  * 
- *     nslices = ndim - idx
+ *     nslices = ndim - len(result)
  */
-    __pyx_v_idx = (__pyx_v_idx + 1);
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 692, __pyx_L1_error)
+    }
+    __pyx_L6:;
 
-    /* "View.MemoryView":683
+    /* "View.MemoryView":679
+ *     have_slices = False
  *     seen_ellipsis = False
- *     idx = 0
- *     for item in tup:             # <<<<<<<<<<<<<<
+ *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "View.MemoryView":694
+ *             result.append(item)
+ * 
+ *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
+ *     if nslices:
+ *         result.extend([slice(None)] * nslices)
+ */
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
+  __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
-  /* "View.MemoryView":697
- *         idx += 1
+  /* "View.MemoryView":695
+ * 
+ *     nslices = ndim - len(result)
+ *     if nslices:             # <<<<<<<<<<<<<<
+ *         result.extend([slice(None)] * nslices)
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_nslices != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":696
+ *     nslices = ndim - len(result)
+ *     if nslices:
+ *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
- *     nslices = ndim - idx             # <<<<<<<<<<<<<<
  *     return have_slices or nslices, tuple(result)
+ */
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 696, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    { Py_ssize_t __pyx_temp;
+      for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
+        __Pyx_INCREF(__pyx_slice__15);
+        __Pyx_GIVEREF(__pyx_slice__15);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__15);
+      }
+    }
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+    /* "View.MemoryView":695
+ * 
+ *     nslices = ndim - len(result)
+ *     if nslices:             # <<<<<<<<<<<<<<
+ *         result.extend([slice(None)] * nslices)
  * 
  */
-  __pyx_v_nslices = (__pyx_v_ndim - __pyx_v_idx);
+  }
 
   /* "View.MemoryView":698
+ *         result.extend([slice(None)] * nslices)
  * 
- *     nslices = ndim - idx
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_1 = __pyx_t_7;
-    __pyx_t_7 = 0;
-    goto __pyx_L9_bool_binop_done;
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_3 = __pyx_t_4;
+    __pyx_t_4 = 0;
+    goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_7 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __pyx_t_7;
-  __pyx_t_7 = 0;
-  __pyx_L9_bool_binop_done:;
-  __pyx_t_7 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_7);
-  __pyx_t_1 = 0;
-  __pyx_t_7 = 0;
-  __pyx_r = ((PyObject*)__pyx_t_3);
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __pyx_t_4;
+  __pyx_t_4 = 0;
+  __pyx_L14_bool_binop_done:;
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
+  __pyx_t_4 = 0;
+  __pyx_r = ((PyObject*)__pyx_t_11);
+  __pyx_t_11 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":671
+  /* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_11);
   __Pyx_AddTraceback("View.MemoryView._unellipsify", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_tup);
   __Pyx_XDECREF(__pyx_v_result);
+  __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:             # <<<<<<<<<<<<<<
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
-static int assert_direct_dimensions(Py_ssize_t *__pyx_v_suboffsets, int __pyx_v_ndim) {
+static PyObject *assert_direct_dimensions(Py_ssize_t *__pyx_v_suboffsets, int __pyx_v_ndim) {
   Py_ssize_t __pyx_v_suboffset;
-  int __pyx_r;
+  PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   Py_ssize_t *__pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
   /* "View.MemoryView":701
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"
+ *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
     __pyx_t_1 = __pyx_t_3;
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
     /* "View.MemoryView":702
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")
+ * 
  */
-    __pyx_t_4 = (__pyx_v_suboffset >= 0);
+    __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
       /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"             # <<<<<<<<<<<<<<
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
+ * 
  * 
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Indirect_dimensions_not_supporte, 0, 0);
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 703, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __PYX_ERR(1, 703, __pyx_L1_error)
 
       /* "View.MemoryView":702
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")
+ * 
  */
     }
   }
 
-  /* "View.MemoryView":704
- *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = 0;
-  goto __pyx_L0;
-
   /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:             # <<<<<<<<<<<<<<
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
   /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.assert_direct_dimensions", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
+  __pyx_r = 0;
   __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":711
+/* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -11477,575 +11023,574 @@
   __Pyx_memviewslice *__pyx_v_p_src;
   struct __pyx_memoryviewslice_obj *__pyx_v_memviewsliceobj = 0;
   __Pyx_memviewslice *__pyx_v_p_dst;
   int *__pyx_v_p_suboffset_dim;
   Py_ssize_t __pyx_v_start;
   Py_ssize_t __pyx_v_stop;
   Py_ssize_t __pyx_v_step;
-  Py_ssize_t __pyx_v_cindex;
   int __pyx_v_have_start;
   int __pyx_v_have_stop;
   int __pyx_v_have_step;
   PyObject *__pyx_v_index = NULL;
   struct __pyx_memoryview_obj *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  struct __pyx_memoryview_obj *__pyx_t_3;
-  char *__pyx_t_4;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  PyObject *(*__pyx_t_7)(PyObject *);
-  PyObject *__pyx_t_8 = NULL;
-  Py_ssize_t __pyx_t_9;
-  int __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  struct __pyx_memoryview_obj *__pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_t_6;
+  Py_ssize_t __pyx_t_7;
+  PyObject *(*__pyx_t_8)(PyObject *);
+  PyObject *__pyx_t_9 = NULL;
+  Py_ssize_t __pyx_t_10;
+  int __pyx_t_11;
+  Py_ssize_t __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memview_slice", 0);
 
-  /* "View.MemoryView":712
+  /* "View.MemoryView":711
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim             # <<<<<<<<<<<<<<
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
-  /* "View.MemoryView":719
+  /* "View.MemoryView":718
  * 
  * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
  * 
  *     cdef _memoryviewslice memviewsliceobj
  */
   (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
-  /* "View.MemoryView":723
+  /* "View.MemoryView":722
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_1 = (__pyx_v_memview->view.ndim > 0);
-    if (unlikely(!__pyx_t_1)) {
-      __Pyx_Raise(__pyx_builtin_AssertionError, 0, 0, 0);
-      __PYX_ERR(1, 723, __pyx_L1_error)
+  if (unlikely(!Py_OptimizeFlag)) {
+    if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
+      PyErr_SetNone(PyExc_AssertionError);
+      __PYX_ERR(1, 722, __pyx_L1_error)
     }
   }
-  #else
-  if ((1)); else __PYX_ERR(1, 723, __pyx_L1_error)
   #endif
 
-  /* "View.MemoryView":725
+  /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":726
+    /* "View.MemoryView":725
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 726, __pyx_L1_error)
-    __pyx_t_2 = ((PyObject *)__pyx_v_memview);
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 725, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_v_memview);
+    __Pyx_INCREF(__pyx_t_3);
+    __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "View.MemoryView":727
+    /* "View.MemoryView":726
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
-    /* "View.MemoryView":725
+    /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":729
+  /* "View.MemoryView":728
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
-    /* "View.MemoryView":730
+    /* "View.MemoryView":729
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":736
+  /* "View.MemoryView":735
  * 
  * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
  * 
  */
-  __pyx_t_3 = __pyx_v_p_src->memview;
-  __pyx_v_dst.memview = __pyx_t_3;
+  __pyx_t_4 = __pyx_v_p_src->memview;
+  __pyx_v_dst.memview = __pyx_t_4;
 
-  /* "View.MemoryView":737
+  /* "View.MemoryView":736
  * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __pyx_v_p_src->data;
-  __pyx_v_dst.data = __pyx_t_4;
+  __pyx_t_5 = __pyx_v_p_src->data;
+  __pyx_v_dst.data = __pyx_t_5;
 
-  /* "View.MemoryView":742
+  /* "View.MemoryView":741
  * 
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
- *     cdef Py_ssize_t start, stop, step, cindex
+ *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
-  /* "View.MemoryView":743
+  /* "View.MemoryView":742
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t start, stop, step, cindex
+ *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
-  /* "View.MemoryView":747
+  /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
- *             cindex = index
+ *             slice_memviewslice(
  */
-  __pyx_t_5 = 0;
+  __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
-    __pyx_t_2 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_2); __pyx_t_6 = 0;
-    __pyx_t_7 = NULL;
+    __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
+    __pyx_t_8 = NULL;
   } else {
-    __pyx_t_6 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 747, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 747, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 746, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 746, __pyx_L1_error)
   }
   for (;;) {
-    if (likely(!__pyx_t_7)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_2)) break;
+    if (likely(!__pyx_t_8)) {
+      if (likely(PyList_CheckExact(__pyx_t_3))) {
+        if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_8 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely((0 < 0))) __PYX_ERR(1, 747, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 747, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_8);
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
-        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
+        if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely((0 < 0))) __PYX_ERR(1, 747, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 747, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_8);
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
-      __pyx_t_8 = __pyx_t_7(__pyx_t_2);
-      if (unlikely(!__pyx_t_8)) {
+      __pyx_t_9 = __pyx_t_8(__pyx_t_3);
+      if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 747, __pyx_L1_error)
+          else __PYX_ERR(1, 746, __pyx_L1_error)
         }
         break;
       }
-      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GOTREF(__pyx_t_9);
     }
-    __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_8);
-    __pyx_t_8 = 0;
-    __pyx_v_dim = __pyx_t_5;
-    __pyx_t_5 = (__pyx_t_5 + 1);
+    __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
+    __pyx_t_9 = 0;
+    __pyx_v_dim = __pyx_t_6;
+    __pyx_t_6 = (__pyx_t_6 + 1);
 
-    /* "View.MemoryView":748
+    /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
- *             cindex = index
  *             slice_memviewslice(
+ *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
-    __pyx_t_1 = (PyIndex_Check(__pyx_v_index) != 0);
-    if (__pyx_t_1) {
+    __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":749
- *     for dim, index in enumerate(indices):
- *         if PyIndex_Check(index):
- *             cindex = index             # <<<<<<<<<<<<<<
- *             slice_memviewslice(
+      /* "View.MemoryView":751
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
+ *                 dim, new_ndim, p_suboffset_dim,
+ *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
+ *                 0, 0, 0, # have_{start,stop,step}
+ *                 False)
  */
-      __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 749, __pyx_L1_error)
-      __pyx_v_cindex = __pyx_t_9;
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 751, __pyx_L1_error)
 
-      /* "View.MemoryView":750
+      /* "View.MemoryView":748
+ *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
- *             cindex = index
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_10 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_cindex, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(1, 750, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 748, __pyx_L1_error)
 
-      /* "View.MemoryView":748
+      /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
- *             cindex = index
  *             slice_memviewslice(
+ *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":756
+    /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
-    __pyx_t_1 = (__pyx_v_index == Py_None);
+    __pyx_t_2 = (__pyx_v_index == Py_None);
+    __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":757
+      /* "View.MemoryView":755
  *                 False)
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1             # <<<<<<<<<<<<<<
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  */
       (__pyx_v_p_dst->shape[__pyx_v_new_ndim]) = 1;
 
-      /* "View.MemoryView":758
+      /* "View.MemoryView":756
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0             # <<<<<<<<<<<<<<
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1
  */
       (__pyx_v_p_dst->strides[__pyx_v_new_ndim]) = 0;
 
-      /* "View.MemoryView":759
+      /* "View.MemoryView":757
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1             # <<<<<<<<<<<<<<
  *             new_ndim += 1
  *         else:
  */
       (__pyx_v_p_dst->suboffsets[__pyx_v_new_ndim]) = -1L;
 
-      /* "View.MemoryView":760
+      /* "View.MemoryView":758
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  *         else:
  *             start = index.start or 0
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
 
-      /* "View.MemoryView":756
+      /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":762
+    /* "View.MemoryView":760
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 762, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 760, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 760, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 760, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
-      __pyx_v_start = __pyx_t_9;
+      __pyx_v_start = __pyx_t_10;
 
-      /* "View.MemoryView":763
+      /* "View.MemoryView":761
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 763, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 761, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 761, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 763, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 761, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
-      __pyx_v_stop = __pyx_t_9;
+      __pyx_v_stop = __pyx_t_10;
 
-      /* "View.MemoryView":764
+      /* "View.MemoryView":762
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 764, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 764, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
-      __pyx_v_step = __pyx_t_9;
+      __pyx_v_step = __pyx_t_10;
 
-      /* "View.MemoryView":766
+      /* "View.MemoryView":764
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 766, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
-      /* "View.MemoryView":767
+      /* "View.MemoryView":765
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 767, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 765, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
-      /* "View.MemoryView":768
+      /* "View.MemoryView":766
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 768, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
-      /* "View.MemoryView":770
+      /* "View.MemoryView":768
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_10 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(1, 770, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 768, __pyx_L1_error)
 
-      /* "View.MemoryView":776
+      /* "View.MemoryView":774
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":747
+    /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
- *             cindex = index
+ *             slice_memviewslice(
  */
   }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":778
+  /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __Pyx_XDECREF((PyObject *)__pyx_r);
+    __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":780
+    /* "View.MemoryView":778
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 780, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 778, __pyx_L1_error) }
 
-    /* "View.MemoryView":781
+    /* "View.MemoryView":779
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 781, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 779, __pyx_L1_error) }
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 779, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_memoryview_type))))) __PYX_ERR(1, 779, __pyx_L1_error)
-    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 777, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 777, __pyx_L1_error)
+    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":778
+    /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
-  /* "View.MemoryView":784
+  /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
   /*else*/ {
-    __Pyx_XDECREF((PyObject *)__pyx_r);
+    __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":785
+    /* "View.MemoryView":783
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 784, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 782, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
 
-    /* "View.MemoryView":784
+    /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_memoryview_type))))) __PYX_ERR(1, 784, __pyx_L1_error)
-    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 782, __pyx_L1_error)
+    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":711
+  /* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("View.MemoryView.memview_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_memviewsliceobj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":793
+/* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -12055,775 +11600,781 @@
   int __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":813
+  /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
-  __pyx_t_1 = (!__pyx_v_is_slice);
+  __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":815
+    /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
-    __pyx_t_1 = (__pyx_v_start < 0);
+    __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":816
+      /* "View.MemoryView":830
  * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-      /* "View.MemoryView":815
+      /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
-    /* "View.MemoryView":817
+    /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     __pyx_t_1 = (0 <= __pyx_v_start);
     if (__pyx_t_1) {
       __pyx_t_1 = (__pyx_v_start < __pyx_v_shape);
     }
-    __pyx_t_2 = (!__pyx_t_1);
+    __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":818
+      /* "View.MemoryView":832
  *             start += shape
  *         if not 0 <= start < shape:
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_IndexError, __pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 818, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 832, __pyx_L1_error)
 
-      /* "View.MemoryView":817
+      /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
-    /* "View.MemoryView":813
+    /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":821
+  /* "View.MemoryView":835
  *     else:
  * 
- *         if have_step:             # <<<<<<<<<<<<<<
- *             negative_step = step < 0
- *             if step == 0:
+ *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
+ * 
+ *         if have_step and step == 0:
  */
   /*else*/ {
-    __pyx_t_2 = (__pyx_v_have_step != 0);
-    if (__pyx_t_2) {
+    __pyx_t_1 = ((__pyx_v_have_step != 0) != 0);
+    if (__pyx_t_1) {
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+      goto __pyx_L6_bool_binop_done;
+    }
+    __pyx_t_1 = ((__pyx_v_step < 0) != 0);
+    __pyx_t_2 = __pyx_t_1;
+    __pyx_L6_bool_binop_done:;
+    __pyx_v_negative_step = __pyx_t_2;
 
-      /* "View.MemoryView":822
+    /* "View.MemoryView":837
+ *         negative_step = have_step != 0 and step < 0
  * 
- *         if have_step:
- *             negative_step = step < 0             # <<<<<<<<<<<<<<
- *             if step == 0:
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- */
-      __pyx_v_negative_step = (__pyx_v_step < 0);
-
-      /* "View.MemoryView":823
- *         if have_step:
- *             negative_step = step < 0
- *             if step == 0:             # <<<<<<<<<<<<<<
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- */
-      __pyx_t_2 = (__pyx_v_step == 0);
-      if (__pyx_t_2) {
-
-        /* "View.MemoryView":824
- *             negative_step = step < 0
- *             if step == 0:
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
- *         else:
- *             negative_step = False
- */
-        __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_ValueError, __pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 824, __pyx_L1_error)
-
-        /* "View.MemoryView":823
- *         if have_step:
- *             negative_step = step < 0
- *             if step == 0:             # <<<<<<<<<<<<<<
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- */
-      }
-
-      /* "View.MemoryView":821
- *     else:
+ *         if have_step and step == 0:             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
- *         if have_step:             # <<<<<<<<<<<<<<
- *             negative_step = step < 0
- *             if step == 0:
  */
-      goto __pyx_L6;
+    __pyx_t_1 = (__pyx_v_have_step != 0);
+    if (__pyx_t_1) {
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+      goto __pyx_L9_bool_binop_done;
     }
+    __pyx_t_1 = ((__pyx_v_step == 0) != 0);
+    __pyx_t_2 = __pyx_t_1;
+    __pyx_L9_bool_binop_done:;
+    if (__pyx_t_2) {
 
-    /* "View.MemoryView":826
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- *             negative_step = False             # <<<<<<<<<<<<<<
- *             step = 1
+      /* "View.MemoryView":838
+ * 
+ *         if have_step and step == 0:
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
+ * 
  * 
  */
-    /*else*/ {
-      __pyx_v_negative_step = 0;
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 838, __pyx_L1_error)
 
-      /* "View.MemoryView":827
- *         else:
- *             negative_step = False
- *             step = 1             # <<<<<<<<<<<<<<
+      /* "View.MemoryView":837
+ *         negative_step = have_step != 0 and step < 0
  * 
+ *         if have_step and step == 0:             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
-      __pyx_v_step = 1;
     }
-    __pyx_L6:;
 
-    /* "View.MemoryView":830
+    /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":831
+      /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
-      __pyx_t_2 = (__pyx_v_start < 0);
+      __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":832
+        /* "View.MemoryView":843
  *         if have_start:
  *             if start < 0:
  *                 start += shape             # <<<<<<<<<<<<<<
  *                 if start < 0:
  *                     start = 0
  */
         __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-        /* "View.MemoryView":833
+        /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
-        __pyx_t_2 = (__pyx_v_start < 0);
+        __pyx_t_2 = ((__pyx_v_start < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":834
+          /* "View.MemoryView":845
  *                 start += shape
  *                 if start < 0:
  *                     start = 0             # <<<<<<<<<<<<<<
  *             elif start >= shape:
  *                 if negative_step:
  */
           __pyx_v_start = 0;
 
-          /* "View.MemoryView":833
+          /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
-        /* "View.MemoryView":831
+        /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
-        goto __pyx_L9;
+        goto __pyx_L12;
       }
 
-      /* "View.MemoryView":835
+      /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
-      __pyx_t_2 = (__pyx_v_start >= __pyx_v_shape);
+      __pyx_t_2 = ((__pyx_v_start >= __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":836
+        /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
-        if (__pyx_v_negative_step) {
+        __pyx_t_2 = (__pyx_v_negative_step != 0);
+        if (__pyx_t_2) {
 
-          /* "View.MemoryView":837
+          /* "View.MemoryView":848
  *             elif start >= shape:
  *                 if negative_step:
  *                     start = shape - 1             # <<<<<<<<<<<<<<
  *                 else:
  *                     start = shape
  */
           __pyx_v_start = (__pyx_v_shape - 1);
 
-          /* "View.MemoryView":836
+          /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
-          goto __pyx_L11;
+          goto __pyx_L14;
         }
 
-        /* "View.MemoryView":839
+        /* "View.MemoryView":850
  *                     start = shape - 1
  *                 else:
  *                     start = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         /*else*/ {
           __pyx_v_start = __pyx_v_shape;
         }
-        __pyx_L11:;
+        __pyx_L14:;
 
-        /* "View.MemoryView":835
+        /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
-      __pyx_L9:;
+      __pyx_L12:;
 
-      /* "View.MemoryView":830
+      /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
-      goto __pyx_L8;
+      goto __pyx_L11;
     }
 
-    /* "View.MemoryView":841
+    /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
     /*else*/ {
-      if (__pyx_v_negative_step) {
+      __pyx_t_2 = (__pyx_v_negative_step != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":842
+        /* "View.MemoryView":853
  *         else:
  *             if negative_step:
  *                 start = shape - 1             # <<<<<<<<<<<<<<
  *             else:
  *                 start = 0
  */
         __pyx_v_start = (__pyx_v_shape - 1);
 
-        /* "View.MemoryView":841
+        /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
-        goto __pyx_L12;
+        goto __pyx_L15;
       }
 
-      /* "View.MemoryView":844
+      /* "View.MemoryView":855
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
  * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
-      __pyx_L12:;
+      __pyx_L15:;
     }
-    __pyx_L8:;
+    __pyx_L11:;
 
-    /* "View.MemoryView":846
+    /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":847
+      /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
-      __pyx_t_2 = (__pyx_v_stop < 0);
+      __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":848
+        /* "View.MemoryView":859
  *         if have_stop:
  *             if stop < 0:
  *                 stop += shape             # <<<<<<<<<<<<<<
  *                 if stop < 0:
  *                     stop = 0
  */
         __pyx_v_stop = (__pyx_v_stop + __pyx_v_shape);
 
-        /* "View.MemoryView":849
+        /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
-        __pyx_t_2 = (__pyx_v_stop < 0);
+        __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":850
+          /* "View.MemoryView":861
  *                 stop += shape
  *                 if stop < 0:
  *                     stop = 0             # <<<<<<<<<<<<<<
  *             elif stop > shape:
  *                 stop = shape
  */
           __pyx_v_stop = 0;
 
-          /* "View.MemoryView":849
+          /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
-        /* "View.MemoryView":847
+        /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
-        goto __pyx_L14;
+        goto __pyx_L17;
       }
 
-      /* "View.MemoryView":851
+      /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
-      __pyx_t_2 = (__pyx_v_stop > __pyx_v_shape);
+      __pyx_t_2 = ((__pyx_v_stop > __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":852
+        /* "View.MemoryView":863
  *                     stop = 0
  *             elif stop > shape:
  *                 stop = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         __pyx_v_stop = __pyx_v_shape;
 
-        /* "View.MemoryView":851
+        /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       }
-      __pyx_L14:;
+      __pyx_L17:;
 
-      /* "View.MemoryView":846
+      /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
-      goto __pyx_L13;
+      goto __pyx_L16;
     }
 
-    /* "View.MemoryView":854
+    /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
     /*else*/ {
-      if (__pyx_v_negative_step) {
+      __pyx_t_2 = (__pyx_v_negative_step != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":855
+        /* "View.MemoryView":866
  *         else:
  *             if negative_step:
  *                 stop = -1             # <<<<<<<<<<<<<<
  *             else:
  *                 stop = shape
  */
         __pyx_v_stop = -1L;
 
-        /* "View.MemoryView":854
+        /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
-        goto __pyx_L16;
+        goto __pyx_L19;
       }
 
-      /* "View.MemoryView":857
+      /* "View.MemoryView":868
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
  * 
- * 
+ *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
-      __pyx_L16:;
+      __pyx_L19:;
     }
-    __pyx_L13:;
+    __pyx_L16:;
 
-    /* "View.MemoryView":861
+    /* "View.MemoryView":870
+ *                 stop = shape
+ * 
+ *         if not have_step:             # <<<<<<<<<<<<<<
+ *             step = 1
+ * 
+ */
+    __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
+    if (__pyx_t_2) {
+
+      /* "View.MemoryView":871
+ * 
+ *         if not have_step:
+ *             step = 1             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+      __pyx_v_step = 1;
+
+      /* "View.MemoryView":870
+ *                 stop = shape
+ * 
+ *         if not have_step:             # <<<<<<<<<<<<<<
+ *             step = 1
+ * 
+ */
+    }
+
+    /* "View.MemoryView":875
  * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
  * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
-    /* "View.MemoryView":863
+    /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":864
+      /* "View.MemoryView":878
  * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
  * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
-      /* "View.MemoryView":863
+      /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     }
 
-    /* "View.MemoryView":866
+    /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
-    __pyx_t_2 = (__pyx_v_new_shape < 0);
+    __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":867
+      /* "View.MemoryView":881
  * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_new_shape = 0;
 
-      /* "View.MemoryView":866
+      /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     }
 
-    /* "View.MemoryView":870
+    /* "View.MemoryView":884
  * 
  * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
-    /* "View.MemoryView":871
+    /* "View.MemoryView":885
  * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
  * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
-    /* "View.MemoryView":872
+    /* "View.MemoryView":886
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":875
+  /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
-  __pyx_t_2 = ((__pyx_v_suboffset_dim[0]) < 0);
+  __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":876
+    /* "View.MemoryView":890
  * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
-    /* "View.MemoryView":875
+    /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
-    goto __pyx_L19;
+    goto __pyx_L23;
   }
 
-  /* "View.MemoryView":878
+  /* "View.MemoryView":892
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
  * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
-  __pyx_L19:;
+  __pyx_L23:;
 
-  /* "View.MemoryView":880
+  /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
-  __pyx_t_2 = (__pyx_v_suboffset >= 0);
+  __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":881
+    /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
-    __pyx_t_2 = (!__pyx_v_is_slice);
+    __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":882
+      /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
-      __pyx_t_2 = (__pyx_v_new_ndim == 0);
+      __pyx_t_2 = ((__pyx_v_new_ndim == 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":883
+        /* "View.MemoryView":897
  *         if not is_slice:
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset             # <<<<<<<<<<<<<<
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  */
         __pyx_v_dst->data = ((((char **)__pyx_v_dst->data)[0]) + __pyx_v_suboffset);
 
-        /* "View.MemoryView":882
+        /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
-        goto __pyx_L22;
+        goto __pyx_L26;
       }
 
-      /* "View.MemoryView":885
+      /* "View.MemoryView":899
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
  *                                      "must be indexed and not sliced", dim)
  *         else:
  */
       /*else*/ {
 
-        /* "View.MemoryView":886
+        /* "View.MemoryView":900
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_IndexError, __pyx_kp_s_All_dimensions_preceding_dimensi, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 885, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 899, __pyx_L1_error)
       }
-      __pyx_L22:;
+      __pyx_L26:;
 
-      /* "View.MemoryView":881
+      /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
-      goto __pyx_L21;
+      goto __pyx_L25;
     }
 
-    /* "View.MemoryView":888
+    /* "View.MemoryView":902
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
  * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
-    __pyx_L21:;
+    __pyx_L25:;
 
-    /* "View.MemoryView":880
+    /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
-  /* "View.MemoryView":890
+  /* "View.MemoryView":904
  *             suboffset_dim[0] = new_ndim
  * 
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":793
+  /* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.slice_memviewslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.slice_memviewslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":896
+/* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -12834,335 +12385,308 @@
   Py_ssize_t __pyx_v_itemsize;
   char *__pyx_v_resultp;
   char *__pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  Py_UCS4 __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("pybuffer_index", 0);
 
-  /* "View.MemoryView":898
+  /* "View.MemoryView":912
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t itemsize = view.itemsize
  *     cdef char *resultp
  */
   __pyx_v_suboffset = -1L;
 
-  /* "View.MemoryView":899
+  /* "View.MemoryView":913
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
  * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":902
+  /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize
  */
-  __pyx_t_2 = (__pyx_v_view->ndim == 0);
+  __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":903
+    /* "View.MemoryView":917
  * 
  *     if view.ndim == 0:
- *         shape = view.len // itemsize             # <<<<<<<<<<<<<<
+ *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 903, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
-    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(__Pyx_UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
+    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 903, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
-    /* "View.MemoryView":904
+    /* "View.MemoryView":918
  *     if view.ndim == 0:
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
-    /* "View.MemoryView":902
+    /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":906
+  /* "View.MemoryView":920
  *         stride = itemsize
  *     else:
  *         shape = view.shape[dim]             # <<<<<<<<<<<<<<
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  */
   /*else*/ {
     __pyx_v_shape = (__pyx_v_view->shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":907
+    /* "View.MemoryView":921
  *     else:
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]             # <<<<<<<<<<<<<<
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]
  */
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":908
+    /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
-    __pyx_t_2 = (__pyx_v_view->suboffsets != NULL);
+    __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":909
+      /* "View.MemoryView":923
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
  * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
-      /* "View.MemoryView":908
+      /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":911
+  /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
-  __pyx_t_2 = (__pyx_v_index < 0);
+  __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":912
+    /* "View.MemoryView":926
  * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
-    /* "View.MemoryView":913
+    /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
-    __pyx_t_2 = (__pyx_v_index < 0);
+    __pyx_t_2 = ((__pyx_v_index < 0) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":914
+      /* "View.MemoryView":928
  *         index += view.shape[dim]
  *         if index < 0:
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"             # <<<<<<<<<<<<<<
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 914, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_1 = 0;
-      __pyx_t_4 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      __pyx_t_1 += 37;
-      __Pyx_GIVEREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      __pyx_t_5 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 914, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_1 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_5);
-      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_5);
-      __pyx_t_5 = 0;
-      __Pyx_INCREF(__pyx_kp_u__7);
-      __pyx_t_1 += 1;
-      __Pyx_GIVEREF(__pyx_kp_u__7);
-      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u__7);
-      __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 914, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_Raise(__pyx_builtin_IndexError, __pyx_t_5, 0, 0);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(1, 914, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __PYX_ERR(1, 928, __pyx_L1_error)
 
-      /* "View.MemoryView":913
+      /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     }
 
-    /* "View.MemoryView":911
+    /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
-  /* "View.MemoryView":916
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+  /* "View.MemoryView":930
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
-  __pyx_t_2 = (__pyx_v_index >= __pyx_v_shape);
+  __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":917
+    /* "View.MemoryView":931
  * 
  *     if index >= shape:
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"             # <<<<<<<<<<<<<<
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 917, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = 0;
-    __pyx_t_4 = 127;
-    __Pyx_INCREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    __pyx_t_1 += 37;
-    __Pyx_GIVEREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    __pyx_t_3 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 917, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __Pyx_INCREF(__pyx_kp_u__7);
-    __pyx_t_1 += 1;
-    __Pyx_GIVEREF(__pyx_kp_u__7);
-    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u__7);
-    __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_5, 3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 917, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 931, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_Raise(__pyx_builtin_IndexError, __pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 917, __pyx_L1_error)
+    __PYX_ERR(1, 931, __pyx_L1_error)
 
-    /* "View.MemoryView":916
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+    /* "View.MemoryView":930
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   }
 
-  /* "View.MemoryView":919
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+  /* "View.MemoryView":933
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
-  /* "View.MemoryView":920
+  /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
-  __pyx_t_2 = (__pyx_v_suboffset >= 0);
+  __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":921
+    /* "View.MemoryView":935
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
  * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
-    /* "View.MemoryView":920
+    /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   }
 
-  /* "View.MemoryView":923
+  /* "View.MemoryView":937
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  *     return resultp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":896
+  /* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView.pybuffer_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":929
+/* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:             # <<<<<<<<<<<<<<
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
 static int __pyx_memslice_transpose(__Pyx_memviewslice *__pyx_v_memslice) {
   int __pyx_v_ndim;
   Py_ssize_t *__pyx_v_shape;
@@ -13178,209 +12702,207 @@
   Py_ssize_t __pyx_t_6;
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":930
+  /* "View.MemoryView":944
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
-  /* "View.MemoryView":932
+  /* "View.MemoryView":946
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
-  /* "View.MemoryView":933
+  /* "View.MemoryView":947
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
-  /* "View.MemoryView":937
+  /* "View.MemoryView":951
  * 
  *     cdef int i, j
- *     for i in range(ndim // 2):             # <<<<<<<<<<<<<<
+ *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = __Pyx_div_long(__pyx_v_ndim, 2);
   __pyx_t_4 = __pyx_t_3;
   for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_4; __pyx_t_1+=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":938
+    /* "View.MemoryView":952
  *     cdef int i, j
- *     for i in range(ndim // 2):
+ *     for i in range(ndim / 2):
  *         j = ndim - 1 - i             # <<<<<<<<<<<<<<
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]
  */
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
-    /* "View.MemoryView":939
- *     for i in range(ndim // 2):
+    /* "View.MemoryView":953
+ *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  */
     __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
     __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
     (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
     (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
-    /* "View.MemoryView":940
+    /* "View.MemoryView":954
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
     __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
     __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
     (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
     (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
-    /* "View.MemoryView":942
+    /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
-    __pyx_t_8 = ((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0);
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
     if (!__pyx_t_8) {
     } else {
       __pyx_t_7 = __pyx_t_8;
       goto __pyx_L6_bool_binop_done;
     }
-    __pyx_t_8 = ((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0);
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
     __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
     if (__pyx_t_7) {
 
-      /* "View.MemoryView":943
+      /* "View.MemoryView":957
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
- *     return 0
+ *     return 1
  */
-      __pyx_t_9 = __pyx_memoryview_err(PyExc_ValueError, __pyx_kp_s_Cannot_transpose_memoryview_with); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 943, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 957, __pyx_L1_error)
 
-      /* "View.MemoryView":942
+      /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":945
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+  /* "View.MemoryView":959
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
- *     return 0             # <<<<<<<<<<<<<<
+ *     return 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_r = 0;
+  __pyx_r = 1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":929
+  /* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:             # <<<<<<<<<<<<<<
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.transpose_memslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.transpose_memslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
+  __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":963
+/* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
 /* Python wrapper */
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":964
+  /* "View.MemoryView":977
  * 
  *     def __dealloc__(self):
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __PYX_XCLEAR_MEMVIEW((&__pyx_v_self->from_slice), 1);
+  __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
-  /* "View.MemoryView":963
+  /* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":966
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+/* "View.MemoryView":979
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp) {
@@ -13389,65 +12911,65 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":967
+  /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
-  __pyx_t_1 = (__pyx_v_self->to_object_func != NULL);
+  __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":968
+    /* "View.MemoryView":981
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 968, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 981, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":967
+    /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
-  /* "View.MemoryView":970
+  /* "View.MemoryView":983
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 970, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":966
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+  /* "View.MemoryView":979
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
   /* function exit code */
@@ -13457,15 +12979,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":972
+/* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13476,58 +12998,58 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":973
+  /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
-  __pyx_t_1 = (__pyx_v_self->to_dtype_func != NULL);
+  __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":974
+    /* "View.MemoryView":987
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 974, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 987, __pyx_L1_error)
 
-    /* "View.MemoryView":973
+    /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":976
+  /* "View.MemoryView":989
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
- *     cdef _get_base(self):
+ *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 976, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 989, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":972
+  /* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13540,226 +13062,173 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":978
- *             memoryview.assign_item_from_object(self, itemp, value)
+/* "View.MemoryView":992
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
-static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
+/* Python wrapper */
+static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_get_base", 0);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":979
- * 
- *     cdef _get_base(self):
+  /* "View.MemoryView":993
+ *     @property
+ *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
  * 
- * 
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
-  /* "View.MemoryView":978
- *             memoryview.assign_item_from_object(self, itemp, value)
+  /* "View.MemoryView":992
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_memoryviewslice___reduce_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_memoryviewslice_2__setstate_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_memoryviewslice_2__setstate_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -13794,15 +13263,15 @@
   /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
-  __pyx_t_1 = (((PyObject *)__pyx_v_memviewslice.memview) == Py_None);
+  __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1008
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
  * 
@@ -13820,15 +13289,15 @@
  * 
  */
   }
 
   /* "View.MemoryView":1013
  * 
  * 
- *     result = _memoryviewslice.__new__(_memoryviewslice, None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
+ *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
@@ -13837,56 +13306,56 @@
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = ((PyObject *)__pyx_tp_new__memoryviewslice(((PyTypeObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
-  __Pyx_GOTREF((PyObject *)__pyx_t_2);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1015
- *     result = _memoryviewslice.__new__(_memoryviewslice, None, 0, dtype_is_object)
+ *     result = _memoryviewslice(None, 0, dtype_is_object)
  * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
   /* "View.MemoryView":1016
  * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()
+ *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
   /* "View.MemoryView":1018
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()             # <<<<<<<<<<<<<<
+ *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->__pyx_vtab)->_get_base(((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1019
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()
+ *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
  * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
@@ -14019,15 +13488,15 @@
     /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
-    __pyx_t_1 = (__pyx_v_suboffset >= 0);
+    __pyx_t_1 = ((__pyx_v_suboffset >= 0) != 0);
     if (__pyx_t_1) {
 
       /* "View.MemoryView":1039
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
@@ -14119,15 +13588,15 @@
  *     result.to_dtype_func = to_dtype_func
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
   /* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
@@ -14158,42 +13627,44 @@
  */
 
 static __Pyx_memviewslice *__pyx_memoryview_get_slice_from_memoryview(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_mslice) {
   struct __pyx_memoryviewslice_obj *__pyx_v_obj = 0;
   __Pyx_memviewslice *__pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_slice_from_memview", 0);
 
   /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "View.MemoryView":1056
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
     if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1056, __pyx_L1_error)
-    __pyx_t_2 = ((PyObject *)__pyx_v_memview);
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((PyObject *)__pyx_v_memview);
+    __Pyx_INCREF(__pyx_t_3);
+    __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
 
     /* "View.MemoryView":1057
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview
  *         return &obj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, mslice)
@@ -14237,27 +13708,27 @@
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.get_slice_from_memview", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
- * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst) noexcept:             # <<<<<<<<<<<<<<
+ * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
 static void __pyx_memoryview_slice_copy(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_dst) {
   int __pyx_v_dim;
   Py_ssize_t *__pyx_v_shape;
@@ -14363,15 +13834,15 @@
     }
     (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
   /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
- * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst) noexcept:             # <<<<<<<<<<<<<<
+ * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
@@ -14446,51 +13917,53 @@
 
 static PyObject *__pyx_memoryview_copy_object_from_slice(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_memviewslice) {
   PyObject *(*__pyx_v_to_object_func)(char *);
   int (*__pyx_v_to_dtype_func)(char *, PyObject *);
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *(*__pyx_t_2)(char *);
-  int (*__pyx_t_3)(char *, PyObject *);
-  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_2;
+  PyObject *(*__pyx_t_3)(char *);
+  int (*__pyx_t_4)(char *, PyObject *);
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
   /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "View.MemoryView":1095
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
-    __pyx_t_2 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
-    __pyx_v_to_object_func = __pyx_t_2;
+    __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
+    __pyx_v_to_object_func = __pyx_t_3;
 
     /* "View.MemoryView":1096
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func             # <<<<<<<<<<<<<<
  *     else:
  *         to_object_func = NULL
  */
-    __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
-    __pyx_v_to_dtype_func = __pyx_t_3;
+    __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
+    __pyx_v_to_dtype_func = __pyx_t_4;
 
     /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
@@ -14531,270 +14004,296 @@
   /* "View.MemoryView":1103
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview_copy_from_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1109
  * 
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:             # <<<<<<<<<<<<<<
- *     return -arg if arg < 0 else arg
- * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
+ *     if arg < 0:
+ *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
-  Py_ssize_t __pyx_t_1;
+  int __pyx_t_1;
 
   /* "View.MemoryView":1110
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:
- *     return -arg if arg < 0 else arg             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:             # <<<<<<<<<<<<<<
+ *         return -arg
+ *     else:
+ */
+  __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":1111
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:
+ *         return -arg             # <<<<<<<<<<<<<<
+ *     else:
+ *         return arg
+ */
+    __pyx_r = (-__pyx_v_arg);
+    goto __pyx_L0;
+
+    /* "View.MemoryView":1110
+ * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:             # <<<<<<<<<<<<<<
+ *         return -arg
+ *     else:
+ */
+  }
+
+  /* "View.MemoryView":1113
+ *         return -arg
+ *     else:
+ *         return arg             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_get_best_slice_order')
  */
-  if ((__pyx_v_arg < 0)) {
-    __pyx_t_1 = (-__pyx_v_arg);
-  } else {
-    __pyx_t_1 = __pyx_v_arg;
+  /*else*/ {
+    __pyx_r = __pyx_v_arg;
+    goto __pyx_L0;
   }
-  __pyx_r = __pyx_t_1;
-  goto __pyx_L0;
 
   /* "View.MemoryView":1109
  * 
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:             # <<<<<<<<<<<<<<
- *     return -arg if arg < 0 else arg
- * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
+ *     if arg < 0:
+ *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1113
+/* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
- * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
 static char __pyx_get_best_slice_order(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim) {
   int __pyx_v_i;
   Py_ssize_t __pyx_v_c_stride;
   Py_ssize_t __pyx_v_f_stride;
   char __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1118
+  /* "View.MemoryView":1121
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
  * 
  */
   __pyx_v_c_stride = 0;
 
-  /* "View.MemoryView":1119
+  /* "View.MemoryView":1122
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
-  /* "View.MemoryView":1121
+  /* "View.MemoryView":1124
  *     cdef Py_ssize_t f_stride = 0
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1122
+    /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
-    __pyx_t_2 = ((__pyx_v_mslice->shape[__pyx_v_i]) > 1);
+    __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1123
+      /* "View.MemoryView":1126
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1124
+      /* "View.MemoryView":1127
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
-      /* "View.MemoryView":1122
+      /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
-  /* "View.MemoryView":1126
+  /* "View.MemoryView":1129
  *             break
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_1;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1127
+    /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
-    __pyx_t_2 = ((__pyx_v_mslice->shape[__pyx_v_i]) > 1);
+    __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1128
+      /* "View.MemoryView":1131
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1129
+      /* "View.MemoryView":1132
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
-      /* "View.MemoryView":1127
+      /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
-  /* "View.MemoryView":1131
+  /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
-  __pyx_t_2 = (abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride));
+  __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1132
+    /* "View.MemoryView":1135
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
-    /* "View.MemoryView":1131
+    /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
-  /* "View.MemoryView":1134
+  /* "View.MemoryView":1137
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
  * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1113
+  /* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
- * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1137
+/* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
@@ -14802,458 +14301,460 @@
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   CYTHON_UNUSED Py_ssize_t __pyx_v_src_extent;
   Py_ssize_t __pyx_v_dst_extent;
   Py_ssize_t __pyx_v_src_stride;
   Py_ssize_t __pyx_v_dst_stride;
   int __pyx_t_1;
   int __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
+  int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
+  Py_ssize_t __pyx_t_6;
 
-  /* "View.MemoryView":1144
+  /* "View.MemoryView":1147
  * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
-  /* "View.MemoryView":1145
+  /* "View.MemoryView":1148
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  */
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
-  /* "View.MemoryView":1146
+  /* "View.MemoryView":1149
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
-  /* "View.MemoryView":1147
+  /* "View.MemoryView":1150
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
-  /* "View.MemoryView":1149
+  /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
-  __pyx_t_1 = (__pyx_v_ndim == 1);
+  __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1150
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
-    __pyx_t_2 = (__pyx_v_src_stride > 0);
+    __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
-    __pyx_t_2 = (__pyx_v_dst_stride > 0);
+    __pyx_t_2 = ((__pyx_v_dst_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
 
-    /* "View.MemoryView":1151
+    /* "View.MemoryView":1154
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
- *         else:
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        else:
  */
     __pyx_t_2 = (((size_t)__pyx_v_src_stride) == __pyx_v_itemsize);
     if (__pyx_t_2) {
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
-    __pyx_t_1 = __pyx_t_2;
+    __pyx_t_3 = (__pyx_t_2 != 0);
+    __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
-    /* "View.MemoryView":1150
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1152
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
- *         else:
- *             for i in range(dst_extent):
+      /* "View.MemoryView":1155
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
+ *        else:
+ *            for i in range(dst_extent):
  */
       (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
-      /* "View.MemoryView":1150
+      /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
 
-    /* "View.MemoryView":1154
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
- *         else:
- *             for i in range(dst_extent):             # <<<<<<<<<<<<<<
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride
+    /* "View.MemoryView":1157
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        else:
+ *            for i in range(dst_extent):             # <<<<<<<<<<<<<<
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride
  */
     /*else*/ {
-      __pyx_t_3 = __pyx_v_dst_extent;
-      __pyx_t_4 = __pyx_t_3;
-      for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-        __pyx_v_i = __pyx_t_5;
-
-        /* "View.MemoryView":1155
- *         else:
- *             for i in range(dst_extent):
- *                 memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
- *                 src_data += src_stride
- *                 dst_data += dst_stride
+      __pyx_t_4 = __pyx_v_dst_extent;
+      __pyx_t_5 = __pyx_t_4;
+      for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+        __pyx_v_i = __pyx_t_6;
+
+        /* "View.MemoryView":1158
+ *        else:
+ *            for i in range(dst_extent):
+ *                memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
+ *                src_data += src_stride
+ *                dst_data += dst_stride
  */
         (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize));
 
-        /* "View.MemoryView":1156
- *             for i in range(dst_extent):
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride             # <<<<<<<<<<<<<<
- *                 dst_data += dst_stride
+        /* "View.MemoryView":1159
+ *            for i in range(dst_extent):
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride             # <<<<<<<<<<<<<<
+ *                dst_data += dst_stride
  *     else:
  */
         __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-        /* "View.MemoryView":1157
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride
- *                 dst_data += dst_stride             # <<<<<<<<<<<<<<
+        /* "View.MemoryView":1160
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride
+ *                dst_data += dst_stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(dst_extent):
  */
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
-    /* "View.MemoryView":1149
+    /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1159
- *                 dst_data += dst_stride
+  /* "View.MemoryView":1162
+ *                dst_data += dst_stride
  *     else:
  *         for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *             _copy_strided_to_strided(src_data, src_strides + 1,
  *                                      dst_data, dst_strides + 1,
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_v_dst_extent;
-    __pyx_t_4 = __pyx_t_3;
-    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-      __pyx_v_i = __pyx_t_5;
+    __pyx_t_4 = __pyx_v_dst_extent;
+    __pyx_t_5 = __pyx_t_4;
+    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+      __pyx_v_i = __pyx_t_6;
 
-      /* "View.MemoryView":1160
+      /* "View.MemoryView":1163
  *     else:
  *         for i in range(dst_extent):
  *             _copy_strided_to_strided(src_data, src_strides + 1,             # <<<<<<<<<<<<<<
  *                                      dst_data, dst_strides + 1,
  *                                      src_shape + 1, dst_shape + 1,
  */
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
-      /* "View.MemoryView":1164
+      /* "View.MemoryView":1167
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
  * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-      /* "View.MemoryView":1165
+      /* "View.MemoryView":1168
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1137
+  /* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1167
+/* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
-  /* "View.MemoryView":1170
+  /* "View.MemoryView":1173
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
  * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1167
+  /* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1174
+/* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *__pyx_v_src, int __pyx_v_ndim) {
   Py_ssize_t __pyx_v_shape;
   Py_ssize_t __pyx_v_size;
   Py_ssize_t __pyx_r;
   Py_ssize_t __pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
 
-  /* "View.MemoryView":1176
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:
+  /* "View.MemoryView":1179
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     for shape in src.shape[:ndim]:
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
-  /* "View.MemoryView":1178
+  /* "View.MemoryView":1181
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  * 
  *     for shape in src.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         size *= shape
  * 
  */
   __pyx_t_3 = (__pyx_v_src->shape + __pyx_v_ndim);
   for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_shape = (__pyx_t_2[0]);
 
-    /* "View.MemoryView":1179
+    /* "View.MemoryView":1182
  * 
  *     for shape in src.shape[:ndim]:
  *         size *= shape             # <<<<<<<<<<<<<<
  * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * __pyx_v_shape);
   }
 
-  /* "View.MemoryView":1181
+  /* "View.MemoryView":1184
  *         size *= shape
  * 
  *     return size             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1174
+  /* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1184
+/* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
- *                 int ndim, char order) noexcept nogil:
+ *                 int ndim, char order) nogil:
  */
 
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, Py_ssize_t __pyx_v_stride, int __pyx_v_ndim, char __pyx_v_order) {
   int __pyx_v_idx;
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1193
+  /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
-  __pyx_t_1 = (__pyx_v_order == 'F');
+  __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1194
+    /* "View.MemoryView":1197
  * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_idx = __pyx_t_4;
 
-      /* "View.MemoryView":1195
+      /* "View.MemoryView":1198
  *     if order == 'F':
  *         for idx in range(ndim):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  *     else:
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1196
+      /* "View.MemoryView":1199
  *         for idx in range(ndim):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
-    /* "View.MemoryView":1193
+    /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1198
+  /* "View.MemoryView":1201
  *             stride *= shape[idx]
  *     else:
  *         for idx in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
   /*else*/ {
     for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1; __pyx_t_2-=1) {
       __pyx_v_idx = __pyx_t_2;
 
-      /* "View.MemoryView":1199
+      /* "View.MemoryView":1202
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1200
+      /* "View.MemoryView":1203
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1202
+  /* "View.MemoryView":1205
  *             stride *= shape[idx]
  * 
  *     return stride             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1184
+  /* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
- *                 int ndim, char order) noexcept nogil:
+ *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1205
+/* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -15268,501 +14769,529 @@
   int __pyx_t_3;
   struct __pyx_memoryview_obj *__pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":1216
+  /* "View.MemoryView":1219
  *     cdef void *result
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1217
+  /* "View.MemoryView":1220
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
  * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
-  /* "View.MemoryView":1219
+  /* "View.MemoryView":1222
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
-  /* "View.MemoryView":1220
+  /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  * 
  */
-  __pyx_t_2 = (!(__pyx_v_result != 0));
+  __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1221
+    /* "View.MemoryView":1224
  *     result = malloc(size)
  *     if not result:
- *         _err_no_memory()             # <<<<<<<<<<<<<<
+ *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err_no_memory(); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1221, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1224, __pyx_L1_error)
 
-    /* "View.MemoryView":1220
+    /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  * 
  */
   }
 
-  /* "View.MemoryView":1224
+  /* "View.MemoryView":1227
  * 
  * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
-  /* "View.MemoryView":1225
+  /* "View.MemoryView":1228
  * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
 
-  /* "View.MemoryView":1226
+  /* "View.MemoryView":1229
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1227
+    /* "View.MemoryView":1230
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1228
+    /* "View.MemoryView":1231
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
- *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize, ndim, order)
+ *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1230
+  /* "View.MemoryView":1233
  *         tmpslice.suboffsets[i] = -1
  * 
- *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize, ndim, order)             # <<<<<<<<<<<<<<
- * 
+ *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
+ *                               ndim, order)
  * 
  */
   (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
-  /* "View.MemoryView":1233
+  /* "View.MemoryView":1237
  * 
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1234
+    /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
-    __pyx_t_2 = ((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1);
+    __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1235
+      /* "View.MemoryView":1239
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
  * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
-      /* "View.MemoryView":1234
+      /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1237
+  /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
-  __pyx_t_2 = __pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim);
+  __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1238
+    /* "View.MemoryView":1242
  * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
     (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
-    /* "View.MemoryView":1237
+    /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":1240
+  /* "View.MemoryView":1244
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":1242
+  /* "View.MemoryView":1246
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1205
+  /* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.copy_data_to_temp", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.copy_data_to_temp", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = NULL;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1247
+/* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
 static int __pyx_memoryview_err_extents(int __pyx_v_i, Py_ssize_t __pyx_v_extent1, Py_ssize_t __pyx_v_extent2) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  Py_UCS4 __pyx_t_3;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
-  /* "View.MemoryView":1249
- * cdef int _err_extents(int i, Py_ssize_t extent1,
+  /* "View.MemoryView":1254
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"             # <<<<<<<<<<<<<<
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
+ *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = 0;
-  __pyx_t_3 = 127;
-  __Pyx_INCREF(__pyx_kp_u_got_differing_extents_in_dimensi);
-  __pyx_t_2 += 35;
-  __Pyx_GIVEREF(__pyx_kp_u_got_differing_extents_in_dimensi);
-  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_got_differing_extents_in_dimensi);
-  __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_i, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u_got);
-  __pyx_t_2 += 6;
-  __Pyx_GIVEREF(__pyx_kp_u_got);
-  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_got);
-  __pyx_t_4 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_extent1, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u_and);
-  __pyx_t_2 += 5;
-  __Pyx_GIVEREF(__pyx_kp_u_and);
-  PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u_and);
-  __pyx_t_4 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_extent2, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u__7);
-  __pyx_t_2 += 1;
-  __Pyx_GIVEREF(__pyx_kp_u__7);
-  PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_kp_u__7);
-  __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __Pyx_GIVEREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
+  __pyx_t_1 = 0;
+  __pyx_t_2 = 0;
+  __pyx_t_3 = 0;
+
+  /* "View.MemoryView":1253
+ * cdef int _err_extents(int i, Py_ssize_t extent1,
+ *                              Py_ssize_t extent2) except -1 with gil:
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
+ *                                                         (i, extent1, extent2))
+ * 
+ */
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_4, 0, 0);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_ERR(1, 1249, __pyx_L1_error)
+  __PYX_ERR(1, 1253, __pyx_L1_error)
 
-  /* "View.MemoryView":1247
+  /* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView._err_extents", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1252
+/* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg % dim
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
-static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, PyObject *__pyx_v_msg, int __pyx_v_dim) {
+static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, char *__pyx_v_msg, int __pyx_v_dim) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_dim", 0);
-  __Pyx_INCREF(__pyx_v_msg);
+  __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1253
+  /* "View.MemoryView":1258
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:
- *     raise <object>error, msg % dim             # <<<<<<<<<<<<<<
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
+ *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1253, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyString_FormatSafe(__pyx_v_msg, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_Raise(((PyObject *)__pyx_v_error), __pyx_t_2, 0, 0);
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __PYX_ERR(1, 1253, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_INCREF(__pyx_v_error);
+  __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 1258, __pyx_L1_error)
 
-  /* "View.MemoryView":1252
+  /* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg % dim
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView._err_dim", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
-  __Pyx_XDECREF(__pyx_v_msg);
+  __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1256
+/* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg
- * 
+ * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))
  */
 
-static int __pyx_memoryview_err(PyObject *__pyx_v_error, PyObject *__pyx_v_msg) {
+static int __pyx_memoryview_err(PyObject *__pyx_v_error, char *__pyx_v_msg) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err", 0);
-  __Pyx_INCREF(__pyx_v_msg);
+  __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1257
+  /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:
- *     raise <object>error, msg             # <<<<<<<<<<<<<<
- * 
- * @cname('__pyx_memoryview_err_no_memory')
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:             # <<<<<<<<<<<<<<
+ *         raise error(msg.decode('ascii'))
+ *     else:
  */
-  __Pyx_Raise(((PyObject *)__pyx_v_error), __pyx_v_msg, 0, 0);
-  __PYX_ERR(1, 1257, __pyx_L1_error)
+  __pyx_t_1 = ((__pyx_v_msg != NULL) != 0);
+  if (unlikely(__pyx_t_1)) {
 
-  /* "View.MemoryView":1256
- * 
- * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg
- * 
+    /* "View.MemoryView":1263
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
+ *     else:
+ *         raise error
  */
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_v_error);
+    __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 1263, __pyx_L1_error)
 
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._err", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __Pyx_XDECREF(__pyx_v_msg);
-  __Pyx_RefNannyFinishContext();
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
-  return __pyx_r;
-}
-
-/* "View.MemoryView":1260
- * 
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise MemoryError
- * 
+    /* "View.MemoryView":1262
+ * @cname('__pyx_memoryview_err')
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:             # <<<<<<<<<<<<<<
+ *         raise error(msg.decode('ascii'))
+ *     else:
  */
+  }
 
-static int __pyx_memoryview_err_no_memory(void) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_RefNannySetupContext("_err_no_memory", 0);
-
-  /* "View.MemoryView":1261
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:
- *     raise MemoryError             # <<<<<<<<<<<<<<
- * 
+  /* "View.MemoryView":1265
+ *         raise error(msg.decode('ascii'))
+ *     else:
+ *         raise error             # <<<<<<<<<<<<<<
  * 
+ * @cname('__pyx_memoryview_copy_contents')
  */
-  PyErr_NoMemory(); __PYX_ERR(1, 1261, __pyx_L1_error)
+  /*else*/ {
+    __Pyx_Raise(__pyx_v_error, 0, 0, 0);
+    __PYX_ERR(1, 1265, __pyx_L1_error)
+  }
 
-  /* "View.MemoryView":1260
- * 
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise MemoryError
+  /* "View.MemoryView":1261
  * 
+ * @cname('__pyx_memoryview_err')
+ * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._err_no_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("View.MemoryView._err", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
+  __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1265
+/* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -15779,1167 +15308,1151 @@
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   void *__pyx_t_7;
+  int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":1273
+  /* "View.MemoryView":1276
  *     Check for overlapping memory and verify the shapes.
  *     """
  *     cdef void *tmpdata = NULL             # <<<<<<<<<<<<<<
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  */
   __pyx_v_tmpdata = NULL;
 
-  /* "View.MemoryView":1274
+  /* "View.MemoryView":1277
  *     """
  *     cdef void *tmpdata = NULL
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  */
   __pyx_t_1 = __pyx_v_src.memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1276
+  /* "View.MemoryView":1279
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)             # <<<<<<<<<<<<<<
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False
  */
   __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_src), __pyx_v_src_ndim);
 
-  /* "View.MemoryView":1277
+  /* "View.MemoryView":1280
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False             # <<<<<<<<<<<<<<
  *     cdef bint direct_copy = False
  *     cdef __Pyx_memviewslice tmp
  */
   __pyx_v_broadcasting = 0;
 
-  /* "View.MemoryView":1278
+  /* "View.MemoryView":1281
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
  * 
  */
   __pyx_v_direct_copy = 0;
 
-  /* "View.MemoryView":1281
+  /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
-  __pyx_t_2 = (__pyx_v_src_ndim < __pyx_v_dst_ndim);
+  __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1282
+    /* "View.MemoryView":1285
  * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
-    /* "View.MemoryView":1281
+    /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1283
+  /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
-  __pyx_t_2 = (__pyx_v_dst_ndim < __pyx_v_src_ndim);
+  __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1284
+    /* "View.MemoryView":1287
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
-    /* "View.MemoryView":1283
+    /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1286
+  /* "View.MemoryView":1289
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
   __pyx_t_4 = __pyx_v_src_ndim;
-  if ((__pyx_t_3 > __pyx_t_4)) {
+  if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
-  /* "View.MemoryView":1288
+  /* "View.MemoryView":1291
  *     cdef int ndim = max(src_ndim, dst_ndim)
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_5;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1289
+    /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
-    __pyx_t_2 = ((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i]));
+    __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1290
+      /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
-      __pyx_t_2 = ((__pyx_v_src.shape[__pyx_v_i]) == 1);
+      __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) == 1) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":1291
+        /* "View.MemoryView":1294
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  *                 broadcasting = True             # <<<<<<<<<<<<<<
  *                 src.strides[i] = 0
  *             else:
  */
         __pyx_v_broadcasting = 1;
 
-        /* "View.MemoryView":1292
+        /* "View.MemoryView":1295
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  *                 src.strides[i] = 0             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  */
         (__pyx_v_src.strides[__pyx_v_i]) = 0;
 
-        /* "View.MemoryView":1290
+        /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":1294
+      /* "View.MemoryView":1297
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1294, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":1289
+      /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
-    /* "View.MemoryView":1296
+    /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
-    __pyx_t_2 = ((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0);
+    __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1297
+      /* "View.MemoryView":1300
  * 
  *         if src.suboffsets[i] >= 0:
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_6 = __pyx_memoryview_err_dim(PyExc_ValueError, __pyx_kp_s_Dimension_d_is_not_direct, __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1300, __pyx_L1_error)
 
-      /* "View.MemoryView":1296
+      /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1299
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+  /* "View.MemoryView":1302
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
-  __pyx_t_2 = __pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
+  __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1301
+    /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
-    __pyx_t_2 = (!__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim));
+    __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1302
+      /* "View.MemoryView":1305
  * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
-      /* "View.MemoryView":1301
+      /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     }
 
-    /* "View.MemoryView":1304
+    /* "View.MemoryView":1307
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1304, __pyx_L1_error)
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1307, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
-    /* "View.MemoryView":1305
+    /* "View.MemoryView":1308
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
-    /* "View.MemoryView":1299
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+    /* "View.MemoryView":1302
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
-  /* "View.MemoryView":1307
+  /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = (!__pyx_v_broadcasting);
+  __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1310
+    /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
-    __pyx_t_2 = __pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim);
+    __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1311
+      /* "View.MemoryView":1314
  * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
-      /* "View.MemoryView":1310
+      /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
-    /* "View.MemoryView":1312
+    /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
-    __pyx_t_2 = __pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim);
+    __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1313
+      /* "View.MemoryView":1316
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
  * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
-      /* "View.MemoryView":1312
+      /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     }
     __pyx_L12:;
 
-    /* "View.MemoryView":1315
+    /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    if (__pyx_v_direct_copy) {
+    __pyx_t_2 = (__pyx_v_direct_copy != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":1317
+      /* "View.MemoryView":1320
  *         if direct_copy:
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-      /* "View.MemoryView":1318
+      /* "View.MemoryView":1321
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
       (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
-      /* "View.MemoryView":1319
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+      /* "View.MemoryView":1322
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  *             free(tmpdata)
  *             return 0
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-      /* "View.MemoryView":1320
+      /* "View.MemoryView":1323
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
  * 
  */
       free(__pyx_v_tmpdata);
 
-      /* "View.MemoryView":1321
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+      /* "View.MemoryView":1324
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
-      /* "View.MemoryView":1315
+      /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
-    /* "View.MemoryView":1307
+    /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1323
+  /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
-  if (__pyx_t_2) {
+  __pyx_t_8 = (__pyx_t_2 != 0);
+  if (__pyx_t_8) {
 
-    /* "View.MemoryView":1326
+    /* "View.MemoryView":1329
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 1326, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1329, __pyx_L1_error)
 
-    /* "View.MemoryView":1327
+    /* "View.MemoryView":1330
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 1327, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1330, __pyx_L1_error)
 
-    /* "View.MemoryView":1323
+    /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1329
+  /* "View.MemoryView":1332
  *         transpose_memslice(&dst)
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1330
+  /* "View.MemoryView":1333
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1331
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+  /* "View.MemoryView":1334
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1333
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+  /* "View.MemoryView":1336
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   free(__pyx_v_tmpdata);
 
-  /* "View.MemoryView":1334
+  /* "View.MemoryView":1337
  * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1265
+  /* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.memoryview_copy_contents", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.memoryview_copy_contents", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1337
+/* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
- *                             int ndim_other) noexcept nogil:
+ *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
   int __pyx_v_i;
   int __pyx_v_offset;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
 
-  /* "View.MemoryView":1341
- *                             int ndim_other) noexcept nogil:
+  /* "View.MemoryView":1344
+ *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
-  /* "View.MemoryView":1343
+  /* "View.MemoryView":1346
  *     cdef int offset = ndim_other - ndim
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1344
+    /* "View.MemoryView":1347
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1345
+    /* "View.MemoryView":1348
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-    /* "View.MemoryView":1346
+    /* "View.MemoryView":1349
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
  * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
-  /* "View.MemoryView":1348
+  /* "View.MemoryView":1351
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1349
+    /* "View.MemoryView":1352
  * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
-    /* "View.MemoryView":1350
+    /* "View.MemoryView":1353
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
-    /* "View.MemoryView":1351
+    /* "View.MemoryView":1354
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1337
+  /* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
- *                             int ndim_other) noexcept nogil:
+ *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1359
+/* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
+ *                            int ndim, bint inc) nogil:
  * 
- *     if dtype_is_object:
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
+  int __pyx_t_1;
 
-  /* "View.MemoryView":1361
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:
+  /* "View.MemoryView":1366
  * 
- *     if dtype_is_object:             # <<<<<<<<<<<<<<
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)
  * 
+ *     if dtype_is_object:             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
+ *                                            dst.strides, ndim, inc)
  */
-  if (__pyx_v_dtype_is_object) {
+  __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":1362
+    /* "View.MemoryView":1367
  * 
  *     if dtype_is_object:
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
+ *                                            dst.strides, ndim, inc)
  * 
- * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
-    /* "View.MemoryView":1361
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:
+    /* "View.MemoryView":1366
  * 
- *     if dtype_is_object:             # <<<<<<<<<<<<<<
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)
  * 
+ *     if dtype_is_object:             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
+ *                                            dst.strides, ndim, inc)
  */
   }
 
-  /* "View.MemoryView":1359
+  /* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
+ *                            int ndim, bint inc) nogil:
  * 
- *     if dtype_is_object:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1365
+/* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   __Pyx_RefNannyDeclarations
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
-  /* "View.MemoryView":1368
+  /* "View.MemoryView":1374
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
-  /* "View.MemoryView":1365
+  /* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "View.MemoryView":1371
+/* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+ *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
-  Py_ssize_t __pyx_v_stride;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
-  /* "View.MemoryView":1374
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+  /* "View.MemoryView":1381
  *     cdef Py_ssize_t i
- *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
- * 
- *     for i in range(shape[0]):
- */
-  __pyx_v_stride = (__pyx_v_strides[0]);
-
-  /* "View.MemoryView":1376
- *     cdef Py_ssize_t stride = strides[0]
  * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1377
+    /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
-    __pyx_t_4 = (__pyx_v_ndim == 1);
+    __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":1378
+      /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
-      if (__pyx_v_inc) {
+      __pyx_t_4 = (__pyx_v_inc != 0);
+      if (__pyx_t_4) {
 
-        /* "View.MemoryView":1379
+        /* "View.MemoryView":1384
  *         if ndim == 1:
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])
  */
         Py_INCREF((((PyObject **)__pyx_v_data)[0]));
 
-        /* "View.MemoryView":1378
+        /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
         goto __pyx_L6;
       }
 
-      /* "View.MemoryView":1381
+      /* "View.MemoryView":1386
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *         else:
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
-      /* "View.MemoryView":1377
+      /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":1383
+    /* "View.MemoryView":1388
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)             # <<<<<<<<<<<<<<
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
+ *                                       ndim - 1, inc)
  * 
- *         data += stride
  */
     /*else*/ {
+
+      /* "View.MemoryView":1389
+ *         else:
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,
+ *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
+ * 
+ *         data += strides[0]
+ */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":1385
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)
+    /* "View.MemoryView":1391
+ *                                       ndim - 1, inc)
  * 
- *         data += stride             # <<<<<<<<<<<<<<
+ *         data += strides[0]             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
+    __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
-  /* "View.MemoryView":1371
+  /* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+ *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1391
+/* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
+ *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
 
-  /* "View.MemoryView":1394
+  /* "View.MemoryView":1400
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)
+ *                               bint dtype_is_object) nogil:
+ *     refcount_copying(dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
+ *                          itemsize, item)
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1395
- *                               bint dtype_is_object) noexcept nogil:
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)             # <<<<<<<<<<<<<<
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)
- * 
+  /* "View.MemoryView":1401
+ *                               bint dtype_is_object) nogil:
+ *     refcount_copying(dst, dtype_is_object, ndim, False)
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,             # <<<<<<<<<<<<<<
+ *                          itemsize, item)
+ *     refcount_copying(dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
-  /* "View.MemoryView":1396
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":1403
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
+ *                          itemsize, item)
+ *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1391
+  /* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
+ *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1400
+/* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
- *                               size_t itemsize, void *item) noexcept nogil:
+ *                               size_t itemsize, void *item) nogil:
  */
 
 static void __pyx_memoryview__slice_assign_scalar(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   Py_ssize_t __pyx_v_stride;
   Py_ssize_t __pyx_v_extent;
   int __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
 
-  /* "View.MemoryView":1404
- *                               size_t itemsize, void *item) noexcept nogil:
+  /* "View.MemoryView":1411
+ *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
  * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
-  /* "View.MemoryView":1405
+  /* "View.MemoryView":1412
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
-  /* "View.MemoryView":1407
+  /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
-  __pyx_t_1 = (__pyx_v_ndim == 1);
+  __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1408
+    /* "View.MemoryView":1415
  * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1409
+      /* "View.MemoryView":1416
  *     if ndim == 1:
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)             # <<<<<<<<<<<<<<
  *             data += stride
  *     else:
  */
       (void)(memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize));
 
-      /* "View.MemoryView":1410
+      /* "View.MemoryView":1417
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  *             data += stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
-    /* "View.MemoryView":1407
+    /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1412
+  /* "View.MemoryView":1419
  *             data += stride
  *     else:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)
- *             data += stride
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,
+ *                                 ndim - 1, itemsize, item)
  */
   /*else*/ {
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1413
+      /* "View.MemoryView":1420
  *     else:
  *         for i in range(extent):
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)             # <<<<<<<<<<<<<<
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
+ *                                 ndim - 1, itemsize, item)
  *             data += stride
- * 
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
-      /* "View.MemoryView":1414
- *         for i in range(extent):
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)
+      /* "View.MemoryView":1422
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,
+ *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1400
+  /* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
- *                               size_t itemsize, void *item) noexcept nogil:
+ *                               size_t itemsize, void *item) nogil:
  */
 
   /* function exit code */
 }
 
 /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v___pyx_type = 0;
   long __pyx_v___pyx_checksum;
   PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};
     PyObject* values[3] = {0,0,0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_type)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 3)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v___pyx_type = values[0];
     __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
     __pyx_v___pyx_state = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 1, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);
 
@@ -16949,140 +16462,151 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
-  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__8, Py_NE)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_2) {
+  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
+  if (__pyx_t_1) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
-    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
-    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
+    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_t_1);
-    __pyx_v___pyx_PickleError = __pyx_t_1;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v___pyx_PickleError = __pyx_t_2;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_INCREF(__pyx_v___pyx_PickleError);
+    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+      }
+    }
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_Raise(__pyx_v___pyx_PickleError, __pyx_t_1, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
-  __pyx_t_5 = 0;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_5 = 1;
+      __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_v___pyx_type};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  }
-  __pyx_v___pyx_result = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v___pyx_result = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
-  __pyx_t_2 = (__pyx_v___pyx_state != Py_None);
-  if (__pyx_t_2) {
+  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
+  __pyx_t_6 = (__pyx_t_1 != 0);
+  if (__pyx_t_6) {
 
     /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None) || __Pyx_RaiseUnexpectedTypeError("tuple", __pyx_v___pyx_state))) __PYX_ERR(1, 9, __pyx_L1_error)
-    __pyx_t_1 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 9, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
+    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
@@ -17102,17 +16626,18 @@
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
@@ -17130,18 +16655,18 @@
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum__set_state", 0);
 
   /* "(tree fragment)":12
  *     return __pyx_result
@@ -17169,62 +16694,58 @@
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_4 = (__pyx_t_3 > 1);
+  __pyx_t_4 = ((__pyx_t_3 > 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_2 = __pyx_t_4;
+  __pyx_t_5 = (__pyx_t_4 != 0);
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
     /* "(tree fragment)":14
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 14, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_update); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 14, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-        __Pyx_INCREF(__pyx_t_7);
+    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
-      __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_6, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
+    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
  *         __pyx_result.__dict__.update(__pyx_state[1])
@@ -17240,2107 +16761,51 @@
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
-static PyObject *__pyx_gb_7chython_10algorithms_12_isomorphism_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
-
-/* "chython/algorithms/_isomorphism.pyx":28
- * 
- * 
- * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
- * @cython.wraparound(False)
- * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
- */
-
-/* Python wrapper */
-static PyObject *__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_7chython_10algorithms_12_isomorphism_1get_mapping = {"get_mapping", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  __Pyx_memviewslice __pyx_v_q_numbers = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_back = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_masks1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_masks2 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_masks3 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_masks4 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_closures = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_from = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_to = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_q_bonds = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_numbers = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_bits1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_bits2 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_bits3 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_bits4 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_bonds = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_from = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_to = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_o_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_scope = { 0, 0, { 0 }, { 0 }, { 0 } };
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("get_mapping (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_q_numbers,&__pyx_n_s_q_back,&__pyx_n_s_q_masks1,&__pyx_n_s_q_masks2,&__pyx_n_s_q_masks3,&__pyx_n_s_q_masks4,&__pyx_n_s_q_closures,&__pyx_n_s_q_from,&__pyx_n_s_q_to,&__pyx_n_s_q_indices,&__pyx_n_s_q_bonds,&__pyx_n_s_o_numbers,&__pyx_n_s_o_bits1,&__pyx_n_s_o_bits2,&__pyx_n_s_o_bits3,&__pyx_n_s_o_bits4,&__pyx_n_s_o_bonds,&__pyx_n_s_o_from,&__pyx_n_s_o_to,&__pyx_n_s_o_indices,&__pyx_n_s_scope,0};
-    PyObject* values[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case 21: values[20] = __Pyx_Arg_FASTCALL(__pyx_args, 20);
-        CYTHON_FALLTHROUGH;
-        case 20: values[19] = __Pyx_Arg_FASTCALL(__pyx_args, 19);
-        CYTHON_FALLTHROUGH;
-        case 19: values[18] = __Pyx_Arg_FASTCALL(__pyx_args, 18);
-        CYTHON_FALLTHROUGH;
-        case 18: values[17] = __Pyx_Arg_FASTCALL(__pyx_args, 17);
-        CYTHON_FALLTHROUGH;
-        case 17: values[16] = __Pyx_Arg_FASTCALL(__pyx_args, 16);
-        CYTHON_FALLTHROUGH;
-        case 16: values[15] = __Pyx_Arg_FASTCALL(__pyx_args, 15);
-        CYTHON_FALLTHROUGH;
-        case 15: values[14] = __Pyx_Arg_FASTCALL(__pyx_args, 14);
-        CYTHON_FALLTHROUGH;
-        case 14: values[13] = __Pyx_Arg_FASTCALL(__pyx_args, 13);
-        CYTHON_FALLTHROUGH;
-        case 13: values[12] = __Pyx_Arg_FASTCALL(__pyx_args, 12);
-        CYTHON_FALLTHROUGH;
-        case 12: values[11] = __Pyx_Arg_FASTCALL(__pyx_args, 11);
-        CYTHON_FALLTHROUGH;
-        case 11: values[10] = __Pyx_Arg_FASTCALL(__pyx_args, 10);
-        CYTHON_FALLTHROUGH;
-        case 10: values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
-        CYTHON_FALLTHROUGH;
-        case  9: values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
-        CYTHON_FALLTHROUGH;
-        case  8: values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
-        CYTHON_FALLTHROUGH;
-        case  7: values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
-        CYTHON_FALLTHROUGH;
-        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-        CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_numbers)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_back)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 1); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_masks1)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 2); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  3:
-        if (likely((values[3] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_masks2)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 3); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  4:
-        if (likely((values[4] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_masks3)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 4); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  5:
-        if (likely((values[5] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_masks4)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 5); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  6:
-        if (likely((values[6] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_closures)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 6); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  7:
-        if (likely((values[7] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_from)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 7); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  8:
-        if (likely((values[8] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_to)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 8); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  9:
-        if (likely((values[9] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_indices)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 9); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 10:
-        if (likely((values[10] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_q_bonds)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 10); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 11:
-        if (likely((values[11] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_numbers)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 11); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 12:
-        if (likely((values[12] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_bits1)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 12); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 13:
-        if (likely((values[13] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_bits2)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 13); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 14:
-        if (likely((values[14] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_bits3)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 14); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 15:
-        if (likely((values[15] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_bits4)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 15); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 16:
-        if (likely((values[16] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_bonds)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 16); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 17:
-        if (likely((values[17] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_from)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 17); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 18:
-        if (likely((values[18] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_to)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 18); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 19:
-        if (likely((values[19] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_o_indices)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 19); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case 20:
-        if (likely((values[20] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_scope)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 28, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 20); __PYX_ERR(0, 28, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "get_mapping") < 0)) __PYX_ERR(0, 28, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 21)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-      values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-      values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-      values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-      values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
-      values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
-      values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
-      values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
-      values[10] = __Pyx_Arg_FASTCALL(__pyx_args, 10);
-      values[11] = __Pyx_Arg_FASTCALL(__pyx_args, 11);
-      values[12] = __Pyx_Arg_FASTCALL(__pyx_args, 12);
-      values[13] = __Pyx_Arg_FASTCALL(__pyx_args, 13);
-      values[14] = __Pyx_Arg_FASTCALL(__pyx_args, 14);
-      values[15] = __Pyx_Arg_FASTCALL(__pyx_args, 15);
-      values[16] = __Pyx_Arg_FASTCALL(__pyx_args, 16);
-      values[17] = __Pyx_Arg_FASTCALL(__pyx_args, 17);
-      values[18] = __Pyx_Arg_FASTCALL(__pyx_args, 18);
-      values[19] = __Pyx_Arg_FASTCALL(__pyx_args, 19);
-      values[20] = __Pyx_Arg_FASTCALL(__pyx_args, 20);
-    }
-    __pyx_v_q_numbers = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_numbers.memview)) __PYX_ERR(0, 30, __pyx_L3_error)
-    __pyx_v_q_back = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_back.memview)) __PYX_ERR(0, 30, __pyx_L3_error)
-    __pyx_v_q_masks1 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks1.memview)) __PYX_ERR(0, 31, __pyx_L3_error)
-    __pyx_v_q_masks2 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[3], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks2.memview)) __PYX_ERR(0, 31, __pyx_L3_error)
-    __pyx_v_q_masks3 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[4], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks3.memview)) __PYX_ERR(0, 32, __pyx_L3_error)
-    __pyx_v_q_masks4 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[5], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks4.memview)) __PYX_ERR(0, 32, __pyx_L3_error)
-    __pyx_v_q_closures = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[6], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_closures.memview)) __PYX_ERR(0, 33, __pyx_L3_error)
-    __pyx_v_q_from = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[7], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_from.memview)) __PYX_ERR(0, 33, __pyx_L3_error)
-    __pyx_v_q_to = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[8], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_to.memview)) __PYX_ERR(0, 34, __pyx_L3_error)
-    __pyx_v_q_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[9], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_indices.memview)) __PYX_ERR(0, 34, __pyx_L3_error)
-    __pyx_v_q_bonds = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[10], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_bonds.memview)) __PYX_ERR(0, 35, __pyx_L3_error)
-    __pyx_v_o_numbers = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(values[11], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_numbers.memview)) __PYX_ERR(0, 35, __pyx_L3_error)
-    __pyx_v_o_bits1 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[12], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits1.memview)) __PYX_ERR(0, 36, __pyx_L3_error)
-    __pyx_v_o_bits2 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[13], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits2.memview)) __PYX_ERR(0, 36, __pyx_L3_error)
-    __pyx_v_o_bits3 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[14], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits3.memview)) __PYX_ERR(0, 37, __pyx_L3_error)
-    __pyx_v_o_bits4 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[15], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits4.memview)) __PYX_ERR(0, 37, __pyx_L3_error)
-    __pyx_v_o_bonds = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[16], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bonds.memview)) __PYX_ERR(0, 38, __pyx_L3_error)
-    __pyx_v_o_from = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[17], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_from.memview)) __PYX_ERR(0, 38, __pyx_L3_error)
-    __pyx_v_o_to = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[18], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_to.memview)) __PYX_ERR(0, 39, __pyx_L3_error)
-    __pyx_v_o_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[19], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_indices.memview)) __PYX_ERR(0, 39, __pyx_L3_error)
-    __pyx_v_scope = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[20], PyBUF_WRITABLE); if (unlikely(!__pyx_v_scope.memview)) __PYX_ERR(0, 40, __pyx_L3_error)
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, __pyx_nargs); __PYX_ERR(0, 28, __pyx_L3_error)
-  __pyx_L3_error:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_numbers, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_back, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks2, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks3, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks4, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_closures, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_from, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_to, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_indices, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_bonds, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_numbers, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits2, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits3, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits4, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bonds, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_from, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_to, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_indices, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_scope, 1);
-  __Pyx_AddTraceback("chython.algorithms._isomorphism.get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(((PyObject *)__pyx_v_q_numbers.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_numbers"); __PYX_ERR(0, 30, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_back.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_back"); __PYX_ERR(0, 30, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_masks1.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks1"); __PYX_ERR(0, 31, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_masks2.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks2"); __PYX_ERR(0, 31, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_masks3.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks3"); __PYX_ERR(0, 32, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_masks4.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks4"); __PYX_ERR(0, 32, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_closures.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_closures"); __PYX_ERR(0, 33, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_from.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_from"); __PYX_ERR(0, 33, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_to.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_to"); __PYX_ERR(0, 34, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_indices.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_indices"); __PYX_ERR(0, 34, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_q_bonds.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_bonds"); __PYX_ERR(0, 35, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_numbers.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_numbers"); __PYX_ERR(0, 35, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_bits1.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits1"); __PYX_ERR(0, 36, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_bits2.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits2"); __PYX_ERR(0, 36, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_bits3.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits3"); __PYX_ERR(0, 37, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_bits4.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits4"); __PYX_ERR(0, 37, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_bonds.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bonds"); __PYX_ERR(0, 38, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_from.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_from"); __PYX_ERR(0, 38, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_to.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_to"); __PYX_ERR(0, 39, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_o_indices.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_indices"); __PYX_ERR(0, 39, __pyx_L1_error)
-  }
-  if (unlikely(((PyObject *)__pyx_v_scope.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "scope"); __PYX_ERR(0, 40, __pyx_L1_error)
-  }
-  __pyx_r = __pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(__pyx_self, __pyx_v_q_numbers, __pyx_v_q_back, __pyx_v_q_masks1, __pyx_v_q_masks2, __pyx_v_q_masks3, __pyx_v_q_masks4, __pyx_v_q_closures, __pyx_v_q_from, __pyx_v_q_to, __pyx_v_q_indices, __pyx_v_q_bonds, __pyx_v_o_numbers, __pyx_v_o_bits1, __pyx_v_o_bits2, __pyx_v_o_bits3, __pyx_v_o_bits4, __pyx_v_o_bonds, __pyx_v_o_from, __pyx_v_o_to, __pyx_v_o_indices, __pyx_v_scope);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_numbers, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_back, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks2, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks3, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_masks4, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_closures, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_from, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_to, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_indices, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_q_bonds, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_numbers, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits2, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits3, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bits4, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_bonds, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_from, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_to, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_o_indices, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_scope, 1);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_q_numbers, __Pyx_memviewslice __pyx_v_q_back, __Pyx_memviewslice __pyx_v_q_masks1, __Pyx_memviewslice __pyx_v_q_masks2, __Pyx_memviewslice __pyx_v_q_masks3, __Pyx_memviewslice __pyx_v_q_masks4, __Pyx_memviewslice __pyx_v_q_closures, __Pyx_memviewslice __pyx_v_q_from, __Pyx_memviewslice __pyx_v_q_to, __Pyx_memviewslice __pyx_v_q_indices, __Pyx_memviewslice __pyx_v_q_bonds, __Pyx_memviewslice __pyx_v_o_numbers, __Pyx_memviewslice __pyx_v_o_bits1, __Pyx_memviewslice __pyx_v_o_bits2, __Pyx_memviewslice __pyx_v_o_bits3, __Pyx_memviewslice __pyx_v_o_bits4, __Pyx_memviewslice __pyx_v_o_bonds, __Pyx_memviewslice __pyx_v_o_from, __Pyx_memviewslice __pyx_v_o_to, __Pyx_memviewslice __pyx_v_o_indices, __Pyx_memviewslice __pyx_v_scope) {
-  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_cur_scope;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_mapping", 0);
-  __pyx_cur_scope = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, __pyx_empty_tuple, NULL);
-  if (unlikely(!__pyx_cur_scope)) {
-    __pyx_cur_scope = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)Py_None);
-    __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 28, __pyx_L1_error)
-  } else {
-    __Pyx_GOTREF((PyObject *)__pyx_cur_scope);
-  }
-  __pyx_cur_scope->__pyx_v_q_numbers = __pyx_v_q_numbers;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_numbers, 1);
-  __pyx_cur_scope->__pyx_v_q_back = __pyx_v_q_back;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_back, 1);
-  __pyx_cur_scope->__pyx_v_q_masks1 = __pyx_v_q_masks1;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks1, 1);
-  __pyx_cur_scope->__pyx_v_q_masks2 = __pyx_v_q_masks2;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks2, 1);
-  __pyx_cur_scope->__pyx_v_q_masks3 = __pyx_v_q_masks3;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks3, 1);
-  __pyx_cur_scope->__pyx_v_q_masks4 = __pyx_v_q_masks4;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks4, 1);
-  __pyx_cur_scope->__pyx_v_q_closures = __pyx_v_q_closures;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_closures, 1);
-  __pyx_cur_scope->__pyx_v_q_from = __pyx_v_q_from;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_from, 1);
-  __pyx_cur_scope->__pyx_v_q_to = __pyx_v_q_to;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_to, 1);
-  __pyx_cur_scope->__pyx_v_q_indices = __pyx_v_q_indices;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_indices, 1);
-  __pyx_cur_scope->__pyx_v_q_bonds = __pyx_v_q_bonds;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_bonds, 1);
-  __pyx_cur_scope->__pyx_v_o_numbers = __pyx_v_o_numbers;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_numbers, 1);
-  __pyx_cur_scope->__pyx_v_o_bits1 = __pyx_v_o_bits1;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits1, 1);
-  __pyx_cur_scope->__pyx_v_o_bits2 = __pyx_v_o_bits2;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits2, 1);
-  __pyx_cur_scope->__pyx_v_o_bits3 = __pyx_v_o_bits3;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits3, 1);
-  __pyx_cur_scope->__pyx_v_o_bits4 = __pyx_v_o_bits4;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits4, 1);
-  __pyx_cur_scope->__pyx_v_o_bonds = __pyx_v_o_bonds;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bonds, 1);
-  __pyx_cur_scope->__pyx_v_o_from = __pyx_v_o_from;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_from, 1);
-  __pyx_cur_scope->__pyx_v_o_to = __pyx_v_o_to;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_to, 1);
-  __pyx_cur_scope->__pyx_v_o_indices = __pyx_v_o_indices;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_indices, 1);
-  __pyx_cur_scope->__pyx_v_scope = __pyx_v_scope;
-  __PYX_INC_MEMVIEW(&__pyx_cur_scope->__pyx_v_scope, 1);
-  {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_7chython_10algorithms_12_isomorphism_2generator, __pyx_codeobj__9, (PyObject *) __pyx_cur_scope, __pyx_n_s_get_mapping, __pyx_n_s_get_mapping, __pyx_n_s_chython_algorithms__isomorphism); if (unlikely(!gen)) __PYX_ERR(0, 28, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_cur_scope);
-    __Pyx_RefNannyFinishContext();
-    return (PyObject *) gen;
-  }
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("chython.algorithms._isomorphism.get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_DECREF((PyObject *)__pyx_cur_scope);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_gb_7chython_10algorithms_12_isomorphism_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
-{
-  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_cur_scope = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)__pyx_generator->closure);
-  PyObject *__pyx_r = NULL;
-  Py_ssize_t __pyx_t_1;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  unsigned int __pyx_t_5;
-  unsigned int __pyx_t_6;
-  unsigned int __pyx_t_7;
-  size_t __pyx_t_8;
-  size_t __pyx_t_9;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  size_t __pyx_t_12;
-  unsigned int __pyx_t_13;
-  unsigned int __pyx_t_14;
-  unsigned int __pyx_t_15;
-  int __pyx_t_16;
-  int __pyx_t_17;
-  char const *__pyx_t_18;
-  PyObject *__pyx_t_19 = NULL;
-  PyObject *__pyx_t_20 = NULL;
-  PyObject *__pyx_t_21 = NULL;
-  PyObject *__pyx_t_22 = NULL;
-  PyObject *__pyx_t_23 = NULL;
-  PyObject *__pyx_t_24 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("get_mapping", 0);
-  switch (__pyx_generator->resume_label) {
-    case 0: goto __pyx_L3_first_run;
-    case 1: goto __pyx_L26_resume_from_yield;
-    default: /* CPython raises the right error here */
-    __Pyx_RefNannyFinishContext();
-    return NULL;
-  }
-  __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 28, __pyx_L1_error)
-
-  /* "chython/algorithms/_isomorphism.pyx":42
- *                 unsigned int[::1] scope not None):
- *     # expected less than 2^16 atoms in structure.
- *     cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num             # <<<<<<<<<<<<<<
- *     cdef unsigned int n, m, o, i, j, closures_counter
- *     cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond, c_bond
- */
-  __pyx_cur_scope->__pyx_v_stack = 0;
-  __pyx_cur_scope->__pyx_v_path_size = 0;
-
-  /* "chython/algorithms/_isomorphism.pyx":47
- *     cdef dict mapping
- * 
- *     q_size = len(q_numbers)             # <<<<<<<<<<<<<<
- *     q_size_dec = q_size - 1
- *     o_size = len(o_numbers)
- */
-  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_cur_scope->__pyx_v_q_numbers); 
-  __pyx_cur_scope->__pyx_v_q_size = __pyx_t_1;
-
-  /* "chython/algorithms/_isomorphism.pyx":48
- * 
- *     q_size = len(q_numbers)
- *     q_size_dec = q_size - 1             # <<<<<<<<<<<<<<
- *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- */
-  __pyx_cur_scope->__pyx_v_q_size_dec = (__pyx_cur_scope->__pyx_v_q_size - 1);
-
-  /* "chython/algorithms/_isomorphism.pyx":49
- *     q_size = len(q_numbers)
- *     q_size_dec = q_size - 1
- *     o_size = len(o_numbers)             # <<<<<<<<<<<<<<
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- */
-  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_cur_scope->__pyx_v_o_numbers); 
-  __pyx_cur_scope->__pyx_v_o_size = __pyx_t_1;
-
-  /* "chython/algorithms/_isomorphism.pyx":50
- *     q_size_dec = q_size - 1
- *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))             # <<<<<<<<<<<<<<
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- */
-  __pyx_cur_scope->__pyx_v_path = ((unsigned int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_q_size_dec * (sizeof(unsigned int)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":51
- *     o_size = len(o_numbers)
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))             # <<<<<<<<<<<<<<
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
- */
-  __pyx_cur_scope->__pyx_v_stack_index = ((unsigned int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(unsigned int)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":52
- *     cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))             # <<<<<<<<<<<<<<
- *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
- *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
- */
-  __pyx_cur_scope->__pyx_v_stack_depth = ((unsigned int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(unsigned int)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":53
- *     cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))             # <<<<<<<<<<<<<<
- *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
- * 
- */
-  __pyx_cur_scope->__pyx_v_matched = ((int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(int)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":54
- *     cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
- *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
- *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))             # <<<<<<<<<<<<<<
- * 
- *     if not path or not stack_index or not stack_depth or not matched or not o_closures:
- */
-  __pyx_cur_scope->__pyx_v_o_closures = ((unsigned PY_LONG_LONG *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(unsigned PY_LONG_LONG)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":56
- *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
- * 
- *     if not path or not stack_index or not stack_depth or not matched or not o_closures:             # <<<<<<<<<<<<<<
- *         raise MemoryError()
- * 
- */
-  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_path != 0));
-  if (!__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L5_bool_binop_done;
-  }
-  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_stack_index != 0));
-  if (!__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L5_bool_binop_done;
-  }
-  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_stack_depth != 0));
-  if (!__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L5_bool_binop_done;
-  }
-  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_matched != 0));
-  if (!__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L5_bool_binop_done;
-  }
-  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_o_closures != 0));
-  __pyx_t_2 = __pyx_t_3;
-  __pyx_L5_bool_binop_done:;
-  if (unlikely(__pyx_t_2)) {
-
-    /* "chython/algorithms/_isomorphism.pyx":57
- * 
- *     if not path or not stack_index or not stack_depth or not matched or not o_closures:
- *         raise MemoryError()             # <<<<<<<<<<<<<<
- * 
- *     memset(matched, 0, o_size * sizeof(bint))
- */
-    PyErr_NoMemory(); __PYX_ERR(0, 57, __pyx_L1_error)
-
-    /* "chython/algorithms/_isomorphism.pyx":56
- *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
- * 
- *     if not path or not stack_index or not stack_depth or not matched or not o_closures:             # <<<<<<<<<<<<<<
- *         raise MemoryError()
- * 
- */
-  }
-
-  /* "chython/algorithms/_isomorphism.pyx":59
- *         raise MemoryError()
- * 
- *     memset(matched, 0, o_size * sizeof(bint))             # <<<<<<<<<<<<<<
- *     memset(o_closures, 0, o_size * sizeof(unsigned long long))
- * 
- */
-  (void)(memset(__pyx_cur_scope->__pyx_v_matched, 0, (__pyx_cur_scope->__pyx_v_o_size * (sizeof(int)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":60
- * 
- *     memset(matched, 0, o_size * sizeof(bint))
- *     memset(o_closures, 0, o_size * sizeof(unsigned long long))             # <<<<<<<<<<<<<<
- * 
- *     # find entry-points.
- */
-  (void)(memset(__pyx_cur_scope->__pyx_v_o_closures, 0, (__pyx_cur_scope->__pyx_v_o_size * (sizeof(unsigned PY_LONG_LONG)))));
-
-  /* "chython/algorithms/_isomorphism.pyx":63
- * 
- *     # find entry-points.
- *     q_mask1 = q_masks1[0]             # <<<<<<<<<<<<<<
- *     q_mask2 = q_masks2[0]
- *     q_mask3 = q_masks3[0]
- */
-  __pyx_t_4 = 0;
-  __pyx_cur_scope->__pyx_v_q_mask1 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks1.data) + __pyx_t_4)) )));
-
-  /* "chython/algorithms/_isomorphism.pyx":64
- *     # find entry-points.
- *     q_mask1 = q_masks1[0]
- *     q_mask2 = q_masks2[0]             # <<<<<<<<<<<<<<
- *     q_mask3 = q_masks3[0]
- *     q_mask4 = q_masks4[0]
- */
-  __pyx_t_4 = 0;
-  __pyx_cur_scope->__pyx_v_q_mask2 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks2.data) + __pyx_t_4)) )));
-
-  /* "chython/algorithms/_isomorphism.pyx":65
- *     q_mask1 = q_masks1[0]
- *     q_mask2 = q_masks2[0]
- *     q_mask3 = q_masks3[0]             # <<<<<<<<<<<<<<
- *     q_mask4 = q_masks4[0]
- *     for n in range(o_size):
- */
-  __pyx_t_4 = 0;
-  __pyx_cur_scope->__pyx_v_q_mask3 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks3.data) + __pyx_t_4)) )));
-
-  /* "chython/algorithms/_isomorphism.pyx":66
- *     q_mask2 = q_masks2[0]
- *     q_mask3 = q_masks3[0]
- *     q_mask4 = q_masks4[0]             # <<<<<<<<<<<<<<
- *     for n in range(o_size):
- *         if (scope[n] and
- */
-  __pyx_t_4 = 0;
-  __pyx_cur_scope->__pyx_v_q_mask4 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks4.data) + __pyx_t_4)) )));
-
-  /* "chython/algorithms/_isomorphism.pyx":67
- *     q_mask3 = q_masks3[0]
- *     q_mask4 = q_masks4[0]
- *     for n in range(o_size):             # <<<<<<<<<<<<<<
- *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- */
-  __pyx_t_5 = __pyx_cur_scope->__pyx_v_o_size;
-  __pyx_t_6 = __pyx_t_5;
-  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
-    __pyx_cur_scope->__pyx_v_n = __pyx_t_7;
-
-    /* "chython/algorithms/_isomorphism.pyx":68
- *     q_mask4 = q_masks4[0]
- *     for n in range(o_size):
- *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- */
-    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_8)) ))) != 0);
-    if (__pyx_t_3) {
-    } else {
-      __pyx_t_2 = __pyx_t_3;
-      goto __pyx_L13_bool_binop_done;
-    }
-
-    /* "chython/algorithms/_isomorphism.pyx":69
- *     for n in range(o_size):
- *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.             # <<<<<<<<<<<<<<
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- *             q_mask3 & o_bits3[n] == o_bits3[n] and
- */
-    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask1 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits1.data) + __pyx_t_8)) )))) != 0);
-    if (__pyx_t_3) {
-    } else {
-      __pyx_t_2 = __pyx_t_3;
-      goto __pyx_L13_bool_binop_done;
-    }
-
-    /* "chython/algorithms/_isomorphism.pyx":70
- *         if (scope[n] and
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- *             q_mask2 & o_bits2[n] == o_bits2[n] and             # <<<<<<<<<<<<<<
- *             q_mask3 & o_bits3[n] == o_bits3[n] and
- *             q_mask4 & o_bits4[n]):
- */
-    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_9 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_8)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_9)) ))));
-    if (__pyx_t_3) {
-    } else {
-      __pyx_t_2 = __pyx_t_3;
-      goto __pyx_L13_bool_binop_done;
-    }
-
-    /* "chython/algorithms/_isomorphism.pyx":71
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- *             q_mask3 & o_bits3[n] == o_bits3[n] and             # <<<<<<<<<<<<<<
- *             q_mask4 & o_bits4[n]):
- * 
- */
-    __pyx_t_9 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask3 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_9)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_8)) ))));
-    if (__pyx_t_3) {
-    } else {
-      __pyx_t_2 = __pyx_t_3;
-      goto __pyx_L13_bool_binop_done;
-    }
-
-    /* "chython/algorithms/_isomorphism.pyx":72
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- *             q_mask3 & o_bits3[n] == o_bits3[n] and
- *             q_mask4 & o_bits4[n]):             # <<<<<<<<<<<<<<
- * 
- *             stack_index[stack] = n
- */
-    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask4 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits4.data) + __pyx_t_8)) )))) != 0);
-    __pyx_t_2 = __pyx_t_3;
-    __pyx_L13_bool_binop_done:;
-
-    /* "chython/algorithms/_isomorphism.pyx":68
- *     q_mask4 = q_masks4[0]
- *     for n in range(o_size):
- *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- */
-    if (__pyx_t_2) {
-
-      /* "chython/algorithms/_isomorphism.pyx":74
- *             q_mask4 & o_bits4[n]):
- * 
- *             stack_index[stack] = n             # <<<<<<<<<<<<<<
- *             stack_depth[stack] = 0
- *             stack += 1
- */
-      (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_n;
-
-      /* "chython/algorithms/_isomorphism.pyx":75
- * 
- *             stack_index[stack] = n
- *             stack_depth[stack] = 0             # <<<<<<<<<<<<<<
- *             stack += 1
- * 
- */
-      (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = 0;
-
-      /* "chython/algorithms/_isomorphism.pyx":76
- *             stack_index[stack] = n
- *             stack_depth[stack] = 0
- *             stack += 1             # <<<<<<<<<<<<<<
- * 
- *     try:
- */
-      __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
-
-      /* "chython/algorithms/_isomorphism.pyx":68
- *     q_mask4 = q_masks4[0]
- *     for n in range(o_size):
- *         if (scope[n] and             # <<<<<<<<<<<<<<
- *             q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
- *             q_mask2 & o_bits2[n] == o_bits2[n] and
- */
-    }
-  }
-
-  /* "chython/algorithms/_isomorphism.pyx":78
- *             stack += 1
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         while stack:
- *             stack -= 1
- */
-  /*try:*/ {
-
-    /* "chython/algorithms/_isomorphism.pyx":79
- * 
- *     try:
- *         while stack:             # <<<<<<<<<<<<<<
- *             stack -= 1
- *             depth = stack_depth[stack]
- */
-    while (1) {
-      __pyx_t_2 = (__pyx_cur_scope->__pyx_v_stack != 0);
-      if (!__pyx_t_2) break;
-
-      /* "chython/algorithms/_isomorphism.pyx":80
- *     try:
- *         while stack:
- *             stack -= 1             # <<<<<<<<<<<<<<
- *             depth = stack_depth[stack]
- *             n = stack_index[stack]
- */
-      __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack - 1);
-
-      /* "chython/algorithms/_isomorphism.pyx":81
- *         while stack:
- *             stack -= 1
- *             depth = stack_depth[stack]             # <<<<<<<<<<<<<<
- *             n = stack_index[stack]
- * 
- */
-      __pyx_cur_scope->__pyx_v_depth = (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]);
-
-      /* "chython/algorithms/_isomorphism.pyx":82
- *             stack -= 1
- *             depth = stack_depth[stack]
- *             n = stack_index[stack]             # <<<<<<<<<<<<<<
- * 
- *             if depth == q_size_dec:
- */
-      __pyx_cur_scope->__pyx_v_n = (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]);
-
-      /* "chython/algorithms/_isomorphism.pyx":84
- *             n = stack_index[stack]
- * 
- *             if depth == q_size_dec:             # <<<<<<<<<<<<<<
- *                 mapping = _PyDict_NewPresized(q_size)
- *                 for i in range(depth):
- */
-      __pyx_t_2 = (__pyx_cur_scope->__pyx_v_depth == __pyx_cur_scope->__pyx_v_q_size_dec);
-      if (__pyx_t_2) {
-
-        /* "chython/algorithms/_isomorphism.pyx":85
- * 
- *             if depth == q_size_dec:
- *                 mapping = _PyDict_NewPresized(q_size)             # <<<<<<<<<<<<<<
- *                 for i in range(depth):
- *                     mapping[q_numbers[i]] = o_numbers[path[i]]
- */
-        __pyx_t_10 = _PyDict_NewPresized(__pyx_cur_scope->__pyx_v_q_size); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 85, __pyx_L19_error)
-        __Pyx_GOTREF(__pyx_t_10);
-        __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_mapping);
-        __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_mapping, ((PyObject*)__pyx_t_10));
-        __Pyx_GIVEREF(__pyx_t_10);
-        __pyx_t_10 = 0;
-
-        /* "chython/algorithms/_isomorphism.pyx":86
- *             if depth == q_size_dec:
- *                 mapping = _PyDict_NewPresized(q_size)
- *                 for i in range(depth):             # <<<<<<<<<<<<<<
- *                     mapping[q_numbers[i]] = o_numbers[path[i]]
- *                 mapping[q_numbers[depth]] = o_numbers[n]
- */
-        __pyx_t_5 = __pyx_cur_scope->__pyx_v_depth;
-        __pyx_t_6 = __pyx_t_5;
-        for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
-          __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
-
-          /* "chython/algorithms/_isomorphism.pyx":87
- *                 mapping = _PyDict_NewPresized(q_size)
- *                 for i in range(depth):
- *                     mapping[q_numbers[i]] = o_numbers[path[i]]             # <<<<<<<<<<<<<<
- *                 mapping[q_numbers[depth]] = o_numbers[n]
- *                 yield mapping
- */
-          __pyx_t_8 = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i]);
-          __pyx_t_10 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_8)) )))); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 87, __pyx_L19_error)
-          __Pyx_GOTREF(__pyx_t_10);
-          if (unlikely(__pyx_cur_scope->__pyx_v_mapping == Py_None)) {
-            PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-            __PYX_ERR(0, 87, __pyx_L19_error)
-          }
-          __pyx_t_8 = __pyx_cur_scope->__pyx_v_i;
-          __pyx_t_11 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_q_numbers.data) + __pyx_t_8)) )))); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 87, __pyx_L19_error)
-          __Pyx_GOTREF(__pyx_t_11);
-          if (unlikely((PyDict_SetItem(__pyx_cur_scope->__pyx_v_mapping, __pyx_t_11, __pyx_t_10) < 0))) __PYX_ERR(0, 87, __pyx_L19_error)
-          __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        }
-
-        /* "chython/algorithms/_isomorphism.pyx":88
- *                 for i in range(depth):
- *                     mapping[q_numbers[i]] = o_numbers[path[i]]
- *                 mapping[q_numbers[depth]] = o_numbers[n]             # <<<<<<<<<<<<<<
- *                 yield mapping
- *             else:
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-        __pyx_t_10 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_8)) )))); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 88, __pyx_L19_error)
-        __Pyx_GOTREF(__pyx_t_10);
-        if (unlikely(__pyx_cur_scope->__pyx_v_mapping == Py_None)) {
-          PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-          __PYX_ERR(0, 88, __pyx_L19_error)
-        }
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_depth;
-        __pyx_t_11 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_q_numbers.data) + __pyx_t_8)) )))); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 88, __pyx_L19_error)
-        __Pyx_GOTREF(__pyx_t_11);
-        if (unlikely((PyDict_SetItem(__pyx_cur_scope->__pyx_v_mapping, __pyx_t_11, __pyx_t_10) < 0))) __PYX_ERR(0, 88, __pyx_L19_error)
-        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-
-        /* "chython/algorithms/_isomorphism.pyx":89
- *                     mapping[q_numbers[i]] = o_numbers[path[i]]
- *                 mapping[q_numbers[depth]] = o_numbers[n]
- *                 yield mapping             # <<<<<<<<<<<<<<
- *             else:
- *                 if path_size != depth:  # dead end reached
- */
-        __Pyx_INCREF(__pyx_cur_scope->__pyx_v_mapping);
-        __pyx_r = __pyx_cur_scope->__pyx_v_mapping;
-        __Pyx_XGIVEREF(__pyx_r);
-        __Pyx_RefNannyFinishContext();
-        __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
-        /* return from generator, yielding value */
-        __pyx_generator->resume_label = 1;
-        return __pyx_r;
-        __pyx_L26_resume_from_yield:;
-        if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 89, __pyx_L19_error)
-
-        /* "chython/algorithms/_isomorphism.pyx":84
- *             n = stack_index[stack]
- * 
- *             if depth == q_size_dec:             # <<<<<<<<<<<<<<
- *                 mapping = _PyDict_NewPresized(q_size)
- *                 for i in range(depth):
- */
-        goto __pyx_L23;
-      }
-
-      /* "chython/algorithms/_isomorphism.pyx":91
- *                 yield mapping
- *             else:
- *                 if path_size != depth:  # dead end reached             # <<<<<<<<<<<<<<
- *                     for i in range(depth, path_size):
- *                         matched[path[i]] = False  # mark unmatched
- */
-      /*else*/ {
-        __pyx_t_2 = (__pyx_cur_scope->__pyx_v_path_size != __pyx_cur_scope->__pyx_v_depth);
-        if (__pyx_t_2) {
-
-          /* "chython/algorithms/_isomorphism.pyx":92
- *             else:
- *                 if path_size != depth:  # dead end reached
- *                     for i in range(depth, path_size):             # <<<<<<<<<<<<<<
- *                         matched[path[i]] = False  # mark unmatched
- *                     path_size = depth
- */
-          __pyx_t_5 = __pyx_cur_scope->__pyx_v_path_size;
-          __pyx_t_6 = __pyx_t_5;
-          for (__pyx_t_7 = __pyx_cur_scope->__pyx_v_depth; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
-            __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
-
-            /* "chython/algorithms/_isomorphism.pyx":93
- *                 if path_size != depth:  # dead end reached
- *                     for i in range(depth, path_size):
- *                         matched[path[i]] = False  # mark unmatched             # <<<<<<<<<<<<<<
- *                     path_size = depth
- * 
- */
-            (__pyx_cur_scope->__pyx_v_matched[(__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i])]) = 0;
-          }
-
-          /* "chython/algorithms/_isomorphism.pyx":94
- *                     for i in range(depth, path_size):
- *                         matched[path[i]] = False  # mark unmatched
- *                     path_size = depth             # <<<<<<<<<<<<<<
- * 
- *                 matched[n] = True
- */
-          __pyx_cur_scope->__pyx_v_path_size = __pyx_cur_scope->__pyx_v_depth;
-
-          /* "chython/algorithms/_isomorphism.pyx":91
- *                 yield mapping
- *             else:
- *                 if path_size != depth:  # dead end reached             # <<<<<<<<<<<<<<
- *                     for i in range(depth, path_size):
- *                         matched[path[i]] = False  # mark unmatched
- */
-        }
-
-        /* "chython/algorithms/_isomorphism.pyx":96
- *                     path_size = depth
- * 
- *                 matched[n] = True             # <<<<<<<<<<<<<<
- *                 path[path_size] = n
- *                 path_size += 1
- */
-        (__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_n]) = 1;
-
-        /* "chython/algorithms/_isomorphism.pyx":97
- * 
- *                 matched[n] = True
- *                 path[path_size] = n             # <<<<<<<<<<<<<<
- *                 path_size += 1
- * 
- */
-        (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_path_size]) = __pyx_cur_scope->__pyx_v_n;
-
-        /* "chython/algorithms/_isomorphism.pyx":98
- *                 matched[n] = True
- *                 path[path_size] = n
- *                 path_size += 1             # <<<<<<<<<<<<<<
- * 
- *                 front = depth + 1
- */
-        __pyx_cur_scope->__pyx_v_path_size = (__pyx_cur_scope->__pyx_v_path_size + 1);
-
-        /* "chython/algorithms/_isomorphism.pyx":100
- *                 path_size += 1
- * 
- *                 front = depth + 1             # <<<<<<<<<<<<<<
- *                 back = q_back[front]
- *                 if back != depth:  # branch
- */
-        __pyx_cur_scope->__pyx_v_front = (__pyx_cur_scope->__pyx_v_depth + 1);
-
-        /* "chython/algorithms/_isomorphism.pyx":101
- * 
- *                 front = depth + 1
- *                 back = q_back[front]             # <<<<<<<<<<<<<<
- *                 if back != depth:  # branch
- *                     n = path[back]
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_back = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_back.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":102
- *                 front = depth + 1
- *                 back = q_back[front]
- *                 if back != depth:  # branch             # <<<<<<<<<<<<<<
- *                     n = path[back]
- * 
- */
-        __pyx_t_2 = (__pyx_cur_scope->__pyx_v_back != __pyx_cur_scope->__pyx_v_depth);
-        if (__pyx_t_2) {
-
-          /* "chython/algorithms/_isomorphism.pyx":103
- *                 back = q_back[front]
- *                 if back != depth:  # branch
- *                     n = path[back]             # <<<<<<<<<<<<<<
- * 
- *                 # load next query atom
- */
-          __pyx_cur_scope->__pyx_v_n = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_back]);
-
-          /* "chython/algorithms/_isomorphism.pyx":102
- *                 front = depth + 1
- *                 back = q_back[front]
- *                 if back != depth:  # branch             # <<<<<<<<<<<<<<
- *                     n = path[back]
- * 
- */
-        }
-
-        /* "chython/algorithms/_isomorphism.pyx":106
- * 
- *                 # load next query atom
- *                 q_mask1 = q_masks1[front]             # <<<<<<<<<<<<<<
- *                 q_mask2 = q_masks2[front]
- *                 q_mask3 = q_masks3[front]
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_q_mask1 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks1.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":107
- *                 # load next query atom
- *                 q_mask1 = q_masks1[front]
- *                 q_mask2 = q_masks2[front]             # <<<<<<<<<<<<<<
- *                 q_mask3 = q_masks3[front]
- *                 q_mask4 = q_masks4[front]
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_q_mask2 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks2.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":108
- *                 q_mask1 = q_masks1[front]
- *                 q_mask2 = q_masks2[front]
- *                 q_mask3 = q_masks3[front]             # <<<<<<<<<<<<<<
- *                 q_mask4 = q_masks4[front]
- *                 closures_num = q_closures[front]
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_q_mask3 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks3.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":109
- *                 q_mask2 = q_masks2[front]
- *                 q_mask3 = q_masks3[front]
- *                 q_mask4 = q_masks4[front]             # <<<<<<<<<<<<<<
- *                 closures_num = q_closures[front]
- * 
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_q_mask4 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks4.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":110
- *                 q_mask3 = q_masks3[front]
- *                 q_mask4 = q_masks4[front]
- *                 closures_num = q_closures[front]             # <<<<<<<<<<<<<<
- * 
- *                 for i in range(o_from[n], o_to[n]):
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
-        __pyx_cur_scope->__pyx_v_closures_num = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_closures.data) + __pyx_t_8)) )));
-
-        /* "chython/algorithms/_isomorphism.pyx":112
- *                 closures_num = q_closures[front]
- * 
- *                 for i in range(o_from[n], o_to[n]):             # <<<<<<<<<<<<<<
- *                     o_bond = o_bonds[i]
- *                     m = o_indices[i]
- */
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-        __pyx_t_5 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
-        __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
-        __pyx_t_6 = __pyx_t_5;
-        for (__pyx_t_7 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
-          __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
-
-          /* "chython/algorithms/_isomorphism.pyx":113
- * 
- *                 for i in range(o_from[n], o_to[n]):
- *                     o_bond = o_bonds[i]             # <<<<<<<<<<<<<<
- *                     m = o_indices[i]
- *                     if (scope[m] and not matched[m] and
- */
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_i;
-          __pyx_cur_scope->__pyx_v_o_bond = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bonds.data) + __pyx_t_9)) )));
-
-          /* "chython/algorithms/_isomorphism.pyx":114
- *                 for i in range(o_from[n], o_to[n]):
- *                     o_bond = o_bonds[i]
- *                     m = o_indices[i]             # <<<<<<<<<<<<<<
- *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- */
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_i;
-          __pyx_cur_scope->__pyx_v_m = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_9)) )));
-
-          /* "chython/algorithms/_isomorphism.pyx":115
- *                     o_bond = o_bonds[i]
- *                     m = o_indices[i]
- *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- */
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_9)) ))) != 0);
-          if (__pyx_t_3) {
-          } else {
-            __pyx_t_2 = __pyx_t_3;
-            goto __pyx_L34_bool_binop_done;
-          }
-          __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_m]));
-          if (__pyx_t_3) {
-          } else {
-            __pyx_t_2 = __pyx_t_3;
-            goto __pyx_L34_bool_binop_done;
-          }
-
-          /* "chython/algorithms/_isomorphism.pyx":116
- *                     m = o_indices[i]
- *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.             # <<<<<<<<<<<<<<
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- *                         q_mask3 & o_bits3[m] == o_bits3[m] and
- */
-          __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask1 & __pyx_cur_scope->__pyx_v_o_bond) == __pyx_cur_scope->__pyx_v_o_bond);
-          if (__pyx_t_3) {
-          } else {
-            __pyx_t_2 = __pyx_t_3;
-            goto __pyx_L34_bool_binop_done;
-          }
-
-          /* "chython/algorithms/_isomorphism.pyx":117
- *                     if (scope[m] and not matched[m] and
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and             # <<<<<<<<<<<<<<
- *                         q_mask3 & o_bits3[m] == o_bits3[m] and
- *                         q_mask4 & o_bits4[m]):
- */
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_12 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_9)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_12)) ))));
-          if (__pyx_t_3) {
-          } else {
-            __pyx_t_2 = __pyx_t_3;
-            goto __pyx_L34_bool_binop_done;
-          }
-
-          /* "chython/algorithms/_isomorphism.pyx":118
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- *                         q_mask3 & o_bits3[m] == o_bits3[m] and             # <<<<<<<<<<<<<<
- *                         q_mask4 & o_bits4[m]):
- * 
- */
-          __pyx_t_12 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask3 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_12)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_9)) ))));
-          if (__pyx_t_3) {
-          } else {
-            __pyx_t_2 = __pyx_t_3;
-            goto __pyx_L34_bool_binop_done;
-          }
-
-          /* "chython/algorithms/_isomorphism.pyx":119
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- *                         q_mask3 & o_bits3[m] == o_bits3[m] and
- *                         q_mask4 & o_bits4[m]):             # <<<<<<<<<<<<<<
- * 
- *                         if closures_num:  # candidate atom should have same closures.
- */
-          __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-          __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask4 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits4.data) + __pyx_t_9)) )))) != 0);
-          __pyx_t_2 = __pyx_t_3;
-          __pyx_L34_bool_binop_done:;
-
-          /* "chython/algorithms/_isomorphism.pyx":115
- *                     o_bond = o_bonds[i]
- *                     m = o_indices[i]
- *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- */
-          if (__pyx_t_2) {
-
-            /* "chython/algorithms/_isomorphism.pyx":121
- *                         q_mask4 & o_bits4[m]):
- * 
- *                         if closures_num:  # candidate atom should have same closures.             # <<<<<<<<<<<<<<
- *                             closures_counter = 0
- *                             # make a map of closures for o_n atom
- */
-            __pyx_t_2 = (__pyx_cur_scope->__pyx_v_closures_num != 0);
-            if (__pyx_t_2) {
-
-              /* "chython/algorithms/_isomorphism.pyx":122
- * 
- *                         if closures_num:  # candidate atom should have same closures.
- *                             closures_counter = 0             # <<<<<<<<<<<<<<
- *                             # make a map of closures for o_n atom
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
- */
-              __pyx_cur_scope->__pyx_v_closures_counter = 0;
-
-              /* "chython/algorithms/_isomorphism.pyx":125
- *                             # make a map of closures for o_n atom
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
- *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
- *                                 o = o_indices[j]
- *                                 if o != n and matched[o]:
- */
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_13 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_9)) )));
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_14 = __pyx_t_13;
-              for (__pyx_t_15 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_9)) ))); __pyx_t_15 < __pyx_t_14; __pyx_t_15+=1) {
-                __pyx_cur_scope->__pyx_v_j = __pyx_t_15;
-
-                /* "chython/algorithms/_isomorphism.pyx":126
- *                             # an index is a neighbor atom and a value is a bond between o_n and the neighbor
- *                             for j in range(o_from[m], o_to[m]):
- *                                 o = o_indices[j]             # <<<<<<<<<<<<<<
- *                                 if o != n and matched[o]:
- *                                     o_closures[o] = o_bonds[j]
- */
-                __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_12)) )));
-
-                /* "chython/algorithms/_isomorphism.pyx":127
- *                             for j in range(o_from[m], o_to[m]):
- *                                 o = o_indices[j]
- *                                 if o != n and matched[o]:             # <<<<<<<<<<<<<<
- *                                     o_closures[o] = o_bonds[j]
- *                                     closures_counter += 1
- */
-                __pyx_t_3 = (__pyx_cur_scope->__pyx_v_o != __pyx_cur_scope->__pyx_v_n);
-                if (__pyx_t_3) {
-                } else {
-                  __pyx_t_2 = __pyx_t_3;
-                  goto __pyx_L44_bool_binop_done;
-                }
-                __pyx_t_2 = (__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_o]);
-                __pyx_L44_bool_binop_done:;
-                if (__pyx_t_2) {
-
-                  /* "chython/algorithms/_isomorphism.pyx":128
- *                                 o = o_indices[j]
- *                                 if o != n and matched[o]:
- *                                     o_closures[o] = o_bonds[j]             # <<<<<<<<<<<<<<
- *                                     closures_counter += 1
- * 
- */
-                  __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                  (__pyx_cur_scope->__pyx_v_o_closures[__pyx_cur_scope->__pyx_v_o]) = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bonds.data) + __pyx_t_12)) )));
-
-                  /* "chython/algorithms/_isomorphism.pyx":129
- *                                 if o != n and matched[o]:
- *                                     o_closures[o] = o_bonds[j]
- *                                     closures_counter += 1             # <<<<<<<<<<<<<<
- * 
- *                             if closures_counter == closures_num:
- */
-                  __pyx_cur_scope->__pyx_v_closures_counter = (__pyx_cur_scope->__pyx_v_closures_counter + 1);
-
-                  /* "chython/algorithms/_isomorphism.pyx":127
- *                             for j in range(o_from[m], o_to[m]):
- *                                 o = o_indices[j]
- *                                 if o != n and matched[o]:             # <<<<<<<<<<<<<<
- *                                     o_closures[o] = o_bonds[j]
- *                                     closures_counter += 1
- */
-                }
-              }
-
-              /* "chython/algorithms/_isomorphism.pyx":131
- *                                     closures_counter += 1
- * 
- *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- */
-              __pyx_t_2 = (__pyx_cur_scope->__pyx_v_closures_counter == __pyx_cur_scope->__pyx_v_closures_num);
-              if (__pyx_t_2) {
-
-                /* "chython/algorithms/_isomorphism.pyx":132
- * 
- *                             if closures_counter == closures_num:
- *                                 for j in range(q_from[front], q_to[front]):             # <<<<<<<<<<<<<<
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
- */
-                __pyx_t_9 = __pyx_cur_scope->__pyx_v_front;
-                __pyx_t_13 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_to.data) + __pyx_t_9)) )));
-                __pyx_t_9 = __pyx_cur_scope->__pyx_v_front;
-                __pyx_t_14 = __pyx_t_13;
-                for (__pyx_t_15 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_from.data) + __pyx_t_9)) ))); __pyx_t_15 < __pyx_t_14; __pyx_t_15+=1) {
-                  __pyx_cur_scope->__pyx_v_j = __pyx_t_15;
-
-                  /* "chython/algorithms/_isomorphism.pyx":133
- *                             if closures_counter == closures_num:
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]             # <<<<<<<<<<<<<<
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
- *                                         break
- */
-                  __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                  __pyx_cur_scope->__pyx_v_c_bond = (__pyx_cur_scope->__pyx_v_o_closures[(__pyx_cur_scope->__pyx_v_path[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_indices.data) + __pyx_t_12)) )))])]);
-
-                  /* "chython/algorithms/_isomorphism.pyx":134
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits             # <<<<<<<<<<<<<<
- *                                         break
- *                                 else:
- */
-                  __pyx_t_3 = (!(__pyx_cur_scope->__pyx_v_c_bond != 0));
-                  if (!__pyx_t_3) {
-                  } else {
-                    __pyx_t_2 = __pyx_t_3;
-                    goto __pyx_L50_bool_binop_done;
-                  }
-                  __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                  __pyx_t_3 = (((*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_bonds.data) + __pyx_t_12)) ))) & __pyx_cur_scope->__pyx_v_c_bond) != __pyx_cur_scope->__pyx_v_c_bond);
-                  __pyx_t_2 = __pyx_t_3;
-                  __pyx_L50_bool_binop_done:;
-                  if (__pyx_t_2) {
-
-                    /* "chython/algorithms/_isomorphism.pyx":135
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
- *                                         break             # <<<<<<<<<<<<<<
- *                                 else:
- *                                     stack_index[stack] = m
- */
-                    goto __pyx_L48_break;
-
-                    /* "chython/algorithms/_isomorphism.pyx":134
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- *                                     if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits             # <<<<<<<<<<<<<<
- *                                         break
- *                                 else:
- */
-                  }
-                }
-                /*else*/ {
-
-                  /* "chython/algorithms/_isomorphism.pyx":137
- *                                         break
- *                                 else:
- *                                     stack_index[stack] = m             # <<<<<<<<<<<<<<
- *                                     stack_depth[stack] = front
- *                                     stack += 1
- */
-                  (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
-
-                  /* "chython/algorithms/_isomorphism.pyx":138
- *                                 else:
- *                                     stack_index[stack] = m
- *                                     stack_depth[stack] = front             # <<<<<<<<<<<<<<
- *                                     stack += 1
- * 
- */
-                  (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
-
-                  /* "chython/algorithms/_isomorphism.pyx":139
- *                                     stack_index[stack] = m
- *                                     stack_depth[stack] = front
- *                                     stack += 1             # <<<<<<<<<<<<<<
- * 
- *                             # fill an array with nulls
- */
-                  __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
-                }
-                __pyx_L48_break:;
-
-                /* "chython/algorithms/_isomorphism.pyx":131
- *                                     closures_counter += 1
- * 
- *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
- *                                 for j in range(q_from[front], q_to[front]):
- *                                     c_bond = o_closures[path[q_indices[j]]]
- */
-              }
-
-              /* "chython/algorithms/_isomorphism.pyx":142
- * 
- *                             # fill an array with nulls
- *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
- *                                 o_closures[o_indices[j]] = 0
- *                         else:  # candidate atom should not have closures.
- */
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_13 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_9)) )));
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_14 = __pyx_t_13;
-              for (__pyx_t_15 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_9)) ))); __pyx_t_15 < __pyx_t_14; __pyx_t_15+=1) {
-                __pyx_cur_scope->__pyx_v_j = __pyx_t_15;
-
-                /* "chython/algorithms/_isomorphism.pyx":143
- *                             # fill an array with nulls
- *                             for j in range(o_from[m], o_to[m]):
- *                                 o_closures[o_indices[j]] = 0             # <<<<<<<<<<<<<<
- *                         else:  # candidate atom should not have closures.
- *                             for j in range(o_from[m], o_to[m]):
- */
-                __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                (__pyx_cur_scope->__pyx_v_o_closures[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_12)) )))]) = 0;
-              }
-
-              /* "chython/algorithms/_isomorphism.pyx":121
- *                         q_mask4 & o_bits4[m]):
- * 
- *                         if closures_num:  # candidate atom should have same closures.             # <<<<<<<<<<<<<<
- *                             closures_counter = 0
- *                             # make a map of closures for o_n atom
- */
-              goto __pyx_L40;
-            }
-
-            /* "chython/algorithms/_isomorphism.pyx":145
- *                                 o_closures[o_indices[j]] = 0
- *                         else:  # candidate atom should not have closures.
- *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
- *                                o = o_indices[j]
- *                                if o != n and matched[o]:
- */
-            /*else*/ {
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_13 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_9)) )));
-              __pyx_t_9 = __pyx_cur_scope->__pyx_v_m;
-              __pyx_t_14 = __pyx_t_13;
-              for (__pyx_t_15 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_9)) ))); __pyx_t_15 < __pyx_t_14; __pyx_t_15+=1) {
-                __pyx_cur_scope->__pyx_v_j = __pyx_t_15;
-
-                /* "chython/algorithms/_isomorphism.pyx":146
- *                         else:  # candidate atom should not have closures.
- *                             for j in range(o_from[m], o_to[m]):
- *                                o = o_indices[j]             # <<<<<<<<<<<<<<
- *                                if o != n and matched[o]:
- *                                    break  # found closure
- */
-                __pyx_t_12 = __pyx_cur_scope->__pyx_v_j;
-                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_12)) )));
-
-                /* "chython/algorithms/_isomorphism.pyx":147
- *                             for j in range(o_from[m], o_to[m]):
- *                                o = o_indices[j]
- *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
- *                                    break  # found closure
- *                             else:
- */
-                __pyx_t_3 = (__pyx_cur_scope->__pyx_v_o != __pyx_cur_scope->__pyx_v_n);
-                if (__pyx_t_3) {
-                } else {
-                  __pyx_t_2 = __pyx_t_3;
-                  goto __pyx_L57_bool_binop_done;
-                }
-                __pyx_t_2 = (__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_o]);
-                __pyx_L57_bool_binop_done:;
-                if (__pyx_t_2) {
-
-                  /* "chython/algorithms/_isomorphism.pyx":148
- *                                o = o_indices[j]
- *                                if o != n and matched[o]:
- *                                    break  # found closure             # <<<<<<<<<<<<<<
- *                             else:
- *                                 stack_index[stack] = m
- */
-                  goto __pyx_L55_break;
-
-                  /* "chython/algorithms/_isomorphism.pyx":147
- *                             for j in range(o_from[m], o_to[m]):
- *                                o = o_indices[j]
- *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
- *                                    break  # found closure
- *                             else:
- */
-                }
-              }
-              /*else*/ {
-
-                /* "chython/algorithms/_isomorphism.pyx":150
- *                                    break  # found closure
- *                             else:
- *                                 stack_index[stack] = m             # <<<<<<<<<<<<<<
- *                                 stack_depth[stack] = front
- *                                 stack += 1
- */
-                (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
-
-                /* "chython/algorithms/_isomorphism.pyx":151
- *                             else:
- *                                 stack_index[stack] = m
- *                                 stack_depth[stack] = front             # <<<<<<<<<<<<<<
- *                                 stack += 1
- *     finally:
- */
-                (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
-
-                /* "chython/algorithms/_isomorphism.pyx":152
- *                                 stack_index[stack] = m
- *                                 stack_depth[stack] = front
- *                                 stack += 1             # <<<<<<<<<<<<<<
- *     finally:
- *         PyMem_Free(path)
- */
-                __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
-              }
-              __pyx_L55_break:;
-            }
-            __pyx_L40:;
-
-            /* "chython/algorithms/_isomorphism.pyx":115
- *                     o_bond = o_bonds[i]
- *                     m = o_indices[i]
- *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
- *                         q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
- *                         q_mask2 & o_bits2[m] == o_bits2[m] and
- */
-          }
-        }
-      }
-      __pyx_L23:;
-    }
-  }
-
-  /* "chython/algorithms/_isomorphism.pyx":154
- *                                 stack += 1
- *     finally:
- *         PyMem_Free(path)             # <<<<<<<<<<<<<<
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)
- */
-  /*finally:*/ {
-    /*normal exit:*/{
-      PyMem_Free(__pyx_cur_scope->__pyx_v_path);
-
-      /* "chython/algorithms/_isomorphism.pyx":155
- *     finally:
- *         PyMem_Free(path)
- *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)
- */
-      PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
-
-      /* "chython/algorithms/_isomorphism.pyx":156
- *         PyMem_Free(path)
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
- *         PyMem_Free(stack_depth)
- *         PyMem_Free(o_closures)
- */
-      PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
-
-      /* "chython/algorithms/_isomorphism.pyx":157
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
- *         PyMem_Free(o_closures)
- */
-      PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
-
-      /* "chython/algorithms/_isomorphism.pyx":158
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)
- *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
- */
-      PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
-      goto __pyx_L20;
-    }
-    __pyx_L19_error:;
-    /*exception exit:*/{
-      __Pyx_PyThreadState_assign
-      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
-      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_22, &__pyx_t_23, &__pyx_t_24);
-      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21) < 0)) __Pyx_ErrFetch(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
-      __Pyx_XGOTREF(__pyx_t_19);
-      __Pyx_XGOTREF(__pyx_t_20);
-      __Pyx_XGOTREF(__pyx_t_21);
-      __Pyx_XGOTREF(__pyx_t_22);
-      __Pyx_XGOTREF(__pyx_t_23);
-      __Pyx_XGOTREF(__pyx_t_24);
-      __pyx_t_16 = __pyx_lineno; __pyx_t_17 = __pyx_clineno; __pyx_t_18 = __pyx_filename;
-      {
-
-        /* "chython/algorithms/_isomorphism.pyx":154
- *                                 stack += 1
- *     finally:
- *         PyMem_Free(path)             # <<<<<<<<<<<<<<
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)
- */
-        PyMem_Free(__pyx_cur_scope->__pyx_v_path);
-
-        /* "chython/algorithms/_isomorphism.pyx":155
- *     finally:
- *         PyMem_Free(path)
- *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)
- */
-        PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
-
-        /* "chython/algorithms/_isomorphism.pyx":156
- *         PyMem_Free(path)
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
- *         PyMem_Free(stack_depth)
- *         PyMem_Free(o_closures)
- */
-        PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
-
-        /* "chython/algorithms/_isomorphism.pyx":157
- *         PyMem_Free(matched)
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
- *         PyMem_Free(o_closures)
- */
-        PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
-
-        /* "chython/algorithms/_isomorphism.pyx":158
- *         PyMem_Free(stack_index)
- *         PyMem_Free(stack_depth)
- *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
- */
-        PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
-      }
-      if (PY_MAJOR_VERSION >= 3) {
-        __Pyx_XGIVEREF(__pyx_t_22);
-        __Pyx_XGIVEREF(__pyx_t_23);
-        __Pyx_XGIVEREF(__pyx_t_24);
-        __Pyx_ExceptionReset(__pyx_t_22, __pyx_t_23, __pyx_t_24);
-      }
-      __Pyx_XGIVEREF(__pyx_t_19);
-      __Pyx_XGIVEREF(__pyx_t_20);
-      __Pyx_XGIVEREF(__pyx_t_21);
-      __Pyx_ErrRestore(__pyx_t_19, __pyx_t_20, __pyx_t_21);
-      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
-      __pyx_lineno = __pyx_t_16; __pyx_clineno = __pyx_t_17; __pyx_filename = __pyx_t_18;
-      goto __pyx_L1_error;
-    }
-    __pyx_L20:;
-  }
-  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
-
-  /* "chython/algorithms/_isomorphism.pyx":28
- * 
- * 
- * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
- * @cython.wraparound(False)
- * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
- */
-
-  /* function exit code */
-  PyErr_SetNone(PyExc_StopIteration);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_Generator_Replace_StopIteration(0);
-  __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_AddTraceback("get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
-  #if !CYTHON_USE_EXC_INFO_STACK
-  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
-  #endif
-  __pyx_generator->resume_label = -1;
-  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[8];
-static int __pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = 0;
-
-static PyObject *__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p;
-  PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (CYTHON_COMPILING_IN_CPYTHON && likely((int)(__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping > 0) & (int)(t->tp_basicsize == sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping)))) {
-    o = (PyObject*)__pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[--__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping];
-    memset(o, 0, sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping));
-    (void) PyObject_INIT(o, t);
-    PyObject_GC_Track(o);
-  } else {
-    o = (*t->tp_alloc)(t, 0);
-    if (unlikely(!o)) return 0;
-  }
-  #endif
-  p = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o);
-  p->__pyx_v_o_bits1.data = NULL;
-  p->__pyx_v_o_bits1.memview = NULL;
-  p->__pyx_v_o_bits2.data = NULL;
-  p->__pyx_v_o_bits2.memview = NULL;
-  p->__pyx_v_o_bits3.data = NULL;
-  p->__pyx_v_o_bits3.memview = NULL;
-  p->__pyx_v_o_bits4.data = NULL;
-  p->__pyx_v_o_bits4.memview = NULL;
-  p->__pyx_v_o_bonds.data = NULL;
-  p->__pyx_v_o_bonds.memview = NULL;
-  p->__pyx_v_o_from.data = NULL;
-  p->__pyx_v_o_from.memview = NULL;
-  p->__pyx_v_o_indices.data = NULL;
-  p->__pyx_v_o_indices.memview = NULL;
-  p->__pyx_v_o_numbers.data = NULL;
-  p->__pyx_v_o_numbers.memview = NULL;
-  p->__pyx_v_o_to.data = NULL;
-  p->__pyx_v_o_to.memview = NULL;
-  p->__pyx_v_q_back.data = NULL;
-  p->__pyx_v_q_back.memview = NULL;
-  p->__pyx_v_q_bonds.data = NULL;
-  p->__pyx_v_q_bonds.memview = NULL;
-  p->__pyx_v_q_closures.data = NULL;
-  p->__pyx_v_q_closures.memview = NULL;
-  p->__pyx_v_q_from.data = NULL;
-  p->__pyx_v_q_from.memview = NULL;
-  p->__pyx_v_q_indices.data = NULL;
-  p->__pyx_v_q_indices.memview = NULL;
-  p->__pyx_v_q_masks1.data = NULL;
-  p->__pyx_v_q_masks1.memview = NULL;
-  p->__pyx_v_q_masks2.data = NULL;
-  p->__pyx_v_q_masks2.memview = NULL;
-  p->__pyx_v_q_masks3.data = NULL;
-  p->__pyx_v_q_masks3.memview = NULL;
-  p->__pyx_v_q_masks4.data = NULL;
-  p->__pyx_v_q_masks4.memview = NULL;
-  p->__pyx_v_q_numbers.data = NULL;
-  p->__pyx_v_q_numbers.memview = NULL;
-  p->__pyx_v_q_to.data = NULL;
-  p->__pyx_v_q_to.memview = NULL;
-  p->__pyx_v_scope.data = NULL;
-  p->__pyx_v_scope.memview = NULL;
-  return o;
-}
-
-static void __pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyObject *o) {
-  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o;
-  #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
-  }
-  #endif
-  PyObject_GC_UnTrack(o);
-  Py_CLEAR(p->__pyx_v_mapping);
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_bits1, 1);
-  p->__pyx_v_o_bits1.memview = NULL; p->__pyx_v_o_bits1.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_bits2, 1);
-  p->__pyx_v_o_bits2.memview = NULL; p->__pyx_v_o_bits2.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_bits3, 1);
-  p->__pyx_v_o_bits3.memview = NULL; p->__pyx_v_o_bits3.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_bits4, 1);
-  p->__pyx_v_o_bits4.memview = NULL; p->__pyx_v_o_bits4.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_bonds, 1);
-  p->__pyx_v_o_bonds.memview = NULL; p->__pyx_v_o_bonds.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_from, 1);
-  p->__pyx_v_o_from.memview = NULL; p->__pyx_v_o_from.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_indices, 1);
-  p->__pyx_v_o_indices.memview = NULL; p->__pyx_v_o_indices.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_numbers, 1);
-  p->__pyx_v_o_numbers.memview = NULL; p->__pyx_v_o_numbers.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_o_to, 1);
-  p->__pyx_v_o_to.memview = NULL; p->__pyx_v_o_to.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_back, 1);
-  p->__pyx_v_q_back.memview = NULL; p->__pyx_v_q_back.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_bonds, 1);
-  p->__pyx_v_q_bonds.memview = NULL; p->__pyx_v_q_bonds.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_closures, 1);
-  p->__pyx_v_q_closures.memview = NULL; p->__pyx_v_q_closures.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_from, 1);
-  p->__pyx_v_q_from.memview = NULL; p->__pyx_v_q_from.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_indices, 1);
-  p->__pyx_v_q_indices.memview = NULL; p->__pyx_v_q_indices.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_masks1, 1);
-  p->__pyx_v_q_masks1.memview = NULL; p->__pyx_v_q_masks1.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_masks2, 1);
-  p->__pyx_v_q_masks2.memview = NULL; p->__pyx_v_q_masks2.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_masks3, 1);
-  p->__pyx_v_q_masks3.memview = NULL; p->__pyx_v_q_masks3.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_masks4, 1);
-  p->__pyx_v_q_masks4.memview = NULL; p->__pyx_v_q_masks4.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_numbers, 1);
-  p->__pyx_v_q_numbers.memview = NULL; p->__pyx_v_q_numbers.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_q_to, 1);
-  p->__pyx_v_q_to.memview = NULL; p->__pyx_v_q_to.data = NULL;
-  __PYX_XCLEAR_MEMVIEW(&p->__pyx_v_scope, 1);
-  p->__pyx_v_scope.memview = NULL; p->__pyx_v_scope.data = NULL;
-  if (CYTHON_COMPILING_IN_CPYTHON && ((int)(__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping < 8) & (int)(Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping)))) {
-    __pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping++] = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o);
-  } else {
-    (*Py_TYPE(o)->tp_free)(o);
-  }
-}
-
-static int __pyx_tp_traverse_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyObject *o, visitproc v, void *a) {
-  int e;
-  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o;
-  if (p->__pyx_v_mapping) {
-    e = (*v)(p->__pyx_v_mapping, a); if (e) return e;
-  }
-  return 0;
-}
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping},
-  {Py_tp_traverse, (void *)__pyx_tp_traverse_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping},
-  {Py_tp_new, (void *)__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping},
-  {0, 0},
-};
-static PyType_Spec __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping_spec = {
-  "chython.algorithms._isomorphism.__pyx_scope_struct__get_mapping",
-  sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_FINALIZE,
-  __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping_slots,
-};
-#else
-
-static PyTypeObject __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "chython.algorithms._isomorphism.""__pyx_scope_struct__get_mapping", /*tp_name*/
-  sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  0, /*tp_repr*/
-  0, /*tp_as_number*/
-  0, /*tp_as_sequence*/
-  0, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_FINALIZE, /*tp_flags*/
-  0, /*tp_doc*/
-  __pyx_tp_traverse_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_traverse*/
-  0, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  0, /*tp_methods*/
-  0, /*tp_members*/
-  0, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
-  0, /*tp_dictoffset*/
-  #endif
-  0, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
-  0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-#endif
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_array_obj *)o);
   p->__pyx_vtab = __pyx_vtabptr_array;
   p->mode = ((PyObject*)Py_None); Py_INCREF(Py_None);
   p->_format = ((PyObject*)Py_None); Py_INCREF(Py_None);
   if (unlikely(__pyx_array___cinit__(o, a, k) < 0)) goto bad;
   return o;
   bad:
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_array(PyObject *o) {
   struct __pyx_array_obj *p = (struct __pyx_array_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_array) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
     __pyx_array___dealloc__(o);
@@ -19360,19 +16825,16 @@
 }
 
 static int __pyx_mp_ass_subscript_array(PyObject *o, PyObject *i, PyObject *v) {
   if (v) {
     return __pyx_array___setitem__(o, i, v);
   }
   else {
-    __Pyx_TypeName o_type_name;
-    o_type_name = __Pyx_PyType_GetName(Py_TYPE(o));
     PyErr_Format(PyExc_NotImplementedError,
-      "Subscript deletion not supported by " __Pyx_FMT_TYPENAME, o_type_name);
-    __Pyx_DECREF_TypeName(o_type_name);
+      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
     return -1;
   }
 }
 
 static PyObject *__pyx_tp_getattro_array(PyObject *o, PyObject *n) {
   PyObject *v = __Pyx_PyObject_GenericGetAttr(o, n);
   if (!v && PyErr_ExceptionMatches(PyExc_AttributeError)) {
@@ -19384,67 +16846,23 @@
 
 static PyObject *__pyx_getprop___pyx_array_memview(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(o);
 }
 
 static PyMethodDef __pyx_methods_array[] = {
   {"__getattr__", (PyCFunction)__pyx_array___getattr__, METH_O|METH_COEXIST, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_array_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_array_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_array_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_array_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_array[] = {
   {(char *)"memview", __pyx_getprop___pyx_array_memview, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-#if !CYTHON_COMPILING_IN_LIMITED_API
-
-static PyBufferProcs __pyx_tp_as_buffer_array = {
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getreadbuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getwritebuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getsegcount*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getcharbuffer*/
-  #endif
-  __pyx_array_getbuffer, /*bf_getbuffer*/
-  0, /*bf_releasebuffer*/
-};
-#endif
-static PyType_Slot __pyx_type___pyx_array_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_array},
-  {Py_sq_length, (void *)__pyx_array___len__},
-  {Py_sq_item, (void *)__pyx_sq_item_array},
-  {Py_mp_length, (void *)__pyx_array___len__},
-  {Py_mp_subscript, (void *)__pyx_array___getitem__},
-  {Py_mp_ass_subscript, (void *)__pyx_mp_ass_subscript_array},
-  {Py_tp_getattro, (void *)__pyx_tp_getattro_array},
-  #if defined(Py_bf_getbuffer)
-  {Py_bf_getbuffer, (void *)__pyx_array_getbuffer},
-  #endif
-  {Py_tp_methods, (void *)__pyx_methods_array},
-  {Py_tp_getset, (void *)__pyx_getsets_array},
-  {Py_tp_new, (void *)__pyx_tp_new_array},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_array_spec = {
-  "chython.algorithms._isomorphism.array",
-  sizeof(struct __pyx_array_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_SEQUENCE,
-  __pyx_type___pyx_array_slots,
-};
-#else
 
 static PySequenceMethods __pyx_tp_as_sequence_array = {
   __pyx_array___len__, /*sq_length*/
   0, /*sq_concat*/
   0, /*sq_repeat*/
   __pyx_sq_item_array, /*sq_item*/
   0, /*sq_slice*/
@@ -19476,15 +16894,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.algorithms._isomorphism.""array", /*tp_name*/
+  "chython.containers._unpack.array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -19504,92 +16922,72 @@
   &__pyx_tp_as_mapping_array, /*tp_as_mapping*/
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   __pyx_tp_getattro_array, /*tp_getattro*/
   0, /*tp_setattro*/
   &__pyx_tp_as_buffer_array, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_SEQUENCE, /*tp_flags*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
   0, /*tp_doc*/
   0, /*tp_traverse*/
   0, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_array, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_array, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_array, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_MemviewEnum_obj *)o);
   p->name = Py_None; Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_Enum(PyObject *o) {
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_Enum) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->name);
   (*Py_TYPE(o)->tp_free)(o);
 }
 
@@ -19607,47 +17005,23 @@
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   tmp = ((PyObject*)p->name);
   p->name = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   return 0;
 }
 
-static PyObject *__pyx_specialmethod___pyx_MemviewEnum___repr__(PyObject *self, CYTHON_UNUSED PyObject *arg) {
-  return __pyx_MemviewEnum___repr__(self);
-}
-
 static PyMethodDef __pyx_methods_Enum[] = {
-  {"__repr__", (PyCFunction)__pyx_specialmethod___pyx_MemviewEnum___repr__, METH_NOARGS|METH_COEXIST, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type___pyx_MemviewEnum_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_Enum},
-  {Py_tp_repr, (void *)__pyx_MemviewEnum___repr__},
-  {Py_tp_traverse, (void *)__pyx_tp_traverse_Enum},
-  {Py_tp_clear, (void *)__pyx_tp_clear_Enum},
-  {Py_tp_methods, (void *)__pyx_methods_Enum},
-  {Py_tp_init, (void *)__pyx_MemviewEnum___init__},
-  {Py_tp_new, (void *)__pyx_tp_new_Enum},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_MemviewEnum_spec = {
-  "chython.algorithms._isomorphism.Enum",
-  sizeof(struct __pyx_MemviewEnum_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
-  __pyx_type___pyx_MemviewEnum_slots,
-};
-#else
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.algorithms._isomorphism.""Enum", /*tp_name*/
+  "chython.containers._unpack.Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -19682,66 +17056,48 @@
   __pyx_methods_Enum, /*tp_methods*/
   0, /*tp_members*/
   0, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   __pyx_MemviewEnum___init__, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_Enum, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_memoryview_obj *)o);
   p->__pyx_vtab = __pyx_vtabptr_memoryview;
   p->obj = Py_None; Py_INCREF(Py_None);
   p->_size = Py_None; Py_INCREF(Py_None);
   p->_array_interface = Py_None; Py_INCREF(Py_None);
   p->view.obj = NULL;
   if (unlikely(__pyx_memoryview___cinit__(o, a, k) < 0)) goto bad;
@@ -19750,18 +17106,16 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_memoryview(PyObject *o) {
   struct __pyx_memoryview_obj *p = (struct __pyx_memoryview_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_memoryview) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -19817,19 +17171,16 @@
 }
 
 static int __pyx_mp_ass_subscript_memoryview(PyObject *o, PyObject *i, PyObject *v) {
   if (v) {
     return __pyx_memoryview___setitem__(o, i, v);
   }
   else {
-    __Pyx_TypeName o_type_name;
-    o_type_name = __Pyx_PyType_GetName(Py_TYPE(o));
     PyErr_Format(PyExc_NotImplementedError,
-      "Subscript deletion not supported by " __Pyx_FMT_TYPENAME, o_type_name);
-    __Pyx_DECREF_TypeName(o_type_name);
+      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
     return -1;
   }
 }
 
 static PyObject *__pyx_getprop___pyx_memoryview_T(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(o);
 }
@@ -19862,26 +17213,21 @@
   return __pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(o);
 }
 
 static PyObject *__pyx_getprop___pyx_memoryview_size(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(o);
 }
 
-static PyObject *__pyx_specialmethod___pyx_memoryview___repr__(PyObject *self, CYTHON_UNUSED PyObject *arg) {
-  return __pyx_memoryview___repr__(self);
-}
-
 static PyMethodDef __pyx_methods_memoryview[] = {
-  {"__repr__", (PyCFunction)__pyx_specialmethod___pyx_memoryview___repr__, METH_NOARGS|METH_COEXIST, 0},
-  {"is_c_contig", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_is_c_contig, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"is_f_contig", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_is_f_contig, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"copy", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_copy, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"copy_fortran", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_copy_fortran, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryview_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryview_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"is_c_contig", (PyCFunction)__pyx_memoryview_is_c_contig, METH_NOARGS, 0},
+  {"is_f_contig", (PyCFunction)__pyx_memoryview_is_f_contig, METH_NOARGS, 0},
+  {"copy", (PyCFunction)__pyx_memoryview_copy, METH_NOARGS, 0},
+  {"copy_fortran", (PyCFunction)__pyx_memoryview_copy_fortran, METH_NOARGS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_memoryview[] = {
   {(char *)"T", __pyx_getprop___pyx_memoryview_T, 0, (char *)0, 0},
   {(char *)"base", __pyx_getprop___pyx_memoryview_base, 0, (char *)0, 0},
   {(char *)"shape", __pyx_getprop___pyx_memoryview_shape, 0, (char *)0, 0},
@@ -19889,61 +17235,14 @@
   {(char *)"suboffsets", __pyx_getprop___pyx_memoryview_suboffsets, 0, (char *)0, 0},
   {(char *)"ndim", __pyx_getprop___pyx_memoryview_ndim, 0, (char *)0, 0},
   {(char *)"itemsize", __pyx_getprop___pyx_memoryview_itemsize, 0, (char *)0, 0},
   {(char *)"nbytes", __pyx_getprop___pyx_memoryview_nbytes, 0, (char *)0, 0},
   {(char *)"size", __pyx_getprop___pyx_memoryview_size, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-#if !CYTHON_COMPILING_IN_LIMITED_API
-
-static PyBufferProcs __pyx_tp_as_buffer_memoryview = {
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getreadbuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getwritebuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getsegcount*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getcharbuffer*/
-  #endif
-  __pyx_memoryview_getbuffer, /*bf_getbuffer*/
-  0, /*bf_releasebuffer*/
-};
-#endif
-static PyType_Slot __pyx_type___pyx_memoryview_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_memoryview},
-  {Py_tp_repr, (void *)__pyx_memoryview___repr__},
-  {Py_sq_length, (void *)__pyx_memoryview___len__},
-  {Py_sq_item, (void *)__pyx_sq_item_memoryview},
-  {Py_mp_length, (void *)__pyx_memoryview___len__},
-  {Py_mp_subscript, (void *)__pyx_memoryview___getitem__},
-  {Py_mp_ass_subscript, (void *)__pyx_mp_ass_subscript_memoryview},
-  {Py_tp_str, (void *)__pyx_memoryview___str__},
-  #if defined(Py_bf_getbuffer)
-  {Py_bf_getbuffer, (void *)__pyx_memoryview_getbuffer},
-  #endif
-  {Py_tp_traverse, (void *)__pyx_tp_traverse_memoryview},
-  {Py_tp_clear, (void *)__pyx_tp_clear_memoryview},
-  {Py_tp_methods, (void *)__pyx_methods_memoryview},
-  {Py_tp_getset, (void *)__pyx_getsets_memoryview},
-  {Py_tp_new, (void *)__pyx_tp_new_memoryview},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_memoryview_spec = {
-  "chython.algorithms._isomorphism.memoryview",
-  sizeof(struct __pyx_memoryview_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
-  __pyx_type___pyx_memoryview_slots,
-};
-#else
 
 static PySequenceMethods __pyx_tp_as_sequence_memoryview = {
   __pyx_memoryview___len__, /*sq_length*/
   0, /*sq_concat*/
   0, /*sq_repeat*/
   __pyx_sq_item_memoryview, /*sq_item*/
   0, /*sq_slice*/
@@ -19975,15 +17274,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.algorithms._isomorphism.""memoryview", /*tp_name*/
+  "chython.containers._unpack.memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20018,50 +17317,37 @@
   __pyx_methods_memoryview, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_memoryview, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_memoryview, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
   PyObject *o = __pyx_tp_new_memoryview(t, a, k);
   if (unlikely(!o)) return 0;
   p = ((struct __pyx_memoryviewslice_obj *)o);
@@ -20070,18 +17356,16 @@
   p->from_slice.memview = NULL;
   return o;
 }
 
 static void __pyx_tp_dealloc__memoryviewslice(PyObject *o) {
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc__memoryviewslice) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -20107,45 +17391,36 @@
 static int __pyx_tp_clear__memoryviewslice(PyObject *o) {
   PyObject* tmp;
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   __pyx_tp_clear_memoryview(o);
   tmp = ((PyObject*)p->from_object);
   p->from_object = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
-  __PYX_XCLEAR_MEMVIEW(&p->from_slice, 1);
+  __PYX_XDEC_MEMVIEW(&p->from_slice, 1);
   return 0;
 }
 
+static PyObject *__pyx_getprop___pyx_memoryviewslice_base(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods__memoryviewslice[] = {
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryviewslice_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryviewslice_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type___pyx_memoryviewslice_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc__memoryviewslice},
-  {Py_tp_doc, (void *)PyDoc_STR("Internal class for passing memoryview slices to Python")},
-  {Py_tp_traverse, (void *)__pyx_tp_traverse__memoryviewslice},
-  {Py_tp_clear, (void *)__pyx_tp_clear__memoryviewslice},
-  {Py_tp_methods, (void *)__pyx_methods__memoryviewslice},
-  {Py_tp_new, (void *)__pyx_tp_new__memoryviewslice},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_memoryviewslice_spec = {
-  "chython.algorithms._isomorphism._memoryviewslice",
-  sizeof(struct __pyx_memoryviewslice_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_SEQUENCE,
-  __pyx_type___pyx_memoryviewslice_slots,
+
+static struct PyGetSetDef __pyx_getsets__memoryviewslice[] = {
+  {(char *)"base", __pyx_getprop___pyx_memoryviewslice_base, 0, (char *)0, 0},
+  {0, 0, 0, 0, 0}
 };
-#else
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.algorithms._isomorphism.""_memoryviewslice", /*tp_name*/
+  "chython.containers._unpack._memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20155,494 +17430,575 @@
   0, /*tp_setattr*/
   #if PY_MAJOR_VERSION < 3
   0, /*tp_compare*/
   #endif
   #if PY_MAJOR_VERSION >= 3
   0, /*tp_as_async*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY || 0
+  #if CYTHON_COMPILING_IN_PYPY
   __pyx_memoryview___repr__, /*tp_repr*/
   #else
   0, /*tp_repr*/
   #endif
   0, /*tp_as_number*/
   0, /*tp_as_sequence*/
   0, /*tp_as_mapping*/
   0, /*tp_hash*/
   0, /*tp_call*/
-  #if CYTHON_COMPILING_IN_PYPY || 0
+  #if CYTHON_COMPILING_IN_PYPY
   __pyx_memoryview___str__, /*tp_str*/
   #else
   0, /*tp_str*/
   #endif
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_SEQUENCE, /*tp_flags*/
-  PyDoc_STR("Internal class for passing memoryview slices to Python"), /*tp_doc*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  "Internal class for passing memoryview slices to Python", /*tp_doc*/
   __pyx_tp_traverse__memoryviewslice, /*tp_traverse*/
   __pyx_tp_clear__memoryviewslice, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods__memoryviewslice, /*tp_methods*/
   0, /*tp_members*/
-  0, /*tp_getset*/
+  __pyx_getsets__memoryviewslice, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new__memoryviewslice, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
+
+#if PY_MAJOR_VERSION >= 3
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
+static int __pyx_pymod_exec__unpack(PyObject* module); /*proto*/
+static PyModuleDef_Slot __pyx_moduledef_slots[] = {
+  {Py_mod_create, (void*)__pyx_pymod_create},
+  {Py_mod_exec, (void*)__pyx_pymod_exec__unpack},
+  {0, NULL}
+};
+#endif
+
+static struct PyModuleDef __pyx_moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "_unpack",
+    0, /* m_doc */
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    0, /* m_size */
+  #else
+    -1, /* m_size */
+  #endif
+    __pyx_methods /* m_methods */,
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    __pyx_moduledef_slots, /* m_slots */
+  #else
+    NULL, /* m_reload */
+  #endif
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
 #ifndef CYTHON_SMALL_CODE
 #if defined(__clang__)
     #define CYTHON_SMALL_CODE
 #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
-/* #### Code section: pystring_table ### */
 
-static int __Pyx_CreateStringTabAndInitStrings(void) {
-  __Pyx_StringTabEntry __pyx_string_tab[] = {
-    {&__pyx_kp_u_, __pyx_k_, sizeof(__pyx_k_), 0, 1, 0, 0},
-    {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
-    {&__pyx_kp_s_All_dimensions_preceding_dimensi, __pyx_k_All_dimensions_preceding_dimensi, sizeof(__pyx_k_All_dimensions_preceding_dimensi), 0, 0, 1, 0},
-    {&__pyx_n_s_AssertionError, __pyx_k_AssertionError, sizeof(__pyx_k_AssertionError), 0, 0, 1, 1},
-    {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
-    {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
-    {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
-    {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
-    {&__pyx_kp_u_Cannot_index_with_type, __pyx_k_Cannot_index_with_type, sizeof(__pyx_k_Cannot_index_with_type), 0, 1, 0, 0},
-    {&__pyx_kp_s_Cannot_transpose_memoryview_with, __pyx_k_Cannot_transpose_memoryview_with, sizeof(__pyx_k_Cannot_transpose_memoryview_with), 0, 0, 1, 0},
-    {&__pyx_kp_s_Dimension_d_is_not_direct, __pyx_k_Dimension_d_is_not_direct, sizeof(__pyx_k_Dimension_d_is_not_direct), 0, 0, 1, 0},
-    {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
-    {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
-    {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
-    {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
-    {&__pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_k_Index_out_of_bounds_axis_d, sizeof(__pyx_k_Index_out_of_bounds_axis_d), 0, 0, 1, 0},
-    {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
-    {&__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 1, 0, 0},
-    {&__pyx_kp_u_Invalid_shape_in_axis, __pyx_k_Invalid_shape_in_axis, sizeof(__pyx_k_Invalid_shape_in_axis), 0, 1, 0, 0},
-    {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
-    {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
-    {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
-    {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
-    {&__pyx_kp_u_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 1, 0, 0},
-    {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
-    {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
-    {&__pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_k_Step_may_not_be_zero_axis_d, sizeof(__pyx_k_Step_may_not_be_zero_axis_d), 0, 0, 1, 0},
-    {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
-    {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
-    {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-    {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
-    {&__pyx_kp_u__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 1, 0, 0},
-    {&__pyx_n_s__22, __pyx_k__22, sizeof(__pyx_k__22), 0, 0, 1, 1},
-    {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
-    {&__pyx_kp_u__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 1, 0, 0},
-    {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
-    {&__pyx_n_s_abc, __pyx_k_abc, sizeof(__pyx_k_abc), 0, 0, 1, 1},
-    {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
-    {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
-    {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
-    {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
-    {&__pyx_n_s_back, __pyx_k_back, sizeof(__pyx_k_back), 0, 0, 1, 1},
-    {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
-    {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
-    {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
-    {&__pyx_n_s_c_bond, __pyx_k_c_bond, sizeof(__pyx_k_c_bond), 0, 0, 1, 1},
-    {&__pyx_n_s_chython_algorithms__isomorphism, __pyx_k_chython_algorithms__isomorphism, sizeof(__pyx_k_chython_algorithms__isomorphism), 0, 0, 1, 1},
-    {&__pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_k_chython_algorithms__isomorphism_2, sizeof(__pyx_k_chython_algorithms__isomorphism_2), 0, 0, 1, 0},
-    {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
-    {&__pyx_n_s_class_getitem, __pyx_k_class_getitem, sizeof(__pyx_k_class_getitem), 0, 0, 1, 1},
-    {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-    {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
-    {&__pyx_n_s_closures_counter, __pyx_k_closures_counter, sizeof(__pyx_k_closures_counter), 0, 0, 1, 1},
-    {&__pyx_n_s_closures_num, __pyx_k_closures_num, sizeof(__pyx_k_closures_num), 0, 0, 1, 1},
-    {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
-    {&__pyx_kp_s_collections_abc, __pyx_k_collections_abc, sizeof(__pyx_k_collections_abc), 0, 0, 1, 0},
-    {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
-    {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
-    {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
-    {&__pyx_n_s_depth, __pyx_k_depth, sizeof(__pyx_k_depth), 0, 0, 1, 1},
-    {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
-    {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
-    {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
-    {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
-    {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
-    {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
-    {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
-    {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
-    {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
-    {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
-    {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
-    {&__pyx_n_s_front, __pyx_k_front, sizeof(__pyx_k_front), 0, 0, 1, 1},
-    {&__pyx_kp_u_gc, __pyx_k_gc, sizeof(__pyx_k_gc), 0, 1, 0, 0},
-    {&__pyx_n_s_get_mapping, __pyx_k_get_mapping, sizeof(__pyx_k_get_mapping), 0, 0, 1, 1},
-    {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-    {&__pyx_kp_u_got, __pyx_k_got, sizeof(__pyx_k_got), 0, 1, 0, 0},
-    {&__pyx_kp_u_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 1, 0, 0},
-    {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
-    {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
-    {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-    {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
-    {&__pyx_n_s_initializing, __pyx_k_initializing, sizeof(__pyx_k_initializing), 0, 0, 1, 1},
-    {&__pyx_n_s_is_coroutine, __pyx_k_is_coroutine, sizeof(__pyx_k_is_coroutine), 0, 0, 1, 1},
-    {&__pyx_kp_u_isenabled, __pyx_k_isenabled, sizeof(__pyx_k_isenabled), 0, 1, 0, 0},
-    {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
-    {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
-    {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
-    {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
-    {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-    {&__pyx_n_s_mapping, __pyx_k_mapping, sizeof(__pyx_k_mapping), 0, 0, 1, 1},
-    {&__pyx_n_s_matched, __pyx_k_matched, sizeof(__pyx_k_matched), 0, 0, 1, 1},
-    {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
-    {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
-    {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
-    {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
-    {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
-    {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
-    {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
-    {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
-    {&__pyx_n_s_o, __pyx_k_o, sizeof(__pyx_k_o), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bits1, __pyx_k_o_bits1, sizeof(__pyx_k_o_bits1), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bits2, __pyx_k_o_bits2, sizeof(__pyx_k_o_bits2), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bits3, __pyx_k_o_bits3, sizeof(__pyx_k_o_bits3), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bits4, __pyx_k_o_bits4, sizeof(__pyx_k_o_bits4), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bond, __pyx_k_o_bond, sizeof(__pyx_k_o_bond), 0, 0, 1, 1},
-    {&__pyx_n_s_o_bonds, __pyx_k_o_bonds, sizeof(__pyx_k_o_bonds), 0, 0, 1, 1},
-    {&__pyx_n_s_o_closures, __pyx_k_o_closures, sizeof(__pyx_k_o_closures), 0, 0, 1, 1},
-    {&__pyx_n_s_o_from, __pyx_k_o_from, sizeof(__pyx_k_o_from), 0, 0, 1, 1},
-    {&__pyx_n_s_o_indices, __pyx_k_o_indices, sizeof(__pyx_k_o_indices), 0, 0, 1, 1},
-    {&__pyx_n_s_o_numbers, __pyx_k_o_numbers, sizeof(__pyx_k_o_numbers), 0, 0, 1, 1},
-    {&__pyx_n_s_o_size, __pyx_k_o_size, sizeof(__pyx_k_o_size), 0, 0, 1, 1},
-    {&__pyx_n_s_o_to, __pyx_k_o_to, sizeof(__pyx_k_o_to), 0, 0, 1, 1},
-    {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
-    {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
-    {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
-    {&__pyx_n_s_path_size, __pyx_k_path_size, sizeof(__pyx_k_path_size), 0, 0, 1, 1},
-    {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-    {&__pyx_n_s_q_back, __pyx_k_q_back, sizeof(__pyx_k_q_back), 0, 0, 1, 1},
-    {&__pyx_n_s_q_bonds, __pyx_k_q_bonds, sizeof(__pyx_k_q_bonds), 0, 0, 1, 1},
-    {&__pyx_n_s_q_closures, __pyx_k_q_closures, sizeof(__pyx_k_q_closures), 0, 0, 1, 1},
-    {&__pyx_n_s_q_from, __pyx_k_q_from, sizeof(__pyx_k_q_from), 0, 0, 1, 1},
-    {&__pyx_n_s_q_indices, __pyx_k_q_indices, sizeof(__pyx_k_q_indices), 0, 0, 1, 1},
-    {&__pyx_n_s_q_mask1, __pyx_k_q_mask1, sizeof(__pyx_k_q_mask1), 0, 0, 1, 1},
-    {&__pyx_n_s_q_mask2, __pyx_k_q_mask2, sizeof(__pyx_k_q_mask2), 0, 0, 1, 1},
-    {&__pyx_n_s_q_mask3, __pyx_k_q_mask3, sizeof(__pyx_k_q_mask3), 0, 0, 1, 1},
-    {&__pyx_n_s_q_mask4, __pyx_k_q_mask4, sizeof(__pyx_k_q_mask4), 0, 0, 1, 1},
-    {&__pyx_n_s_q_masks1, __pyx_k_q_masks1, sizeof(__pyx_k_q_masks1), 0, 0, 1, 1},
-    {&__pyx_n_s_q_masks2, __pyx_k_q_masks2, sizeof(__pyx_k_q_masks2), 0, 0, 1, 1},
-    {&__pyx_n_s_q_masks3, __pyx_k_q_masks3, sizeof(__pyx_k_q_masks3), 0, 0, 1, 1},
-    {&__pyx_n_s_q_masks4, __pyx_k_q_masks4, sizeof(__pyx_k_q_masks4), 0, 0, 1, 1},
-    {&__pyx_n_s_q_numbers, __pyx_k_q_numbers, sizeof(__pyx_k_q_numbers), 0, 0, 1, 1},
-    {&__pyx_n_s_q_size, __pyx_k_q_size, sizeof(__pyx_k_q_size), 0, 0, 1, 1},
-    {&__pyx_n_s_q_size_dec, __pyx_k_q_size_dec, sizeof(__pyx_k_q_size_dec), 0, 0, 1, 1},
-    {&__pyx_n_s_q_to, __pyx_k_q_to, sizeof(__pyx_k_q_to), 0, 0, 1, 1},
-    {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
-    {&__pyx_n_s_register, __pyx_k_register, sizeof(__pyx_k_register), 0, 0, 1, 1},
-    {&__pyx_n_s_scope, __pyx_k_scope, sizeof(__pyx_k_scope), 0, 0, 1, 1},
-    {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
-    {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
-    {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
-    {&__pyx_n_s_stack, __pyx_k_stack, sizeof(__pyx_k_stack), 0, 0, 1, 1},
-    {&__pyx_n_s_stack_depth, __pyx_k_stack_depth, sizeof(__pyx_k_stack_depth), 0, 0, 1, 1},
-    {&__pyx_n_s_stack_index, __pyx_k_stack_index, sizeof(__pyx_k_stack_index), 0, 0, 1, 1},
-    {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
-    {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
-    {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
-    {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
-    {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
-    {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
-    {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
-    {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
-    {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
-    {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-    {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
-    {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
-    {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
-    {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
-    {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
-    {&__pyx_n_s_version_info, __pyx_k_version_info, sizeof(__pyx_k_version_info), 0, 0, 1, 1},
-    {0, 0, 0, 0, 0, 0, 0}
-  };
-  return __Pyx_InitStrings(__pyx_string_tab);
-}
-/* #### Code section: cached_builtins ### */
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
+  {&__pyx_n_s_Bond, __pyx_k_Bond, sizeof(__pyx_k_Bond), 0, 0, 1, 1},
+  {&__pyx_n_s_Bond__order, __pyx_k_Bond__order, sizeof(__pyx_k_Bond__order), 0, 0, 1, 1},
+  {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
+  {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
+  {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
+  {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
+  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
+  {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
+  {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
+  {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
+  {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
+  {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
+  {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
+  {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
+  {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
+  {&__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 0, 1, 0},
+  {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
+  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
+  {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
+  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
+  {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
+  {&__pyx_n_s_all_sign, __pyx_k_all_sign, sizeof(__pyx_k_all_sign), 0, 0, 1, 1},
+  {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
+  {&__pyx_n_s_atom, __pyx_k_atom, sizeof(__pyx_k_atom), 0, 0, 1, 1},
+  {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
+  {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
+  {&__pyx_n_s_bond, __pyx_k_bond, sizeof(__pyx_k_bond), 0, 0, 1, 1},
+  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
+  {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
+  {&__pyx_n_s_charges, __pyx_k_charges, sizeof(__pyx_k_charges), 0, 0, 1, 1},
+  {&__pyx_n_s_chython_containers__unpack, __pyx_k_chython_containers__unpack, sizeof(__pyx_k_chython_containers__unpack), 0, 0, 1, 1},
+  {&__pyx_kp_s_chython_containers__unpack_pyx, __pyx_k_chython_containers__unpack_pyx, sizeof(__pyx_k_chython_containers__unpack_pyx), 0, 0, 1, 0},
+  {&__pyx_n_s_chython_containers_bonds, __pyx_k_chython_containers_bonds, sizeof(__pyx_k_chython_containers_bonds), 0, 0, 1, 1},
+  {&__pyx_n_s_cis_trans_1, __pyx_k_cis_trans_1, sizeof(__pyx_k_cis_trans_1), 0, 0, 1, 1},
+  {&__pyx_n_s_cis_trans_2, __pyx_k_cis_trans_2, sizeof(__pyx_k_cis_trans_2), 0, 0, 1, 1},
+  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
+  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+  {&__pyx_n_s_connections, __pyx_k_connections, sizeof(__pyx_k_connections), 0, 0, 1, 1},
+  {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
+  {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
+  {&__pyx_n_s_ct_sign, __pyx_k_ct_sign, sizeof(__pyx_k_ct_sign), 0, 0, 1, 1},
+  {&__pyx_n_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 1},
+  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
+  {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
+  {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
+  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
+  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
+  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
+  {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
+  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
+  {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
+  {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
+  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
+  {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
+  {&__pyx_n_s_hydrogens, __pyx_k_hydrogens, sizeof(__pyx_k_hydrogens), 0, 0, 1, 1},
+  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
+  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
+  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+  {&__pyx_n_s_is_all, __pyx_k_is_all, sizeof(__pyx_k_is_all), 0, 0, 1, 1},
+  {&__pyx_n_s_is_tet, __pyx_k_is_tet, sizeof(__pyx_k_is_tet), 0, 0, 1, 1},
+  {&__pyx_n_s_isotope_shift, __pyx_k_isotope_shift, sizeof(__pyx_k_isotope_shift), 0, 0, 1, 1},
+  {&__pyx_n_s_isotopes, __pyx_k_isotopes, sizeof(__pyx_k_isotopes), 0, 0, 1, 1},
+  {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
+  {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
+  {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
+  {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
+  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+  {&__pyx_n_s_mapping, __pyx_k_mapping, sizeof(__pyx_k_mapping), 0, 0, 1, 1},
+  {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
+  {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
+  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
+  {&__pyx_n_s_na, __pyx_k_na, sizeof(__pyx_k_na), 0, 0, 1, 1},
+  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
+  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
+  {&__pyx_n_s_nb, __pyx_k_nb, sizeof(__pyx_k_nb), 0, 0, 1, 1},
+  {&__pyx_n_s_nct, __pyx_k_nct, sizeof(__pyx_k_nct), 0, 0, 1, 1},
+  {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
+  {&__pyx_n_s_neighbors, __pyx_k_neighbors, sizeof(__pyx_k_neighbors), 0, 0, 1, 1},
+  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
+  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
+  {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
+  {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
+  {&__pyx_n_s_order_shift, __pyx_k_order_shift, sizeof(__pyx_k_order_shift), 0, 0, 1, 1},
+  {&__pyx_n_s_orders, __pyx_k_orders, sizeof(__pyx_k_orders), 0, 0, 1, 1},
+  {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
+  {&__pyx_n_s_pack_length, __pyx_k_pack_length, sizeof(__pyx_k_pack_length), 0, 0, 1, 1},
+  {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
+  {&__pyx_n_s_py_allenes_stereo, __pyx_k_py_allenes_stereo, sizeof(__pyx_k_py_allenes_stereo), 0, 0, 1, 1},
+  {&__pyx_n_s_py_atoms, __pyx_k_py_atoms, sizeof(__pyx_k_py_atoms), 0, 0, 1, 1},
+  {&__pyx_n_s_py_atoms_stereo, __pyx_k_py_atoms_stereo, sizeof(__pyx_k_py_atoms_stereo), 0, 0, 1, 1},
+  {&__pyx_n_s_py_bonds, __pyx_k_py_bonds, sizeof(__pyx_k_py_bonds), 0, 0, 1, 1},
+  {&__pyx_n_s_py_charges, __pyx_k_py_charges, sizeof(__pyx_k_py_charges), 0, 0, 1, 1},
+  {&__pyx_n_s_py_cis_trans_stereo, __pyx_k_py_cis_trans_stereo, sizeof(__pyx_k_py_cis_trans_stereo), 0, 0, 1, 1},
+  {&__pyx_n_s_py_hydrogens, __pyx_k_py_hydrogens, sizeof(__pyx_k_py_hydrogens), 0, 0, 1, 1},
+  {&__pyx_n_s_py_isotopes, __pyx_k_py_isotopes, sizeof(__pyx_k_py_isotopes), 0, 0, 1, 1},
+  {&__pyx_n_s_py_mapping, __pyx_k_py_mapping, sizeof(__pyx_k_py_mapping), 0, 0, 1, 1},
+  {&__pyx_n_s_py_plane, __pyx_k_py_plane, sizeof(__pyx_k_py_plane), 0, 0, 1, 1},
+  {&__pyx_n_s_py_radicals, __pyx_k_py_radicals, sizeof(__pyx_k_py_radicals), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
+  {&__pyx_n_s_radicals, __pyx_k_radicals, sizeof(__pyx_k_radicals), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
+  {&__pyx_n_s_seen, __pyx_k_seen, sizeof(__pyx_k_seen), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
+  {&__pyx_n_s_shift, __pyx_k_shift, sizeof(__pyx_k_shift), 0, 0, 1, 1},
+  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
+  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
+  {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
+  {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
+  {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
+  {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
+  {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
+  {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
+  {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
+  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_n_s_tet_sign, __pyx_k_tet_sign, sizeof(__pyx_k_tet_sign), 0, 0, 1, 1},
+  {&__pyx_n_s_tmp, __pyx_k_tmp, sizeof(__pyx_k_tmp), 0, 0, 1, 1},
+  {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
+  {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
+  {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
+  {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
+  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 57, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 67, __pyx_L1_error)
-  __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(1, 100, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 141, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 159, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 47, __pyx_L1_error)
+  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 152, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 133, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 148, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 151, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(1, 373, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 408, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 618, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 914, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 404, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 613, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 832, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: cached_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "View.MemoryView":582
- *     def suboffsets(self):
- *         if self.view.suboffsets == NULL:
- *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":133
  * 
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+ *         if not self.ndim:
+ *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
+ * 
+ *         if itemsize <= 0:
+ */
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
+
+  /* "View.MemoryView":136
+ * 
+ *         if itemsize <= 0:
+ *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
+ * 
+ *         if not isinstance(format, bytes):
+ */
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+
+  /* "View.MemoryView":148
+ * 
+ *         if not self._shape:
+ *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 148, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
+
+  /* "View.MemoryView":176
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
+ * 
+ *             if self.dtype_is_object:
  */
-  __pyx_tuple__4 = PyTuple_New(1); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 582, __pyx_L1_error)
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_INCREF(__pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__4, 0, __pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* "View.MemoryView":679
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)
- * 
- *     result = [slice(None)] * ndim             # <<<<<<<<<<<<<<
- *     have_slices = False
- *     seen_ellipsis = False
+  /* "View.MemoryView":192
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
+ *         info.buf = self.data
+ *         info.len = self.len
  */
-  __pyx_slice__5 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__5)) __PYX_ERR(1, 679, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__5);
-  __Pyx_GIVEREF(__pyx_slice__5);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "(tree fragment)":4
- *     cdef object __pyx_PickleError
- *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
- *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
+
+  /* "View.MemoryView":418
+ *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         have_slices, index = _unellipsify(index, self.view.ndim)
+ */
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 418, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
+  /* "View.MemoryView":495
+ *             result = struct.unpack(self.view.format, bytesitem)
+ *         except struct.error:
+ *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
+ *         else:
+ *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_n_s_sys); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 100, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 495, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
+
+  /* "View.MemoryView":520
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         if flags & PyBUF_ND:
+ */
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 520, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
-  __pyx_tuple__11 = PyTuple_Pack(2, __pyx_int_3, __pyx_int_3); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 100, __pyx_L1_error)
+
+  /* "View.MemoryView":570
+ *         if self.view.strides == NULL:
+ * 
+ *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
+ * 
+ *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
+ */
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 570, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "View.MemoryView":101
- * try:
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
+  /* "View.MemoryView":577
+ *     def suboffsets(self):
+ *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
+ * 
+ *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_collections_abc); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 101, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_New(1); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 577, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_INCREF(__pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_int_neg_1);
+  PyTuple_SET_ITEM(__pyx_tuple__12, 0, __pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_tuple__12);
 
-  /* "View.MemoryView":103
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
- * except:
- * 
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_n_s_collections); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 103, __pyx_L1_error)
+  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
-  /* "View.MemoryView":309
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+
+  /* "View.MemoryView":682
+ *         if item is Ellipsis:
+ *             if not seen_ellipsis:
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
+ *                 seen_ellipsis = True
+ *             else:
+ */
+  __pyx_slice__15 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__15)) __PYX_ERR(1, 682, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__15);
+  __Pyx_GIVEREF(__pyx_slice__15);
+
+  /* "View.MemoryView":703
+ *     for suboffset in suboffsets[:ndim]:
+ *         if suboffset >= 0:
+ *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 703, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+
+  /* "chython/containers/_unpack.pyx":25
+ * 
+ * @cython.boundscheck(False)
+ * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
+ */
+  __pyx_tuple__19 = PyTuple_Pack(49, __pyx_n_s_data, __pyx_n_s_data, __pyx_n_s_isotope_shift, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_c, __pyx_n_s_d, __pyx_n_s_na, __pyx_n_s_nct, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_pack_length, __pyx_n_s_shift, __pyx_n_s_order_shift, __pyx_n_s_nb, __pyx_n_s_mapping, __pyx_n_s_atom, __pyx_n_s_isotopes, __pyx_n_s_hydrogens, __pyx_n_s_neighbors, __pyx_n_s_orders, __pyx_n_s_cis_trans_1, __pyx_n_s_cis_trans_2, __pyx_n_s_connections, __pyx_n_s_charges, __pyx_n_s_radicals, __pyx_n_s_is_tet, __pyx_n_s_is_all, __pyx_n_s_tet_sign, __pyx_n_s_all_sign, __pyx_n_s_ct_sign, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_seen, __pyx_n_s_bond, __pyx_n_s_py_charges, __pyx_n_s_py_radicals, __pyx_n_s_py_hydrogens, __pyx_n_s_py_plane, __pyx_n_s_py_bonds, __pyx_n_s_tmp, __pyx_n_s_py_atoms_stereo, __pyx_n_s_py_allenes_stereo, __pyx_n_s_py_cis_trans_stereo, __pyx_n_s_py_mapping, __pyx_n_s_py_atoms, __pyx_n_s_py_isotopes); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(1, 0, 49, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_containers__unpack_pyx, __pyx_n_s_unpack, 25, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(0, 25, __pyx_L1_error)
+
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 309, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 310, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "View.MemoryView":311
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 311, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
-  /* "View.MemoryView":314
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 314, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
-  /* "View.MemoryView":315
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 315, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__19 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(1, 1, __pyx_L1_error)
-
-  /* "chython/algorithms/_isomorphism.pyx":28
- * 
- * 
- * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
- * @cython.wraparound(False)
- * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
- */
-  __pyx_tuple__21 = PyTuple_Pack(48, __pyx_n_s_q_numbers, __pyx_n_s_q_back, __pyx_n_s_q_masks1, __pyx_n_s_q_masks2, __pyx_n_s_q_masks3, __pyx_n_s_q_masks4, __pyx_n_s_q_closures, __pyx_n_s_q_from, __pyx_n_s_q_to, __pyx_n_s_q_indices, __pyx_n_s_q_bonds, __pyx_n_s_o_numbers, __pyx_n_s_o_bits1, __pyx_n_s_o_bits2, __pyx_n_s_o_bits3, __pyx_n_s_o_bits4, __pyx_n_s_o_bonds, __pyx_n_s_o_from, __pyx_n_s_o_to, __pyx_n_s_o_indices, __pyx_n_s_scope, __pyx_n_s_stack, __pyx_n_s_path_size, __pyx_n_s_q_size, __pyx_n_s_q_size_dec, __pyx_n_s_o_size, __pyx_n_s_depth, __pyx_n_s_front, __pyx_n_s_back, __pyx_n_s_closures_num, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_o, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_closures_counter, __pyx_n_s_q_mask1, __pyx_n_s_q_mask2, __pyx_n_s_q_mask3, __pyx_n_s_q_mask4, __pyx_n_s_o_bond, __pyx_n_s_c_bond, __pyx_n_s_mapping, __pyx_n_s_path, __pyx_n_s_stack_index, __pyx_n_s_stack_depth, __pyx_n_s_matched, __pyx_n_s_o_closures); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(21, 0, 0, 48, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_GENERATOR, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_n_s_get_mapping, 28, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
-/* #### Code section: init_constants ### */
 
-static CYTHON_SMALL_CODE int __Pyx_InitConstants(void) {
-  if (__Pyx_CreateStringTabAndInitStrings() < 0) __PYX_ERR(0, 1, __pyx_L1_error);
+static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: init_globals ### */
-
-static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  /* AssertionsEnabled.init */
-  __Pyx_init_assertions_enabled();
-
-if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
-
-  return 0;
-  __pyx_L1_error:;
-  return -1;
-}
-/* #### Code section: init_module ### */
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/
 
 static int __Pyx_modinit_global_init_code(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
   /*--- Global init code ---*/
-  __pyx_collections_abc_Sequence = Py_None; Py_INCREF(Py_None);
   generic = Py_None; Py_INCREF(Py_None);
   strided = Py_None; Py_INCREF(Py_None);
   indirect = Py_None; Py_INCREF(Py_None);
   contiguous = Py_None; Py_INCREF(Py_None);
   indirect_contiguous = Py_None; Py_INCREF(Py_None);
   __Pyx_RefNannyFinishContext();
   return 0;
@@ -20662,183 +18018,73 @@
   /*--- Function export code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping_spec, NULL); if (unlikely(!__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping)) __PYX_ERR(0, 28, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping_spec, __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
-  #else
-  __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = &__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping->tp_dictoffset && __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping->tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
-  }
-  #endif
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_array_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_array_spec, NULL); if (unlikely(!__pyx_array_type)) __PYX_ERR(1, 114, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_array_type->tp_as_buffer = &__pyx_tp_as_buffer_array;
-  if (!__pyx_array_type->tp_as_buffer->bf_releasebuffer && __pyx_array_type->tp_base->tp_as_buffer && __pyx_array_type->tp_base->tp_as_buffer->bf_releasebuffer) {
-    __pyx_array_type->tp_as_buffer->bf_releasebuffer = __pyx_array_type->tp_base->tp_as_buffer->bf_releasebuffer;
-  }
-  #elif defined(Py_bf_getbuffer) && defined(Py_bf_releasebuffer)
-  /* PY_VERSION_HEX >= 0x03090000 || Py_LIMITED_API >= 0x030B0000 */
-  #elif defined(_MSC_VER)
-  #pragma message ("The buffer protocol is not supported in the Limited C-API < 3.11.")
-  #else
-  #warning "The buffer protocol is not supported in the Limited C-API < 3.11."
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_array.tp_print = 0;
   #endif
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_array_spec, __pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #else
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   __pyx_array_type = &__pyx_type___pyx_array;
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_MemviewEnum.tp_print = 0;
   #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_array_type->tp_print = 0;
-  #endif
-  if (__Pyx_SetVtable(__pyx_array_type, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_MemviewEnum_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_MemviewEnum_spec, NULL); if (unlikely(!__pyx_MemviewEnum_type)) __PYX_ERR(1, 302, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_MemviewEnum_spec, __pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #else
-  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_MemviewEnum_type->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_MemviewEnum_type->tp_dictoffset && __pyx_MemviewEnum_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_MemviewEnum_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #endif
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
   __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
   __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
   __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
   __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
   __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
   __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
   __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
   __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  __pyx_vtable_memoryview._get_base = (PyObject *(*)(struct __pyx_memoryview_obj *))__pyx_memoryview__get_base;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_memoryview_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_memoryview_spec, NULL); if (unlikely(!__pyx_memoryview_type)) __PYX_ERR(1, 337, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_memoryview_type->tp_as_buffer = &__pyx_tp_as_buffer_memoryview;
-  if (!__pyx_memoryview_type->tp_as_buffer->bf_releasebuffer && __pyx_memoryview_type->tp_base->tp_as_buffer && __pyx_memoryview_type->tp_base->tp_as_buffer->bf_releasebuffer) {
-    __pyx_memoryview_type->tp_as_buffer->bf_releasebuffer = __pyx_memoryview_type->tp_base->tp_as_buffer->bf_releasebuffer;
-  }
-  #elif defined(Py_bf_getbuffer) && defined(Py_bf_releasebuffer)
-  /* PY_VERSION_HEX >= 0x03090000 || Py_LIMITED_API >= 0x030B0000 */
-  #elif defined(_MSC_VER)
-  #pragma message ("The buffer protocol is not supported in the Limited C-API < 3.11.")
-  #else
-  #warning "The buffer protocol is not supported in the Limited C-API < 3.11."
-  #endif
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_memoryview_spec, __pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #else
-  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_memoryview.tp_print = 0;
   #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_memoryview_type->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_memoryview_type->tp_dictoffset && __pyx_memoryview_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_memoryview_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  if (__Pyx_SetVtable(__pyx_memoryview_type, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #endif
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
   __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
   __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
   __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
   __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
-  __pyx_vtable__memoryviewslice.__pyx_base._get_base = (PyObject *(*)(struct __pyx_memoryview_obj *))__pyx_memoryviewslice__get_base;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_memoryview_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 952, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_memoryviewslice_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_memoryviewslice_spec, __pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_memoryviewslice_type)) __PYX_ERR(1, 952, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_memoryviewslice_spec, __pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #else
-  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_memoryviewslice_type->tp_base = __pyx_memoryview_type;
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_memoryviewslice_type->tp_print = 0;
+  __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_memoryviewslice.tp_print = 0;
   #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_memoryviewslice_type->tp_dictoffset && __pyx_memoryviewslice_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_memoryviewslice_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  if (__Pyx_SetVtable(__pyx_memoryviewslice_type, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #endif
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static int __Pyx_modinit_type_import_code(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
@@ -20860,63 +18106,14 @@
   __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
   /*--- Function import code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 
-#if PY_MAJOR_VERSION >= 3
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec__isomorphism(PyObject* module); /*proto*/
-static PyModuleDef_Slot __pyx_moduledef_slots[] = {
-  {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec__isomorphism},
-  {0, NULL}
-};
-#endif
-
-#ifdef __cplusplus
-namespace {
-  struct PyModuleDef __pyx_moduledef =
-  #else
-  static struct PyModuleDef __pyx_moduledef =
-  #endif
-  {
-      PyModuleDef_HEAD_INIT,
-      "_isomorphism",
-      0, /* m_doc */
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      0, /* m_size */
-    #elif CYTHON_USE_MODULE_STATE
-      sizeof(__pyx_mstate), /* m_size */
-    #else
-      -1, /* m_size */
-    #endif
-      __pyx_methods /* m_methods */,
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      __pyx_moduledef_slots, /* m_slots */
-    #else
-      NULL, /* m_reload */
-    #endif
-    #if CYTHON_USE_MODULE_STATE
-      __pyx_m_traverse, /* m_traverse */
-      __pyx_m_clear, /* m_clear */
-      NULL /* m_free */
-    #else
-      NULL, /* m_traverse */
-      NULL, /* m_clear */
-      NULL /* m_free */
-    #endif
-  };
-  #ifdef __cplusplus
-} /* anonymous namespace */
-#endif
-#endif
-
 #ifndef CYTHON_NO_PYINIT_EXPORT
 #define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
 #elif PY_MAJOR_VERSION < 3
 #ifdef __cplusplus
 #define __Pyx_PyMODINIT_FUNC extern "C" void
 #else
 #define __Pyx_PyMODINIT_FUNC void
@@ -20927,19 +18124,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC init_isomorphism(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC init_isomorphism(void)
+__Pyx_PyMODINIT_FUNC init_unpack(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC init_unpack(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void)
+__Pyx_PyMODINIT_FUNC PyInit__unpack(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit__unpack(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -20959,786 +18156,518 @@
         PyErr_SetString(
             PyExc_ImportError,
             "Interpreter change detected - this module can only be loaded into one interpreter per process.");
         return -1;
     }
     return 0;
 }
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *module, const char* from_name, const char* to_name, int allow_none)
-#else
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none)
-#endif
-{
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
     PyObject *value = PyObject_GetAttrString(spec, from_name);
     int result = 0;
     if (likely(value)) {
         if (allow_none || value != Py_None) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-            result = PyModule_AddObject(module, to_name, value);
-#else
             result = PyDict_SetItemString(moddict, to_name, value);
-#endif
         }
         Py_DECREF(value);
     } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Clear();
     } else {
         result = -1;
     }
     return result;
 }
-static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def) {
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
     PyObject *module = NULL, *moddict, *modname;
-    CYTHON_UNUSED_VAR(def);
     if (__Pyx_check_single_interpreter())
         return NULL;
     if (__pyx_m)
         return __Pyx_NewRef(__pyx_m);
     modname = PyObject_GetAttrString(spec, "name");
     if (unlikely(!modname)) goto bad;
     module = PyModule_NewObject(modname);
     Py_DECREF(modname);
     if (unlikely(!module)) goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    moddict = module;
-#else
     moddict = PyModule_GetDict(module);
     if (unlikely(!moddict)) goto bad;
-#endif
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec__isomorphism(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec__unpack(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
-  int stringtab_initialized = 0;
-  #if CYTHON_USE_MODULE_STATE
-  int pystate_addmodule_run = 0;
-  #endif
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  static PyThread_type_lock __pyx_t_8[8];
+  static int __pyx_t_3[119];
+  static PyThread_type_lock __pyx_t_4[8];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module '_isomorphism' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module '_unpack' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
-  /*--- Module creation code ---*/
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  __pyx_m = __pyx_pyinit_module;
-  Py_INCREF(__pyx_m);
-  #else
-  #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("_isomorphism", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #elif CYTHON_USE_MODULE_STATE
-  __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  {
-    int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
-    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to _isomorphism pseudovariable */
-    if (unlikely((add_module_result < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
-    pystate_addmodule_run = 1;
-  }
-  #else
-  __pyx_m = PyModule_Create(&__pyx_moduledef);
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #endif
-  CYTHON_UNUSED_VAR(__pyx_t_1);
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_b);
-  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if CYTHON_REFNANNY
 __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void)", 0);
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__unpack(void)", 0);
   if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   PyEval_InitThreads();
   #endif
+  /*--- Module creation code ---*/
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  __pyx_m = __pyx_pyinit_module;
+  Py_INCREF(__pyx_m);
+  #else
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4("_unpack", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_d);
+  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_b);
+  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_cython_runtime);
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
-  if (__Pyx_InitConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_chython__algorithms___isomorphism) {
+  if (__pyx_module_is_main_chython__containers___unpack) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "chython.algorithms._isomorphism")) {
-      if (unlikely((PyDict_SetItemString(modules, "chython.algorithms._isomorphism", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "chython.containers._unpack")) {
+      if (unlikely(PyDict_SetItemString(modules, "chython.containers._unpack", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Global type/function init code ---*/
   (void)__Pyx_modinit_global_init_code();
   (void)__Pyx_modinit_variable_export_code();
   (void)__Pyx_modinit_function_export_code();
-  if (unlikely((__Pyx_modinit_type_init_code() < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
   (void)__Pyx_modinit_type_import_code();
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "View.MemoryView":99
+  /* "chython/containers/_unpack.pyx":21
+ * cimport cython
+ * from libc.math cimport ldexp
+ * from chython.containers.bonds import Bond             # <<<<<<<<<<<<<<
  * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_3);
-    /*try:*/ {
-
-      /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- */
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_version_info); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_tuple__11, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (__pyx_t_6) {
-
-        /* "View.MemoryView":101
- * try:
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
- */
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_abc); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-        __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, __pyx_t_4);
-        __Pyx_GIVEREF(__pyx_t_4);
-        __pyx_t_4 = 0;
-
-        /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- */
-        goto __pyx_L8;
-      }
-
-      /* "View.MemoryView":103
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
- * except:
  * 
  */
-      /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 103, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 103, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-        __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, __pyx_t_5);
-        __Pyx_GIVEREF(__pyx_t_5);
-        __pyx_t_5 = 0;
-      }
-      __pyx_L8:;
-
-      /* "View.MemoryView":99
- * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-    }
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L7_try_end;
-    __pyx_L2_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-    /* "View.MemoryView":104
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
- * except:             # <<<<<<<<<<<<<<
- * 
- *     __pyx_collections_abc_Sequence = None
- */
-    /*except:*/ {
-      __Pyx_AddTraceback("View.MemoryView", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(1, 104, __pyx_L4_except_error)
-      __Pyx_XGOTREF(__pyx_t_5);
-      __Pyx_XGOTREF(__pyx_t_4);
-      __Pyx_XGOTREF(__pyx_t_7);
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_n_s_Bond);
+  __Pyx_GIVEREF(__pyx_n_s_Bond);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Bond);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_chython_containers_bonds, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Bond); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Bond, __pyx_t_1) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "View.MemoryView":106
- * except:
- * 
- *     __pyx_collections_abc_Sequence = None             # <<<<<<<<<<<<<<
- * 
+  /* "chython/containers/_unpack.pyx":25
  * 
+ * @cython.boundscheck(False)
+ * def unpack(const unsigned char[::1] data not None):             # <<<<<<<<<<<<<<
+ *     cdef int isotope_shift
+ *     cdef unsigned char a, b, c, d
  */
-      __Pyx_INCREF(Py_None);
-      __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-      __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, Py_None);
-      __Pyx_GIVEREF(Py_None);
-      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      goto __pyx_L3_exception_handled;
-    }
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7chython_10containers_7_unpack_1unpack, NULL, __pyx_n_s_chython_containers__unpack); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unpack, __pyx_t_2) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "View.MemoryView":99
+  /* "chython/containers/_unpack.pyx":168
  * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-    __pyx_L4_except_error:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    goto __pyx_L1_error;
-    __pyx_L3_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    __pyx_L7_try_end:;
+ * cdef int[119] common_isotopes
+ * common_isotopes[:] = [0, -15, -12, -9, -7, -5, -4, -2, 0, 3, 4, 7, 8, 11, 12, 15, 16, 19, 24, 23, 24, 29,             # <<<<<<<<<<<<<<
+ *                       32, 35, 36, 39, 40, 43, 43, 48, 49, 54, 57, 59, 63, 64, 68, 69, 72, 73, 75, 77,
+ *                       80, 82, 85, 87, 90, 92, 96, 99, 103, 106, 112, 111, 115, 117, 121, 123, 124, 125,
+ */
+  __pyx_t_3[0] = 0;
+  __pyx_t_3[1] = -15;
+  __pyx_t_3[2] = -12;
+  __pyx_t_3[3] = -9;
+  __pyx_t_3[4] = -7;
+  __pyx_t_3[5] = -5;
+  __pyx_t_3[6] = -4;
+  __pyx_t_3[7] = -2;
+  __pyx_t_3[8] = 0;
+  __pyx_t_3[9] = 3;
+  __pyx_t_3[10] = 4;
+  __pyx_t_3[11] = 7;
+  __pyx_t_3[12] = 8;
+  __pyx_t_3[13] = 11;
+  __pyx_t_3[14] = 12;
+  __pyx_t_3[15] = 15;
+  __pyx_t_3[16] = 16;
+  __pyx_t_3[17] = 19;
+  __pyx_t_3[18] = 24;
+  __pyx_t_3[19] = 23;
+  __pyx_t_3[20] = 24;
+  __pyx_t_3[21] = 29;
+  __pyx_t_3[22] = 32;
+  __pyx_t_3[23] = 35;
+  __pyx_t_3[24] = 36;
+  __pyx_t_3[25] = 39;
+  __pyx_t_3[26] = 40;
+  __pyx_t_3[27] = 43;
+  __pyx_t_3[28] = 43;
+  __pyx_t_3[29] = 48;
+  __pyx_t_3[30] = 49;
+  __pyx_t_3[31] = 54;
+  __pyx_t_3[32] = 57;
+  __pyx_t_3[33] = 59;
+  __pyx_t_3[34] = 63;
+  __pyx_t_3[35] = 64;
+  __pyx_t_3[36] = 68;
+  __pyx_t_3[37] = 69;
+  __pyx_t_3[38] = 72;
+  __pyx_t_3[39] = 73;
+  __pyx_t_3[40] = 75;
+  __pyx_t_3[41] = 77;
+  __pyx_t_3[42] = 80;
+  __pyx_t_3[43] = 82;
+  __pyx_t_3[44] = 85;
+  __pyx_t_3[45] = 87;
+  __pyx_t_3[46] = 90;
+  __pyx_t_3[47] = 92;
+  __pyx_t_3[48] = 96;
+  __pyx_t_3[49] = 99;
+  __pyx_t_3[50] = 0x67;
+  __pyx_t_3[51] = 0x6A;
+  __pyx_t_3[52] = 0x70;
+  __pyx_t_3[53] = 0x6F;
+  __pyx_t_3[54] = 0x73;
+  __pyx_t_3[55] = 0x75;
+  __pyx_t_3[56] = 0x79;
+  __pyx_t_3[57] = 0x7B;
+  __pyx_t_3[58] = 0x7C;
+  __pyx_t_3[59] = 0x7D;
+  __pyx_t_3[60] = 0x80;
+  __pyx_t_3[61] = 0x81;
+  __pyx_t_3[62] = 0x86;
+  __pyx_t_3[63] = 0x88;
+  __pyx_t_3[64] = 0x8D;
+  __pyx_t_3[65] = 0x8F;
+  __pyx_t_3[66] = 0x93;
+  __pyx_t_3[67] = 0x95;
+  __pyx_t_3[68] = 0x97;
+  __pyx_t_3[69] = 0x99;
+  __pyx_t_3[70] = 0x9D;
+  __pyx_t_3[71] = 0x9F;
+  __pyx_t_3[72] = 0xA2;
+  __pyx_t_3[73] = 0xA5;
+  __pyx_t_3[74] = 0xA8;
+  __pyx_t_3[75] = 0xAA;
+  __pyx_t_3[76] = 0xAE;
+  __pyx_t_3[77] = 0xB0;
+  __pyx_t_3[78] = 0xB3;
+  __pyx_t_3[79] = 0xB5;
+  __pyx_t_3[80] = 0xB9;
+  __pyx_t_3[81] = 0xBC;
+  __pyx_t_3[82] = 0xBF;
+  __pyx_t_3[83] = 0xC1;
+  __pyx_t_3[84] = 0xC1;
+  __pyx_t_3[85] = 0xC2;
+  __pyx_t_3[86] = 0xCE;
+  __pyx_t_3[87] = 0xCF;
+  __pyx_t_3[88] = 0xD2;
+  __pyx_t_3[89] = 0xD3;
+  __pyx_t_3[90] = 0xD8;
+  __pyx_t_3[91] = 0xD7;
+  __pyx_t_3[92] = 0xDE;
+  __pyx_t_3[93] = 0xDD;
+  __pyx_t_3[94] = 0xE4;
+  __pyx_t_3[95] = 0xE3;
+  __pyx_t_3[96] = 0xE7;
+  __pyx_t_3[97] = 0xE7;
+  __pyx_t_3[98] = 0xEB;
+  __pyx_t_3[99] = 0xEC;
+  __pyx_t_3[100] = 0xF1;
+  __pyx_t_3[101] = 0xF2;
+  __pyx_t_3[102] = 0xF3;
+  __pyx_t_3[103] = 0xF4;
+  __pyx_t_3[104] = 0xF5;
+  __pyx_t_3[105] = 0xFE;
+  __pyx_t_3[106] = 0xFD;
+  __pyx_t_3[107] = 0xFE;
+  __pyx_t_3[108] = 0xFE;
+  __pyx_t_3[109] = 0x106;
+  __pyx_t_3[110] = 0x109;
+  __pyx_t_3[111] = 0x109;
+  __pyx_t_3[112] = 0x10D;
+  __pyx_t_3[113] = 0x106;
+  __pyx_t_3[114] = 0x111;
+  __pyx_t_3[115] = 0x111;
+  __pyx_t_3[116] = 0x115;
+  __pyx_t_3[117] = 0x119;
+  __pyx_t_3[118] = 0x116;
+  if (unlikely((0x77) != (119))) {
+    PyErr_Format(PyExc_ValueError, "Assignment to slice of wrong length, expected %" CYTHON_FORMAT_SSIZE_T "d, got %" CYTHON_FORMAT_SSIZE_T "d", (Py_ssize_t)(119), (Py_ssize_t)(0x77));
+    __PYX_ERR(0, 168, __pyx_L1_error)
   }
+  memcpy(&(__pyx_v_7chython_10containers_7_unpack_common_isotopes[0]), __pyx_t_3, sizeof(__pyx_v_7chython_10containers_7_unpack_common_isotopes[0]) * (119));
 
-  /* "View.MemoryView":241
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_2, &__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_1);
-    /*try:*/ {
-
-      /* "View.MemoryView":242
- * 
- *     try:
- *         count = __pyx_collections_abc_Sequence.count             # <<<<<<<<<<<<<<
- *         index = __pyx_collections_abc_Sequence.index
- *     except:
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 242, __pyx_L11_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_array_type->tp_dict, __pyx_n_s_count, __pyx_t_7) < 0) __PYX_ERR(1, 242, __pyx_L11_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_array_type);
-
-      /* "View.MemoryView":243
- *     try:
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index             # <<<<<<<<<<<<<<
- *     except:
- *         pass
+  /* "chython/containers/_unpack.pyx":1
+ * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
+ * #
+ * #  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
  */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_index); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 243, __pyx_L11_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_array_type->tp_dict, __pyx_n_s_index, __pyx_t_7) < 0) __PYX_ERR(1, 243, __pyx_L11_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_array_type);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "View.MemoryView":241
- * 
+  /* "View.MemoryView":209
+ *         info.obj = self
  * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-    }
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    goto __pyx_L16_try_end;
-    __pyx_L11_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":244
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- *     except:             # <<<<<<<<<<<<<<
- *         pass
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
+ *     def __dealloc__(array self):
  */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L12_exception_handled;
-    }
-    __pyx_L12_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_2, __pyx_t_1);
-    __pyx_L16_try_end:;
-  }
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 209, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 209, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  PyType_Modified(__pyx_array_type);
 
-  /* "View.MemoryView":309
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 309, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(generic);
-  __Pyx_DECREF_SET(generic, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(generic, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 310, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(strided);
-  __Pyx_DECREF_SET(strided, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(strided, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "View.MemoryView":311
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 311, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(indirect);
-  __Pyx_DECREF_SET(indirect, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(indirect, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "View.MemoryView":314
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 314, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(contiguous);
-  __Pyx_DECREF_SET(contiguous, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(contiguous, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "View.MemoryView":315
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 315, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_XGOTREF(indirect_contiguous);
-  __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "View.MemoryView":323
- * 
+  /* "View.MemoryView":316
  * 
+ * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
- * cdef PyThread_type_lock[8] __pyx_memoryview_thread_locks = [
+ * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
-  /* "View.MemoryView":324
- * 
+  /* "View.MemoryView":317
+ * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0
- * cdef PyThread_type_lock[8] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
+ * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
  *     PyThread_allocate_lock(),
  *     PyThread_allocate_lock(),
  */
-  __pyx_t_8[0] = PyThread_allocate_lock();
-  __pyx_t_8[1] = PyThread_allocate_lock();
-  __pyx_t_8[2] = PyThread_allocate_lock();
-  __pyx_t_8[3] = PyThread_allocate_lock();
-  __pyx_t_8[4] = PyThread_allocate_lock();
-  __pyx_t_8[5] = PyThread_allocate_lock();
-  __pyx_t_8[6] = PyThread_allocate_lock();
-  __pyx_t_8[7] = PyThread_allocate_lock();
-  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_8, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
-
-  /* "View.MemoryView":982
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_3);
-    /*try:*/ {
-
-      /* "View.MemoryView":983
- * 
- *     try:
- *         count = __pyx_collections_abc_Sequence.count             # <<<<<<<<<<<<<<
- *         index = __pyx_collections_abc_Sequence.index
- *     except:
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 983, __pyx_L17_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_count, __pyx_t_7) < 0) __PYX_ERR(1, 983, __pyx_L17_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_memoryviewslice_type);
-
-      /* "View.MemoryView":984
- *     try:
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index             # <<<<<<<<<<<<<<
- *     except:
- *         pass
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_index); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 984, __pyx_L17_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_index, __pyx_t_7) < 0) __PYX_ERR(1, 984, __pyx_L17_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_memoryviewslice_type);
+  __pyx_t_4[0] = PyThread_allocate_lock();
+  __pyx_t_4[1] = PyThread_allocate_lock();
+  __pyx_t_4[2] = PyThread_allocate_lock();
+  __pyx_t_4[3] = PyThread_allocate_lock();
+  __pyx_t_4[4] = PyThread_allocate_lock();
+  __pyx_t_4[5] = PyThread_allocate_lock();
+  __pyx_t_4[6] = PyThread_allocate_lock();
+  __pyx_t_4[7] = PyThread_allocate_lock();
+  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_4, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
-      /* "View.MemoryView":982
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-    }
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L22_try_end;
-    __pyx_L17_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":985
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- *     except:             # <<<<<<<<<<<<<<
- *         pass
- * 
- */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L18_exception_handled;
-    }
-    __pyx_L18_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    __pyx_L22_try_end:;
-  }
-
-  /* "View.MemoryView":988
- *         pass
- * 
- * try:             # <<<<<<<<<<<<<<
- *     if __pyx_collections_abc_Sequence:
- * 
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_2, &__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_1);
-    /*try:*/ {
-
-      /* "View.MemoryView":989
- * 
- * try:
- *     if __pyx_collections_abc_Sequence:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_collections_abc_Sequence); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(1, 989, __pyx_L23_error)
-      if (__pyx_t_6) {
-
-        /* "View.MemoryView":993
- * 
- * 
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence.register(array)
- * except:
- */
-        __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_register); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 993, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_7, ((PyObject *)__pyx_memoryviewslice_type)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 993, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-        /* "View.MemoryView":994
- * 
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)
- *         __pyx_collections_abc_Sequence.register(array)             # <<<<<<<<<<<<<<
- * except:
- *     pass  # ignore failure, it's a minor issue
- */
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_register); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 994, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_4, ((PyObject *)__pyx_array_type)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 994, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-        /* "View.MemoryView":989
+  /* "View.MemoryView":549
+ *         info.obj = self
  * 
- * try:
- *     if __pyx_collections_abc_Sequence:             # <<<<<<<<<<<<<<
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      }
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 549, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 549, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  PyType_Modified(__pyx_memoryview_type);
 
-      /* "View.MemoryView":988
- *         pass
+  /* "View.MemoryView":995
+ *         return self.from_object
  * 
- * try:             # <<<<<<<<<<<<<<
- *     if __pyx_collections_abc_Sequence:
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
- */
-    }
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    goto __pyx_L28_try_end;
-    __pyx_L23_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":995
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)
- *         __pyx_collections_abc_Sequence.register(array)
- * except:             # <<<<<<<<<<<<<<
- *     pass  # ignore failure, it's a minor issue
  * 
  */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L24_exception_handled;
-    }
-    __pyx_L24_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_2, __pyx_t_1);
-    __pyx_L28_try_end:;
-  }
+  __pyx_t_2 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 995, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_2) < 0) __PYX_ERR(1, 995, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-  /* "chython/algorithms/_isomorphism.pyx":28
- * 
- * 
- * @cython.boundscheck(False)             # <<<<<<<<<<<<<<
- * @cython.wraparound(False)
- * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
- */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_7chython_10algorithms_12_isomorphism_1get_mapping, 0, __pyx_n_s_get_mapping, NULL, __pyx_n_s_chython_algorithms__isomorphism, __pyx_d, ((PyObject *)__pyx_codeobj__9)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_mapping, __pyx_t_7) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "chython/algorithms/_isomorphism.pyx":1
- * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
- * #
- * #  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
+  /* "(tree fragment)":11
+ *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
+ *     return __pyx_result
+ * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
+ *     __pyx_result.name = __pyx_state[0]
+ *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  */
-  __pyx_t_7 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_7) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   if (__pyx_m) {
-    if (__pyx_d && stringtab_initialized) {
-      __Pyx_AddTraceback("init chython.algorithms._isomorphism", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    if (__pyx_d) {
+      __Pyx_AddTraceback("init chython.containers._unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
-    #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
-    #else
-    Py_DECREF(__pyx_m);
-    if (pystate_addmodule_run) {
-      PyObject *tp, *value, *tb;
-      PyErr_Fetch(&tp, &value, &tb);
-      PyState_RemoveModule(&__pyx_moduledef);
-      PyErr_Restore(tp, value, tb);
-    }
-    #endif
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init chython.algorithms._isomorphism");
+    PyErr_SetString(PyExc_ImportError, "init chython.containers._unpack");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
   #else
   return;
   #endif
 }
-/* #### Code section: cleanup_globals ### */
-/* #### Code section: cleanup_module ### */
-/* #### Code section: main_method ### */
-/* #### Code section: utility_code_pragmas ### */
-#ifdef _MSC_VER
-#pragma warning( push )
-/* Warning 4127: conditional expression is constant
- * Cython uses constant conditional expressions to allow in inline functions to be optimized at
- * compile-time, so this warning is not useful
- */
-#pragma warning( disable : 4127 )
-#endif
-
-
-
-/* #### Code section: utility_code_def ### */
 
 /* --- Runtime support code --- */
 /* Refnanny */
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
@@ -21750,370 +18679,625 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif
 
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
+/* PyObjectGetAttrStr */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
 #endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
-    }
-    return 0;
+    return PyObject_GetAttr(obj, attr_name);
 }
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    int result;
-    PyObject *exc_type;
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *current_exception = tstate->current_exception;
-    if (unlikely(!current_exception)) return 0;
-    exc_type = (PyObject*) Py_TYPE(current_exception);
-    if (exc_type == err) return 1;
+#endif
+
+/* GetBuiltinName */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
 #else
-    exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
+            "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_INCREF(exc_type);
-    #endif
-    if (unlikely(PyTuple_Check(err))) {
-        result = __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    } else {
-        result = __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
     }
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_DECREF(exc_type);
-    #endif
     return result;
 }
+
+/* None */
+static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
+    long q = a / b;
+    long r = a - q*b;
+    q -= ((r != 0) & ((r ^ b) < 0));
+    return q;
+}
+
+/* None */
+static CYTHON_INLINE long __Pyx_mod_long(long a, long b) {
+    long r = a % b;
+    r += ((r != 0) & ((r ^ b) < 0)) * b;
+    return r;
+}
+
+/* DictGetItem */
+#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
+    PyObject *value;
+    value = PyDict_GetItemWithError(d, key);
+    if (unlikely(!value)) {
+        if (!PyErr_Occurred()) {
+            if (unlikely(PyTuple_Check(key))) {
+                PyObject* args = PyTuple_Pack(1, key);
+                if (likely(args)) {
+                    PyErr_SetObject(PyExc_KeyError, args);
+                    Py_DECREF(args);
+                }
+            } else {
+                PyErr_SetObject(PyExc_KeyError, key);
+            }
+        }
+        return NULL;
+    }
+    Py_INCREF(value);
+    return value;
+}
 #endif
 
-/* PyErrFetchRestore */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *tmp_value;
-    assert(type == NULL || (value != NULL && type == (PyObject*) Py_TYPE(value)));
-    if (value) {
-        #if CYTHON_COMPILING_IN_CPYTHON
-        if (unlikely(((PyBaseExceptionObject*) value)->traceback != tb))
-        #endif
-            PyException_SetTraceback(value, tb);
+/* GetItemInt */
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyList_GET_SIZE(o);
     }
-    tmp_value = tstate->current_exception;
-    tstate->current_exception = value;
-    Py_XDECREF(tmp_value);
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 #else
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
+    return PySequence_GetItem(o, i);
 #endif
 }
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject* exc_value;
-    exc_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    *value = exc_value;
-    *type = NULL;
-    *tb = NULL;
-    if (exc_value) {
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        #if CYTHON_COMPILING_IN_CPYTHON
-        *tb = ((PyBaseExceptionObject*) exc_value)->traceback;
-        Py_XINCREF(*tb);
-        #else
-        *tb = PyException_GetTraceback(exc_value);
-        #endif
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyTuple_GET_SIZE(o);
     }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 #else
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
+    return PySequence_GetItem(o, i);
 #endif
 }
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
+                                                     CYTHON_NCP_UNUSED int wraparound,
+                                                     CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
+                        return NULL;
+                    PyErr_Clear();
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
 #endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
 
-/* PyObjectGetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+/* PyDictVersioning */
+#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
+    PyObject **dictptr = NULL;
+    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
+    if (offset) {
+#if CYTHON_COMPILING_IN_CPYTHON
+        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
+#else
+        dictptr = _PyObject_GetDictPtr(obj);
 #endif
-    return PyObject_GetAttr(obj, attr_name);
+    }
+    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
+}
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
+        return 0;
+    return obj_dict_version == __Pyx_get_object_dict_version(obj);
 }
 #endif
 
-/* PyObjectGetAttrStrNoError */
-static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        __Pyx_PyErr_Clear();
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+/* GetModuleGlobalName */
+#if CYTHON_USE_DICT_VERSIONS
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
+#else
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
+#endif
+{
     PyObject *result;
-#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
-        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
+#if !CYTHON_AVOID_BORROWED_REFS
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
+    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    } else if (unlikely(PyErr_Occurred())) {
+        return NULL;
+    }
+#else
+    result = PyDict_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
     }
 #endif
-    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
-    if (unlikely(!result)) {
-        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
     }
-    return result;
+    PyErr_Clear();
+#endif
+    return __Pyx_GetBuiltinName(name);
 }
 
-/* GetBuiltinName */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStrNoError(__pyx_b, name);
-    if (unlikely(!result) && !PyErr_Occurred()) {
-        PyErr_Format(PyExc_NameError,
+/* PyCFunctionFastCall */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
+    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
+    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
+    PyObject *self = PyCFunction_GET_SELF(func);
+    int flags = PyCFunction_GET_FLAGS(func);
+    assert(PyCFunction_Check(func));
+    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
+    assert(nargs >= 0);
+    assert(nargs == 0 || args != NULL);
+    /* _PyCFunction_FastCallDict() must not be called with an exception set,
+       because it may clear it (directly or indirectly) and so the
+       caller loses its exception */
+    assert(!PyErr_Occurred());
+    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
+        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+    } else {
+        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+    }
+}
+#endif
+
+/* PyFunctionFastCall */
+#if CYTHON_FAST_PYCALL
+static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
+                                               PyObject *globals) {
+    PyFrameObject *f;
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject **fastlocals;
+    Py_ssize_t i;
+    PyObject *result;
+    assert(globals != NULL);
+    /* XXX Perhaps we should create a specialized
+       PyFrame_New() that doesn't take locals, but does
+       take builtins without sanity checking them.
+       */
+    assert(tstate != NULL);
+    f = PyFrame_New(tstate, co, globals, NULL);
+    if (f == NULL) {
+        return NULL;
+    }
+    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
+    for (i = 0; i < na; i++) {
+        Py_INCREF(*args);
+        fastlocals[i] = *args++;
+    }
+    result = PyEval_EvalFrameEx(f,0);
+    ++tstate->recursion_depth;
+    Py_DECREF(f);
+    --tstate->recursion_depth;
+    return result;
+}
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
+    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
+    PyObject *globals = PyFunction_GET_GLOBALS(func);
+    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
+    PyObject *closure;
 #if PY_MAJOR_VERSION >= 3
-            "name '%U' is not defined", name);
-#else
-            "name '%.200s' is not defined", PyString_AS_STRING(name));
+    PyObject *kwdefs;
+#endif
+    PyObject *kwtuple, **k;
+    PyObject **d;
+    Py_ssize_t nd;
+    Py_ssize_t nk;
+    PyObject *result;
+    assert(kwargs == NULL || PyDict_Check(kwargs));
+    nk = kwargs ? PyDict_Size(kwargs) : 0;
+    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
+        return NULL;
+    }
+    if (
+#if PY_MAJOR_VERSION >= 3
+            co->co_kwonlyargcount == 0 &&
+#endif
+            likely(kwargs == NULL || nk == 0) &&
+            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
+        if (argdefs == NULL && co->co_argcount == nargs) {
+            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
+            goto done;
+        }
+        else if (nargs == 0 && argdefs != NULL
+                 && co->co_argcount == Py_SIZE(argdefs)) {
+            /* function called with no arguments, but all parameters have
+               a default value: use default values as arguments .*/
+            args = &PyTuple_GET_ITEM(argdefs, 0);
+            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
+            goto done;
+        }
+    }
+    if (kwargs != NULL) {
+        Py_ssize_t pos, i;
+        kwtuple = PyTuple_New(2 * nk);
+        if (kwtuple == NULL) {
+            result = NULL;
+            goto done;
+        }
+        k = &PyTuple_GET_ITEM(kwtuple, 0);
+        pos = i = 0;
+        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
+            Py_INCREF(k[i]);
+            Py_INCREF(k[i+1]);
+            i += 2;
+        }
+        nk = i / 2;
+    }
+    else {
+        kwtuple = NULL;
+        k = NULL;
+    }
+    closure = PyFunction_GET_CLOSURE(func);
+#if PY_MAJOR_VERSION >= 3
+    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
 #endif
+    if (argdefs != NULL) {
+        d = &PyTuple_GET_ITEM(argdefs, 0);
+        nd = Py_SIZE(argdefs);
+    }
+    else {
+        d = NULL;
+        nd = 0;
     }
+#if PY_MAJOR_VERSION >= 3
+    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, kwdefs, closure);
+#else
+    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
+                               args, (int)nargs,
+                               k, (int)nk,
+                               d, (int)nd, closure);
+#endif
+    Py_XDECREF(kwtuple);
+done:
+    Py_LeaveRecursiveCall();
     return result;
 }
+#endif
+#endif
 
-/* TupleAndListFromArray */
+/* PyObjectCall */
 #if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE void __Pyx_copy_object_array(PyObject *const *CYTHON_RESTRICT src, PyObject** CYTHON_RESTRICT dest, Py_ssize_t length) {
-    PyObject *v;
-    Py_ssize_t i;
-    for (i = 0; i < length; i++) {
-        v = dest[i] = src[i];
-        Py_INCREF(v);
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
     }
+    return result;
 }
-static CYTHON_INLINE PyObject *
-__Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        Py_INCREF(__pyx_empty_tuple);
-        return __pyx_empty_tuple;
-    }
-    res = PyTuple_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyTupleObject*)res)->ob_item, n);
-    return res;
+#endif
+
+/* PyObjectCall2Args */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
+    PyObject *args, *result = NULL;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyFunction_FastCall(function, args, 2);
+    }
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyCFunction_FastCall(function, args, 2);
+    }
+    #endif
+    args = PyTuple_New(2);
+    if (unlikely(!args)) goto done;
+    Py_INCREF(arg1);
+    PyTuple_SET_ITEM(args, 0, arg1);
+    Py_INCREF(arg2);
+    PyTuple_SET_ITEM(args, 1, arg2);
+    Py_INCREF(function);
+    result = __Pyx_PyObject_Call(function, args, NULL);
+    Py_DECREF(args);
+    Py_DECREF(function);
+done:
+    return result;
 }
-static CYTHON_INLINE PyObject *
-__Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        return PyList_New(0);
-    }
-    res = PyList_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyListObject*)res)->ob_item, n);
-    return res;
+
+/* PyObjectCallMethO */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
+    PyObject *self, *result;
+    PyCFunction cfunc;
+    cfunc = PyCFunction_GET_FUNCTION(func);
+    self = PyCFunction_GET_SELF(func);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = cfunc(self, arg);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
 }
 #endif
 
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
-        } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
+/* PyObjectCallOneArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_New(1);
+    if (unlikely(!args)) return NULL;
+    Py_INCREF(arg);
+    PyTuple_SET_ITEM(args, 0, arg);
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, &arg, 1);
+    }
+#endif
+    if (likely(PyCFunction_Check(func))) {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
+            return __Pyx_PyObject_CallMethO(func, arg);
+#if CYTHON_FAST_PYCCALL
+        } else if (__Pyx_PyFastCFunction_Check(func)) {
+            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
 #endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
         }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
     }
-#endif
+    return __Pyx__PyObject_CallOneArg(func, arg);
 }
-
-/* UnicodeEquals */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
 #else
-#if PY_MAJOR_VERSION < 3
-    PyObject* owned_ref = NULL;
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_Pack(1, arg);
+    if (unlikely(!args)) return NULL;
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
 #endif
-    int s1_is_unicode, s2_is_unicode;
-    if (s1 == s2) {
-        goto return_eq;
-    }
-    s1_is_unicode = PyUnicode_CheckExact(s1);
-    s2_is_unicode = PyUnicode_CheckExact(s2);
+
+/* PyObjectSetAttrStr */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_setattro))
+        return tp->tp_setattro(obj, attr_name, value);
 #if PY_MAJOR_VERSION < 3
-    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
-        owned_ref = PyUnicode_FromObject(s2);
-        if (unlikely(!owned_ref))
-            return -1;
-        s2 = owned_ref;
-        s2_is_unicode = 1;
-    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
-        owned_ref = PyUnicode_FromObject(s1);
-        if (unlikely(!owned_ref))
-            return -1;
-        s1 = owned_ref;
-        s1_is_unicode = 1;
-    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
-        return __Pyx_PyBytes_Equals(s1, s2, equals);
-    }
+    if (likely(tp->tp_setattr))
+        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
 #endif
-    if (s1_is_unicode & s2_is_unicode) {
-        Py_ssize_t length;
-        int kind;
-        void *data1, *data2;
-        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
-            return -1;
-        length = __Pyx_PyUnicode_GET_LENGTH(s1);
-        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
-            goto return_ne;
-        }
-#if CYTHON_USE_UNICODE_INTERNALS
-        {
-            Py_hash_t hash1, hash2;
-        #if CYTHON_PEP393_ENABLED
-            hash1 = ((PyASCIIObject*)s1)->hash;
-            hash2 = ((PyASCIIObject*)s2)->hash;
-        #else
-            hash1 = ((PyUnicodeObject*)s1)->hash;
-            hash2 = ((PyUnicodeObject*)s2)->hash;
-        #endif
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                goto return_ne;
-            }
-        }
+    return PyObject_SetAttr(obj, attr_name, value);
+}
 #endif
-        kind = __Pyx_PyUnicode_KIND(s1);
-        if (kind != __Pyx_PyUnicode_KIND(s2)) {
-            goto return_ne;
+
+/* MemviewSliceInit */
+static int
+__Pyx_init_memviewslice(struct __pyx_memoryview_obj *memview,
+                        int ndim,
+                        __Pyx_memviewslice *memviewslice,
+                        int memview_is_new_reference)
+{
+    __Pyx_RefNannyDeclarations
+    int i, retval=-1;
+    Py_buffer *buf = &memview->view;
+    __Pyx_RefNannySetupContext("init_memviewslice", 0);
+    if (unlikely(memviewslice->memview || memviewslice->data)) {
+        PyErr_SetString(PyExc_ValueError,
+            "memviewslice is already initialized!");
+        goto fail;
+    }
+    if (buf->strides) {
+        for (i = 0; i < ndim; i++) {
+            memviewslice->strides[i] = buf->strides[i];
         }
-        data1 = __Pyx_PyUnicode_DATA(s1);
-        data2 = __Pyx_PyUnicode_DATA(s2);
-        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
-            goto return_ne;
-        } else if (length == 1) {
-            goto return_eq;
+    } else {
+        Py_ssize_t stride = buf->itemsize;
+        for (i = ndim - 1; i >= 0; i--) {
+            memviewslice->strides[i] = stride;
+            stride *= buf->shape[i];
+        }
+    }
+    for (i = 0; i < ndim; i++) {
+        memviewslice->shape[i]   = buf->shape[i];
+        if (buf->suboffsets) {
+            memviewslice->suboffsets[i] = buf->suboffsets[i];
         } else {
-            int result = memcmp(data1, data2, (size_t)(length * kind));
-            #if PY_MAJOR_VERSION < 3
-            Py_XDECREF(owned_ref);
-            #endif
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+            memviewslice->suboffsets[i] = -1;
         }
-    } else if ((s1 == Py_None) & s2_is_unicode) {
-        goto return_ne;
-    } else if ((s2 == Py_None) & s1_is_unicode) {
-        goto return_ne;
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        #if PY_MAJOR_VERSION < 3
-        Py_XDECREF(owned_ref);
-        #endif
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
     }
-return_eq:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_EQ);
-return_ne:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_NE);
+    memviewslice->memview = memview;
+    memviewslice->data = (char *)buf->buf;
+    if (__pyx_add_acquisition_count(memview) == 0 && !memview_is_new_reference) {
+        Py_INCREF(memview);
+    }
+    retval = 0;
+    goto no_fail;
+fail:
+    memviewslice->memview = 0;
+    memviewslice->data = 0;
+    retval = -1;
+no_fail:
+    __Pyx_RefNannyFinishContext();
+    return retval;
+}
+#ifndef Py_NO_RETURN
+#define Py_NO_RETURN
 #endif
+static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
+    va_list vargs;
+    char msg[200];
+#ifdef HAVE_STDARG_PROTOTYPES
+    va_start(vargs, fmt);
+#else
+    va_start(vargs);
+#endif
+    vsnprintf(msg, 200, fmt, vargs);
+    va_end(vargs);
+    Py_FatalError(msg);
 }
-
-/* fastcall */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s)
+static CYTHON_INLINE int
+__pyx_add_acquisition_count_locked(__pyx_atomic_int *acquisition_count,
+                                   PyThread_type_lock lock)
 {
-    Py_ssize_t i, n = PyTuple_GET_SIZE(kwnames);
-    for (i = 0; i < n; i++)
-    {
-        if (s == PyTuple_GET_ITEM(kwnames, i)) return kwvalues[i];
+    int result;
+    PyThread_acquire_lock(lock, 1);
+    result = (*acquisition_count)++;
+    PyThread_release_lock(lock);
+    return result;
+}
+static CYTHON_INLINE int
+__pyx_sub_acquisition_count_locked(__pyx_atomic_int *acquisition_count,
+                                   PyThread_type_lock lock)
+{
+    int result;
+    PyThread_acquire_lock(lock, 1);
+    result = (*acquisition_count)--;
+    PyThread_release_lock(lock);
+    return result;
+}
+static CYTHON_INLINE void
+__Pyx_INC_MEMVIEW(__Pyx_memviewslice *memslice, int have_gil, int lineno)
+{
+    int first_time;
+    struct __pyx_memoryview_obj *memview = memslice->memview;
+    if (unlikely(!memview || (PyObject *) memview == Py_None))
+        return;
+    if (unlikely(__pyx_get_slice_count(memview) < 0))
+        __pyx_fatalerror("Acquisition count is %d (line %d)",
+                         __pyx_get_slice_count(memview), lineno);
+    first_time = __pyx_add_acquisition_count(memview) == 0;
+    if (unlikely(first_time)) {
+        if (have_gil) {
+            Py_INCREF((PyObject *) memview);
+        } else {
+            PyGILState_STATE _gilstate = PyGILState_Ensure();
+            Py_INCREF((PyObject *) memview);
+            PyGILState_Release(_gilstate);
+        }
     }
-    for (i = 0; i < n; i++)
-    {
-        int eq = __Pyx_PyUnicode_Equals(s, PyTuple_GET_ITEM(kwnames, i), Py_EQ);
-        if (unlikely(eq != 0)) {
-            if (unlikely(eq < 0)) return NULL;  // error
-            return kwvalues[i];
+}
+static CYTHON_INLINE void __Pyx_XDEC_MEMVIEW(__Pyx_memviewslice *memslice,
+                                             int have_gil, int lineno) {
+    int last_time;
+    struct __pyx_memoryview_obj *memview = memslice->memview;
+    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
+        memslice->memview = NULL;
+        return;
+    }
+    if (unlikely(__pyx_get_slice_count(memview) <= 0))
+        __pyx_fatalerror("Acquisition count is %d (line %d)",
+                         __pyx_get_slice_count(memview), lineno);
+    last_time = __pyx_sub_acquisition_count(memview) == 1;
+    memslice->data = NULL;
+    if (unlikely(last_time)) {
+        if (have_gil) {
+            Py_CLEAR(memslice->memview);
+        } else {
+            PyGILState_STATE _gilstate = PyGILState_Ensure();
+            Py_CLEAR(memslice->memview);
+            PyGILState_Release(_gilstate);
         }
+    } else {
+        memslice->memview = NULL;
     }
-    return NULL;  // not found (no exception set)
 }
-#endif
 
 /* RaiseArgTupleInvalid */
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
@@ -22150,37 +19334,25 @@
         PyString_AsString(kw_name));
         #endif
 }
 
 /* ParseKeywords */
 static int __Pyx_ParseOptionalKeywords(
     PyObject *kwds,
-    PyObject *const *kwvalues,
     PyObject **argnames[],
     PyObject *kwds2,
     PyObject *values[],
     Py_ssize_t num_pos_args,
     const char* function_name)
 {
     PyObject *key = 0, *value = 0;
     Py_ssize_t pos = 0;
     PyObject*** name;
     PyObject*** first_kw_arg = argnames + num_pos_args;
-    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));
-    while (1) {
-        if (kwds_is_tuple) {
-            if (pos >= PyTuple_GET_SIZE(kwds)) break;
-            key = PyTuple_GET_ITEM(kwds, pos);
-            value = kwvalues[pos];
-            pos++;
-        }
-        else
-        {
-            if (!PyDict_Next(kwds, &pos, &key, &value)) break;
-        }
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
         name = first_kw_arg;
         while (*name && (**name != key)) name++;
         if (*name) {
             values[name-argnames] = value;
             continue;
         }
         name = first_kw_arg;
@@ -22206,20 +19378,19 @@
                     argname++;
                 }
             }
         } else
         #endif
         if (likely(PyUnicode_Check(key))) {
             while (*name) {
-                int cmp = (
+                int cmp = (**name == key) ? 0 :
                 #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                     (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                 #endif
-                    PyUnicode_Compare(**name, key)
-                );
+                    PyUnicode_Compare(**name, key);
                 if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                 if (cmp == 0) {
                     values[name-argnames] = value;
                     break;
                 }
                 name++;
             }
@@ -22250,59 +19421,76 @@
     __Pyx_RaiseDoubleKeywordsError(function_name, key);
     goto bad;
 invalid_keyword_type:
     PyErr_Format(PyExc_TypeError,
         "%.200s() keywords must be strings", function_name);
     goto bad;
 invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
     PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
         "%.200s() got an unexpected keyword argument '%.200s'",
         function_name, PyString_AsString(key));
     #else
-    PyErr_Format(PyExc_TypeError,
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
     return -1;
 }
 
 /* ArgTypeTest */
 static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
 {
-    __Pyx_TypeName type_name;
-    __Pyx_TypeName obj_type_name;
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     else if (exact) {
         #if PY_MAJOR_VERSION == 2
         if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
         #endif
     }
     else {
         if (likely(__Pyx_TypeCheck(obj, type))) return 1;
     }
-    type_name = __Pyx_PyType_GetName(type);
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
     PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected " __Pyx_FMT_TYPENAME
-        ", got " __Pyx_FMT_TYPENAME ")", name, type_name, obj_type_name);
-    __Pyx_DECREF_TypeName(type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
+        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
     return 0;
 }
 
+/* PyErrFetchRestore */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+#endif
+
 /* RaiseException */
 #if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
-    CYTHON_UNUSED_VAR(cause);
     Py_XINCREF(type);
     if (!value || value == Py_None)
         value = NULL;
     else
         Py_INCREF(value);
     if (!tb || tb == Py_None)
         tb = NULL;
@@ -22427,596 +19615,191 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-      #if PY_VERSION_HEX >= 0x030C00A6
-        PyException_SetTraceback(value, tb);
-      #elif CYTHON_FAST_THREAD_STATE
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
-#else
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
 
-/* PyFunctionFastCall */
-#if CYTHON_FAST_PYCALL && !CYTHON_VECTORCALL
-static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
-                                               PyObject *globals) {
-    PyFrameObject *f;
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject **fastlocals;
-    Py_ssize_t i;
-    PyObject *result;
-    assert(globals != NULL);
-    /* XXX Perhaps we should create a specialized
-       PyFrame_New() that doesn't take locals, but does
-       take builtins without sanity checking them.
-       */
-    assert(tstate != NULL);
-    f = PyFrame_New(tstate, co, globals, NULL);
-    if (f == NULL) {
-        return NULL;
-    }
-    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
-    for (i = 0; i < na; i++) {
-        Py_INCREF(*args);
-        fastlocals[i] = *args++;
-    }
-    result = PyEval_EvalFrameEx(f,0);
-    ++tstate->recursion_depth;
-    Py_DECREF(f);
-    --tstate->recursion_depth;
-    return result;
-}
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
-    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
-    PyObject *globals = PyFunction_GET_GLOBALS(func);
-    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
-    PyObject *closure;
-#if PY_MAJOR_VERSION >= 3
-    PyObject *kwdefs;
-#endif
-    PyObject *kwtuple, **k;
-    PyObject **d;
-    Py_ssize_t nd;
-    Py_ssize_t nk;
-    PyObject *result;
-    assert(kwargs == NULL || PyDict_Check(kwargs));
-    nk = kwargs ? PyDict_Size(kwargs) : 0;
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object"))) {
-        return NULL;
-    }
-    if (
-#if PY_MAJOR_VERSION >= 3
-            co->co_kwonlyargcount == 0 &&
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
+            }
 #endif
-            likely(kwargs == NULL || nk == 0) &&
-            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
-        if (argdefs == NULL && co->co_argcount == nargs) {
-            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
-            goto done;
-        }
-        else if (nargs == 0 && argdefs != NULL
-                 && co->co_argcount == Py_SIZE(argdefs)) {
-            /* function called with no arguments, but all parameters have
-               a default value: use default values as arguments .*/
-            args = &PyTuple_GET_ITEM(argdefs, 0);
-            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
-            goto done;
-        }
-    }
-    if (kwargs != NULL) {
-        Py_ssize_t pos, i;
-        kwtuple = PyTuple_New(2 * nk);
-        if (kwtuple == NULL) {
-            result = NULL;
-            goto done;
-        }
-        k = &PyTuple_GET_ITEM(kwtuple, 0);
-        pos = i = 0;
-        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
-            Py_INCREF(k[i]);
-            Py_INCREF(k[i+1]);
-            i += 2;
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
         }
-        nk = i / 2;
-    }
-    else {
-        kwtuple = NULL;
-        k = NULL;
-    }
-    closure = PyFunction_GET_CLOSURE(func);
-#if PY_MAJOR_VERSION >= 3
-    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
-#endif
-    if (argdefs != NULL) {
-        d = &PyTuple_GET_ITEM(argdefs, 0);
-        nd = Py_SIZE(argdefs);
-    }
-    else {
-        d = NULL;
-        nd = 0;
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-#if PY_MAJOR_VERSION >= 3
-    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, kwdefs, closure);
-#else
-    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
-                               args, (int)nargs,
-                               k, (int)nk,
-                               d, (int)nd, closure);
 #endif
-    Py_XDECREF(kwtuple);
-done:
-    Py_LeaveRecursiveCall();
-    return result;
 }
-#endif
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
+/* UnicodeEquals */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+#if PY_MAJOR_VERSION < 3
+    PyObject* owned_ref = NULL;
 #endif
-
-/* PyObjectCallMethO */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
-    PyObject *self, *result;
-    PyCFunction cfunc;
-    cfunc = PyCFunction_GET_FUNCTION(func);
-    self = PyCFunction_GET_SELF(func);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = cfunc(self, arg);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
+    int s1_is_unicode, s2_is_unicode;
+    if (s1 == s2) {
+        goto return_eq;
     }
-    return result;
-}
-#endif
-
-/* PyObjectFastCall */
-static PyObject* __Pyx_PyObject_FastCall_fallback(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs) {
-    PyObject *argstuple;
-    PyObject *result;
-    size_t i;
-    argstuple = PyTuple_New((Py_ssize_t)nargs);
-    if (unlikely(!argstuple)) return NULL;
-    for (i = 0; i < nargs; i++) {
-        Py_INCREF(args[i]);
-        PyTuple_SET_ITEM(argstuple, (Py_ssize_t)i, args[i]);
+    s1_is_unicode = PyUnicode_CheckExact(s1);
+    s2_is_unicode = PyUnicode_CheckExact(s2);
+#if PY_MAJOR_VERSION < 3
+    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
+        owned_ref = PyUnicode_FromObject(s2);
+        if (unlikely(!owned_ref))
+            return -1;
+        s2 = owned_ref;
+        s2_is_unicode = 1;
+    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
+        owned_ref = PyUnicode_FromObject(s1);
+        if (unlikely(!owned_ref))
+            return -1;
+        s1 = owned_ref;
+        s1_is_unicode = 1;
+    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
+        return __Pyx_PyBytes_Equals(s1, s2, equals);
     }
-    result = __Pyx_PyObject_Call(func, argstuple, kwargs);
-    Py_DECREF(argstuple);
-    return result;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t _nargs, PyObject *kwargs) {
-    Py_ssize_t nargs = __Pyx_PyVectorcall_NARGS(_nargs);
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (nargs == 0 && kwargs == NULL) {
-#if defined(__Pyx_CyFunction_USED) && defined(NDEBUG)
-        if (__Pyx_IsCyOrPyCFunction(func))
-#else
-        if (PyCFunction_Check(func))
 #endif
-        {
-            if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
-                return __Pyx_PyObject_CallMethO(func, NULL);
-            }
+    if (s1_is_unicode & s2_is_unicode) {
+        Py_ssize_t length;
+        int kind;
+        void *data1, *data2;
+        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
+            return -1;
+        length = __Pyx_PyUnicode_GET_LENGTH(s1);
+        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
+            goto return_ne;
         }
-    }
-    else if (nargs == 1 && kwargs == NULL) {
-        if (PyCFunction_Check(func))
+#if CYTHON_USE_UNICODE_INTERNALS
         {
-            if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
-                return __Pyx_PyObject_CallMethO(func, args[0]);
+            Py_hash_t hash1, hash2;
+        #if CYTHON_PEP393_ENABLED
+            hash1 = ((PyASCIIObject*)s1)->hash;
+            hash2 = ((PyASCIIObject*)s2)->hash;
+        #else
+            hash1 = ((PyUnicodeObject*)s1)->hash;
+            hash2 = ((PyUnicodeObject*)s2)->hash;
+        #endif
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                goto return_ne;
             }
         }
-    }
 #endif
-    #if PY_VERSION_HEX < 0x030800B1
-    #if CYTHON_FAST_PYCCALL
-    if (PyCFunction_Check(func)) {
-        if (kwargs) {
-            return _PyCFunction_FastCallDict(func, args, nargs, kwargs);
+        kind = __Pyx_PyUnicode_KIND(s1);
+        if (kind != __Pyx_PyUnicode_KIND(s2)) {
+            goto return_ne;
+        }
+        data1 = __Pyx_PyUnicode_DATA(s1);
+        data2 = __Pyx_PyUnicode_DATA(s2);
+        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
+            goto return_ne;
+        } else if (length == 1) {
+            goto return_eq;
         } else {
-            return _PyCFunction_FastCallKeywords(func, args, nargs, NULL);
+            int result = memcmp(data1, data2, (size_t)(length * kind));
+            #if PY_MAJOR_VERSION < 3
+            Py_XDECREF(owned_ref);
+            #endif
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
         }
+    } else if ((s1 == Py_None) & s2_is_unicode) {
+        goto return_ne;
+    } else if ((s2 == Py_None) & s1_is_unicode) {
+        goto return_ne;
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-    #if PY_VERSION_HEX >= 0x030700A1
-    if (!kwargs && __Pyx_IS_TYPE(func, &PyMethodDescr_Type)) {
-        return _PyMethodDescr_FastCallKeywords(func, args, nargs, NULL);
-    }
-    #endif
-    #endif
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs);
-    }
-    #endif
+return_eq:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
     #endif
-    #if CYTHON_VECTORCALL
-    vectorcallfunc f = _PyVectorcall_Function(func);
-    if (f) {
-        return f(func, args, (size_t)nargs, kwargs);
-    }
-    #elif defined(__Pyx_CyFunction_USED) && CYTHON_BACKPORT_VECTORCALL
-    if (__Pyx_CyFunction_CheckExact(func)) {
-        __pyx_vectorcallfunc f = __Pyx_CyFunction_func_vectorcall(func);
-        if (f) return f(func, args, (size_t)nargs, kwargs);
-    }
+    return (equals == Py_EQ);
+return_ne:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
     #endif
-    if (nargs == 0) {
-        return __Pyx_PyObject_Call(func, __pyx_empty_tuple, kwargs);
-    }
-    return __Pyx_PyObject_FastCall_fallback(func, args, (size_t)nargs, kwargs);
-}
-
-/* RaiseUnexpectedTypeError */
-static int
-__Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj)
-{
-    __Pyx_TypeName obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError, "Expected %s, got " __Pyx_FMT_TYPENAME,
-                 expected, obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    return 0;
-}
-
-/* CIntToDigits */
-static const char DIGIT_PAIRS_10[2*10*10+1] = {
-    "00010203040506070809"
-    "10111213141516171819"
-    "20212223242526272829"
-    "30313233343536373839"
-    "40414243444546474849"
-    "50515253545556575859"
-    "60616263646566676869"
-    "70717273747576777879"
-    "80818283848586878889"
-    "90919293949596979899"
-};
-static const char DIGIT_PAIRS_8[2*8*8+1] = {
-    "0001020304050607"
-    "1011121314151617"
-    "2021222324252627"
-    "3031323334353637"
-    "4041424344454647"
-    "5051525354555657"
-    "6061626364656667"
-    "7071727374757677"
-};
-static const char DIGITS_HEX[2*16+1] = {
-    "0123456789abcdef"
-    "0123456789ABCDEF"
-};
-
-/* BuildPyUnicode */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char) {
-    PyObject *uval;
-    Py_ssize_t uoffset = ulength - clength;
-#if CYTHON_USE_UNICODE_INTERNALS
-    Py_ssize_t i;
-#if CYTHON_PEP393_ENABLED
-    void *udata;
-    uval = PyUnicode_New(ulength, 127);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_DATA(uval);
-#else
-    Py_UNICODE *udata;
-    uval = PyUnicode_FromUnicode(NULL, ulength);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_AS_UNICODE(uval);
-#endif
-    if (uoffset > 0) {
-        i = 0;
-        if (prepend_sign) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, 0, '-');
-            i++;
-        }
-        for (; i < uoffset; i++) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, i, padding_char);
-        }
-    }
-    for (i=0; i < clength; i++) {
-        __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, uoffset+i, chars[i]);
-    }
-#else
-    {
-        PyObject *sign = NULL, *padding = NULL;
-        uval = NULL;
-        if (uoffset > 0) {
-            prepend_sign = !!prepend_sign;
-            if (uoffset > prepend_sign) {
-                padding = PyUnicode_FromOrdinal(padding_char);
-                if (likely(padding) && uoffset > prepend_sign + 1) {
-                    PyObject *tmp;
-                    PyObject *repeat = PyInt_FromSsize_t(uoffset - prepend_sign);
-                    if (unlikely(!repeat)) goto done_or_error;
-                    tmp = PyNumber_Multiply(padding, repeat);
-                    Py_DECREF(repeat);
-                    Py_DECREF(padding);
-                    padding = tmp;
-                }
-                if (unlikely(!padding)) goto done_or_error;
-            }
-            if (prepend_sign) {
-                sign = PyUnicode_FromOrdinal('-');
-                if (unlikely(!sign)) goto done_or_error;
-            }
-        }
-        uval = PyUnicode_DecodeASCII(chars, clength, NULL);
-        if (likely(uval) && padding) {
-            PyObject *tmp = PyNumber_Add(padding, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-        if (likely(uval) && sign) {
-            PyObject *tmp = PyNumber_Add(sign, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-done_or_error:
-        Py_XDECREF(padding);
-        Py_XDECREF(sign);
-    }
-#endif
-    return uval;
-}
-
-/* CIntToPyUnicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_int(int value, Py_ssize_t width, char padding_char, char format_char) {
-    char digits[sizeof(int)*3+2];
-    char *dpos, *end = digits + sizeof(int)*3+2;
-    const char *hex_digits = DIGITS_HEX;
-    Py_ssize_t length, ulength;
-    int prepend_sign, last_one_off;
-    int remaining;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
+    return (equals == Py_NE);
 #endif
-    const int is_unsigned = neg_one > const_zero;
-    if (format_char == 'X') {
-        hex_digits += 16;
-        format_char = 'x';
-    }
-    remaining = value;
-    last_one_off = 0;
-    dpos = end;
-    do {
-        int digit_pos;
-        switch (format_char) {
-        case 'o':
-            digit_pos = abs((int)(remaining % (8*8)));
-            remaining = (int) (remaining / (8*8));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 8);
-            break;
-        case 'd':
-            digit_pos = abs((int)(remaining % (10*10)));
-            remaining = (int) (remaining / (10*10));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 10);
-            break;
-        case 'x':
-            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
-            remaining = (int) (remaining / 16);
-            break;
-        default:
-            assert(0);
-            break;
-        }
-    } while (unlikely(remaining != 0));
-    assert(!last_one_off || *dpos == '0');
-    dpos += last_one_off;
-    length = end - dpos;
-    ulength = length;
-    prepend_sign = 0;
-    if (!is_unsigned && value <= neg_one) {
-        if (padding_char == ' ' || width <= length + 1) {
-            *(--dpos) = '-';
-            ++length;
-        } else {
-            prepend_sign = 1;
-        }
-        ++ulength;
-    }
-    if (width > ulength) {
-        ulength = width;
-    }
-    if (ulength == 1) {
-        return PyUnicode_FromOrdinal(*dpos);
-    }
-    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
 }
 
-/* CIntToPyUnicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char) {
-    char digits[sizeof(Py_ssize_t)*3+2];
-    char *dpos, *end = digits + sizeof(Py_ssize_t)*3+2;
-    const char *hex_digits = DIGITS_HEX;
-    Py_ssize_t length, ulength;
-    int prepend_sign, last_one_off;
-    Py_ssize_t remaining;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const Py_ssize_t neg_one = (Py_ssize_t) -1, const_zero = (Py_ssize_t) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (format_char == 'X') {
-        hex_digits += 16;
-        format_char = 'x';
-    }
-    remaining = value;
-    last_one_off = 0;
-    dpos = end;
-    do {
-        int digit_pos;
-        switch (format_char) {
-        case 'o':
-            digit_pos = abs((int)(remaining % (8*8)));
-            remaining = (Py_ssize_t) (remaining / (8*8));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 8);
-            break;
-        case 'd':
-            digit_pos = abs((int)(remaining % (10*10)));
-            remaining = (Py_ssize_t) (remaining / (10*10));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 10);
-            break;
-        case 'x':
-            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
-            remaining = (Py_ssize_t) (remaining / 16);
-            break;
-        default:
-            assert(0);
-            break;
-        }
-    } while (unlikely(remaining != 0));
-    assert(!last_one_off || *dpos == '0');
-    dpos += last_one_off;
-    length = end - dpos;
-    ulength = length;
-    prepend_sign = 0;
-    if (!is_unsigned && value <= neg_one) {
-        if (padding_char == ' ' || width <= length + 1) {
-            *(--dpos) = '-';
-            ++length;
-        } else {
-            prepend_sign = 1;
-        }
-        ++ulength;
-    }
-    if (width > ulength) {
-        ulength = width;
-    }
-    if (ulength == 1) {
-        return PyUnicode_FromOrdinal(*dpos);
-    }
-    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
-}
-
-/* JoinPyUnicode */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char) {
-#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyObject *result_uval;
-    int result_ukind, kind_shift;
-    Py_ssize_t i, char_pos;
-    void *result_udata;
-    CYTHON_MAYBE_UNUSED_VAR(max_char);
-#if CYTHON_PEP393_ENABLED
-    result_uval = PyUnicode_New(result_ulength, max_char);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    kind_shift = (result_ukind == PyUnicode_4BYTE_KIND) ? 2 : result_ukind - 1;
-    result_udata = PyUnicode_DATA(result_uval);
-#else
-    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = sizeof(Py_UNICODE);
-    kind_shift = (result_ukind == 4) ? 2 : result_ukind - 1;
-    result_udata = PyUnicode_AS_UNICODE(result_uval);
-#endif
-    assert(kind_shift == 2 || kind_shift == 1 || kind_shift == 0);
-    char_pos = 0;
-    for (i=0; i < value_count; i++) {
-        int ukind;
-        Py_ssize_t ulength;
-        void *udata;
-        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
-        if (unlikely(__Pyx_PyUnicode_READY(uval)))
-            goto bad;
-        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
-        if (unlikely(!ulength))
-            continue;
-        if (unlikely((PY_SSIZE_T_MAX >> kind_shift) - ulength < char_pos))
-            goto overflow;
-        ukind = __Pyx_PyUnicode_KIND(uval);
-        udata = __Pyx_PyUnicode_DATA(uval);
-        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + (char_pos << kind_shift), udata, (size_t) (ulength << kind_shift));
-        } else {
-            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
-            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
-            #else
-            Py_ssize_t j;
-            for (j=0; j < ulength; j++) {
-                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
-                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
-            }
-            #endif
-        }
-        char_pos += ulength;
-    }
-    return result_uval;
-overflow:
-    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
-bad:
-    Py_DECREF(result_uval);
-    return NULL;
-#else
-    CYTHON_UNUSED_VAR(max_char);
-    CYTHON_UNUSED_VAR(result_ulength);
-    CYTHON_UNUSED_VAR(value_count);
-    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
-#endif
+/* None */
+static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
+    Py_ssize_t q = a / b;
+    Py_ssize_t r = a - q*b;
+    q -= ((r != 0) & ((r ^ b) < 0));
+    return q;
 }
 
 /* GetAttr */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
 #if CYTHON_USE_TYPE_SLOTS
 #if PY_MAJOR_VERSION >= 3
     if (likely(PyUnicode_Check(n)))
@@ -23024,322 +19807,116 @@
     if (likely(PyString_Check(n)))
 #endif
         return __Pyx_PyObject_GetAttrStr(o, n);
 #endif
     return PyObject_GetAttr(o, n);
 }
 
-/* GetItemInt */
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (unlikely(!j)) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyList_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyTuple_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
-                                                     CYTHON_NCP_UNUSED int wraparound,
-                                                     CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_subscript) {
-            PyObject *r, *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return NULL;
-            r = mm->mp_subscript(o, key);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return NULL;
-                    PyErr_Clear();
-                }
-            }
-            return sm->sq_item(o, i);
-        }
-    }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
-    }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-}
-
-/* PyObjectCallOneArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *args[2] = {NULL, arg};
-    return __Pyx_PyObject_FastCall(func, args+1, 1 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
 /* ObjectGetItem */
 #if CYTHON_USE_TYPE_SLOTS
-static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject *index) {
-    PyObject *runerr = NULL;
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr;
     Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
     key_value = __Pyx_PyIndex_AsSsize_t(index);
     if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
         return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
     }
     if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
-        __Pyx_TypeName index_type_name = __Pyx_PyType_GetName(Py_TYPE(index));
         PyErr_Clear();
-        PyErr_Format(PyExc_IndexError,
-            "cannot fit '" __Pyx_FMT_TYPENAME "' into an index-sized integer", index_type_name);
-        __Pyx_DECREF_TypeName(index_type_name);
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
     }
     return NULL;
 }
-static PyObject *__Pyx_PyObject_GetItem_Slow(PyObject *obj, PyObject *key) {
-    __Pyx_TypeName obj_type_name;
-    if (likely(PyType_Check(obj))) {
-        PyObject *meth = __Pyx_PyObject_GetAttrStrNoError(obj, __pyx_n_s_class_getitem);
-        if (meth) {
-            PyObject *result = __Pyx_PyObject_CallOneArg(meth, key);
-            Py_DECREF(meth);
-            return result;
-        }
-    }
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError,
-        "'" __Pyx_FMT_TYPENAME "' object is not subscriptable", obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    return NULL;
-}
-static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key) {
-    PyTypeObject *tp = Py_TYPE(obj);
-    PyMappingMethods *mm = tp->tp_as_mapping;
-    PySequenceMethods *sm = tp->tp_as_sequence;
-    if (likely(mm && mm->mp_subscript)) {
-        return mm->mp_subscript(obj, key);
-    }
-    if (likely(sm && sm->sq_item)) {
-        return __Pyx_PyObject_GetIndex(obj, key);
-    }
-    return __Pyx_PyObject_GetItem_Slow(obj, key);
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
 }
 #endif
 
-/* KeywordStringCheck */
-static int __Pyx_CheckKeywordStrings(
-    PyObject *kw,
-    const char* function_name,
-    int kw_allowed)
-{
-    PyObject* key = 0;
-    Py_ssize_t pos = 0;
-#if CYTHON_COMPILING_IN_PYPY
-    if (!kw_allowed && PyDict_Next(kw, &pos, &key, 0))
-        goto invalid_keyword;
-    return 1;
-#else
-    if (CYTHON_METH_FASTCALL && likely(PyTuple_Check(kw))) {
-        if (unlikely(PyTuple_GET_SIZE(kw) == 0))
-            return 1;
-        if (!kw_allowed) {
-            key = PyTuple_GET_ITEM(kw, 0);
-            goto invalid_keyword;
-        }
-#if PY_VERSION_HEX < 0x03090000
-        for (pos = 0; pos < PyTuple_GET_SIZE(kw); pos++) {
-            key = PyTuple_GET_ITEM(kw, pos);
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
+/* decode_c_string */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    Py_ssize_t length;
+    if (unlikely((start < 0) | (stop < 0))) {
+        size_t slen = strlen(cstring);
+        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "c-string too long to convert to Python");
+            return NULL;
         }
-#endif
-        return 1;
+        length = (Py_ssize_t) slen;
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    if (unlikely(stop <= start))
+        return __Pyx_NewRef(__pyx_empty_unicode);
+    length = stop - start;
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
     }
-    while (PyDict_Next(kw, &pos, &key, 0)) {
-        #if PY_MAJOR_VERSION < 3
-        if (unlikely(!PyString_Check(key)))
-        #endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
+}
+
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
     }
-    if (!kw_allowed && unlikely(key))
-        goto invalid_keyword;
-    return 1;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    return 0;
 #endif
-invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-    PyErr_Format(PyExc_TypeError,
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
     return 0;
 }
-
-/* DivInt[Py_ssize_t] */
-static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
-    Py_ssize_t q = a / b;
-    Py_ssize_t r = a - q*b;
-    q -= ((r != 0) & ((r ^ b) < 0));
-    return q;
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
 }
+#endif
 
 /* GetAttr3 */
 static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
         return NULL;
     __Pyx_PyErr_Clear();
     Py_INCREF(d);
     return d;
 }
 static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
-    PyObject *r;
-#if CYTHON_USE_TYPE_SLOTS
-    if (likely(PyString_Check(n))) {
-        r = __Pyx_PyObject_GetAttrStrNoError(o, n);
-        if (unlikely(!r) && likely(!PyErr_Occurred())) {
-            r = __Pyx_NewRef(d);
-        }
-        return r;
-    }
-#endif
-    r = PyObject_GetAttr(o, n);
+    PyObject *r = __Pyx_GetAttr(o, n);
     return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
 }
 
-/* PyDictVersioning */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
-    PyObject **dictptr = NULL;
-    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
-    if (offset) {
-#if CYTHON_COMPILING_IN_CPYTHON
-        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
-#else
-        dictptr = _PyObject_GetDictPtr(obj);
-#endif
-    }
-    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
-}
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
-        return 0;
-    return obj_dict_version == __Pyx_get_object_dict_version(obj);
-}
-#endif
-
-/* GetModuleGlobalName */
-#if CYTHON_USE_DICT_VERSIONS
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
-#else
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
-#endif
-{
-    PyObject *result;
-#if !CYTHON_AVOID_BORROWED_REFS
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
-    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    } else if (unlikely(PyErr_Occurred())) {
-        return NULL;
-    }
-#elif CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(!__pyx_m)) {
-        return NULL;
-    }
-    result = PyObject_GetAttr(__pyx_m, name);
-    if (likely(result)) {
-        return result;
-    }
-#else
-    result = PyDict_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-#endif
-#else
-    result = PyObject_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-    PyErr_Clear();
-#endif
-    return __Pyx_GetBuiltinName(name);
-}
-
 /* RaiseTooManyValuesToUnpack */
 static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
     PyErr_Format(PyExc_ValueError,
                  "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
 }
 
 /* RaiseNeedMoreValuesToUnpack */
@@ -23352,90 +19929,58 @@
 /* RaiseNoneIterError */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
 /* ExtTypeTest */
 static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    __Pyx_TypeName obj_type_name;
-    __Pyx_TypeName type_name;
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     if (likely(__Pyx_TypeCheck(obj, type)))
         return 1;
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    type_name = __Pyx_PyType_GetName(type);
-    PyErr_Format(PyExc_TypeError,
-                 "Cannot convert " __Pyx_FMT_TYPENAME " to " __Pyx_FMT_TYPENAME,
-                 obj_type_name, type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    __Pyx_DECREF_TypeName(type_name);
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
 }
 
 /* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
+#if CYTHON_USE_EXC_INFO_STACK
 static _PyErr_StackItem *
 __Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
 {
     _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_value == NULL || exc_info->exc_value == Py_None) &&
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
            exc_info->previous_item != NULL)
     {
         exc_info = exc_info->previous_item;
     }
     return exc_info;
 }
 #endif
 
 /* SaveResetException */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    PyObject *exc_value = exc_info->exc_value;
-    if (exc_value == NULL || exc_value == Py_None) {
-        *value = NULL;
-        *type = NULL;
-        *tb = NULL;
-    } else {
-        *value = exc_value;
-        Py_INCREF(*value);
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        *tb = PyException_GetTraceback(exc_value);
-    }
-  #elif CYTHON_USE_EXC_INFO_STACK
+    #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
     *type = exc_info->exc_type;
     *value = exc_info->exc_value;
     *tb = exc_info->exc_traceback;
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-  #else
+    #else
     *type = tstate->exc_type;
     *value = tstate->exc_value;
     *tb = tstate->exc_traceback;
+    #endif
     Py_XINCREF(*type);
     Py_XINCREF(*value);
     Py_XINCREF(*tb);
-  #endif
 }
 static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    PyObject *tmp_value = exc_info->exc_value;
-    exc_info->exc_value = value;
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-  #else
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = tstate->exc_info;
     tmp_type = exc_info->exc_type;
     tmp_value = exc_info->exc_value;
     tmp_tb = exc_info->exc_traceback;
     exc_info->exc_type = type;
@@ -23448,51 +19993,38 @@
     tstate->exc_type = type;
     tstate->exc_value = value;
     tstate->exc_traceback = tb;
     #endif
     Py_XDECREF(tmp_type);
     Py_XDECREF(tmp_value);
     Py_XDECREF(tmp_tb);
-  #endif
 }
 #endif
 
 /* GetException */
 #if CYTHON_FAST_THREAD_STATE
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
 #endif
 {
-    PyObject *local_type = NULL, *local_value, *local_tb = NULL;
+    PyObject *local_type, *local_value, *local_tb;
 #if CYTHON_FAST_THREAD_STATE
     PyObject *tmp_type, *tmp_value, *tmp_tb;
-  #if PY_VERSION_HEX >= 0x030C00A6
-    local_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    if (likely(local_value)) {
-        local_type = (PyObject*) Py_TYPE(local_value);
-        Py_INCREF(local_type);
-        local_tb = PyException_GetTraceback(local_value);
-    }
-  #else
     local_type = tstate->curexc_type;
     local_value = tstate->curexc_value;
     local_tb = tstate->curexc_traceback;
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
-  #endif
 #else
     PyErr_Fetch(&local_type, &local_value, &local_tb);
 #endif
     PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE && PY_VERSION_HEX >= 0x030C00A6
-    if (unlikely(tstate->current_exception))
-#elif CYTHON_FAST_THREAD_STATE
+#if CYTHON_FAST_THREAD_STATE
     if (unlikely(tstate->curexc_type))
 #else
     if (unlikely(PyErr_Occurred()))
 #endif
         goto bad;
     #if PY_MAJOR_VERSION >= 3
     if (local_tb) {
@@ -23506,29 +20038,20 @@
     *type = local_type;
     *value = local_value;
     *tb = local_tb;
 #if CYTHON_FAST_THREAD_STATE
     #if CYTHON_USE_EXC_INFO_STACK
     {
         _PyErr_StackItem *exc_info = tstate->exc_info;
-      #if PY_VERSION_HEX >= 0x030B00a4
-        tmp_value = exc_info->exc_value;
-        exc_info->exc_value = local_value;
-        tmp_type = NULL;
-        tmp_tb = NULL;
-        Py_XDECREF(local_type);
-        Py_XDECREF(local_tb);
-      #else
         tmp_type = exc_info->exc_type;
         tmp_value = exc_info->exc_value;
         tmp_tb = exc_info->exc_traceback;
         exc_info->exc_type = local_type;
         exc_info->exc_value = local_value;
         exc_info->exc_traceback = local_tb;
-      #endif
     }
     #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = local_type;
     tstate->exc_value = local_value;
@@ -23551,49 +20074,30 @@
     return -1;
 }
 
 /* SwapException */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_value = exc_info->exc_value;
-    exc_info->exc_value = *value;
-    if (tmp_value == NULL || tmp_value == Py_None) {
-        Py_XDECREF(tmp_value);
-        tmp_value = NULL;
-        tmp_type = NULL;
-        tmp_tb = NULL;
-    } else {
-        tmp_type = (PyObject*) Py_TYPE(tmp_value);
-        Py_INCREF(tmp_type);
-        #if CYTHON_COMPILING_IN_CPYTHON
-        tmp_tb = ((PyBaseExceptionObject*) tmp_value)->traceback;
-        Py_XINCREF(tmp_tb);
-        #else
-        tmp_tb = PyException_GetTraceback(tmp_value);
-        #endif
-    }
-  #elif CYTHON_USE_EXC_INFO_STACK
+    #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = tstate->exc_info;
     tmp_type = exc_info->exc_type;
     tmp_value = exc_info->exc_value;
     tmp_tb = exc_info->exc_traceback;
     exc_info->exc_type = *type;
     exc_info->exc_value = *value;
     exc_info->exc_traceback = *tb;
-  #else
+    #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = *type;
     tstate->exc_value = *value;
     tstate->exc_traceback = *tb;
-  #endif
+    #endif
     *type = tmp_type;
     *value = tmp_value;
     *tb = tmp_tb;
 }
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
@@ -23603,223 +20107,82 @@
     *value = tmp_value;
     *tb = tmp_tb;
 }
 #endif
 
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
     PyObject *module = 0;
+    PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
-    PyObject *empty_list = 0;
+    PyObject *list;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
     py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
-    if (unlikely(!py_import))
+    if (!py_import)
         goto bad;
-    if (!from_list) {
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
         empty_list = PyList_New(0);
-        if (unlikely(!empty_list))
+        if (!empty_list)
             goto bad;
-        from_list = empty_list;
+        list = empty_list;
     }
-    #endif
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
     empty_dict = PyDict_New();
-    if (unlikely(!empty_dict))
+    if (!empty_dict)
         goto bad;
     {
         #if PY_MAJOR_VERSION >= 3
         if (level == -1) {
             if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
-                #if CYTHON_COMPILING_IN_LIMITED_API
                 module = PyImport_ImportModuleLevelObject(
-                    name, empty_dict, empty_dict, from_list, 1);
-                #else
-                module = PyImport_ImportModuleLevelObject(
-                    name, __pyx_d, empty_dict, from_list, 1);
-                #endif
-                if (unlikely(!module)) {
-                    if (unlikely(!PyErr_ExceptionMatches(PyExc_ImportError)))
+                    name, global_dict, empty_dict, list, 1);
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                         goto bad;
                     PyErr_Clear();
                 }
             }
             level = 0;
         }
         #endif
         if (!module) {
             #if PY_MAJOR_VERSION < 3
             PyObject *py_level = PyInt_FromLong(level);
-            if (unlikely(!py_level))
+            if (!py_level)
                 goto bad;
             module = PyObject_CallFunctionObjArgs(py_import,
-                name, __pyx_d, empty_dict, from_list, py_level, (PyObject *)NULL);
+                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
             Py_DECREF(py_level);
             #else
-            #if CYTHON_COMPILING_IN_LIMITED_API
             module = PyImport_ImportModuleLevelObject(
-                name, empty_dict, empty_dict, from_list, level);
-            #else
-            module = PyImport_ImportModuleLevelObject(
-                name, __pyx_d, empty_dict, from_list, level);
-            #endif
+                name, global_dict, empty_dict, list, level);
             #endif
         }
     }
 bad:
-    Py_XDECREF(empty_dict);
-    Py_XDECREF(empty_list);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_import);
     #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
     return module;
 }
 
-/* ImportDottedModule */
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Error(PyObject *name, PyObject *parts_tuple, Py_ssize_t count) {
-    PyObject *partial_name = NULL, *slice = NULL, *sep = NULL;
-    if (unlikely(PyErr_Occurred())) {
-        PyErr_Clear();
-    }
-    if (likely(PyTuple_GET_SIZE(parts_tuple) == count)) {
-        partial_name = name;
-    } else {
-        slice = PySequence_GetSlice(parts_tuple, 0, count);
-        if (unlikely(!slice))
-            goto bad;
-        sep = PyUnicode_FromStringAndSize(".", 1);
-        if (unlikely(!sep))
-            goto bad;
-        partial_name = PyUnicode_Join(sep, slice);
-    }
-    PyErr_Format(
-#if PY_MAJOR_VERSION < 3
-        PyExc_ImportError,
-        "No module named '%s'", PyString_AS_STRING(partial_name));
-#else
-#if PY_VERSION_HEX >= 0x030600B1
-        PyExc_ModuleNotFoundError,
-#else
-        PyExc_ImportError,
-#endif
-        "No module named '%U'", partial_name);
-#endif
-bad:
-    Py_XDECREF(sep);
-    Py_XDECREF(slice);
-    Py_XDECREF(partial_name);
-    return NULL;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Lookup(PyObject *name) {
-    PyObject *imported_module;
-#if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-    PyObject *modules = PyImport_GetModuleDict();
-    if (unlikely(!modules))
-        return NULL;
-    imported_module = __Pyx_PyDict_GetItemStr(modules, name);
-    Py_XINCREF(imported_module);
-#else
-    imported_module = PyImport_GetModule(name);
-#endif
-    return imported_module;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple) {
-    Py_ssize_t i, nparts;
-    nparts = PyTuple_GET_SIZE(parts_tuple);
-    for (i=1; i < nparts && module; i++) {
-        PyObject *part, *submodule;
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        part = PyTuple_GET_ITEM(parts_tuple, i);
-#else
-        part = PySequence_ITEM(parts_tuple, i);
-#endif
-        submodule = __Pyx_PyObject_GetAttrStrNoError(module, part);
-#if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-        Py_DECREF(part);
-#endif
-        Py_DECREF(module);
-        module = submodule;
-    }
-    if (unlikely(!module)) {
-        return __Pyx__ImportDottedModule_Error(name, parts_tuple, i);
-    }
-    return module;
-}
-#endif
-static PyObject *__Pyx__ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if PY_MAJOR_VERSION < 3
-    PyObject *module, *from_list, *star = __pyx_n_s__3;
-    CYTHON_UNUSED_VAR(parts_tuple);
-    from_list = PyList_New(1);
-    if (unlikely(!from_list))
-        return NULL;
-    Py_INCREF(star);
-    PyList_SET_ITEM(from_list, 0, star);
-    module = __Pyx_Import(name, from_list, 0);
-    Py_DECREF(from_list);
-    return module;
-#else
-    PyObject *imported_module;
-    PyObject *module = __Pyx_Import(name, NULL, 0);
-    if (!parts_tuple || unlikely(!module))
-        return module;
-    imported_module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(imported_module)) {
-        Py_DECREF(module);
-        return imported_module;
-    }
-    PyErr_Clear();
-    return __Pyx_ImportDottedModule_WalkParts(module, name, parts_tuple);
-#endif
-}
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030400B1
-    PyObject *module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(module)) {
-        PyObject *spec = __Pyx_PyObject_GetAttrStrNoError(module, __pyx_n_s_spec);
-        if (likely(spec)) {
-            PyObject *unsafe = __Pyx_PyObject_GetAttrStrNoError(spec, __pyx_n_s_initializing);
-            if (likely(!unsafe || !__Pyx_PyObject_IsTrue(unsafe))) {
-                Py_DECREF(spec);
-                spec = NULL;
-            }
-            Py_XDECREF(unsafe);
-        }
-        if (likely(!spec)) {
-            PyErr_Clear();
-            return module;
-        }
-        Py_DECREF(spec);
-        Py_DECREF(module);
-    } else if (PyErr_Occurred()) {
-        PyErr_Clear();
-    }
-#endif
-    return __Pyx__ImportDottedModule(name, parts_tuple);
-}
-
-/* ssize_strlen */
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s) {
-    size_t len = strlen(s);
-    if (unlikely(len > PY_SSIZE_T_MAX)) {
-        PyErr_SetString(PyExc_OverflowError, "byte string is too long");
-        return -1;
-    }
-    return (Py_ssize_t) len;
-}
-
 /* FastTypeChecks */
 #if CYTHON_COMPILING_IN_CPYTHON
 static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
     while (a) {
-        a = __Pyx_PyType_GetSlot(a, tp_base, PyTypeObject*);
+        a = a->tp_base;
         if (a == b)
             return 1;
     }
     return b == &PyBaseObject_Type;
 }
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
     PyObject *mro;
@@ -23832,30 +20195,14 @@
             if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                 return 1;
         }
         return 0;
     }
     return __Pyx_InBases(a, b);
 }
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b) {
-    PyObject *mro;
-    if (cls == a || cls == b) return 1;
-    mro = cls->tp_mro;
-    if (likely(mro)) {
-        Py_ssize_t i, n;
-        n = PyTuple_GET_SIZE(mro);
-        for (i = 0; i < n; i++) {
-            PyObject *base = PyTuple_GET_ITEM(mro, i);
-            if (base == (PyObject *)a || base == (PyObject *)b)
-                return 1;
-        }
-        return 0;
-    }
-    return __Pyx_InBases(cls, a) || __Pyx_InBases(cls, b);
-}
 #if PY_MAJOR_VERSION == 2
 static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
     PyObject *exception, *value, *tb;
     int res;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ErrFetch(&exception, &value, &tb);
@@ -23872,19 +20219,19 @@
         }
     }
     __Pyx_ErrRestore(exception, value, tb);
     return res;
 }
 #else
 static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    if (exc_type1) {
-        return __Pyx_IsAnySubtype2((PyTypeObject*)err, (PyTypeObject*)exc_type1, (PyTypeObject*)exc_type2);
-    } else {
-        return __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
+    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
+    if (!res) {
+        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
     }
+    return res;
 }
 #endif
 static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
     Py_ssize_t i, n;
     assert(PyExceptionClass_Check(exc_type));
     n = PyTuple_GET_SIZE(tuple);
 #if PY_MAJOR_VERSION >= 3
@@ -23923,139 +20270,147 @@
     if (likely(PyExceptionClass_Check(err))) {
         return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
     }
     return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
 }
 #endif
 
-/* PySequenceMultiply */
-static PyObject* __Pyx_PySequence_Multiply_Generic(PyObject *seq, Py_ssize_t mul) {
-    PyObject *result, *pymul = PyInt_FromSsize_t(mul);
-    if (unlikely(!pymul))
-        return NULL;
-    result = PyNumber_Multiply(seq, pymul);
-    Py_DECREF(pymul);
-    return result;
-}
-static CYTHON_INLINE PyObject* __Pyx_PySequence_Multiply(PyObject *seq, Py_ssize_t mul) {
-#if CYTHON_USE_TYPE_SLOTS
-    PyTypeObject *type = Py_TYPE(seq);
-    if (likely(type->tp_as_sequence && type->tp_as_sequence->sq_repeat)) {
-        return type->tp_as_sequence->sq_repeat(seq, mul);
-    } else
-#endif
-    {
-        return __Pyx_PySequence_Multiply_Generic(seq, mul);
+/* PyIntBinop */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, int inplace, int zerodivision_check) {
+    (void)inplace;
+    (void)zerodivision_check;
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_CheckExact(op1))) {
+        const long b = intval;
+        long x;
+        long a = PyInt_AS_LONG(op1);
+            x = (long)((unsigned long)a + b);
+            if (likely((x^a) >= 0 || (x^b) >= 0))
+                return PyInt_FromLong(x);
+            return PyLong_Type.tp_as_number->nb_add(op1, op2);
     }
-}
-
-/* SetItemInt */
-static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
-    int r;
-    if (unlikely(!j)) return -1;
-    r = PyObject_SetItem(o, j, v);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
-                                               CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = (!wraparound) ? i : ((likely(i >= 0)) ? i : i + PyList_GET_SIZE(o));
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o)))) {
-            PyObject* old = PyList_GET_ITEM(o, n);
-            Py_INCREF(v);
-            PyList_SET_ITEM(o, n, v);
-            Py_DECREF(old);
-            return 1;
-        }
-    } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_ass_subscript) {
-            int r;
-            PyObject *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return -1;
-            r = mm->mp_ass_subscript(o, key, v);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_ass_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return -1;
-                    PyErr_Clear();
-                }
+    #endif
+    #if CYTHON_USE_PYLONG_INTERNALS
+    if (likely(PyLong_CheckExact(op1))) {
+        const long b = intval;
+        long a, x;
+#ifdef HAVE_LONG_LONG
+        const PY_LONG_LONG llb = intval;
+        PY_LONG_LONG lla, llx;
+#endif
+        const digit* digits = ((PyLongObject*)op1)->ob_digit;
+        const Py_ssize_t size = Py_SIZE(op1);
+        if (likely(__Pyx_sst_abs(size) <= 1)) {
+            a = likely(size) ? digits[0] : 0;
+            if (size == -1) a = -a;
+        } else {
+            switch (size) {
+                case -2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
             }
-            return sm->sq_ass_item(o, i, v);
         }
-    }
-#else
-#if CYTHON_COMPILING_IN_PYPY
-    if (is_list || (PySequence_Check(o) && !PyDict_Check(o)))
-#else
-    if (is_list || PySequence_Check(o))
+                x = a + b;
+            return PyLong_FromLong(x);
+#ifdef HAVE_LONG_LONG
+        long_long:
+                llx = lla + llb;
+            return PyLong_FromLongLong(llx);
 #endif
-    {
-        return PySequence_SetItem(o, i, v);
+        
+        
     }
-#endif
-    return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
+    #endif
+    if (PyFloat_CheckExact(op1)) {
+        const long b = intval;
+        double a = PyFloat_AS_DOUBLE(op1);
+            double result;
+            PyFPE_START_PROTECT("add", return NULL)
+            result = ((double)a) + (double)b;
+            PyFPE_END_PROTECT(result)
+            return PyFloat_FromDouble(result);
+    }
+    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
 }
+#endif
 
-/* RaiseUnboundLocalError */
+/* None */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
-/* DivInt[long] */
-static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
-    long q = a / b;
-    long r = a - q*b;
-    q -= ((r != 0) & ((r ^ b) < 0));
-    return q;
-}
-
 /* ImportFrom */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
     PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
     if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        const char* module_name_str = 0;
-        PyObject* module_name = 0;
-        PyObject* module_dot = 0;
-        PyObject* full_name = 0;
-        PyErr_Clear();
-        module_name_str = PyModule_GetName(module);
-        if (unlikely(!module_name_str)) { goto modbad; }
-        module_name = PyUnicode_FromString(module_name_str);
-        if (unlikely(!module_name)) { goto modbad; }
-        module_dot = PyUnicode_Concat(module_name, __pyx_kp_u__2);
-        if (unlikely(!module_dot)) { goto modbad; }
-        full_name = PyUnicode_Concat(module_dot, name);
-        if (unlikely(!full_name)) { goto modbad; }
-        #if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-        {
-            PyObject *modules = PyImport_GetModuleDict();
-            if (unlikely(!modules))
-                goto modbad;
-            value = PyObject_GetItem(modules, full_name);
-        }
-        #else
-        value = PyImport_GetModule(full_name);
-        #endif
-      modbad:
-        Py_XDECREF(full_name);
-        Py_XDECREF(module_dot);
-        Py_XDECREF(module_name);
-    }
-    if (unlikely(!value)) {
         PyErr_Format(PyExc_ImportError,
         #if PY_MAJOR_VERSION < 3
             "cannot import name %.230s", PyString_AS_STRING(name));
         #else
             "cannot import name %S", name);
         #endif
     }
@@ -24067,66 +20422,34 @@
     PyObject *r;
     if (unlikely(!__Pyx_PyBaseString_Check(n))) {
         PyErr_SetString(PyExc_TypeError,
                         "hasattr(): attribute name must be string");
         return -1;
     }
     r = __Pyx_GetAttr(o, n);
-    if (!r) {
+    if (unlikely(!r)) {
         PyErr_Clear();
         return 0;
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 
-/* pep479 */
-static void __Pyx_Generator_Replace_StopIteration(int in_async_gen) {
-    PyObject *exc, *val, *tb, *cur_exc;
-    __Pyx_PyThreadState_declare
-    #ifdef __Pyx_StopAsyncIteration_USED
-    int is_async_stopiteration = 0;
-    #endif
-    CYTHON_MAYBE_UNUSED_VAR(in_async_gen);
-    cur_exc = PyErr_Occurred();
-    if (likely(!__Pyx_PyErr_GivenExceptionMatches(cur_exc, PyExc_StopIteration))) {
-        #ifdef __Pyx_StopAsyncIteration_USED
-        if (in_async_gen && unlikely(__Pyx_PyErr_GivenExceptionMatches(cur_exc, __Pyx_PyExc_StopAsyncIteration))) {
-            is_async_stopiteration = 1;
-        } else
-        #endif
-            return;
-    }
-    __Pyx_PyThreadState_assign
-    __Pyx_GetException(&exc, &val, &tb);
-    Py_XDECREF(exc);
-    Py_XDECREF(val);
-    Py_XDECREF(tb);
-    PyErr_SetString(PyExc_RuntimeError,
-        #ifdef __Pyx_StopAsyncIteration_USED
-        is_async_stopiteration ? "async generator raised StopAsyncIteration" :
-        in_async_gen ? "async generator raised StopIteration" :
-        #endif
-        "generator raised StopIteration");
-}
-
 /* PyObject_GenericGetAttrNoDict */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
-    __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, attr_name);
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, attr_name);
 #else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(attr_name));
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(attr_name));
 #endif
-    __Pyx_DECREF_TypeName(type_name);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
     PyObject *descr;
     PyTypeObject *tp = Py_TYPE(obj);
     if (unlikely(!PyString_Check(attr_name))) {
         return PyObject_GenericGetAttr(obj, attr_name);
@@ -24158,431 +20481,59 @@
     if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
         return PyObject_GenericGetAttr(obj, attr_name);
     }
     return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
 }
 #endif
 
-/* FixUpExtensionType */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
-#if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    CYTHON_UNUSED_VAR(spec);
-    CYTHON_UNUSED_VAR(type);
-#else
-    const PyType_Slot *slot = spec->slots;
-    while (slot && slot->slot && slot->slot != Py_tp_members)
-        slot++;
-    if (slot && slot->slot == Py_tp_members) {
-        int changed = 0;
-#if !(PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON)
-        const
-#endif
-            PyMemberDef *memb = (PyMemberDef*) slot->pfunc;
-        while (memb && memb->name) {
-            if (memb->name[0] == '_' && memb->name[1] == '_') {
-#if PY_VERSION_HEX < 0x030900b1
-                if (strcmp(memb->name, "__weaklistoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_weaklistoffset = memb->offset;
-                    changed = 1;
-                }
-                else if (strcmp(memb->name, "__dictoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_dictoffset = memb->offset;
-                    changed = 1;
-                }
-#if CYTHON_METH_FASTCALL
-                else if (strcmp(memb->name, "__vectorcalloffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-#if PY_VERSION_HEX >= 0x030800b4
-                    type->tp_vectorcall_offset = memb->offset;
-#else
-                    type->tp_print = (printfunc) memb->offset;
-#endif
-                    changed = 1;
-                }
-#endif
-#else
-                if ((0));
-#endif
-#if PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON
-                else if (strcmp(memb->name, "__module__") == 0) {
-                    PyObject *descr;
-                    assert(memb->type == T_OBJECT);
-                    assert(memb->flags == 0 || memb->flags == READONLY);
-                    descr = PyDescr_NewMember(type, memb);
-                    if (unlikely(!descr))
-                        return -1;
-                    if (unlikely(PyDict_SetItem(type->tp_dict, PyDescr_NAME(descr), descr) < 0)) {
-                        Py_DECREF(descr);
-                        return -1;
-                    }
-                    Py_DECREF(descr);
-                    changed = 1;
-                }
-#endif
-            }
-            memb++;
-        }
-        if (changed)
-            PyType_Modified(type);
-    }
-#endif
-    return 0;
-}
-#endif
-
-/* PyObjectCallNoArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
-    PyObject *arg = NULL;
-    return __Pyx_PyObject_FastCall(func, (&arg)+1, 0 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
-/* PyObjectGetMethod */
-static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
-    PyObject *attr;
-#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
-    __Pyx_TypeName type_name;
-    PyTypeObject *tp = Py_TYPE(obj);
-    PyObject *descr;
-    descrgetfunc f = NULL;
-    PyObject **dictptr, *dict;
-    int meth_found = 0;
-    assert (*method == NULL);
-    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
-        attr = __Pyx_PyObject_GetAttrStr(obj, name);
-        goto try_unpack;
-    }
-    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
-        return 0;
-    }
-    descr = _PyType_Lookup(tp, name);
-    if (likely(descr != NULL)) {
-        Py_INCREF(descr);
-#if defined(Py_TPFLAGS_METHOD_DESCRIPTOR) && Py_TPFLAGS_METHOD_DESCRIPTOR
-        if (__Pyx_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR))
-#elif PY_MAJOR_VERSION >= 3
-        #ifdef __Pyx_CyFunction_USED
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
-        #else
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type)))
-        #endif
-#else
-        #ifdef __Pyx_CyFunction_USED
-        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
-        #else
-        if (likely(PyFunction_Check(descr)))
-        #endif
-#endif
-        {
-            meth_found = 1;
-        } else {
-            f = Py_TYPE(descr)->tp_descr_get;
-            if (f != NULL && PyDescr_IsData(descr)) {
-                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
-                Py_DECREF(descr);
-                goto try_unpack;
-            }
-        }
-    }
-    dictptr = _PyObject_GetDictPtr(obj);
-    if (dictptr != NULL && (dict = *dictptr) != NULL) {
-        Py_INCREF(dict);
-        attr = __Pyx_PyDict_GetItemStr(dict, name);
-        if (attr != NULL) {
-            Py_INCREF(attr);
-            Py_DECREF(dict);
-            Py_XDECREF(descr);
-            goto try_unpack;
-        }
-        Py_DECREF(dict);
-    }
-    if (meth_found) {
-        *method = descr;
-        return 1;
-    }
-    if (f != NULL) {
-        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
-        Py_DECREF(descr);
-        goto try_unpack;
-    }
-    if (likely(descr != NULL)) {
-        *method = descr;
-        return 0;
-    }
-    type_name = __Pyx_PyType_GetName(tp);
-    PyErr_Format(PyExc_AttributeError,
-#if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, name);
-#else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(name));
-#endif
-    __Pyx_DECREF_TypeName(type_name);
-    return 0;
-#else
-    attr = __Pyx_PyObject_GetAttrStr(obj, name);
-    goto try_unpack;
-#endif
-try_unpack:
-#if CYTHON_UNPACK_METHODS
-    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
-        PyObject *function = PyMethod_GET_FUNCTION(attr);
-        Py_INCREF(function);
-        Py_DECREF(attr);
-        *method = function;
-        return 1;
-    }
-#endif
-    *method = attr;
-    return 0;
-}
-
-/* PyObjectCallMethod0 */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
-    PyObject *method = NULL, *result = NULL;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_CallOneArg(method, obj);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) goto bad;
-    result = __Pyx_PyObject_CallNoArg(method);
-    Py_DECREF(method);
-bad:
-    return result;
-}
-
-/* ValidateBasesTuple */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
-    Py_ssize_t i, n = PyTuple_GET_SIZE(bases);
-    for (i = 1; i < n; i++)
-    {
-        PyObject *b0 = PyTuple_GET_ITEM(bases, i);
-        PyTypeObject *b;
-#if PY_MAJOR_VERSION < 3
-        if (PyClass_Check(b0))
-        {
-            PyErr_Format(PyExc_TypeError, "base class '%.200s' is an old-style class",
-                         PyString_AS_STRING(((PyClassObject*)b0)->cl_name));
-            return -1;
-        }
-#endif
-        b = (PyTypeObject*) b0;
-        if (!__Pyx_PyType_HasFeature(b, Py_TPFLAGS_HEAPTYPE))
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "base class '" __Pyx_FMT_TYPENAME "' is not a heap type", b_name);
-            __Pyx_DECREF_TypeName(b_name);
-            return -1;
-        }
-        if (dictoffset == 0 && b->tp_dictoffset)
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "extension type '%.200s' has no __dict__ slot, "
-                "but base type '" __Pyx_FMT_TYPENAME "' has: "
-                "either add 'cdef dict __dict__' to the extension type "
-                "or add '__slots__ = [...]' to the base type",
-                type_name, b_name);
-            __Pyx_DECREF_TypeName(b_name);
-            return -1;
-        }
-    }
-    return 0;
-}
-#endif
-
-/* PyType_Ready */
-static int __Pyx_PyType_Ready(PyTypeObject *t) {
-#if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
-    (void)__Pyx_PyObject_CallMethod0;
-#if CYTHON_USE_TYPE_SPECS
-    (void)__Pyx_validate_bases_tuple;
-#endif
-    return PyType_Ready(t);
-#else
-    int r;
-    PyObject *bases = __Pyx_PyType_GetSlot(t, tp_bases, PyObject*);
-    if (bases && unlikely(__Pyx_validate_bases_tuple(t->tp_name, t->tp_dictoffset, bases) == -1))
-        return -1;
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-    {
-        int gc_was_enabled;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        gc_was_enabled = PyGC_Disable();
-        (void)__Pyx_PyObject_CallMethod0;
-    #else
-        PyObject *ret, *py_status;
-        PyObject *gc = NULL;
-        #if PY_VERSION_HEX >= 0x030700a1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM+0 >= 0x07030400)
-        gc = PyImport_GetModule(__pyx_kp_u_gc);
-        #endif
-        if (unlikely(!gc)) gc = PyImport_Import(__pyx_kp_u_gc);
-        if (unlikely(!gc)) return -1;
-        py_status = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_isenabled);
-        if (unlikely(!py_status)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-        gc_was_enabled = __Pyx_PyObject_IsTrue(py_status);
-        Py_DECREF(py_status);
-        if (gc_was_enabled > 0) {
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_disable);
-            if (unlikely(!ret)) {
-                Py_DECREF(gc);
-                return -1;
-            }
-            Py_DECREF(ret);
-        } else if (unlikely(gc_was_enabled == -1)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-    #endif
-        t->tp_flags |= Py_TPFLAGS_HEAPTYPE;
-#if PY_VERSION_HEX >= 0x030A0000
-        t->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;
-#endif
-#else
-        (void)__Pyx_PyObject_CallMethod0;
-#endif
-    r = PyType_Ready(t);
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-        t->tp_flags &= ~Py_TPFLAGS_HEAPTYPE;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        if (gc_was_enabled)
-            PyGC_Enable();
-    #else
-        if (gc_was_enabled) {
-            PyObject *tp, *v, *tb;
-            PyErr_Fetch(&tp, &v, &tb);
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_enable);
-            if (likely(ret || r == -1)) {
-                Py_XDECREF(ret);
-                PyErr_Restore(tp, v, tb);
-            } else {
-                Py_XDECREF(tp);
-                Py_XDECREF(v);
-                Py_XDECREF(tb);
-                r = -1;
-            }
-        }
-        Py_DECREF(gc);
-    #endif
-    }
-#endif
-    return r;
-#endif
-}
-
 /* SetVTable */
-static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000
     PyObject *ob = PyCapsule_New(vtable, 0, 0);
-    if (unlikely(!ob))
-        goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
 #else
-    if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
 #endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
         goto bad;
     Py_DECREF(ob);
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
-/* GetVTable */
-static void* __Pyx_GetVtable(PyTypeObject *type) {
-    void* ptr;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
-#else
-    PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
-#endif
-    if (!ob)
-        goto bad;
-    ptr = PyCapsule_GetPointer(ob, 0);
-    if (!ptr && !PyErr_Occurred())
-        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
-    Py_DECREF(ob);
-    return ptr;
-bad:
-    Py_XDECREF(ob);
-    return NULL;
+/* PyObjectGetAttrStrNoError */
+static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        __Pyx_PyErr_Clear();
 }
-
-/* MergeVTables */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type) {
-    int i;
-    void** base_vtables;
-    __Pyx_TypeName tp_base_name;
-    __Pyx_TypeName base_name;
-    void* unknown = (void*)-1;
-    PyObject* bases = type->tp_bases;
-    int base_depth = 0;
-    {
-        PyTypeObject* base = type->tp_base;
-        while (base) {
-            base_depth += 1;
-            base = base->tp_base;
-        }
-    }
-    base_vtables = (void**) malloc(sizeof(void*) * (size_t)(base_depth + 1));
-    base_vtables[0] = unknown;
-    for (i = 1; i < PyTuple_GET_SIZE(bases); i++) {
-        void* base_vtable = __Pyx_GetVtable(((PyTypeObject*)PyTuple_GET_ITEM(bases, i)));
-        if (base_vtable != NULL) {
-            int j;
-            PyTypeObject* base = type->tp_base;
-            for (j = 0; j < base_depth; j++) {
-                if (base_vtables[j] == unknown) {
-                    base_vtables[j] = __Pyx_GetVtable(base);
-                    base_vtables[j + 1] = unknown;
-                }
-                if (base_vtables[j] == base_vtable) {
-                    break;
-                } else if (base_vtables[j] == NULL) {
-                    goto bad;
-                }
-                base = base->tp_base;
-            }
-        }
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
+        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
     }
-    PyErr_Clear();
-    free(base_vtables);
-    return 0;
-bad:
-    tp_base_name = __Pyx_PyType_GetName(type->tp_base);
-    base_name = __Pyx_PyType_GetName((PyTypeObject*)PyTuple_GET_ITEM(bases, i));
-    PyErr_Format(PyExc_TypeError,
-        "multiple bases have vtable conflict: '" __Pyx_FMT_TYPENAME "' and '" __Pyx_FMT_TYPENAME "'", tp_base_name, base_name);
-    __Pyx_DECREF_TypeName(tp_base_name);
-    __Pyx_DECREF_TypeName(base_name);
-    free(base_vtables);
-    return -1;
-}
 #endif
+    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
+    if (unlikely(!result)) {
+        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+    }
+    return result;
+}
 
 /* SetupReduce */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
   int ret;
   PyObject *name_attr;
-  name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name_2);
+  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name_2);
   if (likely(name_attr)) {
       ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
   } else {
       ret = -1;
   }
   if (unlikely(ret < 0)) {
       PyErr_Clear();
@@ -24590,43 +20541,25 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
 #if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
+    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -24640,15 +20573,15 @@
             reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
             if (likely(reduce_cython)) {
                 ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
             } else if (reduce == object_reduce || PyErr_Occurred()) {
                 goto __PYX_BAD;
             }
-            setstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate);
+            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
             if (!setstate) PyErr_Clear();
             if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                 setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
                 if (likely(setstate_cython)) {
                     ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                     ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 } else if (!setstate || PyErr_Occurred()) {
@@ -24656,1132 +20589,73 @@
                 }
             }
             PyType_Modified((PyTypeObject*)type_obj);
         }
     }
     goto __PYX_GOOD;
 __PYX_BAD:
-    if (!PyErr_Occurred()) {
-        __Pyx_TypeName type_obj_name =
-            __Pyx_PyType_GetName((PyTypeObject*)type_obj);
-        PyErr_Format(PyExc_RuntimeError,
-            "Unable to initialize pickling for " __Pyx_FMT_TYPENAME, type_obj_name);
-        __Pyx_DECREF_TypeName(type_obj_name);
-    }
+    if (!PyErr_Occurred())
+        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
-#endif
-
-/* FetchSharedCythonModule */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
-    PyObject *abi_module = PyImport_AddModule((char*) __PYX_ABI_MODULE_NAME);
-    if (unlikely(!abi_module)) return NULL;
-    Py_INCREF(abi_module);
-    return abi_module;
-}
-
-/* FetchCommonType */
-static int __Pyx_VerifyCachedType(PyObject *cached_type,
-                               const char *name,
-                               Py_ssize_t basicsize,
-                               Py_ssize_t expected_basicsize) {
-    if (!PyType_Check(cached_type)) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s is not a type object", name);
-        return -1;
-    }
-    if (basicsize != expected_basicsize) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s has the wrong size, try recompiling",
-            name);
-        return -1;
-    }
-    return 0;
-}
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
-    PyObject* abi_module;
-    const char* object_name;
-    PyTypeObject *cached_type = NULL;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    object_name = strrchr(type->tp_name, '.');
-    object_name = object_name ? object_name+1 : type->tp_name;
-    cached_type = (PyTypeObject*) PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        if (__Pyx_VerifyCachedType(
-              (PyObject *)cached_type,
-              object_name,
-              cached_type->tp_basicsize,
-              type->tp_basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    if (PyType_Ready(type) < 0) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, (PyObject *)type) < 0)
-        goto bad;
-    Py_INCREF(type);
-    cached_type = type;
-done:
-    Py_DECREF(abi_module);
-    return cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#else
-static PyTypeObject *__Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases) {
-    PyObject *abi_module, *cached_type = NULL;
-    const char* object_name = strrchr(spec->name, '.');
-    object_name = object_name ? object_name+1 : spec->name;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    cached_type = PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        Py_ssize_t basicsize;
-#if CYTHON_COMPILING_IN_LIMITED_API
-        PyObject *py_basicsize;
-        py_basicsize = PyObject_GetAttrString(cached_type, "__basicsize__");
-        if (unlikely(!py_basicsize)) goto bad;
-        basicsize = PyLong_AsSsize_t(py_basicsize);
-        Py_DECREF(py_basicsize);
-        py_basicsize = 0;
-        if (unlikely(basicsize == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
-#else
-        basicsize = likely(PyType_Check(cached_type)) ? ((PyTypeObject*) cached_type)->tp_basicsize : -1;
-#endif
-        if (__Pyx_VerifyCachedType(
-              cached_type,
-              object_name,
-              basicsize,
-              spec->basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    CYTHON_UNUSED_VAR(module);
-    cached_type = __Pyx_PyType_FromModuleAndSpec(abi_module, spec, bases);
-    if (unlikely(!cached_type)) goto bad;
-    if (unlikely(__Pyx_fix_up_extension_type_from_spec(spec, (PyTypeObject *) cached_type) < 0)) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, cached_type) < 0) goto bad;
-done:
-    Py_DECREF(abi_module);
-    assert(cached_type == NULL || PyType_Check(cached_type));
-    return (PyTypeObject *) cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#endif
-
-/* PyVectorcallFastCallDict */
-#if CYTHON_METH_FASTCALL
-static PyObject *__Pyx_PyVectorcall_FastCallDict_kw(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    PyObject *res = NULL;
-    PyObject *kwnames;
-    PyObject **newargs;
-    PyObject **kwvalues;
-    Py_ssize_t i, pos;
-    size_t j;
-    PyObject *key, *value;
-    unsigned long keys_are_strings;
-    Py_ssize_t nkw = PyDict_GET_SIZE(kw);
-    newargs = (PyObject **)PyMem_Malloc((nargs + (size_t)nkw) * sizeof(args[0]));
-    if (unlikely(newargs == NULL)) {
-        PyErr_NoMemory();
-        return NULL;
-    }
-    for (j = 0; j < nargs; j++) newargs[j] = args[j];
-    kwnames = PyTuple_New(nkw);
-    if (unlikely(kwnames == NULL)) {
-        PyMem_Free(newargs);
-        return NULL;
-    }
-    kwvalues = newargs + nargs;
-    pos = i = 0;
-    keys_are_strings = Py_TPFLAGS_UNICODE_SUBCLASS;
-    while (PyDict_Next(kw, &pos, &key, &value)) {
-        keys_are_strings &= Py_TYPE(key)->tp_flags;
-        Py_INCREF(key);
-        Py_INCREF(value);
-        PyTuple_SET_ITEM(kwnames, i, key);
-        kwvalues[i] = value;
-        i++;
-    }
-    if (unlikely(!keys_are_strings)) {
-        PyErr_SetString(PyExc_TypeError, "keywords must be strings");
-        goto cleanup;
-    }
-    res = vc(func, newargs, nargs, kwnames);
-cleanup:
-    Py_DECREF(kwnames);
-    for (i = 0; i < nkw; i++)
-        Py_DECREF(kwvalues[i]);
-    PyMem_Free(newargs);
-    return res;
-}
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    if (likely(kw == NULL) || PyDict_GET_SIZE(kw) == 0) {
-        return vc(func, args, nargs, NULL);
-    }
-    return __Pyx_PyVectorcall_FastCallDict_kw(func, vc, args, nargs, kw);
-}
-#endif
-
-/* CythonFunctionShared */
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj) {
-#if PY_VERSION_HEX < 0x030900B1
-    __Pyx_Py_XDECREF_SET(
-        __Pyx_CyFunction_GetClassObj(f),
-            ((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#else
-    __Pyx_Py_XDECREF_SET(
-        ((PyCMethodObject *) (f))->mm_class,
-        (PyTypeObject*)((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#endif
-}
-static PyObject *
-__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, void *closure)
-{
-    CYTHON_UNUSED_VAR(closure);
-    if (unlikely(op->func_doc == NULL)) {
-        if (((PyCFunctionObject*)op)->m_ml->ml_doc) {
-#if PY_MAJOR_VERSION >= 3
-            op->func_doc = PyUnicode_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#else
-            op->func_doc = PyString_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#endif
-            if (unlikely(op->func_doc == NULL))
-                return NULL;
-        } else {
-            Py_INCREF(Py_None);
-            return Py_None;
-        }
-    }
-    Py_INCREF(op->func_doc);
-    return op->func_doc;
-}
-static int
-__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (value == NULL) {
-        value = Py_None;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_doc, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_name == NULL)) {
-#if PY_MAJOR_VERSION >= 3
-        op->func_name = PyUnicode_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#else
-        op->func_name = PyString_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#endif
-        if (unlikely(op->func_name == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_name);
-    return op->func_name;
-}
-static int
-__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__name__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_name, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_qualname);
-    return op->func_qualname;
-}
-static int
-__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__qualname__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_qualname, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_dict == NULL)) {
-        op->func_dict = PyDict_New();
-        if (unlikely(op->func_dict == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_dict);
-    return op->func_dict;
-}
-static int
-__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(value == NULL)) {
-        PyErr_SetString(PyExc_TypeError,
-               "function's dictionary may not be deleted");
-        return -1;
-    }
-    if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-               "setting function's dictionary to a non-dict");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_dict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_globals);
-    return op->func_globals;
-}
-static PyObject *
-__Pyx_CyFunction_get_closure(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(op);
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-static PyObject *
-__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, void *context)
-{
-    PyObject* result = (op->func_code) ? op->func_code : Py_None;
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
-    int result = 0;
-    PyObject *res = op->defaults_getter((PyObject *) op);
-    if (unlikely(!res))
-        return -1;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
-    Py_INCREF(op->defaults_tuple);
-    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
-    Py_INCREF(op->defaults_kwdict);
-    #else
-    op->defaults_tuple = PySequence_ITEM(res, 0);
-    if (unlikely(!op->defaults_tuple)) result = -1;
-    else {
-        op->defaults_kwdict = PySequence_ITEM(res, 1);
-        if (unlikely(!op->defaults_kwdict)) result = -1;
-    }
-    #endif
-    Py_DECREF(res);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyTuple_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__defaults__ must be set to a tuple object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__defaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_tuple, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_tuple;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_tuple;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__kwdefaults__ must be set to a dict object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__kwdefaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_kwdict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_kwdict;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_kwdict;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value || value == Py_None) {
-        value = NULL;
-    } else if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__annotations__ must be set to a dict object");
-        return -1;
-    }
-    Py_XINCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_annotations, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->func_annotations;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        result = PyDict_New();
-        if (unlikely(!result)) return NULL;
-        op->func_annotations = result;
-    }
-    Py_INCREF(result);
-    return result;
-}
-static PyObject *
-__Pyx_CyFunction_get_is_coroutine(__pyx_CyFunctionObject *op, void *context) {
-    int is_coroutine;
-    CYTHON_UNUSED_VAR(context);
-    if (op->func_is_coroutine) {
-        return __Pyx_NewRef(op->func_is_coroutine);
-    }
-    is_coroutine = op->flags & __Pyx_CYFUNCTION_COROUTINE;
-#if PY_VERSION_HEX >= 0x03050000
-    if (is_coroutine) {
-        PyObject *module, *fromlist, *marker = __pyx_n_s_is_coroutine;
-        fromlist = PyList_New(1);
-        if (unlikely(!fromlist)) return NULL;
-        Py_INCREF(marker);
-        PyList_SET_ITEM(fromlist, 0, marker);
-        module = PyImport_ImportModuleLevelObject(__pyx_n_s_asyncio_coroutines, NULL, NULL, fromlist, 0);
-        Py_DECREF(fromlist);
-        if (unlikely(!module)) goto ignore;
-        op->func_is_coroutine = __Pyx_PyObject_GetAttrStr(module, marker);
-        Py_DECREF(module);
-        if (likely(op->func_is_coroutine)) {
-            return __Pyx_NewRef(op->func_is_coroutine);
-        }
-ignore:
-        PyErr_Clear();
-    }
-#endif
-    op->func_is_coroutine = __Pyx_PyBool_FromLong(is_coroutine);
-    return __Pyx_NewRef(op->func_is_coroutine);
-}
-static PyGetSetDef __pyx_CyFunction_getsets[] = {
-    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
-    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
-    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
-    {(char *) "_is_coroutine", (getter)__Pyx_CyFunction_get_is_coroutine, 0, 0, 0},
-    {0, 0, 0, 0, 0}
-};
-static PyMemberDef __pyx_CyFunction_members[] = {
-    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), 0, 0},
-#if CYTHON_USE_TYPE_SPECS
-    {(char *) "__dictoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_dict), READONLY, 0},
-#if CYTHON_METH_FASTCALL
-#if CYTHON_BACKPORT_VECTORCALL
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_vectorcall), READONLY, 0},
-#else
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(PyCFunctionObject, vectorcall), READONLY, 0},
-#endif
-#endif
-#if PY_VERSION_HEX < 0x030500A0
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_weakreflist), READONLY, 0},
-#else
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(PyCFunctionObject, m_weakreflist), READONLY, 0},
-#endif
-#endif
-    {0, 0, 0,  0, 0}
-};
-static PyObject *
-__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, PyObject *args)
-{
-    CYTHON_UNUSED_VAR(args);
-#if PY_MAJOR_VERSION >= 3
-    Py_INCREF(m->func_qualname);
-    return m->func_qualname;
-#else
-    return PyString_FromString(((PyCFunctionObject*)m)->m_ml->ml_name);
-#endif
-}
-static PyMethodDef __pyx_CyFunction_methods[] = {
-    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
-    {0, 0, 0, 0}
-};
-#if PY_VERSION_HEX < 0x030500A0
-#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
-#else
-#define __Pyx_CyFunction_weakreflist(cyfunc) (((PyCFunctionObject*)cyfunc)->m_weakreflist)
-#endif
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
-                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyCFunctionObject *cf = (PyCFunctionObject*) op;
-    if (unlikely(op == NULL))
-        return NULL;
-    op->flags = flags;
-    __Pyx_CyFunction_weakreflist(op) = NULL;
-    cf->m_ml = ml;
-    cf->m_self = (PyObject *) op;
-    Py_XINCREF(closure);
-    op->func_closure = closure;
-    Py_XINCREF(module);
-    cf->m_module = module;
-    op->func_dict = NULL;
-    op->func_name = NULL;
-    Py_INCREF(qualname);
-    op->func_qualname = qualname;
-    op->func_doc = NULL;
-#if PY_VERSION_HEX < 0x030900B1
-    op->func_classobj = NULL;
-#else
-    ((PyCMethodObject*)op)->mm_class = NULL;
-#endif
-    op->func_globals = globals;
-    Py_INCREF(op->func_globals);
-    Py_XINCREF(code);
-    op->func_code = code;
-    op->defaults_pyobjects = 0;
-    op->defaults_size = 0;
-    op->defaults = NULL;
-    op->defaults_tuple = NULL;
-    op->defaults_kwdict = NULL;
-    op->defaults_getter = NULL;
-    op->func_annotations = NULL;
-    op->func_is_coroutine = NULL;
-#if CYTHON_METH_FASTCALL
-    switch (ml->ml_flags & (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS | METH_METHOD)) {
-    case METH_NOARGS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_NOARGS;
-        break;
-    case METH_O:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_O;
-        break;
-    case METH_METHOD | METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD;
-        break;
-    case METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS;
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = NULL;
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        Py_DECREF(op);
-        return NULL;
-    }
-#endif
-    return (PyObject *) op;
-}
-static int
-__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
-{
-    Py_CLEAR(m->func_closure);
-    Py_CLEAR(((PyCFunctionObject*)m)->m_module);
-    Py_CLEAR(m->func_dict);
-    Py_CLEAR(m->func_name);
-    Py_CLEAR(m->func_qualname);
-    Py_CLEAR(m->func_doc);
-    Py_CLEAR(m->func_globals);
-    Py_CLEAR(m->func_code);
-#if PY_VERSION_HEX < 0x030900B1
-    Py_CLEAR(__Pyx_CyFunction_GetClassObj(m));
-#else
-    {
-        PyObject *cls = (PyObject*) ((PyCMethodObject *) (m))->mm_class;
-        ((PyCMethodObject *) (m))->mm_class = NULL;
-        Py_XDECREF(cls);
-    }
-#endif
-    Py_CLEAR(m->defaults_tuple);
-    Py_CLEAR(m->defaults_kwdict);
-    Py_CLEAR(m->func_annotations);
-    Py_CLEAR(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_XDECREF(pydefaults[i]);
-        PyObject_Free(m->defaults);
-        m->defaults = NULL;
-    }
-    return 0;
-}
-static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    if (__Pyx_CyFunction_weakreflist(m) != NULL)
-        PyObject_ClearWeakRefs((PyObject *) m);
-    __Pyx_CyFunction_clear(m);
-    __Pyx_PyHeapTypeObject_GC_Del(m);
-}
-static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    PyObject_GC_UnTrack(m);
-    __Pyx__CyFunction_dealloc(m);
-}
-static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
-{
-    Py_VISIT(m->func_closure);
-    Py_VISIT(((PyCFunctionObject*)m)->m_module);
-    Py_VISIT(m->func_dict);
-    Py_VISIT(m->func_name);
-    Py_VISIT(m->func_qualname);
-    Py_VISIT(m->func_doc);
-    Py_VISIT(m->func_globals);
-    Py_VISIT(m->func_code);
-    Py_VISIT(__Pyx_CyFunction_GetClassObj(m));
-    Py_VISIT(m->defaults_tuple);
-    Py_VISIT(m->defaults_kwdict);
-    Py_VISIT(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_VISIT(pydefaults[i]);
-    }
-    return 0;
-}
-static PyObject*
-__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
-{
-#if PY_MAJOR_VERSION >= 3
-    return PyUnicode_FromFormat("<cyfunction %U at %p>",
-                                op->func_qualname, (void *)op);
-#else
-    return PyString_FromFormat("<cyfunction %s at %p>",
-                               PyString_AsString(op->func_qualname), (void *)op);
-#endif
-}
-static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
-    PyCFunctionObject* f = (PyCFunctionObject*)func;
-    PyCFunction meth = f->m_ml->ml_meth;
-    Py_ssize_t size;
-    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
-    case METH_VARARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0))
-            return (*meth)(self, arg);
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
-    case METH_NOARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 0))
-                return (*meth)(self, NULL);
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    case METH_O:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 1)) {
-                PyObject *result, *arg0;
-                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-                arg0 = PyTuple_GET_ITEM(arg, 0);
-                #else
-                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
-                #endif
-                result = (*meth)(self, arg0);
-                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-                Py_DECREF(arg0);
-                #endif
-                return result;
-            }
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        return NULL;
-    }
-    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
-                 f->m_ml->ml_name);
-    return NULL;
-}
-static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
-}
-static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
-    PyObject *result;
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
-#if CYTHON_METH_FASTCALL
-     __pyx_vectorcallfunc vc = __Pyx_CyFunction_func_vectorcall(cyfunc);
-    if (vc) {
-#if CYTHON_ASSUME_SAFE_MACROS
-        return __Pyx_PyVectorcall_FastCallDict(func, vc, &PyTuple_GET_ITEM(args, 0), (size_t)PyTuple_GET_SIZE(args), kw);
-#else
-        (void) &__Pyx_PyVectorcall_FastCallDict;
-        return PyVectorcall_Call(func, args, kw);
-#endif
-    }
-#endif
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        Py_ssize_t argc;
-        PyObject *new_args;
-        PyObject *self;
-        argc = PyTuple_GET_SIZE(args);
-        new_args = PyTuple_GetSlice(args, 1, argc);
-        if (unlikely(!new_args))
-            return NULL;
-        self = PyTuple_GetItem(args, 0);
-        if (unlikely(!self)) {
-            Py_DECREF(new_args);
-#if PY_MAJOR_VERSION > 2
-            PyErr_Format(PyExc_TypeError,
-                         "unbound method %.200S() needs an argument",
-                         cyfunc->func_qualname);
-#else
-            PyErr_SetString(PyExc_TypeError,
-                            "unbound method needs an argument");
-#endif
-            return NULL;
-        }
-        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
-        Py_DECREF(new_args);
-    } else {
-        result = __Pyx_CyFunction_Call(func, args, kw);
-    }
-    return result;
-}
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE int __Pyx_CyFunction_Vectorcall_CheckArgs(__pyx_CyFunctionObject *cyfunc, Py_ssize_t nargs, PyObject *kwnames)
-{
-    int ret = 0;
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        if (unlikely(nargs < 1)) {
-            PyErr_Format(PyExc_TypeError, "%.200s() needs an argument",
-                         ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-            return -1;
-        }
-        ret = 1;
-    }
-    if (unlikely(kwnames) && unlikely(PyTuple_GET_SIZE(kwnames))) {
-        PyErr_Format(PyExc_TypeError,
-                     "%.200s() takes no keyword arguments", ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-        return -1;
-    }
-    return ret;
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 0)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, NULL);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 1)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, args[0]);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-    PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((__Pyx_PyCMethod)(void(*)(void))def->ml_meth)(self, cls, args, (size_t)nargs, kwnames);
-}
-#endif
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_CyFunctionType_slots[] = {
-    {Py_tp_dealloc, (void *)__Pyx_CyFunction_dealloc},
-    {Py_tp_repr, (void *)__Pyx_CyFunction_repr},
-    {Py_tp_call, (void *)__Pyx_CyFunction_CallAsMethod},
-    {Py_tp_traverse, (void *)__Pyx_CyFunction_traverse},
-    {Py_tp_clear, (void *)__Pyx_CyFunction_clear},
-    {Py_tp_methods, (void *)__pyx_CyFunction_methods},
-    {Py_tp_members, (void *)__pyx_CyFunction_members},
-    {Py_tp_getset, (void *)__pyx_CyFunction_getsets},
-    {Py_tp_descr_get, (void *)__Pyx_PyMethod_New},
-    {0, 0},
-};
-static PyType_Spec __pyx_CyFunctionType_spec = {
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#if (defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL)
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    __pyx_CyFunctionType_slots
-};
-#else
-static PyTypeObject __pyx_CyFunctionType_type = {
-    PyVarObject_HEAD_INIT(0, 0)
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-    (destructor) __Pyx_CyFunction_dealloc,
-#if !CYTHON_METH_FASTCALL
-    0,
-#elif CYTHON_BACKPORT_VECTORCALL
-    (printfunc)offsetof(__pyx_CyFunctionObject, func_vectorcall),
-#else
-    offsetof(PyCFunctionObject, vectorcall),
-#endif
-    0,
-    0,
-#if PY_MAJOR_VERSION < 3
-    0,
-#else
-    0,
-#endif
-    (reprfunc) __Pyx_CyFunction_repr,
-    0,
-    0,
-    0,
-    0,
-    __Pyx_CyFunction_CallAsMethod,
-    0,
-    0,
-    0,
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#ifdef _Py_TPFLAGS_HAVE_VECTORCALL
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    0,
-    (traverseproc) __Pyx_CyFunction_traverse,
-    (inquiry) __Pyx_CyFunction_clear,
-    0,
-#if PY_VERSION_HEX < 0x030500A0
-    offsetof(__pyx_CyFunctionObject, func_weakreflist),
-#else
-    offsetof(PyCFunctionObject, m_weakreflist),
-#endif
-    0,
-    0,
-    __pyx_CyFunction_methods,
-    __pyx_CyFunction_members,
-    __pyx_CyFunction_getsets,
-    0,
-    0,
-    __Pyx_PyMethod_New,
-    0,
-    offsetof(__pyx_CyFunctionObject, func_dict),
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-#if PY_VERSION_HEX >= 0x030400a1
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-    0,
-#endif
-#if __PYX_NEED_TP_PRINT_SLOT
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030C0000
-    0,
-#endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-    0,
-#endif
-};
-#endif
-static int __pyx_CyFunction_init(PyObject *module) {
-#if CYTHON_USE_TYPE_SPECS
-    __pyx_CyFunctionType = __Pyx_FetchCommonTypeFromSpec(module, &__pyx_CyFunctionType_spec, NULL);
-#else
-    CYTHON_UNUSED_VAR(module);
-    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
-#endif
-    if (unlikely(__pyx_CyFunctionType == NULL)) {
-        return -1;
-    }
-    return 0;
-}
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults = PyObject_Malloc(size);
-    if (unlikely(!m->defaults))
-        return PyErr_NoMemory();
-    memset(m->defaults, 0, size);
-    m->defaults_pyobjects = pyobjects;
-    m->defaults_size = size;
-    return m->defaults;
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_tuple = tuple;
-    Py_INCREF(tuple);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_kwdict = dict;
-    Py_INCREF(dict);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->func_annotations = dict;
-    Py_INCREF(dict);
-}
-
-/* CythonFunction */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
-                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyObject *op = __Pyx_CyFunction_Init(
-        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
-        ml, flags, qualname, closure, module, globals, code
-    );
-    if (likely(op)) {
-        PyObject_GC_Track(op);
-    }
-    return op;
-}
 
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
-    CYTHON_MAYBE_UNUSED_VAR(tstate);
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
     }
     __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
 #if CYTHON_COMPILING_IN_CPYTHON
     cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
     if (likely(cython_runtime_dict)) {
         __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
             use_cline, *cython_runtime_dict,
             __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
     } else
 #endif
     {
-      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStrNoError(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
+      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
       if (use_cline_obj) {
         use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
         Py_DECREF(use_cline_obj);
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
-        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
     else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
@@ -25852,118 +20726,84 @@
         entries[i] = entries[i-1];
     }
     entries[pos].code_line = code_line;
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
-#endif
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    if (c_line) {
-        (void) __pyx_cfilenm;
-        (void) __Pyx_CLineForTraceback(__Pyx_PyThreadState_Current, c_line);
-    }
-    _PyTraceback_Add(funcname, filename, py_line);
-}
-#else
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
-    PyCodeObject *py_code = NULL;
-    PyObject *py_funcname = NULL;
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
     #if PY_MAJOR_VERSION < 3
-    PyObject *py_srcfile = NULL;
     py_srcfile = PyString_FromString(filename);
-    if (!py_srcfile) goto bad;
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
     #endif
+    if (!py_srcfile) goto bad;
     if (c_line) {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
         #else
         py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        funcname = PyUnicode_AsUTF8(py_funcname);
-        if (!funcname) goto bad;
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
-        if (!py_funcname) goto bad;
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
-    #if PY_MAJOR_VERSION < 3
+    if (!py_funcname) goto bad;
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
-        0,
         __pyx_empty_bytes, /*PyObject *code,*/
         __pyx_empty_tuple, /*PyObject *consts,*/
         __pyx_empty_tuple, /*PyObject *names,*/
         __pyx_empty_tuple, /*PyObject *varnames,*/
         __pyx_empty_tuple, /*PyObject *freevars,*/
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
-    #else
-    py_code = PyCode_NewEmpty(filename, funcname, py_line);
-    #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    Py_DECREF(py_funcname);
     return py_code;
 bad:
-    Py_XDECREF(py_funcname);
-    #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
-    #endif
+    Py_XDECREF(py_funcname);
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        if (!py_code) goto bad;
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -25971,27 +20811,21 @@
     if (!py_frame) goto bad;
     __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
     PyTraceBack_Here(py_frame);
 bad:
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
-#endif
 
 #if PY_MAJOR_VERSION < 3
 static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
-    __Pyx_TypeName obj_type_name;
     if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
         if (__Pyx_TypeCheck(obj, __pyx_array_type)) return __pyx_array_getbuffer(obj, view, flags);
         if (__Pyx_TypeCheck(obj, __pyx_memoryview_type)) return __pyx_memoryview_getbuffer(obj, view, flags);
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError,
-                 "'" __Pyx_FMT_TYPENAME "' does not have the buffer interface",
-                 obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
+    PyErr_Format(PyExc_TypeError, "'%.200s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
     return -1;
 }
 static void __Pyx_ReleaseBuffer(Py_buffer *view) {
     PyObject *obj = view->obj;
     if (!obj) return;
     if (PyObject_CheckBuffer(obj)) {
         PyBuffer_Release(view);
@@ -26058,14 +20892,27 @@
 {
     void *start1, *end1, *start2, *end2;
     __pyx_get_array_memory_extents(slice1, &start1, &end1, ndim, itemsize);
     __pyx_get_array_memory_extents(slice2, &start2, &end2, ndim, itemsize);
     return (start1 < end2) && (start2 < end1);
 }
 
+/* Capsule */
+static CYTHON_INLINE PyObject *
+__pyx_capsule_create(void *p, CYTHON_UNUSED const char *sig)
+{
+    PyObject *cobj;
+#if PY_VERSION_HEX >= 0x02070000
+    cobj = PyCapsule_New(p, sig, NULL);
+#else
+    cobj = PyCObject_FromVoidPtr(p, NULL);
+#endif
+    return cobj;
+}
+
 /* IsLittleEndian */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
 {
   union {
     uint32_t u32;
     uint8_t u8[4];
   } S;
@@ -26145,15 +20992,15 @@
     case 'd': return (is_complex ? "'complex double'" : "'double'");
     case 'g': return (is_complex ? "'complex long double'" : "'long double'");
     case 'T': return "a struct";
     case 'O': return "Python object";
     case 'P': return "a pointer";
     case 's': case 'p': return "a string";
     case 0: return "end";
-    default: return "unparsable format string";
+    default: return "unparseable format string";
   }
 }
 static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return 2;
     case 'i': case 'I': case 'l': case 'L': return 4;
@@ -26195,16 +21042,15 @@
 typedef struct { char c; float x; } __Pyx_st_float;
 typedef struct { char c; double x; } __Pyx_st_double;
 typedef struct { char c; long double x; } __Pyx_st_longdouble;
 typedef struct { char c; void *x; } __Pyx_st_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, CYTHON_UNUSED int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
@@ -26228,16 +21074,15 @@
 typedef struct { float x; char c; } __Pyx_pad_float;
 typedef struct { double x; char c; } __Pyx_pad_double;
 typedef struct { long double x; char c; } __Pyx_pad_longdouble;
 typedef struct { void *x; char c; } __Pyx_pad_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
+static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, CYTHON_UNUSED int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
@@ -26669,17 +21514,16 @@
         }
     }
     return 1;
 fail:
     return 0;
 }
 static int
-__pyx_check_suboffsets(Py_buffer *buf, int dim, int ndim, int spec)
+__pyx_check_suboffsets(Py_buffer *buf, int dim, CYTHON_UNUSED int ndim, int spec)
 {
-    CYTHON_UNUSED_VAR(ndim);
     if (spec & __Pyx_MEMVIEW_DIRECT) {
         if (unlikely(buf->suboffsets && buf->suboffsets[dim] >= 0)) {
             PyErr_Format(PyExc_ValueError,
                          "Buffer not compatible with direct access "
                          "in dimension %d.", dim);
             goto fail;
         }
@@ -26797,72 +21641,26 @@
     retval = -1;
 no_fail:
     __Pyx_RefNannyFinishContext();
     return retval;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(PyObject *obj, int writable_flag) {
-    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
-    __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
-    int retcode;
-    if (obj == Py_None) {
-        result.memview = (struct __pyx_memoryview_obj *) Py_None;
-        return result;
-    }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
-                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_unsigned_long, stack,
-                                                 &result, obj);
-    if (unlikely(retcode == -1))
-        goto __pyx_fail;
-    return result;
-__pyx_fail:
-    result.memview = NULL;
-    result.data = NULL;
-    return result;
-}
-
-/* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
     int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
     retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
                                                  (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_unsigned_int, stack,
-                                                 &result, obj);
-    if (unlikely(retcode == -1))
-        goto __pyx_fail;
-    return result;
-__pyx_fail:
-    result.memview = NULL;
-    result.data = NULL;
-    return result;
-}
-
-/* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(PyObject *obj, int writable_flag) {
-    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
-    __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
-    int retcode;
-    if (obj == Py_None) {
-        result.memview = (struct __pyx_memoryview_obj *) Py_None;
-        return result;
-    }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
-                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_unsigned_PY_LONG_LONG, stack,
+                                                 &__Pyx_TypeInfo_unsigned_char__const__, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
@@ -26887,26 +21685,14 @@
                 else\
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
-/* MemviewDtypeToObject */
-  static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_long(const char *itemp) {
-    return (PyObject *) __Pyx_PyInt_From_unsigned_long(*(unsigned long *) itemp);
-}
-static CYTHON_INLINE int __pyx_memview_set_unsigned_long(const char *itemp, PyObject *obj) {
-    unsigned long value = __Pyx_PyInt_As_unsigned_long(obj);
-    if (unlikely((value == (unsigned long)-1) && PyErr_Occurred()))
-        return 0;
-    *(unsigned long *) itemp = value;
-    return 1;
-}
-
 /* MemviewSliceCopyTemplate */
   static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object)
 {
@@ -26966,805 +21752,320 @@
     __Pyx_XDECREF(shape_tuple);
     __Pyx_XDECREF(temp_int);
     __Pyx_XDECREF(array_obj);
     __Pyx_RefNannyFinishContext();
     return new_mvs;
 }
 
-/* MemviewSliceInit */
-  static int
-__Pyx_init_memviewslice(struct __pyx_memoryview_obj *memview,
-                        int ndim,
-                        __Pyx_memviewslice *memviewslice,
-                        int memview_is_new_reference)
-{
-    __Pyx_RefNannyDeclarations
-    int i, retval=-1;
-    Py_buffer *buf = &memview->view;
-    __Pyx_RefNannySetupContext("init_memviewslice", 0);
-    if (unlikely(memviewslice->memview || memviewslice->data)) {
-        PyErr_SetString(PyExc_ValueError,
-            "memviewslice is already initialized!");
-        goto fail;
-    }
-    if (buf->strides) {
-        for (i = 0; i < ndim; i++) {
-            memviewslice->strides[i] = buf->strides[i];
-        }
-    } else {
-        Py_ssize_t stride = buf->itemsize;
-        for (i = ndim - 1; i >= 0; i--) {
-            memviewslice->strides[i] = stride;
-            stride *= buf->shape[i];
-        }
-    }
-    for (i = 0; i < ndim; i++) {
-        memviewslice->shape[i]   = buf->shape[i];
-        if (buf->suboffsets) {
-            memviewslice->suboffsets[i] = buf->suboffsets[i];
-        } else {
-            memviewslice->suboffsets[i] = -1;
-        }
-    }
-    memviewslice->memview = memview;
-    memviewslice->data = (char *)buf->buf;
-    if (__pyx_add_acquisition_count(memview) == 0 && !memview_is_new_reference) {
-        Py_INCREF(memview);
-    }
-    retval = 0;
-    goto no_fail;
-fail:
-    memviewslice->memview = 0;
-    memviewslice->data = 0;
-    retval = -1;
-no_fail:
-    __Pyx_RefNannyFinishContext();
-    return retval;
-}
-#ifndef Py_NO_RETURN
-#define Py_NO_RETURN
-#endif
-static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
-    va_list vargs;
-    char msg[200];
-#if PY_VERSION_HEX >= 0x030A0000 || defined(HAVE_STDARG_PROTOTYPES)
-    va_start(vargs, fmt);
-#else
-    va_start(vargs);
-#endif
-    vsnprintf(msg, 200, fmt, vargs);
-    va_end(vargs);
-    Py_FatalError(msg);
-}
-static CYTHON_INLINE int
-__pyx_add_acquisition_count_locked(__pyx_atomic_int_type *acquisition_count,
-                                   PyThread_type_lock lock)
-{
-    int result;
-    PyThread_acquire_lock(lock, 1);
-    result = (*acquisition_count)++;
-    PyThread_release_lock(lock);
-    return result;
-}
-static CYTHON_INLINE int
-__pyx_sub_acquisition_count_locked(__pyx_atomic_int_type *acquisition_count,
-                                   PyThread_type_lock lock)
-{
-    int result;
-    PyThread_acquire_lock(lock, 1);
-    result = (*acquisition_count)--;
-    PyThread_release_lock(lock);
-    return result;
-}
-static CYTHON_INLINE void
-__Pyx_INC_MEMVIEW(__Pyx_memviewslice *memslice, int have_gil, int lineno)
-{
-    __pyx_nonatomic_int_type old_acquisition_count;
-    struct __pyx_memoryview_obj *memview = memslice->memview;
-    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
-        return;
-    }
-    old_acquisition_count = __pyx_add_acquisition_count(memview);
-    if (unlikely(old_acquisition_count <= 0)) {
-        if (likely(old_acquisition_count == 0)) {
-            if (have_gil) {
-                Py_INCREF((PyObject *) memview);
-            } else {
-                PyGILState_STATE _gilstate = PyGILState_Ensure();
-                Py_INCREF((PyObject *) memview);
-                PyGILState_Release(_gilstate);
-            }
-        } else {
-            __pyx_fatalerror("Acquisition count is %d (line %d)",
-                             old_acquisition_count+1, lineno);
-        }
-    }
-}
-static CYTHON_INLINE void __Pyx_XCLEAR_MEMVIEW(__Pyx_memviewslice *memslice,
-                                             int have_gil, int lineno) {
-    __pyx_nonatomic_int_type old_acquisition_count;
-    struct __pyx_memoryview_obj *memview = memslice->memview;
-    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
-        memslice->memview = NULL;
-        return;
-    }
-    old_acquisition_count = __pyx_sub_acquisition_count(memview);
-    memslice->data = NULL;
-    if (likely(old_acquisition_count > 1)) {
-        memslice->memview = NULL;
-    } else if (likely(old_acquisition_count == 1)) {
-        if (have_gil) {
-            Py_CLEAR(memslice->memview);
-        } else {
-            PyGILState_STATE _gilstate = PyGILState_Ensure();
-            Py_CLEAR(memslice->memview);
-            PyGILState_Release(_gilstate);
-        }
-    } else {
-        __pyx_fatalerror("Acquisition count is %d (line %d)",
-                         old_acquisition_count-1, lineno);
-    }
-}
-
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned long) < sizeof(long)) {
+        if (sizeof(unsigned int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned long) <= sizeof(unsigned long)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned long) <= sizeof(long)) {
+        if (sizeof(unsigned int) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned long) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned long),
+        return _PyLong_FromByteArray(bytes, sizeof(unsigned int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
-  static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *x) {
+  static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(unsigned long) < sizeof(long))) {
-            __PYX_VERIFY_RETURN_INT(unsigned long, long, PyInt_AS_LONG(x))
+        if (sizeof(unsigned int) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (unsigned long) val;
+            return (unsigned int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned long, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(unsigned long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) >= 2 * PyLong_SHIFT)) {
-                                return (unsigned long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) >= 3 * PyLong_SHIFT)) {
-                                return (unsigned long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) >= 4 * PyLong_SHIFT)) {
-                                return (unsigned long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (unsigned long) -1;
+                    return (unsigned int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(unsigned long) <= sizeof(unsigned long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned long, PyLong_AsUnsignedLong(x))
+            if (sizeof(unsigned int) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned long, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(unsigned long) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned long) (((unsigned long)-1)*(((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(unsigned int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(unsigned long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned long) ((((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned long) (((unsigned long)-1)*(((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned long) ((((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned long) (((unsigned long)-1)*(((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned long) ((((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(unsigned long) <= sizeof(long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, long, PyLong_AsLong(x))
+            if (sizeof(unsigned int) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned long) <= sizeof(PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-            unsigned long val;
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            unsigned int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (unsigned long) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (unsigned long) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (unsigned long) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (unsigned long) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (unsigned long) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(unsigned long) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((unsigned long) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(unsigned long) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((unsigned long) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((unsigned long) 1) << (sizeof(unsigned long) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-            return (unsigned long) -1;
+#endif
+            return (unsigned int) -1;
         }
     } else {
-        unsigned long val;
+        unsigned int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned long) -1;
-        val = __Pyx_PyInt_As_unsigned_long(tmp);
+        if (!tmp) return (unsigned int) -1;
+        val = __Pyx_PyInt_As_unsigned_int(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned long");
-    return (unsigned long) -1;
+        "value too large to convert to unsigned int");
+    return (unsigned int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned long");
-    return (unsigned long) -1;
+        "can't convert negative value to unsigned int");
+    return (unsigned int) -1;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
+    const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned int) < sizeof(long)) {
+        if (sizeof(long) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned int) <= sizeof(unsigned long)) {
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned int) <= sizeof(long)) {
+        if (sizeof(long) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned int),
+        return _PyLong_FromByteArray(bytes, sizeof(long),
                                      little, !is_unsigned);
     }
 }
 
-/* CIntFromPy */
-  static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-#if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_Check(x))) {
-        if ((sizeof(unsigned int) < sizeof(long))) {
-            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
-        } else {
-            long val = PyInt_AS_LONG(x);
-            if (is_unsigned && unlikely(val < 0)) {
-                goto raise_neg_overflow;
-            }
-            return (unsigned int) val;
-        }
-    } else
-#endif
-    if (likely(PyLong_Check(x))) {
-        if (is_unsigned) {
-#if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned int, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(unsigned int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT)) {
-                                return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
-                            }
-                        }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT)) {
-                                return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
-                            }
-                        }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT)) {
-                                return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
-                            }
-                        }
-                        break;
-                }
-            }
-#endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
-            if (unlikely(Py_SIZE(x) < 0)) {
-                goto raise_neg_overflow;
-            }
-#else
-            {
-                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                if (unlikely(result < 0))
-                    return (unsigned int) -1;
-                if (unlikely(result == 1))
-                    goto raise_neg_overflow;
-            }
-#endif
-            if ((sizeof(unsigned int) <= sizeof(unsigned long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
-#endif
-            }
-        } else {
-#if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned int, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(unsigned int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
-                            }
-                        }
-                        break;
-                }
-            }
-#endif
-            if ((sizeof(unsigned int) <= sizeof(long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
-#ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned int) <= sizeof(PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
-#endif
-            }
-        }
-        {
-            unsigned int val;
-            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
-            if (likely(v) && !PyLong_Check(v)) {
-                PyObject *tmp = v;
-                v = PyNumber_Long(tmp);
-                Py_DECREF(tmp);
-            }
-#endif
-            if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
-                int one = 1; int is_little = (int)*(unsigned char *)&one;
-                unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (unsigned int) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (unsigned int) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (unsigned int) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (unsigned int) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (unsigned int) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(unsigned int) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((unsigned int) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(unsigned int) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((unsigned int) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((unsigned int) 1) << (sizeof(unsigned int) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
-                Py_DECREF(v);
-                if (likely(!ret))
-                    return val;
-            }
-            return (unsigned int) -1;
-        }
-    } else {
-        unsigned int val;
-        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned int) -1;
-        val = __Pyx_PyInt_As_unsigned_int(tmp);
-        Py_DECREF(tmp);
-        return val;
-    }
-raise_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned int");
-    return (unsigned int) -1;
-raise_neg_overflow:
-    PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned int");
-    return (unsigned int) -1;
-}
-
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG) -1, const_zero = (unsigned PY_LONG_LONG) 0;
+    const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned PY_LONG_LONG) < sizeof(long)) {
+        if (sizeof(int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long)) {
+        } else if (sizeof(int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned PY_LONG_LONG) <= sizeof(long)) {
+        if (sizeof(int) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned PY_LONG_LONG),
+        return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
   static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
@@ -27774,254 +22075,177 @@
     const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(int) < sizeof(long))) {
+        if (sizeof(int) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 2 * PyLong_SHIFT)) {
-                                return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
+                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 3 * PyLong_SHIFT)) {
-                                return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
+                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 4 * PyLong_SHIFT)) {
-                                return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
+                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(int) <= sizeof(unsigned long))) {
+            if (sizeof(int) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(int) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(int) <= sizeof(long))) {
+            if (sizeof(int) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (int) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (int) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (int) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (int) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (int) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(int) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((int) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(int) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((int) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((int) 1) << (sizeof(int) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (int) -1;
         }
     } else {
         int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (int) -1;
         val = __Pyx_PyInt_As_int(tmp);
@@ -28047,254 +22271,177 @@
     const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(long) < sizeof(long))) {
+        if (sizeof(long) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (long) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 2 * PyLong_SHIFT)) {
-                                return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
+                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 3 * PyLong_SHIFT)) {
-                                return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
+                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 4 * PyLong_SHIFT)) {
-                                return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
+                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (long) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(long) <= sizeof(unsigned long))) {
+            if (sizeof(long) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(long) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(long) <= sizeof(long))) {
+            if (sizeof(long) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             long val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (long) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (long) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (long) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (long) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (long) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(long) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((long) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(long) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((long) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((long) 1) << (sizeof(long) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (long) -1;
         }
     } else {
         long val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (long) -1;
         val = __Pyx_PyInt_As_long(tmp);
@@ -28307,343 +22454,190 @@
     return (long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to long");
     return (long) -1;
 }
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
-    }
-}
-
 /* CIntFromPy */
   static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const char neg_one = (char) -1, const_zero = (char) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(char) < sizeof(long))) {
+        if (sizeof(char) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(char, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (char) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(char, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 2 * PyLong_SHIFT)) {
-                                return (char) (((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (char) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(char, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(char) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 2 * PyLong_SHIFT) {
+                            return (char) (((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 3 * PyLong_SHIFT)) {
-                                return (char) (((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(char) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 3 * PyLong_SHIFT) {
+                            return (char) (((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 4 * PyLong_SHIFT)) {
-                                return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(char) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 4 * PyLong_SHIFT) {
+                            return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (char) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(char) <= sizeof(unsigned long))) {
+            if (sizeof(char) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(char) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(char) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(char, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(char) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (char) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(char, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(char,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(char) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (char) ((((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(char) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                            return (char) ((((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (char) ((((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(char) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                            return (char) ((((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 4 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (char) ((((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(char) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 4 * PyLong_SHIFT) {
+                            return (char) ((((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(char) <= sizeof(long))) {
+            if (sizeof(char) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(char) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(char) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             char val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (char) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (char) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (char) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (char) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (char) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(char) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((char) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(char) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((char) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((char) 1) << (sizeof(char) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (char) -1;
         }
     } else {
         char val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (char) -1;
         val = __Pyx_PyInt_As_char(tmp);
@@ -28656,1196 +22650,58 @@
     return (char) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to char");
     return (char) -1;
 }
 
-/* FormatTypeName */
-  #if CYTHON_COMPILING_IN_LIMITED_API
-static __Pyx_TypeName
-__Pyx_PyType_GetName(PyTypeObject* tp)
-{
-    PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
-                                               __pyx_n_s_name_2);
-    if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
-        PyErr_Clear();
-        Py_XSETREF(name, __Pyx_NewRef(__pyx_n_s__22));
-    }
-    return name;
-}
-#endif
-
-/* PyObjectCall2Args */
-  static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
-    PyObject *args[3] = {NULL, arg1, arg2};
-    return __Pyx_PyObject_FastCall(function, args+1, 2 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
-/* PyObjectCallMethod1 */
-  static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
-    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
-    Py_DECREF(method);
-    return result;
-}
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
-    PyObject *method = NULL, *result;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_Call2Args(method, obj, arg);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) return NULL;
-    return __Pyx__PyObject_CallMethod1(method, arg);
-}
-
-/* CoroutineBase */
-  #include <frameobject.h>
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
-static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *__pyx_tstate, PyObject **pvalue) {
-    PyObject *et, *ev, *tb;
-    PyObject *value = NULL;
-    CYTHON_UNUSED_VAR(__pyx_tstate);
-    __Pyx_ErrFetch(&et, &ev, &tb);
-    if (!et) {
-        Py_XDECREF(tb);
-        Py_XDECREF(ev);
-        Py_INCREF(Py_None);
-        *pvalue = Py_None;
-        return 0;
-    }
-    if (likely(et == PyExc_StopIteration)) {
-        if (!ev) {
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-#if PY_VERSION_HEX >= 0x030300A0
-        else if (likely(__Pyx_IS_TYPE(ev, (PyTypeObject*)PyExc_StopIteration))) {
-            value = ((PyStopIterationObject *)ev)->value;
-            Py_INCREF(value);
-            Py_DECREF(ev);
-        }
-#endif
-        else if (unlikely(PyTuple_Check(ev))) {
-            if (PyTuple_GET_SIZE(ev) >= 1) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-                value = PyTuple_GET_ITEM(ev, 0);
-                Py_INCREF(value);
-#else
-                value = PySequence_ITEM(ev, 0);
-#endif
-            } else {
-                Py_INCREF(Py_None);
-                value = Py_None;
-            }
-            Py_DECREF(ev);
-        }
-        else if (!__Pyx_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
-            value = ev;
-        }
-        if (likely(value)) {
-            Py_XDECREF(tb);
-            Py_DECREF(et);
-            *pvalue = value;
-            return 0;
-        }
-    } else if (!__Pyx_PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
-        __Pyx_ErrRestore(et, ev, tb);
-        return -1;
-    }
-    PyErr_NormalizeException(&et, &ev, &tb);
-    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
-        __Pyx_ErrRestore(et, ev, tb);
-        return -1;
-    }
-    Py_XDECREF(tb);
-    Py_DECREF(et);
-#if PY_VERSION_HEX >= 0x030300A0
-    value = ((PyStopIterationObject *)ev)->value;
-    Py_INCREF(value);
-    Py_DECREF(ev);
-#else
-    {
-        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
-        Py_DECREF(ev);
-        if (likely(args)) {
-            value = PySequence_GetItem(args, 0);
-            Py_DECREF(args);
-        }
-        if (unlikely(!value)) {
-            __Pyx_ErrRestore(NULL, NULL, NULL);
-            Py_INCREF(Py_None);
-            value = Py_None;
-        }
-    }
-#endif
-    *pvalue = value;
-    return 0;
-}
-static CYTHON_INLINE
-void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
-#if PY_VERSION_HEX >= 0x030B00a4
-    Py_CLEAR(exc_state->exc_value);
-#else
-    PyObject *t, *v, *tb;
-    t = exc_state->exc_type;
-    v = exc_state->exc_value;
-    tb = exc_state->exc_traceback;
-    exc_state->exc_type = NULL;
-    exc_state->exc_value = NULL;
-    exc_state->exc_traceback = NULL;
-    Py_XDECREF(t);
-    Py_XDECREF(v);
-    Py_XDECREF(tb);
-#endif
-}
-#define __Pyx_Coroutine_AlreadyRunningError(gen)  (__Pyx__Coroutine_AlreadyRunningError(gen), (PyObject*)NULL)
-static void __Pyx__Coroutine_AlreadyRunningError(__pyx_CoroutineObject *gen) {
-    const char *msg;
-    CYTHON_MAYBE_UNUSED_VAR(gen);
-    if ((0)) {
-    #ifdef __Pyx_Coroutine_USED
-    } else if (__Pyx_Coroutine_Check((PyObject*)gen)) {
-        msg = "coroutine already executing";
-    #endif
-    #ifdef __Pyx_AsyncGen_USED
-    } else if (__Pyx_AsyncGen_CheckExact((PyObject*)gen)) {
-        msg = "async generator already executing";
-    #endif
-    } else {
-        msg = "generator already executing";
-    }
-    PyErr_SetString(PyExc_ValueError, msg);
-}
-#define __Pyx_Coroutine_NotStartedError(gen)  (__Pyx__Coroutine_NotStartedError(gen), (PyObject*)NULL)
-static void __Pyx__Coroutine_NotStartedError(PyObject *gen) {
-    const char *msg;
-    CYTHON_MAYBE_UNUSED_VAR(gen);
-    if ((0)) {
-    #ifdef __Pyx_Coroutine_USED
-    } else if (__Pyx_Coroutine_Check(gen)) {
-        msg = "can't send non-None value to a just-started coroutine";
-    #endif
-    #ifdef __Pyx_AsyncGen_USED
-    } else if (__Pyx_AsyncGen_CheckExact(gen)) {
-        msg = "can't send non-None value to a just-started async generator";
-    #endif
-    } else {
-        msg = "can't send non-None value to a just-started generator";
-    }
-    PyErr_SetString(PyExc_TypeError, msg);
-}
-#define __Pyx_Coroutine_AlreadyTerminatedError(gen, value, closing)  (__Pyx__Coroutine_AlreadyTerminatedError(gen, value, closing), (PyObject*)NULL)
-static void __Pyx__Coroutine_AlreadyTerminatedError(PyObject *gen, PyObject *value, int closing) {
-    CYTHON_MAYBE_UNUSED_VAR(gen);
-    CYTHON_MAYBE_UNUSED_VAR(closing);
-    #ifdef __Pyx_Coroutine_USED
-    if (!closing && __Pyx_Coroutine_Check(gen)) {
-        PyErr_SetString(PyExc_RuntimeError, "cannot reuse already awaited coroutine");
-    } else
-    #endif
-    if (value) {
-        #ifdef __Pyx_AsyncGen_USED
-        if (__Pyx_AsyncGen_CheckExact(gen))
-            PyErr_SetNone(__Pyx_PyExc_StopAsyncIteration);
-        else
-        #endif
-        PyErr_SetNone(PyExc_StopIteration);
-    }
-}
-static
-PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, int closing) {
-    __Pyx_PyThreadState_declare
-    PyThreadState *tstate;
-    __Pyx_ExcInfoStruct *exc_state;
-    PyObject *retval;
-    assert(!self->is_running);
-    if (unlikely(self->resume_label == 0)) {
-        if (unlikely(value && value != Py_None)) {
-            return __Pyx_Coroutine_NotStartedError((PyObject*)self);
-        }
-    }
-    if (unlikely(self->resume_label == -1)) {
-        return __Pyx_Coroutine_AlreadyTerminatedError((PyObject*)self, value, closing);
-    }
-#if CYTHON_FAST_THREAD_STATE
-    __Pyx_PyThreadState_assign
-    tstate = __pyx_tstate;
-#else
-    tstate = __Pyx_PyThreadState_Current;
-#endif
-    exc_state = &self->gi_exc_state;
-    if (exc_state->exc_value) {
-        #if CYTHON_COMPILING_IN_PYPY
-        #else
-        PyObject *exc_tb;
-        #if PY_VERSION_HEX >= 0x030B00a4 && !CYTHON_COMPILING_IN_CPYTHON
-        exc_tb = PyException_GetTraceback(exc_state->exc_value);
-        #elif PY_VERSION_HEX >= 0x030B00a4
-        exc_tb = ((PyBaseExceptionObject*) exc_state->exc_value)->traceback;
-        #else
-        exc_tb = exc_state->exc_traceback;
-        #endif
-        if (exc_tb) {
-            PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
-            PyFrameObject *f = tb->tb_frame;
-            assert(f->f_back == NULL);
-            #if PY_VERSION_HEX >= 0x030B00A1
-            f->f_back = PyThreadState_GetFrame(tstate);
-            #else
-            Py_XINCREF(tstate->frame);
-            f->f_back = tstate->frame;
-            #endif
-            #if PY_VERSION_HEX >= 0x030B00a4 && !CYTHON_COMPILING_IN_CPYTHON
-            Py_DECREF(exc_tb);
-            #endif
-        }
-        #endif
-    }
-#if CYTHON_USE_EXC_INFO_STACK
-    exc_state->previous_item = tstate->exc_info;
-    tstate->exc_info = exc_state;
-#else
-    if (exc_state->exc_type) {
-        __Pyx_ExceptionSwap(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
-    } else {
-        __Pyx_Coroutine_ExceptionClear(exc_state);
-        __Pyx_ExceptionSave(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
-    }
-#endif
-    self->is_running = 1;
-    retval = self->body(self, tstate, value);
-    self->is_running = 0;
-#if CYTHON_USE_EXC_INFO_STACK
-    exc_state = &self->gi_exc_state;
-    tstate->exc_info = exc_state->previous_item;
-    exc_state->previous_item = NULL;
-    __Pyx_Coroutine_ResetFrameBackpointer(exc_state);
-#endif
-    return retval;
-}
-static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state) {
-#if CYTHON_COMPILING_IN_PYPY
-    CYTHON_UNUSED_VAR(exc_state);
-#else
-    PyObject *exc_tb;
-    #if PY_VERSION_HEX >= 0x030B00a4
-    if (!exc_state->exc_value) return;
-    exc_tb = PyException_GetTraceback(exc_state->exc_value);
-    #else
-    exc_tb = exc_state->exc_traceback;
-    #endif
-    if (likely(exc_tb)) {
-        PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
-        PyFrameObject *f = tb->tb_frame;
-        Py_CLEAR(f->f_back);
-        #if PY_VERSION_HEX >= 0x030B00a4
-        Py_DECREF(exc_tb);
-        #endif
-    }
-#endif
-}
-static CYTHON_INLINE
-PyObject *__Pyx_Coroutine_MethodReturn(PyObject* gen, PyObject *retval) {
-    CYTHON_MAYBE_UNUSED_VAR(gen);
-    if (unlikely(!retval)) {
-        __Pyx_PyThreadState_declare
-        __Pyx_PyThreadState_assign
-        if (!__Pyx_PyErr_Occurred()) {
-            PyObject *exc = PyExc_StopIteration;
-            #ifdef __Pyx_AsyncGen_USED
-            if (__Pyx_AsyncGen_CheckExact(gen))
-                exc = __Pyx_PyExc_StopAsyncIteration;
-            #endif
-            __Pyx_PyErr_SetNone(exc);
-        }
-    }
-    return retval;
-}
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
-static CYTHON_INLINE
-PyObject *__Pyx_PyGen_Send(PyGenObject *gen, PyObject *arg) {
-#if PY_VERSION_HEX <= 0x030A00A1
-    return _PyGen_Send(gen, arg);
-#else
-    PyObject *result;
-    if (PyIter_Send((PyObject*)gen, arg ? arg : Py_None, &result) == PYGEN_RETURN) {
-        if (PyAsyncGen_CheckExact(gen)) {
-            assert(result == Py_None);
-            PyErr_SetNone(PyExc_StopAsyncIteration);
-        }
-        else if (result == Py_None) {
-            PyErr_SetNone(PyExc_StopIteration);
-        }
-        else {
-            _PyGen_SetStopIterationValue(result);
-        }
-        Py_CLEAR(result);
-    }
-    return result;
-#endif
-}
-#endif
-static CYTHON_INLINE
-PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
-    PyObject *ret;
-    PyObject *val = NULL;
-    __Pyx_Coroutine_Undelegate(gen);
-    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, &val);
-    ret = __Pyx_Coroutine_SendEx(gen, val, 0);
-    Py_XDECREF(val);
-    return ret;
-}
-static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
-    PyObject *retval;
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
-    PyObject *yf = gen->yieldfrom;
-    if (unlikely(gen->is_running))
-        return __Pyx_Coroutine_AlreadyRunningError(gen);
-    if (yf) {
-        PyObject *ret;
-        gen->is_running = 1;
-        #ifdef __Pyx_Generator_USED
-        if (__Pyx_Generator_CheckExact(yf)) {
-            ret = __Pyx_Coroutine_Send(yf, value);
-        } else
-        #endif
-        #ifdef __Pyx_Coroutine_USED
-        if (__Pyx_Coroutine_Check(yf)) {
-            ret = __Pyx_Coroutine_Send(yf, value);
-        } else
-        #endif
-        #ifdef __Pyx_AsyncGen_USED
-        if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
-            ret = __Pyx_async_gen_asend_send(yf, value);
-        } else
-        #endif
-        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
-        if (PyGen_CheckExact(yf)) {
-            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
-        } else
-        #endif
-        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03050000 && defined(PyCoro_CheckExact) && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
-        if (PyCoro_CheckExact(yf)) {
-            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
-        } else
-        #endif
-        {
-            if (value == Py_None)
-                ret = __Pyx_PyObject_GetIterNextFunc(yf)(yf);
-            else
-                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
-        }
-        gen->is_running = 0;
-        if (likely(ret)) {
-            return ret;
-        }
-        retval = __Pyx_Coroutine_FinishDelegation(gen);
-    } else {
-        retval = __Pyx_Coroutine_SendEx(gen, value, 0);
-    }
-    return __Pyx_Coroutine_MethodReturn(self, retval);
-}
-static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
-    PyObject *retval = NULL;
-    int err = 0;
-    #ifdef __Pyx_Generator_USED
-    if (__Pyx_Generator_CheckExact(yf)) {
-        retval = __Pyx_Coroutine_Close(yf);
-        if (!retval)
-            return -1;
-    } else
-    #endif
-    #ifdef __Pyx_Coroutine_USED
-    if (__Pyx_Coroutine_Check(yf)) {
-        retval = __Pyx_Coroutine_Close(yf);
-        if (!retval)
-            return -1;
-    } else
-    if (__Pyx_CoroutineAwait_CheckExact(yf)) {
-        retval = __Pyx_CoroutineAwait_Close((__pyx_CoroutineAwaitObject*)yf, NULL);
-        if (!retval)
-            return -1;
-    } else
-    #endif
-    #ifdef __Pyx_AsyncGen_USED
-    if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
-        retval = __Pyx_async_gen_asend_close(yf, NULL);
-    } else
-    if (__pyx_PyAsyncGenAThrow_CheckExact(yf)) {
-        retval = __Pyx_async_gen_athrow_close(yf, NULL);
-    } else
-    #endif
-    {
-        PyObject *meth;
-        gen->is_running = 1;
-        meth = __Pyx_PyObject_GetAttrStrNoError(yf, __pyx_n_s_close);
-        if (unlikely(!meth)) {
-            if (unlikely(PyErr_Occurred())) {
-                PyErr_WriteUnraisable(yf);
-            }
-        } else {
-            retval = __Pyx_PyObject_CallNoArg(meth);
-            Py_DECREF(meth);
-            if (unlikely(!retval))
-                err = -1;
-        }
-        gen->is_running = 0;
-    }
-    Py_XDECREF(retval);
-    return err;
-}
-static PyObject *__Pyx_Generator_Next(PyObject *self) {
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
-    PyObject *yf = gen->yieldfrom;
-    if (unlikely(gen->is_running))
-        return __Pyx_Coroutine_AlreadyRunningError(gen);
-    if (yf) {
-        PyObject *ret;
-        gen->is_running = 1;
-        #ifdef __Pyx_Generator_USED
-        if (__Pyx_Generator_CheckExact(yf)) {
-            ret = __Pyx_Generator_Next(yf);
-        } else
-        #endif
-        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
-        if (PyGen_CheckExact(yf)) {
-            ret = __Pyx_PyGen_Send((PyGenObject*)yf, NULL);
-        } else
-        #endif
-        #ifdef __Pyx_Coroutine_USED
-        if (__Pyx_Coroutine_Check(yf)) {
-            ret = __Pyx_Coroutine_Send(yf, Py_None);
-        } else
-        #endif
-            ret = __Pyx_PyObject_GetIterNextFunc(yf)(yf);
-        gen->is_running = 0;
-        if (likely(ret)) {
-            return ret;
-        }
-        return __Pyx_Coroutine_FinishDelegation(gen);
-    }
-    return __Pyx_Coroutine_SendEx(gen, Py_None, 0);
-}
-static PyObject *__Pyx_Coroutine_Close_Method(PyObject *self, PyObject *arg) {
-    CYTHON_UNUSED_VAR(arg);
-    return __Pyx_Coroutine_Close(self);
-}
-static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
-    PyObject *retval, *raised_exception;
-    PyObject *yf = gen->yieldfrom;
-    int err = 0;
-    if (unlikely(gen->is_running))
-        return __Pyx_Coroutine_AlreadyRunningError(gen);
-    if (yf) {
-        Py_INCREF(yf);
-        err = __Pyx_Coroutine_CloseIter(gen, yf);
-        __Pyx_Coroutine_Undelegate(gen);
-        Py_DECREF(yf);
-    }
-    if (err == 0)
-        PyErr_SetNone(PyExc_GeneratorExit);
-    retval = __Pyx_Coroutine_SendEx(gen, NULL, 1);
-    if (unlikely(retval)) {
-        const char *msg;
-        Py_DECREF(retval);
-        if ((0)) {
-        #ifdef __Pyx_Coroutine_USED
-        } else if (__Pyx_Coroutine_Check(self)) {
-            msg = "coroutine ignored GeneratorExit";
-        #endif
-        #ifdef __Pyx_AsyncGen_USED
-        } else if (__Pyx_AsyncGen_CheckExact(self)) {
-#if PY_VERSION_HEX < 0x03060000
-            msg = "async generator ignored GeneratorExit - might require Python 3.6+ finalisation (PEP 525)";
-#else
-            msg = "async generator ignored GeneratorExit";
-#endif
-        #endif
-        } else {
-            msg = "generator ignored GeneratorExit";
-        }
-        PyErr_SetString(PyExc_RuntimeError, msg);
-        return NULL;
-    }
-    raised_exception = PyErr_Occurred();
-    if (likely(!raised_exception || __Pyx_PyErr_GivenExceptionMatches2(raised_exception, PyExc_GeneratorExit, PyExc_StopIteration))) {
-        if (raised_exception) PyErr_Clear();
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return NULL;
-}
-static PyObject *__Pyx__Coroutine_Throw(PyObject *self, PyObject *typ, PyObject *val, PyObject *tb,
-                                        PyObject *args, int close_on_genexit) {
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
-    PyObject *yf = gen->yieldfrom;
-    if (unlikely(gen->is_running))
-        return __Pyx_Coroutine_AlreadyRunningError(gen);
-    if (yf) {
-        PyObject *ret;
-        Py_INCREF(yf);
-        if (__Pyx_PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit) && close_on_genexit) {
-            int err = __Pyx_Coroutine_CloseIter(gen, yf);
-            Py_DECREF(yf);
-            __Pyx_Coroutine_Undelegate(gen);
-            if (err < 0)
-                return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
-            goto throw_here;
-        }
-        gen->is_running = 1;
-        if (0
-        #ifdef __Pyx_Generator_USED
-            || __Pyx_Generator_CheckExact(yf)
-        #endif
-        #ifdef __Pyx_Coroutine_USED
-            || __Pyx_Coroutine_Check(yf)
-        #endif
-            ) {
-            ret = __Pyx__Coroutine_Throw(yf, typ, val, tb, args, close_on_genexit);
-        #ifdef __Pyx_Coroutine_USED
-        } else if (__Pyx_CoroutineAwait_CheckExact(yf)) {
-            ret = __Pyx__Coroutine_Throw(((__pyx_CoroutineAwaitObject*)yf)->coroutine, typ, val, tb, args, close_on_genexit);
-        #endif
-        } else {
-            PyObject *meth = __Pyx_PyObject_GetAttrStrNoError(yf, __pyx_n_s_throw);
-            if (unlikely(!meth)) {
-                Py_DECREF(yf);
-                if (unlikely(PyErr_Occurred())) {
-                    gen->is_running = 0;
-                    return NULL;
-                }
-                __Pyx_Coroutine_Undelegate(gen);
-                gen->is_running = 0;
-                goto throw_here;
-            }
-            if (likely(args)) {
-                ret = __Pyx_PyObject_Call(meth, args, NULL);
-            } else {
-                PyObject *cargs[4] = {NULL, typ, val, tb};
-                ret = __Pyx_PyObject_FastCall(meth, cargs+1, 3 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-            }
-            Py_DECREF(meth);
-        }
-        gen->is_running = 0;
-        Py_DECREF(yf);
-        if (!ret) {
-            ret = __Pyx_Coroutine_FinishDelegation(gen);
-        }
-        return __Pyx_Coroutine_MethodReturn(self, ret);
-    }
-throw_here:
-    __Pyx_Raise(typ, val, tb, NULL);
-    return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
-}
-static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
-    PyObject *typ;
-    PyObject *val = NULL;
-    PyObject *tb = NULL;
-    if (unlikely(!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb)))
-        return NULL;
-    return __Pyx__Coroutine_Throw(self, typ, val, tb, args, 1);
-}
-static CYTHON_INLINE int __Pyx_Coroutine_traverse_excstate(__Pyx_ExcInfoStruct *exc_state, visitproc visit, void *arg) {
-#if PY_VERSION_HEX >= 0x030B00a4
-    Py_VISIT(exc_state->exc_value);
-#else
-    Py_VISIT(exc_state->exc_type);
-    Py_VISIT(exc_state->exc_value);
-    Py_VISIT(exc_state->exc_traceback);
-#endif
-    return 0;
-}
-static int __Pyx_Coroutine_traverse(__pyx_CoroutineObject *gen, visitproc visit, void *arg) {
-    Py_VISIT(gen->closure);
-    Py_VISIT(gen->classobj);
-    Py_VISIT(gen->yieldfrom);
-    return __Pyx_Coroutine_traverse_excstate(&gen->gi_exc_state, visit, arg);
-}
-static int __Pyx_Coroutine_clear(PyObject *self) {
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
-    Py_CLEAR(gen->closure);
-    Py_CLEAR(gen->classobj);
-    Py_CLEAR(gen->yieldfrom);
-    __Pyx_Coroutine_ExceptionClear(&gen->gi_exc_state);
-#ifdef __Pyx_AsyncGen_USED
-    if (__Pyx_AsyncGen_CheckExact(self)) {
-        Py_CLEAR(((__pyx_PyAsyncGenObject*)gen)->ag_finalizer);
-    }
-#endif
-    Py_CLEAR(gen->gi_code);
-    Py_CLEAR(gen->gi_frame);
-    Py_CLEAR(gen->gi_name);
-    Py_CLEAR(gen->gi_qualname);
-    Py_CLEAR(gen->gi_modulename);
-    return 0;
-}
-static void __Pyx_Coroutine_dealloc(PyObject *self) {
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
-    PyObject_GC_UnTrack(gen);
-    if (gen->gi_weakreflist != NULL)
-        PyObject_ClearWeakRefs(self);
-    if (gen->resume_label >= 0) {
-        PyObject_GC_Track(self);
-#if PY_VERSION_HEX >= 0x030400a1 && CYTHON_USE_TP_FINALIZE
-        if (unlikely(PyObject_CallFinalizerFromDealloc(self)))
-#else
-        Py_TYPE(gen)->tp_del(self);
-        if (unlikely(Py_REFCNT(self) > 0))
-#endif
-        {
-            return;
-        }
-        PyObject_GC_UnTrack(self);
-    }
-#ifdef __Pyx_AsyncGen_USED
-    if (__Pyx_AsyncGen_CheckExact(self)) {
-        /* We have to handle this case for asynchronous generators
-           right here, because this code has to be between UNTRACK
-           and GC_Del. */
-        Py_CLEAR(((__pyx_PyAsyncGenObject*)self)->ag_finalizer);
-    }
-#endif
-    __Pyx_Coroutine_clear(self);
-    __Pyx_PyHeapTypeObject_GC_Del(gen);
-}
-static void __Pyx_Coroutine_del(PyObject *self) {
-    PyObject *error_type, *error_value, *error_traceback;
-    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
-    __Pyx_PyThreadState_declare
-    if (gen->resume_label < 0) {
-        return;
-    }
-#if !CYTHON_USE_TP_FINALIZE
-    assert(self->ob_refcnt == 0);
-    __Pyx_SET_REFCNT(self, 1);
-#endif
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
-#ifdef __Pyx_AsyncGen_USED
-    if (__Pyx_AsyncGen_CheckExact(self)) {
-        __pyx_PyAsyncGenObject *agen = (__pyx_PyAsyncGenObject*)self;
-        PyObject *finalizer = agen->ag_finalizer;
-        if (finalizer && !agen->ag_closed) {
-            PyObject *res = __Pyx_PyObject_CallOneArg(finalizer, self);
-            if (unlikely(!res)) {
-                PyErr_WriteUnraisable(self);
-            } else {
-                Py_DECREF(res);
-            }
-            __Pyx_ErrRestore(error_type, error_value, error_traceback);
-            return;
-        }
-    }
-#endif
-    if (unlikely(gen->resume_label == 0 && !error_value)) {
-#ifdef __Pyx_Coroutine_USED
-#ifdef __Pyx_Generator_USED
-    if (!__Pyx_Generator_CheckExact(self))
-#endif
-        {
-        PyObject_GC_UnTrack(self);
-#if PY_MAJOR_VERSION >= 3  || defined(PyErr_WarnFormat)
-        if (unlikely(PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "coroutine '%.50S' was never awaited", gen->gi_qualname) < 0))
-            PyErr_WriteUnraisable(self);
-#else
-        {PyObject *msg;
-        char *cmsg;
-        #if CYTHON_COMPILING_IN_PYPY
-        msg = NULL;
-        cmsg = (char*) "coroutine was never awaited";
-        #else
-        char *cname;
-        PyObject *qualname;
-        qualname = gen->gi_qualname;
-        cname = PyString_AS_STRING(qualname);
-        msg = PyString_FromFormat("coroutine '%.50s' was never awaited", cname);
-        if (unlikely(!msg)) {
-            PyErr_Clear();
-            cmsg = (char*) "coroutine was never awaited";
-        } else {
-            cmsg = PyString_AS_STRING(msg);
-        }
-        #endif
-        if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, cmsg, 1) < 0))
-            PyErr_WriteUnraisable(self);
-        Py_XDECREF(msg);}
-#endif
-        PyObject_GC_Track(self);
-        }
-#endif
-    } else {
-        PyObject *res = __Pyx_Coroutine_Close(self);
-        if (unlikely(!res)) {
-            if (PyErr_Occurred())
-                PyErr_WriteUnraisable(self);
-        } else {
-            Py_DECREF(res);
-        }
-    }
-    __Pyx_ErrRestore(error_type, error_value, error_traceback);
-#if !CYTHON_USE_TP_FINALIZE
-    assert(Py_REFCNT(self) > 0);
-    if (likely(--self->ob_refcnt == 0)) {
-        return;
-    }
-    {
-        Py_ssize_t refcnt = Py_REFCNT(self);
-        _Py_NewReference(self);
-        __Pyx_SET_REFCNT(self, refcnt);
-    }
-#if CYTHON_COMPILING_IN_CPYTHON
-    assert(PyType_IS_GC(Py_TYPE(self)) &&
-           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
-    _Py_DEC_REFTOTAL;
-#endif
-#ifdef COUNT_ALLOCS
-    --Py_TYPE(self)->tp_frees;
-    --Py_TYPE(self)->tp_allocs;
-#endif
-#endif
-}
-static PyObject *
-__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self, void *context)
-{
-    PyObject *name = self->gi_name;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!name)) name = Py_None;
-    Py_INCREF(name);
-    return name;
-}
-static int
-__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__name__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(self->gi_name, value);
-    return 0;
-}
-static PyObject *
-__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self, void *context)
-{
-    PyObject *name = self->gi_qualname;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!name)) name = Py_None;
-    Py_INCREF(name);
-    return name;
-}
-static int
-__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__qualname__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(self->gi_qualname, value);
-    return 0;
-}
-static PyObject *
-__Pyx_Coroutine_get_frame(__pyx_CoroutineObject *self, void *context)
-{
-    PyObject *frame = self->gi_frame;
-    CYTHON_UNUSED_VAR(context);
-    if (!frame) {
-        if (unlikely(!self->gi_code)) {
-            Py_RETURN_NONE;
-        }
-        frame = (PyObject *) PyFrame_New(
-            PyThreadState_Get(),            /*PyThreadState *tstate,*/
-            (PyCodeObject*) self->gi_code,  /*PyCodeObject *code,*/
-            __pyx_d,                 /*PyObject *globals,*/
-            0                               /*PyObject *locals*/
-        );
-        if (unlikely(!frame))
-            return NULL;
-        self->gi_frame = frame;
-    }
-    Py_INCREF(frame);
-    return frame;
-}
-static __pyx_CoroutineObject *__Pyx__Coroutine_New(
-            PyTypeObject* type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
-            PyObject *name, PyObject *qualname, PyObject *module_name) {
-    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
-    if (unlikely(!gen))
-        return NULL;
-    return __Pyx__Coroutine_NewInit(gen, body, code, closure, name, qualname, module_name);
-}
-static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
-            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
-            PyObject *name, PyObject *qualname, PyObject *module_name) {
-    gen->body = body;
-    gen->closure = closure;
-    Py_XINCREF(closure);
-    gen->is_running = 0;
-    gen->resume_label = 0;
-    gen->classobj = NULL;
-    gen->yieldfrom = NULL;
-    #if PY_VERSION_HEX >= 0x030B00a4
-    gen->gi_exc_state.exc_value = NULL;
-    #else
-    gen->gi_exc_state.exc_type = NULL;
-    gen->gi_exc_state.exc_value = NULL;
-    gen->gi_exc_state.exc_traceback = NULL;
-    #endif
-#if CYTHON_USE_EXC_INFO_STACK
-    gen->gi_exc_state.previous_item = NULL;
-#endif
-    gen->gi_weakreflist = NULL;
-    Py_XINCREF(qualname);
-    gen->gi_qualname = qualname;
-    Py_XINCREF(name);
-    gen->gi_name = name;
-    Py_XINCREF(module_name);
-    gen->gi_modulename = module_name;
-    Py_XINCREF(code);
-    gen->gi_code = code;
-    gen->gi_frame = NULL;
-    PyObject_GC_Track(gen);
-    return gen;
-}
-
-/* PatchModuleWithCoroutine */
-  static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
-#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
-    int result;
-    PyObject *globals, *result_obj;
-    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
-    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
-    #ifdef __Pyx_Coroutine_USED
-        (PyObject*)__pyx_CoroutineType);
-    #else
-        Py_None);
-    #endif
-    if (unlikely(result < 0)) goto ignore;
-    result = PyDict_SetItemString(globals, "_cython_generator_type",
-    #ifdef __Pyx_Generator_USED
-        (PyObject*)__pyx_GeneratorType);
-    #else
-        Py_None);
-    #endif
-    if (unlikely(result < 0)) goto ignore;
-    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
-    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
-    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
-    if (unlikely(!result_obj)) goto ignore;
-    Py_DECREF(result_obj);
-    Py_DECREF(globals);
-    return module;
-ignore:
-    Py_XDECREF(globals);
-    PyErr_WriteUnraisable(module);
-    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
-        Py_DECREF(module);
-        module = NULL;
-    }
-#else
-    py_code++;
-#endif
-    return module;
-}
-
-/* PatchGeneratorABC */
-  #ifndef CYTHON_REGISTER_ABCS
-#define CYTHON_REGISTER_ABCS 1
-#endif
-#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
-static PyObject* __Pyx_patch_abc_module(PyObject *module);
-static PyObject* __Pyx_patch_abc_module(PyObject *module) {
-    module = __Pyx_Coroutine_patch_module(
-        module, ""
-"if _cython_generator_type is not None:\n"
-"    try: Generator = _module.Generator\n"
-"    except AttributeError: pass\n"
-"    else: Generator.register(_cython_generator_type)\n"
-"if _cython_coroutine_type is not None:\n"
-"    try: Coroutine = _module.Coroutine\n"
-"    except AttributeError: pass\n"
-"    else: Coroutine.register(_cython_coroutine_type)\n"
-    );
-    return module;
-}
-#endif
-static int __Pyx_patch_abc(void) {
-#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
-    static int abc_patched = 0;
-    if (CYTHON_REGISTER_ABCS && !abc_patched) {
-        PyObject *module;
-        module = PyImport_ImportModule((PY_MAJOR_VERSION >= 3) ? "collections.abc" : "collections");
-        if (unlikely(!module)) {
-            PyErr_WriteUnraisable(NULL);
-            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
-                    ((PY_MAJOR_VERSION >= 3) ?
-                        "Cython module failed to register with collections.abc module" :
-                        "Cython module failed to register with collections module"), 1) < 0)) {
-                return -1;
-            }
-        } else {
-            module = __Pyx_patch_abc_module(module);
-            abc_patched = 1;
-            if (unlikely(!module))
-                return -1;
-            Py_DECREF(module);
-        }
-        module = PyImport_ImportModule("backports_abc");
-        if (module) {
-            module = __Pyx_patch_abc_module(module);
-            Py_XDECREF(module);
-        }
-        if (!module) {
-            PyErr_Clear();
-        }
-    }
-#else
-    if ((0)) __Pyx_Coroutine_patch_module(NULL, NULL);
-#endif
-    return 0;
-}
-
-/* Generator */
-  static PyMethodDef __pyx_Generator_methods[] = {
-    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
-     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
-    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
-     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
-    {"close", (PyCFunction) __Pyx_Coroutine_Close_Method, METH_NOARGS,
-     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
-    {0, 0, 0, 0}
-};
-static PyMemberDef __pyx_Generator_memberlist[] = {
-    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
-    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
-     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
-    {(char*) "gi_code", T_OBJECT, offsetof(__pyx_CoroutineObject, gi_code), READONLY, NULL},
-    {(char *) "__module__", T_OBJECT, offsetof(__pyx_CoroutineObject, gi_modulename), 0, 0},
-#if CYTHON_USE_TYPE_SPECS
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(__pyx_CoroutineObject, gi_weakreflist), READONLY, 0},
-#endif
-    {0, 0, 0, 0, 0}
-};
-static PyGetSetDef __pyx_Generator_getsets[] = {
-    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
-     (char*) PyDoc_STR("name of the generator"), 0},
-    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
-     (char*) PyDoc_STR("qualified name of the generator"), 0},
-    {(char *) "gi_frame", (getter)__Pyx_Coroutine_get_frame, NULL,
-     (char*) PyDoc_STR("Frame of the generator"), 0},
-    {0, 0, 0, 0, 0}
-};
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_GeneratorType_slots[] = {
-    {Py_tp_dealloc, (void *)__Pyx_Coroutine_dealloc},
-    {Py_tp_traverse, (void *)__Pyx_Coroutine_traverse},
-    {Py_tp_iter, (void *)PyObject_SelfIter},
-    {Py_tp_iternext, (void *)__Pyx_Generator_Next},
-    {Py_tp_methods, (void *)__pyx_Generator_methods},
-    {Py_tp_members, (void *)__pyx_Generator_memberlist},
-    {Py_tp_getset, (void *)__pyx_Generator_getsets},
-    {Py_tp_getattro, (void *) __Pyx_PyObject_GenericGetAttrNoDict},
-#if CYTHON_USE_TP_FINALIZE
-    {Py_tp_finalize, (void *)__Pyx_Coroutine_del},
-#endif
-    {0, 0},
-};
-static PyType_Spec __pyx_GeneratorType_spec = {
-    __PYX_TYPE_MODULE_PREFIX "generator",
-    sizeof(__pyx_CoroutineObject),
-    0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
-    __pyx_GeneratorType_slots
-};
-#else
-static PyTypeObject __pyx_GeneratorType_type = {
-    PyVarObject_HEAD_INIT(0, 0)
-    __PYX_TYPE_MODULE_PREFIX "generator",
-    sizeof(__pyx_CoroutineObject),
-    0,
-    (destructor) __Pyx_Coroutine_dealloc,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
-    0,
-    (traverseproc) __Pyx_Coroutine_traverse,
-    0,
-    0,
-    offsetof(__pyx_CoroutineObject, gi_weakreflist),
-    0,
-    (iternextfunc) __Pyx_Generator_Next,
-    __pyx_Generator_methods,
-    __pyx_Generator_memberlist,
-    __pyx_Generator_getsets,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-#if CYTHON_USE_TP_FINALIZE
-    0,
-#else
-    __Pyx_Coroutine_del,
-#endif
-    0,
-#if CYTHON_USE_TP_FINALIZE
-    __Pyx_Coroutine_del,
-#elif PY_VERSION_HEX >= 0x030400a1
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-    0,
-#endif
-#if __PYX_NEED_TP_PRINT_SLOT
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030C0000
-    0,
-#endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-    0,
-#endif
-};
-#endif
-static int __pyx_Generator_init(PyObject *module) {
-#if CYTHON_USE_TYPE_SPECS
-    __pyx_GeneratorType = __Pyx_FetchCommonTypeFromSpec(module, &__pyx_GeneratorType_spec, NULL);
-#else
-    CYTHON_UNUSED_VAR(module);
-    __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
-    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
-    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
-#endif
-    if (unlikely(!__pyx_GeneratorType)) {
-        return -1;
-    }
-    return 0;
-}
-
 /* CheckBinaryVersion */
   static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
-        }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
-            break;
-        }
-    }
-    if (!same) {
-        char rtversion[5] = {'\0'};
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
-            }
-            rtversion[i] = rt_from_call[i];
-        }
         PyOS_snprintf(message, sizeof(message),
-                      "compile time version %s of module '%.100s' "
+                      "compiletime version %s of module '%.100s' "
                       "does not match runtime version %s",
                       ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
     return 0;
 }
 
 /* InitStrings */
-  #if PY_MAJOR_VERSION >= 3
-static int __Pyx_InitString(__Pyx_StringTabEntry t, PyObject **str) {
-    if (t.is_unicode | t.is_str) {
-        if (t.intern) {
-            *str = PyUnicode_InternFromString(t.s);
-        } else if (t.encoding) {
-            *str = PyUnicode_Decode(t.s, t.n - 1, t.encoding, NULL);
-        } else {
-            *str = PyUnicode_FromStringAndSize(t.s, t.n - 1);
-        }
-    } else {
-        *str = PyBytes_FromStringAndSize(t.s, t.n - 1);
-    }
-    if (!*str)
-        return -1;
-    if (PyObject_Hash(*str) == -1)
-        return -1;
-    return 0;
-}
-#endif
-static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+  static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
-        #if PY_MAJOR_VERSION >= 3
-        __Pyx_InitString(*t, t->p);
-        #else
+        #if PY_MAJOR_VERSION < 3
         if (t->is_unicode) {
             *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
         } else if (t->intern) {
             *t->p = PyString_InternFromString(t->s);
         } else {
             *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
         }
+        #else
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
         if (!*t->p)
             return -1;
         if (PyObject_Hash(*t->p) == -1)
             return -1;
-        #endif
         ++t;
     }
     return 0;
 }
 
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
     return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
@@ -29899,15 +22755,15 @@
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
             __Pyx_sys_getdefaultencoding_not_ascii &&
 #endif
             PyUnicode_Check(o)) {
         return __Pyx_PyUnicode_AsStringAndSize(o, length);
     } else
 #endif
-#if (!CYTHON_COMPILING_IN_PYPY && !CYTHON_COMPILING_IN_LIMITED_API) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
+#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
     if (PyByteArray_Check(o)) {
         *length = PyByteArray_GET_SIZE(o);
         return PyByteArray_AS_STRING(o);
     } else
 #endif
     {
         char* result;
@@ -29928,34 +22784,30 @@
     int retval;
     if (unlikely(!x)) return -1;
     retval = __Pyx_PyObject_IsTrue(x);
     Py_DECREF(x);
     return retval;
 }
 static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
-    __Pyx_TypeName result_type_name = __Pyx_PyType_GetName(Py_TYPE(result));
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(result)) {
         if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
-                "__int__ returned non-int (type " __Pyx_FMT_TYPENAME ").  "
-                "The ability to return an instance of a strict subclass of int is deprecated, "
-                "and may be removed in a future version of Python.",
-                result_type_name)) {
-            __Pyx_DECREF_TypeName(result_type_name);
+                "__int__ returned non-int (type %.200s).  "
+                "The ability to return an instance of a strict subclass of int "
+                "is deprecated, and may be removed in a future version of Python.",
+                Py_TYPE(result)->tp_name)) {
             Py_DECREF(result);
             return NULL;
         }
-        __Pyx_DECREF_TypeName(result_type_name);
         return result;
     }
 #endif
     PyErr_Format(PyExc_TypeError,
-                 "__%.4s__ returned non-%.4s (type " __Pyx_FMT_TYPENAME ")",
-                 type_name, type_name, result_type_name);
-    __Pyx_DECREF_TypeName(result_type_name);
+                 "__%.4s__ returned non-%.4s (type %.200s)",
+                 type_name, type_name, Py_TYPE(result)->tp_name);
     Py_DECREF(result);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
 #if CYTHON_USE_TYPE_SLOTS
   PyNumberMethods *m;
 #endif
@@ -30013,19 +22865,21 @@
         return PyInt_AS_LONG(b);
     else
         return PyInt_AsSsize_t(b);
   }
 #endif
   if (likely(PyLong_CheckExact(b))) {
     #if CYTHON_USE_PYLONG_INTERNALS
-    if (likely(__Pyx_PyLong_IsCompact(b))) {
-        return __Pyx_PyLong_CompactValue(b);
+    const digit* digits = ((PyLongObject*)b)->ob_digit;
+    const Py_ssize_t size = Py_SIZE(b);
+    if (likely(__Pyx_sst_abs(size) <= 1)) {
+        ival = likely(size) ? digits[0] : 0;
+        if (size == -1) ival = -ival;
+        return ival;
     } else {
-      const digit* digits = __Pyx_PyLong_Digits(b);
-      const Py_ssize_t size = __Pyx_PyLong_SignedDigitCount(b);
       switch (size) {
          case 2:
            if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
              return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
            }
            break;
          case -2:
@@ -30060,41 +22914,16 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
-  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
-    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
-#if PY_MAJOR_VERSION < 3
-  } else if (likely(PyInt_CheckExact(o))) {
-    return PyInt_AS_LONG(o);
-#endif
-  } else {
-    Py_ssize_t ival;
-    PyObject *x;
-    x = PyNumber_Index(o);
-    if (!x) return -1;
-    ival = PyInt_AsLong(x);
-    Py_DECREF(x);
-    return ival;
-  }
-}
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
 
 
-/* #### Code section: utility_code_pragmas_end ### */
-#ifdef _MSC_VER
-#pragma warning( pop )
-#endif
-
-
-
-/* #### Code section: end ### */
 #endif /* Py_PYTHON_H */
```

### Comparing `chython-1.67/chython/algorithms/_isomorphism.pyx` & `chython-1.8/chython/algorithms/_isomorphism.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -1,158 +1,157 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-cimport cython
-from cpython.mem cimport PyMem_Malloc, PyMem_Free
-from libc.string cimport memset
-
-cdef extern from "Python.h":
-    dict _PyDict_NewPresized(Py_ssize_t minused)
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
-                unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
-                unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
-                unsigned int[::1] q_closures not None, unsigned int[::1] q_from not None,
-                unsigned int[::1] q_to not None, unsigned int[::1] q_indices not None,
-                unsigned long long[::1] q_bonds not None, unsigned long[::1] o_numbers not None,
-                unsigned long long[::1] o_bits1 not None, unsigned long long[::1] o_bits2 not None,
-                unsigned long long[::1] o_bits3 not None, unsigned long long[::1] o_bits4 not None,
-                unsigned long long[::1] o_bonds not None, unsigned int[::1] o_from not None,
-                unsigned int[::1] o_to not None, unsigned int[::1] o_indices not None,
-                unsigned int[::1] scope not None):
-    # expected less than 2^16 atoms in structure.
-    cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num
-    cdef unsigned int n, m, o, i, j, closures_counter
-    cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond, c_bond
-    cdef dict mapping
-
-    q_size = len(q_numbers)
-    q_size_dec = q_size - 1
-    o_size = len(o_numbers)
-    cdef unsigned int *path = <unsigned int *> PyMem_Malloc(q_size_dec * sizeof(unsigned int))
-    cdef unsigned int *stack_index = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
-    cdef unsigned int *stack_depth = <unsigned int *> PyMem_Malloc(2 * o_size * sizeof(unsigned int))
-    cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
-    cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
-
-    if not path or not stack_index or not stack_depth or not matched or not o_closures:
-        raise MemoryError()
-
-    memset(matched, 0, o_size * sizeof(bint))
-    memset(o_closures, 0, o_size * sizeof(unsigned long long))
-
-    # find entry-points.
-    q_mask1 = q_masks1[0]
-    q_mask2 = q_masks2[0]
-    q_mask3 = q_masks3[0]
-    q_mask4 = q_masks4[0]
-    for n in range(o_size):
-        if (scope[n] and
-            q_mask1 & o_bits1[n] and  # o_bits1 doesn't contain bond bits.
-            q_mask2 & o_bits2[n] == o_bits2[n] and
-            q_mask3 & o_bits3[n] == o_bits3[n] and
-            q_mask4 & o_bits4[n]):
-
-            stack_index[stack] = n
-            stack_depth[stack] = 0
-            stack += 1
-
-    try:
-        while stack:
-            stack -= 1
-            depth = stack_depth[stack]
-            n = stack_index[stack]
-
-            if depth == q_size_dec:
-                mapping = _PyDict_NewPresized(q_size)
-                for i in range(depth):
-                    mapping[q_numbers[i]] = o_numbers[path[i]]
-                mapping[q_numbers[depth]] = o_numbers[n]
-                yield mapping
-            else:
-                if path_size != depth:  # dead end reached
-                    for i in range(depth, path_size):
-                        matched[path[i]] = False  # mark unmatched
-                    path_size = depth
-
-                matched[n] = True
-                path[path_size] = n
-                path_size += 1
-
-                front = depth + 1
-                back = q_back[front]
-                if back != depth:  # branch
-                    n = path[back]
-
-                # load next query atom
-                q_mask1 = q_masks1[front]
-                q_mask2 = q_masks2[front]
-                q_mask3 = q_masks3[front]
-                q_mask4 = q_masks4[front]
-                closures_num = q_closures[front]
-
-                for i in range(o_from[n], o_to[n]):
-                    o_bond = o_bonds[i]
-                    m = o_indices[i]
-                    if (scope[m] and not matched[m] and
-                        q_mask1 & o_bond == o_bond and  # bond order, in ring mark and atom bit should match.
-                        q_mask2 & o_bits2[m] == o_bits2[m] and
-                        q_mask3 & o_bits3[m] == o_bits3[m] and
-                        q_mask4 & o_bits4[m]):
-
-                        if closures_num:  # candidate atom should have same closures.
-                            closures_counter = 0
-                            # make a map of closures for o_n atom
-                            # an index is a neighbor atom and a value is a bond between o_n and the neighbor
-                            for j in range(o_from[m], o_to[m]):
-                                o = o_indices[j]
-                                if o != n and matched[o]:
-                                    o_closures[o] = o_bonds[j]
-                                    closures_counter += 1
-
-                            if closures_counter == closures_num:
-                                for j in range(q_from[front], q_to[front]):
-                                    c_bond = o_closures[path[q_indices[j]]]
-                                    if not c_bond or q_bonds[j] & c_bond != c_bond:  # compare order and ring bits
-                                        break
-                                else:
-                                    stack_index[stack] = m
-                                    stack_depth[stack] = front
-                                    stack += 1
-
-                            # fill an array with nulls
-                            for j in range(o_from[m], o_to[m]):
-                                o_closures[o_indices[j]] = 0
-                        else:  # candidate atom should not have closures.
-                            for j in range(o_from[m], o_to[m]):
-                               o = o_indices[j]
-                               if o != n and matched[o]:
-                                   break  # found closure
-                            else:
-                                stack_index[stack] = m
-                                stack_depth[stack] = front
-                                stack += 1
-    finally:
-        PyMem_Free(path)
-        PyMem_Free(matched)
-        PyMem_Free(stack_index)
-        PyMem_Free(stack_depth)
-        PyMem_Free(o_closures)
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+cimport cython
+from cpython.mem cimport PyMem_Malloc, PyMem_Free
+from libc.string cimport memset
+
+cdef extern from "Python.h":
+    dict _PyDict_NewPresized(Py_ssize_t minused)
+
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,
+                unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+                unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+                unsigned int[::1] q_closures not None, unsigned int[::1] q_from not None,
+                unsigned int[::1] q_to not None, unsigned int[::1] q_indices not None,
+                unsigned long long[::1] q_bonds not None, unsigned long[::1] o_numbers not None,
+                unsigned long long[::1] o_bits1 not None, unsigned long long[::1] o_bits2 not None,
+                unsigned long long[::1] o_bits3 not None, unsigned long long[::1] o_bits4 not None,
+                unsigned long long[::1] o_bonds not None, unsigned int[::1] o_from not None,
+                unsigned int[::1] o_to not None, unsigned int[::1] o_indices not None,
+                unsigned int[::1] scope not None):
+    # expected less than 2^16 atoms in structure.
+    cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num
+    cdef unsigned int n, m, o, i, j, closures_counter
+    cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond
+    cdef dict mapping
+
+    q_size = len(q_numbers)
+    q_size_dec = q_size - 1
+    o_size = len(o_numbers)
+    cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+    cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+    cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+    cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
+    cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+
+    if not path or not stack_index or not stack_depth or not matched or not o_closures:
+        raise MemoryError()
+
+    memset(matched, 0, o_size * sizeof(bint))
+    memset(o_closures, 0, o_size * sizeof(unsigned long long))
+
+    # find entry-points.
+    q_mask1 = q_masks1[0]
+    q_mask2 = q_masks2[0]
+    q_mask3 = q_masks3[0]
+    q_mask4 = q_masks4[0]
+    for n in range(o_size):
+        if (scope[n] and
+            q_mask1 & o_bits1[n] and
+            q_mask2 & o_bits2[n] == o_bits2[n] and
+            q_mask3 & o_bits3[n] == o_bits3[n] and
+            q_mask4 & o_bits4[n]):
+
+            stack_index[stack] = n
+            stack_depth[stack] = 0
+            stack += 1
+
+    try:
+        while stack:
+            stack -= 1
+            depth = stack_depth[stack]
+            n = stack_index[stack]
+
+            if depth == q_size_dec:
+                mapping = _PyDict_NewPresized(q_size)
+                for i in range(depth):
+                    mapping[q_numbers[i]] = o_numbers[path[i]]
+                mapping[q_numbers[depth]] = o_numbers[n]
+                yield mapping
+            else:
+                if path_size != depth:  # dead end reached
+                    for i in range(depth, path_size):
+                        matched[path[i]] = False  # mark unmatched
+                    path_size = depth
+
+                matched[n] = True
+                path[path_size] = n
+                path_size += 1
+
+                front = depth + 1
+                back = q_back[front]
+                if back != depth:  # branch
+                    n = path[back]
+
+                # load next query atom
+                q_mask1 = q_masks1[front]
+                q_mask2 = q_masks2[front]
+                q_mask3 = q_masks3[front]
+                q_mask4 = q_masks4[front]
+                closures_num = q_closures[front]
+
+                for i in range(o_from[n], o_to[n]):
+                    o_bond = o_bonds[i]
+                    m = o_indices[i]
+                    if (scope[m] and not matched[m] and
+                        q_mask1 & o_bond == o_bond and
+                        q_mask2 & o_bits2[m] == o_bits2[m] and
+                        q_mask3 & o_bits3[m] == o_bits3[m] and
+                        q_mask4 & o_bits4[m]):
+
+                        if closures_num:  # candidate atom should have same closures.
+                            closures_counter = 0
+                            # make a map of closures for o_n atom
+                            # an index is an neighbor atom and an value is an bond between o_n and the neighbor
+                            for j in range(o_from[m], o_to[m]):
+                                o = o_indices[j]
+                                if o != n and matched[o]:
+                                    o_closures[o] = o_bonds[j]
+                                    closures_counter += 1
+
+                            if closures_counter == closures_num:
+                                for j in range(q_from[front], q_to[front]):
+                                    if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+                                        break
+                                else:
+                                    stack_index[stack] = m
+                                    stack_depth[stack] = front
+                                    stack += 1
+
+                            # fill an array with nulls
+                            for j in range(o_from[m], o_to[m]):
+                                o_closures[o_indices[j]] = 0
+                        else:  # candidate atom should not have closures.
+                            for j in range(o_from[m], o_to[m]):
+                               o = o_indices[j]
+                               if o != n and matched[o]:
+                                   break  # found closure
+                            else:
+                                stack_index[stack] = m
+                                stack_depth[stack] = front
+                                stack += 1
+    finally:
+        PyMem_Free(path)
+        PyMem_Free(matched)
+        PyMem_Free(stack_index)
+        PyMem_Free(stack_depth)
+        PyMem_Free(o_closures)
```

### Comparing `chython-1.67/chython/algorithms/aromatics/__init__.py` & `chython-1.8/chython/algorithms/fingerprints/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,29 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .kekule import *
-from .thiele import *
-
-
-class Aromatize(Thiele, Kekule):
-    __slots__ = ()
-
-
-__all__ = ['Aromatize']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .linear import *
+from .morgan import *
+from .pharmacophore import *
+
+
+class Fingerprints(LinearFingerprint, MorganFingerprint, Pharmacophore):
+    __slots__ = ()
+
+
+__all__ = ['Fingerprints']
```

### Comparing `chython-1.67/chython/algorithms/aromatics/kekule.py` & `chython-1.8/chython/algorithms/aromatics/kekule.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,521 +1,476 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict, deque
-from typing import List, Optional, Tuple, TYPE_CHECKING, Union
-from ._rules import rules
-from ..._functions import lazy_product
-from ...exceptions import InvalidAromaticRing
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-class Kekule:
-    __slots__ = ()
-
-    def kekule(self: Union['Kekule', 'MoleculeContainer'], *, buffer_size=7) -> bool:
-        """
-        Convert structure to kekule form. Return True if found any aromatic ring. Set implicit hydrogen count and
-        hybridization marks on atoms.
-
-        Only one of possible double/single bonds positions will be set.
-        For enumerate bonds positions use `enumerate_kekule`.
-
-        :param buffer_size: number of attempts of pyridine form searching.
-        """
-        fixed = self.__fix_rings()  # fix bad aromatic rings
-        kekule = next(self.__kekule_full(buffer_size), None)
-        if kekule:
-            bonds = self._bonds
-            atoms = set()
-            for n, m, b in kekule:
-                bonds[n][m]._Bond__order = b  # noqa
-                atoms.add(n)
-                atoms.add(m)
-            for n in atoms:
-                self._calc_implicit(n)
-            self.flush_cache()
-            return True
-        return fixed
-
-    def enumerate_kekule(self: Union['Kekule', 'MoleculeContainer']):
-        """
-        Enumerate all possible kekule forms of molecule.
-        """
-        self.__fix_rings()  # fix bad aromatic rings
-        for form in self.__kekule_full(0):
-            copy = self.copy()
-            bonds = copy._bonds
-            atoms = set()
-            for n, m, b in form:
-                bonds[n][m]._Bond__order = b  # noqa
-                atoms.add(n)
-                atoms.add(m)
-            for n in atoms:
-                copy._calc_implicit(n)
-            yield copy
-
-    def __fix_rings(self: 'MoleculeContainer'):
-        bonds = self._bonds
-        charges = self._charges
-        seen = set()
-        for q, af, bf, mm in rules:
-            for mapping in q.get_mapping(self, automorphism_filter=False):
-                match = set(mapping.values())
-                if not mm and not match.isdisjoint(seen):  # prevent double patching of atoms
-                    continue
-                seen.update(match)
-
-                for n, c in af.items():
-                    n = mapping[n]
-                    charges[n] = c
-                for n, m, b in bf:
-                    n = mapping[n]
-                    m = mapping[m]
-                    bonds[n][m]._Bond__order = b  # noqa
-        if seen:
-            self.flush_cache()
-            return True
-        return False
-
-    def __prepare_rings(self: 'MoleculeContainer'):
-        atoms = self._atoms
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        hydrogens = self._hydrogens
-        neighbors = self.neighbors
-
-        rings = defaultdict(list)  # aromatic skeleton
-        pyrroles = set()
-
-        double_bonded = defaultdict(list)
-        triple_bonded = set()
-        for n, m_bond in bonds.items():
-            for m, bond in m_bond.items():
-                bo = bond.order
-                if bo == 4:
-                    rings[n].append(m)
-                elif bo == 2:
-                    double_bonded[n].append(m)
-                elif bo == 3:
-                    triple_bonded.add(n)
-
-        if not rings:
-            return rings, pyrroles, set()
-        elif not triple_bonded.isdisjoint(rings):
-            raise InvalidAromaticRing('triple bonds connected to rings')
-
-        copy_rings = {n: ms.copy() for n, ms in rings.items()}
-        for r in self.sssr:
-            if set(r).issubset(rings):
-                n, *_, m = r
-                if n not in rings[m]:  # fix invalid structures: c1ccc-cc1
-                    # remove inner ring double bonds: c1ccc=cc1
-                    if n in double_bonded and m in double_bonded and m in double_bonded[n]:
-                        double_bonded[n].remove(m)
-                        double_bonded[m].remove(n)
-                    rings[m].append(n)
-                    rings[n].append(m)
-                elif m in copy_rings[n]:
-                    copy_rings[n].remove(m)
-                    copy_rings[m].remove(n)
-                for n, m in zip(r, r[1:]):
-                    if n not in rings[m]:
-                        if n in double_bonded and m in double_bonded and m in double_bonded[n]:
-                            double_bonded[n].remove(m)
-                            double_bonded[m].remove(n)
-                        rings[m].append(n)
-                        rings[n].append(m)
-                    elif m in copy_rings[n]:
-                        copy_rings[n].remove(m)
-                        copy_rings[m].remove(n)
-
-        # fix invalid smiles: c1ccccc1c2ccccc2 instead of c1ccccc1-c2ccccc2
-        seen = set()
-        for n, ms in copy_rings.items():
-            if ms:
-                seen.add(n)
-                for m in ms:
-                    if m not in seen:
-                        rings[n].remove(m)
-                        rings[m].remove(n)
-                        bonds[n][m]._Bond__order = 1  # noqa
-
-        if any(len(ms) not in (2, 3) for ms in rings.values()):
-            raise InvalidAromaticRing('not in ring aromatic bond or hypercondensed rings: '
-                                      f'{{{", ".join(str(n) for n, ms in rings.items() if len(ms) not in (2, 3))}}}')
-
-        # get double bonded ring atoms
-        double_bonded = {n for n, ms in double_bonded.items() if ms and n in rings}
-        if any(len(rings[n]) != 2 for n in double_bonded):  # double bonded never condensed
-            raise InvalidAromaticRing('quinone valence error')
-        for n in double_bonded:
-            if atoms[n].atomic_number == 7:
-                if charges[n] != 1:
-                    raise InvalidAromaticRing('quinone should be charged N atom')
-            elif atoms[n].atomic_number not in (6, 15, 16, 33, 34, 52) or charges[n]:
-                raise InvalidAromaticRing('quinone should be neutral S, Se, Te, C, P, As atom')
-
-        for n in rings:
-            an = atoms[n].atomic_number
-            ac = charges[n]
-            ab = neighbors(n)
-            if an == 6:  # carbon
-                if ac == 0:
-                    if ab not in (2, 3):
-                        raise InvalidAromaticRing
-                elif ac in (-1, 1):
-                    if radicals[n]:
-                        if ab == 2:
-                            double_bonded.add(n)
-                        else:
-                            raise InvalidAromaticRing
-                    elif ab == 3:
-                        double_bonded.add(n)
-                    elif ab == 2:  # benzene (an|cat)ion or pyrrole
-                        pyrroles.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                else:
-                    raise InvalidAromaticRing
-            elif an in (7, 15, 33):
-                if ac == 0:  # pyrrole or pyridine. include radical pyrrole
-                    if radicals[n]:
-                        if ab != 2:  # only pyrrole radical
-                            raise InvalidAromaticRing
-                        double_bonded.add(n)
-                    elif ab == 3:
-                        if an == 7:  # pyrrole only possible
-                            double_bonded.add(n)
-                        else:  # P(III) or P(V)H
-                            pyrroles.add(n)
-                    elif ab == 2:
-                        ah = hydrogens[n]
-                        if ah is None:  # pyrrole or pyridine
-                            pyrroles.add(n)
-                        elif ah == 1:  # only pyrrole
-                            double_bonded.add(n)
-                        elif ah:  # too many hydrogens for aromatic rings
-                            raise InvalidAromaticRing
-                    elif ab != 4 or an not in (15, 33):  # P(V) in ring [P;a](-R1)-R2
-                        raise InvalidAromaticRing
-                elif ac == -1:  # pyrrole only
-                    if ab != 2 or radicals[n]:
-                        raise InvalidAromaticRing
-                    double_bonded.add(n)
-                elif ac != 1:
-                    raise InvalidAromaticRing
-                elif radicals[n]:
-                    if ab != 2:  # not cation-radical pyridine
-                        raise InvalidAromaticRing
-                elif ab == 2:  # pyrrole cation or protonated pyridine
-                    pyrroles.add(n)
-                elif ab != 3:  # not pyridine oxyde
-                    raise InvalidAromaticRing
-            elif an == 8:  # furan
-                if ab == 2:
-                    if ac == 0:
-                        if radicals[n]:
-                            raise InvalidAromaticRing('radical oxygen')
-                        double_bonded.add(n)
-                    elif ac == 1:
-                        if radicals[n]:  # furan cation-radical
-                            double_bonded.add(n)
-                        # pyrylium
-                    else:
-                        raise InvalidAromaticRing('invalid oxygen charge')
-                else:
-                    raise InvalidAromaticRing('Triple-bonded oxygen')
-            elif an in (16, 34, 52):  # thiophene
-                if n not in double_bonded:  # not sulphoxyde nor sulphone
-                    if ab == 2:
-                        if radicals[n]:
-                            if ac == 1:
-                                double_bonded.add(n)
-                            else:
-                                raise InvalidAromaticRing('S, Se, Te cation-radical expected')
-                        if ac == 0:
-                            double_bonded.add(n)
-                        elif ac != 1:
-                            raise InvalidAromaticRing('S, Se, Te cation in benzene like ring expected')
-                    elif ab == 3:
-                        if radicals[n]:
-                            if ac:
-                                raise InvalidAromaticRing('S, Se, Te ion-radical ring')
-                            double_bonded.add(n)
-                        elif ac == 1:
-                            double_bonded.add(n)
-                        elif ac:
-                            raise InvalidAromaticRing('S, Se, Te invalid charge ring')
-                    else:
-                        raise InvalidAromaticRing('S, Se, Te hypervalent ring')
-            elif an == 5:  # boron
-                if ac == 0:
-                    if ab == 2:
-                        if radicals[n]:  # C=1O[B]OC=1
-                            double_bonded.add(n)
-                        else:
-                            ah = hydrogens[n]
-                            if ah is None:  # b1ccccc1, C=1OBOC=1 or B1C=CC=N1
-                                pyrroles.add(n)
-                            elif ah == 1:  # C=1O[BH]OC=1 or [BH]1C=CC=N1
-                                double_bonded.add(n)
-                            elif ah:
-                                raise InvalidAromaticRing
-                    elif not radicals[n]:
-                        double_bonded.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                elif ac == 1:
-                    if ab == 2 and not radicals[n]:
-                        double_bonded.add(n)
-                    else:
-                        raise InvalidAromaticRing
-                elif ac == -1:
-                    if ab == 2:
-                        if not radicals[n]:  # C=1O[B-]OC=1 or [bH-]1ccccc1
-                            pyrroles.add(n)
-                        # anion-radical is benzene like
-                    elif radicals[n]:  # C=1O[B-*](R)OC=1
-                        double_bonded.add(n)
-                    else:
-                        pyrroles.add(n)
-                else:
-                    raise InvalidAromaticRing
-            else:
-                raise InvalidAromaticRing(f'only B, C, N, P, O, S, Se, Te possible, not: {atoms[n].atomic_symbol}')
-        return rings, pyrroles, double_bonded
-
-    def __kekule_full(self, buffer_size):
-        rings, pyrroles, double_bonded = self.__prepare_rings()
-        atoms = set(rings)
-        components = []
-        while atoms:
-            start = atoms.pop()
-            component = {start: rings[start]}
-            queue = deque([start])
-            while queue:
-                current = queue.popleft()
-                for n in rings[current]:
-                    if n not in component:
-                        queue.append(n)
-                        component[n] = rings[n]
-
-            components.append(component)
-            atoms.difference_update(component)
-
-        for keks in lazy_product(*(_kekule_component(c, double_bonded & c.keys(), pyrroles & c.keys(), buffer_size)
-                                   for c in components)):
-            yield [x for x in keks for x in x]
-
-
-def _kekule_component(rings, double_bonded, pyrroles, buffer_size):
-    # (current atom, previous atom, bond between cp atoms, path deep for cutting [None if cut impossible])
-    stack: List[List[Tuple[int, int, int, Optional[int]]]]
-    if double_bonded:  # start from double bonded if exists
-        start = next(iter(double_bonded))
-        stack = [[(next(iter(rings[start])), start, 1, 0)]]
-    else:  # select not pyrrole not condensed atom
-        try:
-            start = next(n for n, ms in rings.items() if len(ms) == 2 and n not in pyrroles)
-        except StopIteration:  # all pyrroles. select not condensed atom.
-            try:
-                start = next(n for n, ms in rings.items() if len(ms) == 2)
-            except StopIteration:  # fullerene?
-                start = next(iter(rings))
-                double_bonded.add(start)
-                stack = [[(next_atom, start, 2, 0)] for next_atom in rings[start]]
-            else:
-                stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
-        else:
-            stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
-
-    size = sum(len(x) for x in rings.values()) // 2
-    path = []
-    hashed_path = set()
-    nether_yielded = True
-    buffer = []
-
-    while stack:
-        atom, prev_atom, bond, _ = stack[-1].pop()
-        path.append((atom, prev_atom, bond))
-        hashed_path.add(atom)
-
-        if len(path) == size:
-            if nether_yielded:
-                nether_yielded = False
-            if pyrroles and buffer_size:  # prioritize pyridine over pyrrole
-                g = defaultdict(int)
-                for n, m, b in path:
-                    g[n] += b
-                    g[m] += b
-                # should be pairs of pyrrole atoms
-                if sum(b == 2 and n in pyrroles for n, b in g.items()) >= 2:
-                    if len(buffer) == buffer_size:  # optimization. try only few times to prevent freezes.
-                        buffer_size = 0  # disable bufferization
-                        yield from buffer
-                        yield path
-                        buffer = []
-                    else:
-                        buffer.append(path)
-                else:
-                    yield path
-                    buffer_size = 0  # disable bufferization
-                    if buffer:  # empty buffer
-                        yield from buffer
-                        buffer = []
-            else:
-                yield path
-
-            del stack[-1]
-            if stack:
-                path = path[:stack[-1][-1][-1]]
-                hashed_path = {x for x, *_ in path}
-        elif atom != start:
-            for_stack = []
-            closures = []
-            loop = 0
-            for next_atom in rings[atom]:
-                if next_atom == prev_atom:  # only forward. behind us is the homeland
-                    continue
-                elif next_atom == start:
-                    loop = next_atom
-                elif next_atom in hashed_path:  # closure found
-                    closures.append(next_atom)
-                else:
-                    for_stack.append(next_atom)
-
-            if loop:  # we found starting point.
-                if bond == 2:  # finish should be single bonded
-                    if double_bonded:  # ok
-                        stack[-1].insert(0, (loop, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                        continue
-                elif double_bonded:  # we in quinone ring. finish should be single bonded
-                    # side-path for storing double bond or atom is quinone or pyrrole
-                    if for_stack or atom in double_bonded or atom in pyrroles:
-                        stack[-1].insert(0, (loop, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                        continue
-                else:  # finish should be double bonded
-                    stack[-1].insert(0, (loop, atom, 2, None))
-                    bond = 2  # grow should be single bonded
-
-            if bond == 2 or atom in double_bonded:  # double in - single out. quinone has two single bonds
-                for next_atom in closures:
-                    path.append((next_atom, atom, 1))  # closures always single-bonded
-                    stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
-                for next_atom in for_stack:
-                    stack[-1].append((next_atom, atom, 1, None))
-            elif len(for_stack) == 1:  # easy path grow. next bond double or include single for pyrroles
-                next_atom = for_stack[0]
-                if next_atom in double_bonded:  # need double bond, but next atom quinone
-                    if atom in pyrroles:
-                        stack[-1].append((next_atom, atom, 1, None))
-                    else:
-                        del stack[-1]
-                        if stack:
-                            path = path[:stack[-1][-1][-1]]
-                            hashed_path = {x for x, *_ in path}
-                elif atom in pyrroles:  # try pyrrole and pyridine
-                    opposite = stack[-1].copy()
-                    opposite.append((next_atom, atom, 2, None))
-                    stack[-1].append((next_atom, atom, 1, len(path)))
-                    stack.append(opposite)
-                else:
-                    stack[-1].append((next_atom, atom, 2, None))
-                    if closures:
-                        next_atom = closures[0]
-                        path.append((next_atom, atom, 1))  # closures always single-bonded
-                        stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
-            elif for_stack:  # fork
-                next_atom1, next_atom2 = for_stack
-                if next_atom1 in double_bonded:  # quinone next from fork
-                    if next_atom2 in double_bonded:
-                        if atom in pyrroles:  # shit like O=C1C=CC2=CC=CC3=C2P1C(=O)C=C3
-                            stack[-1].append((next_atom1, atom, 1, None))
-                            stack[-1].append((next_atom2, atom, 1, None))
-                        else:  # bad path
-                            del stack[-1]
-                            if stack:
-                                path = path[:stack[-1][-1][-1]]
-                                hashed_path = {x for x, *_ in path}
-                    elif atom in pyrroles:  # O=C1C=CC2=CC=CC3=C2P1C=C3 or O=C1C=CC2=CC=CC3=C2P1=CC=C3
-                        opposite = stack[-1].copy()
-                        opposite.append((next_atom1, atom, 1, None))
-                        opposite.append((next_atom2, atom, 2, None))
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 1, len(path)))
-                        stack.append(opposite)  # pyridine first
-                    else:  # normal condensed ring
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 2, None))
-                elif next_atom2 in double_bonded:  # quinone next from fork
-                    if atom in pyrroles:
-                        opposite = stack[-1].copy()
-                        opposite.append((next_atom2, atom, 1, None))
-                        opposite.append((next_atom1, atom, 2, None))
-                        stack[-1].append((next_atom1, atom, 1, None))
-                        stack[-1].append((next_atom2, atom, 1, len(path)))
-                        stack.append(opposite)
-                    else:
-                        stack[-1].append((next_atom2, atom, 1, None))
-                        stack[-1].append((next_atom1, atom, 2, None))
-                elif atom in pyrroles:  # C1=CC2=CC=CC3=C2P1C=C3 or C1=CP2=CC=CC3=C2C1=CC=C3
-                    opposite1 = stack[-1].copy()
-                    opposite1.append((next_atom2, atom, 1, None))
-                    opposite1.append((next_atom1, atom, 2, len(path)))
-                    opposite2 = stack[-1].copy()
-                    opposite2.append((next_atom1, atom, 1, None))
-                    opposite2.append((next_atom2, atom, 2, None))
-
-                    stack[-1].append((next_atom1, atom, 1, None))
-                    stack[-1].append((next_atom2, atom, 1, len(path)))
-                    stack.append(opposite1)
-                    stack.append(opposite2)
-                else:  # new path
-                    opposite = stack[-1].copy()
-                    stack[-1].append((next_atom1, atom, 1, None))
-                    stack[-1].append((next_atom2, atom, 2, len(path)))  # double bond on top of stack
-                    opposite.append((next_atom2, atom, 1, None))
-                    opposite.append((next_atom1, atom, 2, None))
-                    stack.append(opposite)
-            elif closures and atom not in pyrroles:  # need double bond, but closure should be single bonded
-                del stack[-1]
-                if stack:
-                    path = path[:stack[-1][-1][-1]]
-                    hashed_path = {x for x, *_ in path}
-
-    if nether_yielded:
-        raise InvalidAromaticRing(f'kekule form not found for: {list(rings)}')
-    elif buffer:  # optimal solution not found. return available.
-        yield from buffer
-
-
-__all__ = ['Kekule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, deque
+from typing import List, Optional, Tuple, TYPE_CHECKING, Union
+from ._rules import rules
+from ..._functions import lazy_product
+from ...exceptions import InvalidAromaticRing
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+class Kekule:
+    __slots__ = ()
+
+    def kekule(self: Union['Kekule', 'MoleculeContainer']) -> bool:
+        """
+        Convert structure to kekule form. Return True if found any aromatic ring. Set implicit hydrogen count and
+        hybridization marks on atoms.
+
+        Only one of possible double/single bonds positions will be set.
+        For enumerate bonds positions use `enumerate_kekule`.
+        """
+        kekule = next(self.__kekule_full(), None)
+        if kekule:
+            bonds = self._bonds
+            atoms = set()
+            for n, m, b in kekule:
+                bonds[n][m]._Bond__order = b
+                atoms.add(n)
+                atoms.add(m)
+            for n in atoms:
+                self._calc_implicit(n)
+            self.flush_cache()
+            return True
+        return False
+
+    def enumerate_kekule(self: Union['Kekule', 'MoleculeContainer']):
+        """
+        Enumerate all possible kekule forms of molecule.
+        """
+        for form in self.__kekule_full():
+            copy = self.copy()
+            bonds = copy._bonds
+            atoms = set()
+            for n, m, b in form:
+                bonds[n][m]._Bond__order = b
+                atoms.add(n)
+                atoms.add(m)
+            for n in atoms:
+                copy._calc_implicit(n)
+            yield copy
+
+    def check_thiele(self, fast=True) -> bool:
+        """
+        Check basic aromaticity errors of molecule.
+
+        :param fast: don't try to solve kekule form
+        """
+        try:
+            if fast:
+                self.__prepare_rings()
+            else:
+                next(self.__kekule_full(), None)
+        except InvalidAromaticRing:
+            return False
+        return True
+
+    def __fix_rings(self: 'MoleculeContainer'):
+        bonds = self._bonds
+        seen = set()
+        for q, af, bf in rules:
+            for mapping in q.get_mapping(self, automorphism_filter=False):
+                match = set(mapping.values())
+                if not match.isdisjoint(seen):  # prevent double patching of atoms
+                    continue
+                seen.update(match)
+
+                for n, fix in af.items():
+                    n = mapping[n]
+                    for key, value in fix.items():
+                        getattr(self, key)[n] = value
+                for n, m, b in bf:
+                    n = mapping[n]
+                    m = mapping[m]
+                    bonds[n][m]._Bond__order = b
+        if seen:
+            self.flush_cache()
+
+    def __prepare_rings(self: 'MoleculeContainer'):
+        atoms = self._atoms
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        hydrogens = self._hydrogens
+        neighbors = self.neighbors
+
+        rings = defaultdict(list)  # aromatic skeleton
+        pyroles = set()
+
+        double_bonded = defaultdict(list)
+        triple_bonded = set()
+        for n, m_bond in bonds.items():
+            for m, bond in m_bond.items():
+                bo = bond.order
+                if bo == 4:
+                    rings[n].append(m)
+                elif bo == 2:
+                    double_bonded[n].append(m)
+                elif bo == 3:
+                    triple_bonded.add(n)
+
+        if not rings:
+            return rings, pyroles, set()
+        elif not triple_bonded.isdisjoint(rings):
+            raise InvalidAromaticRing('triple bonds connected to rings')
+
+        copy_rings = {n: ms.copy() for n, ms in rings.items()}
+        for r in self.sssr:
+            if set(r).issubset(rings):
+                n, *_, m = r
+                if n not in rings[m]:  # fix invalid structures: c1ccc-cc1
+                    # remove inner ring double bonds: c1ccc=cc1
+                    if n in double_bonded and m in double_bonded and m in double_bonded[n]:
+                        double_bonded[n].remove(m)
+                        double_bonded[m].remove(n)
+                    rings[m].append(n)
+                    rings[n].append(m)
+                elif m in copy_rings[n]:
+                    copy_rings[n].remove(m)
+                    copy_rings[m].remove(n)
+                for n, m in zip(r, r[1:]):
+                    if n not in rings[m]:
+                        if n in double_bonded and m in double_bonded and m in double_bonded[n]:
+                            double_bonded[n].remove(m)
+                            double_bonded[m].remove(n)
+                        rings[m].append(n)
+                        rings[n].append(m)
+                    elif m in copy_rings[n]:
+                        copy_rings[n].remove(m)
+                        copy_rings[m].remove(n)
+
+        # fix invalid smiles: c1ccccc1c2ccccc2 instead of c1ccccc1-c2ccccc2
+        seen = set()
+        for n, ms in copy_rings.items():
+            if ms:
+                seen.add(n)
+                for m in ms:
+                    if m not in seen:
+                        rings[n].remove(m)
+                        rings[m].remove(n)
+                        bonds[n][m]._Bond__order = 1
+
+        if any(len(ms) not in (2, 3) for ms in rings.values()):
+            raise InvalidAromaticRing('not in ring aromatic bond or hypercondensed rings: '
+                                      f'{{{", ".join(str(n) for n, ms in rings.items() if len(ms) not in (2, 3))}}}')
+
+        # get double bonded ring atoms
+        double_bonded = {n for n, ms in double_bonded.items() if ms and n in rings}
+        if any(len(rings[n]) != 2 for n in double_bonded):  # double bonded never condensed
+            raise InvalidAromaticRing('quinone valence error')
+        for n in double_bonded:
+            if atoms[n].atomic_number == 7:
+                if charges[n] != 1:
+                    raise InvalidAromaticRing('quinone should be charged N atom')
+            elif atoms[n].atomic_number not in (6, 15, 16, 33, 34, 52) or charges[n]:
+                raise InvalidAromaticRing('quinone should be neutral S, Se, Te, C, P, As atom')
+
+        for n in rings:
+            an = atoms[n].atomic_number
+            ac = charges[n]
+            ab = neighbors(n)
+            if an == 6:  # carbon
+                if ac == 0:
+                    if ab not in (2, 3):
+                        raise InvalidAromaticRing
+                elif ac in (-1, 1):
+                    if radicals[n]:
+                        if ab == 2:
+                            double_bonded.add(n)
+                        else:
+                            raise InvalidAromaticRing
+                    elif ab == 3:
+                        double_bonded.add(n)
+                    elif ab == 2:  # benzene an[cat]ion or pyrole
+                        pyroles.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                else:
+                    raise InvalidAromaticRing
+            elif an in (7, 15, 33):
+                if ac == 0:  # pyrole or pyridine. include radical pyrole
+                    if radicals[n]:
+                        if ab != 2:
+                            raise InvalidAromaticRing
+                        double_bonded.add(n)
+                    elif ab == 3:
+                        if an == 7:  # pyrole only possible
+                            double_bonded.add(n)
+                        else:  # P(III) or P(V)H
+                            pyroles.add(n)
+                    elif ab == 2:
+                        ah = hydrogens[n]
+                        if ah is None:
+                            pyroles.add(n)
+                        elif ah == 1:  # only pyrole
+                            double_bonded.add(n)
+                        elif ah:
+                            raise InvalidAromaticRing
+                    elif ab != 4 or an not in (15, 33):  # P(V) in ring
+                        raise InvalidAromaticRing
+                elif ac == -1:  # pyrole only
+                    if ab != 2 or radicals[n]:
+                        raise InvalidAromaticRing
+                    double_bonded.add(n)
+                elif ac != 1:
+                    raise InvalidAromaticRing
+                elif radicals[n]:
+                    if ab != 2:  # not cation-radical pyridine
+                        raise InvalidAromaticRing
+                elif ab == 2:  # pyrole cation or protonated pyridine
+                    pyroles.add(n)
+                elif ab != 3:  # not pyridine oxyde
+                    raise InvalidAromaticRing
+            elif an == 8:  # furan
+                if ab == 2:
+                    if ac == 0:
+                        if radicals[n]:
+                            raise InvalidAromaticRing('radical oxygen')
+                        double_bonded.add(n)
+                    elif ac == 1:
+                        if radicals[n]:  # furan cation-radical
+                            double_bonded.add(n)
+                        # pyrylium
+                    else:
+                        raise InvalidAromaticRing('invalid oxygen charge')
+                else:
+                    raise InvalidAromaticRing('Triple-bonded oxygen')
+            elif an in (16, 34, 52):  # thiophene
+                if n not in double_bonded:  # not sulphoxyde or sulphone
+                    if ab == 2:
+                        if radicals[n]:
+                            if ac == 1:
+                                double_bonded.add(n)
+                            else:
+                                raise InvalidAromaticRing('S, Se, Te cation-radical expected')
+                        if ac == 0:
+                            double_bonded.add(n)
+                        elif ac != 1:
+                            raise InvalidAromaticRing('S, Se, Te cation in benzene like ring expected')
+                    elif ab == 3:
+                        if radicals[n]:
+                            if ac:
+                                raise InvalidAromaticRing('S, Se, Te ion-radical ring')
+                            double_bonded.add(n)
+                        elif ac == 1:
+                            double_bonded.add(n)
+                        elif ac:
+                            raise InvalidAromaticRing('S, Se, Te invalid charge ring')
+                    else:
+                        raise InvalidAromaticRing('S, Se, Te hypervalent ring')
+            elif an == 5:  # boron
+                if ac == 0:
+                    if ab == 2:
+                        if radicals[n]:  # C=1O[B]OC=1
+                            double_bonded.add(n)
+                        else:
+                            ah = hydrogens[n]
+                            if ah is None:  # b1ccccc1, C=1OBOC=1 or B1C=CC=N1
+                                pyroles.add(n)
+                            elif ah == 1:  # C=1O[BH]OC=1 or [BH]1C=CC=N1
+                                double_bonded.add(n)
+                            elif ah:
+                                raise InvalidAromaticRing
+                    elif not radicals[n]:
+                        double_bonded.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                elif ac == 1:
+                    if ab == 2 and not radicals[n]:
+                        double_bonded.add(n)
+                    else:
+                        raise InvalidAromaticRing
+                elif ac == -1:
+                    if ab == 2:
+                        if not radicals[n]:  # C=1O[B-]OC=1 or [bH-]1ccccc1
+                            pyroles.add(n)
+                        # anion-radical is benzene like
+                    elif radicals[n]:  # C=1O[B-*](R)OC=1
+                        double_bonded.add(n)
+                    else:
+                        pyroles.add(n)
+                else:
+                    raise InvalidAromaticRing
+            else:
+                raise InvalidAromaticRing(f'only B, C, N, P, O, S, Se, Te possible, not: {atoms[n].atomic_symbol}')
+        return rings, pyroles, double_bonded
+
+    def __kekule_full(self):
+        self.__fix_rings()  # fix bad aromatic rings
+        rings, pyroles, double_bonded = self.__prepare_rings()
+        atoms = set(rings)
+        components = []
+        while atoms:
+            start = atoms.pop()
+            component = {start: rings[start]}
+            queue = deque([start])
+            while queue:
+                current = queue.popleft()
+                for n in rings[current]:
+                    if n not in component:
+                        queue.append(n)
+                        component[n] = rings[n]
+
+            components.append(component)
+            atoms.difference_update(component)
+
+        for keks in lazy_product(*(_kekule_component(c, double_bonded & c.keys(), pyroles & c.keys())
+                                   for c in components)):
+            yield [x for x in keks for x in x]
+
+
+def _kekule_component(rings, double_bonded, pyroles):
+    # (current atom, previous atom, bond between cp atoms, path deep for cutting [None if cut impossible])
+    stack: List[List[Tuple[int, int, int, Optional[int]]]]
+    if double_bonded:  # start from double bonded if exists
+        start = next(iter(double_bonded))
+        stack = [[(next(iter(rings[start])), start, 1, 0)]]
+    else:  # select not pyrole not condensed atom
+        try:
+            start = next(n for n, ms in rings.items() if len(ms) == 2 and n not in pyroles)
+        except StopIteration:  # all pyroles. select not condensed atom.
+            try:
+                start = next(n for n, ms in rings.items() if len(ms) == 2)
+            except StopIteration:  # fullerene?
+                start = next(iter(rings))
+                double_bonded.add(start)
+                stack = [[(next_atom, start, 2, 0)] for next_atom in rings[start]]
+            else:
+                stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
+        else:
+            stack = [[(next_atom, start, 1, 0)] for next_atom in rings[start]]
+
+    size = sum(len(x) for x in rings.values()) // 2
+    path = []
+    hashed_path = set()
+    nether_yielded = True
+
+    while stack:
+        atom, prev_atom, bond, _ = stack[-1].pop()
+        path.append((atom, prev_atom, bond))
+        hashed_path.add(atom)
+
+        if len(path) == size:
+            yield path
+            if nether_yielded:
+                nether_yielded = False
+            del stack[-1]
+            if stack:
+                path = path[:stack[-1][-1][-1]]
+                hashed_path = {x for x, *_ in path}
+        elif atom != start:
+            for_stack = []
+            closures = []
+            loop = 0
+            for next_atom in rings[atom]:
+                if next_atom == prev_atom:  # only forward. behind us is the homeland
+                    continue
+                elif next_atom == start:
+                    loop = next_atom
+                elif next_atom in hashed_path:  # closure found
+                    closures.append(next_atom)
+                else:
+                    for_stack.append(next_atom)
+
+            if loop:  # we found starting point.
+                if bond == 2:  # finish should be single bonded
+                    if double_bonded:  # ok
+                        stack[-1].insert(0, (loop, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                        continue
+                elif double_bonded:  # we in quinone ring. finish should be single bonded
+                    # side-path for storing double bond or atom is quinone or pyrole
+                    if for_stack or atom in double_bonded or atom in pyroles:
+                        stack[-1].insert(0, (loop, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                        continue
+                else:  # finish should be double bonded
+                    stack[-1].insert(0, (loop, atom, 2, None))
+                    bond = 2  # grow should be single bonded
+
+            if bond == 2 or atom in double_bonded:  # double in - single out. quinone has two single bonds
+                for next_atom in closures:
+                    path.append((next_atom, atom, 1))  # closures always single-bonded
+                    stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
+                for next_atom in for_stack:
+                    stack[-1].append((next_atom, atom, 1, None))
+            elif len(for_stack) == 1:  # easy path grow. next bond double or include single for pyroles
+                next_atom = for_stack[0]
+                if next_atom in double_bonded:  # need double bond, but next atom quinone
+                    if atom in pyroles:
+                        stack[-1].append((next_atom, atom, 1, None))
+                    else:
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                else:
+                    if atom in pyroles:  # try pyrole and pyridine
+                        opposite = stack[-1].copy()
+                        opposite.append((next_atom, atom, 2, None))
+                        stack[-1].append((next_atom, atom, 1, len(path)))
+                        stack.append(opposite)
+                    else:
+                        stack[-1].append((next_atom, atom, 2, None))
+                        if closures:
+                            next_atom = closures[0]
+                            path.append((next_atom, atom, 1))  # closures always single-bonded
+                            stack[-1].remove((atom, next_atom, 1, None))  # remove fork from stack
+            elif for_stack:  # fork
+                next_atom1, next_atom2 = for_stack
+                if next_atom1 in double_bonded:  # quinone next from fork
+                    if next_atom2 in double_bonded:  # bad path
+                        del stack[-1]
+                        if stack:
+                            path = path[:stack[-1][-1][-1]]
+                            hashed_path = {x for x, *_ in path}
+                    else:
+                        stack[-1].append((next_atom1, atom, 1, None))
+                        stack[-1].append((next_atom2, atom, 2, None))
+                elif next_atom2 in double_bonded:  # quinone next from fork
+                    stack[-1].append((next_atom2, atom, 1, None))
+                    stack[-1].append((next_atom1, atom, 2, None))
+                else:  # new path
+                    opposite = stack[-1].copy()
+                    stack[-1].append((next_atom1, atom, 1, None))
+                    stack[-1].append((next_atom2, atom, 2, len(path)))
+                    opposite.append((next_atom2, atom, 1, None))
+                    opposite.append((next_atom1, atom, 2, None))
+                    stack.append(opposite)
+            elif closures and atom not in pyroles:  # need double bond, but closure should be single bonded
+                del stack[-1]
+                if stack:
+                    path = path[:stack[-1][-1][-1]]
+                    hashed_path = {x for x, *_ in path}
+
+    if nether_yielded:
+        raise InvalidAromaticRing(f'kekule form not found for: {list(rings)}')
+
+
+__all__ = ['Kekule']
```

### Comparing `chython-1.67/chython/algorithms/calculate2d/clean2d.js` & `chython-1.8/chython/algorithms/calculate2d/clean2d.js`

 * *Files 10% similar despite different names*

#### js-beautify {}

```diff
@@ -1,12 +1,47 @@
 ! function(t, e) {
     "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.$ = e() : t.$ = e()
 }(self, (function() {
     return (() => {
         var t = {
+                261: (t, e, i) => {
+                    const r = i(881),
+                        n = i(19),
+                        s = i(479);
+                    var o = !("undefined" == typeof window || !window.document || !window.document.createElement),
+                        a = {
+                            Version: "1.0.0"
+                        };
+                    a.Drawer = r, a.Parser = n, a.SvgDrawer = s, a.clean = function(t) {
+                        return t.replace(/[^A-Za-z0-9@\.\+\-\?!\(\)\[\]\{\}/\\=#\$:\*]/g, "")
+                    }, a.apply = function(t, e = "canvas[data-smiles]", i = "light", n = null) {
+                        let s = new r(t),
+                            o = document.querySelectorAll(e);
+                        for (var h = 0; h < o.length; h++) {
+                            let t = o[h];
+                            a.parse(t.getAttribute("data-smiles"), (function(e) {
+                                s.draw(e, t, i, !1)
+                            }), (function(t) {
+                                n && n(t)
+                            }))
+                        }
+                    }, a.parse = function(t, e, i) {
+                        try {
+                            e && e(n.parse(t))
+                        } catch (t) {
+                            i && i(t)
+                        }
+                    }, o && (window.SmilesDrawer = a), Array.prototype.fill || Object.defineProperty(Array.prototype, "fill", {
+                        value: function(t) {
+                            if (null == this) throw new TypeError("this is null or not defined");
+                            for (var e = Object(this), i = e.length >>> 0, r = arguments[1], n = r >> 0, s = n < 0 ? Math.max(i + n, 0) : Math.min(n, i), o = arguments[2], a = void 0 === o ? i : o >> 0, h = a < 0 ? Math.max(i + a, 0) : Math.min(a, i); s < h;) e[s] = t, s++;
+                            return e
+                        }
+                    }), t.exports = a
+                },
                 348: t => {
                     class e {
                         static clone(t) {
                             let i = Array.isArray(t) ? Array() : {};
                             for (let r in t) {
                                 let n = t[r];
                                 "function" == typeof n.clone ? i[r] = n.clone() : i[r] = "object" == typeof n ? e.clone(n) : n
@@ -124,15 +159,15 @@
                     t.exports = e
                 },
                 427: (t, e, i) => {
                     const r = i(348);
                     i(843), i(421);
                     class n {
                         constructor(t, e = "-") {
-                            this.element = 1 === t.length ? t.toUpperCase() : t, this.drawExplicit = !1, this.ringbonds = Array(), this.rings = Array(), this.bondType = e, this.branchBond = null, this.isBridge = !1, this.isBridgeNode = !1, this.originalRings = Array(), this.bridgedRing = null, this.anchoredRings = Array(), this.bracket = null, this.plane = 0, this.attachedPseudoElements = {}, this.hasAttachedPseudoElements = !1, this.isDrawn = !0, this.isConnectedToRing = !1, this.neighbouringElements = Array(), this.isPartOfAromaticRing = t !== this.element, this.bondCount = 0, this.chirality = "", this.isStereoCenter = !1, this.priority = 0, this.mainChain = !1, this.hydrogenDirection = "down", this.subtreeDepth = 1, this.hasHydrogen = !1, this.class = void 0
+                            this.element = 1 === t.length ? t.toUpperCase() : t, this.drawExplicit = !1, this.ringbonds = Array(), this.rings = Array(), this.bondType = e, this.branchBond = null, this.isBridge = !1, this.isBridgeNode = !1, this.originalRings = Array(), this.bridgedRing = null, this.anchoredRings = Array(), this.bracket = null, this.plane = 0, this.attachedPseudoElements = {}, this.hasAttachedPseudoElements = !1, this.isDrawn = !0, this.isConnectedToRing = !1, this.neighbouringElements = Array(), this.isPartOfAromaticRing = t !== this.element, this.bondCount = 0, this.chirality = "", this.isStereoCenter = !1, this.priority = 0, this.mainChain = !1, this.hydrogenDirection = "down", this.subtreeDepth = 1, this.hasHydrogen = !1
                         }
                         addNeighbouringElement(t) {
                             this.neighbouringElements.push(t)
                         }
                         attachPseudoElement(t, e, i = 0, r = 0) {
                             null === i && (i = 0), null === r && (r = 0);
                             let n = i + t + r;
@@ -490,87 +525,87 @@
                             for (var s = 0; s < t.length; s++) {
                                 if (!t[s].value.isDrawn) continue;
                                 let o = t[s].position;
                                 e < o.x && (e = o.x), i < o.y && (i = o.y), r > o.x && (r = o.x), n > o.y && (n = o.y)
                             }
                             var o = this.opts.padding;
                             e += o, i += o, r -= o, n -= o, this.drawingWidth = e - r, this.drawingHeight = i - n;
-                            var h = this.canvas.offsetWidth / this.drawingWidth,
-                                a = this.canvas.offsetHeight / this.drawingHeight,
-                                l = h < a ? h : a;
-                            this.ctx.scale(l, l), this.offsetX = -r, this.offsetY = -n, h < a ? this.offsetY += this.canvas.offsetHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.canvas.offsetWidth / (2 * l) - this.drawingWidth / 2
+                            var a = this.canvas.offsetWidth / this.drawingWidth,
+                                h = this.canvas.offsetHeight / this.drawingHeight,
+                                l = a < h ? a : h;
+                            this.ctx.scale(l, l), this.offsetX = -r, this.offsetY = -n, a < h ? this.offsetY += this.canvas.offsetHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.canvas.offsetWidth / (2 * l) - this.drawingWidth / 2
                         }
                         reset() {
                             this.ctx.setTransform(1, 0, 0, 1, 0, 0)
                         }
                         getColor(t) {
                             return (t = t.toUpperCase()) in this.colors ? this.colors[t] : this.colors.C
                         }
-                        drawCircle(t, e, i, n, s = !0, o = !1, h = "") {
-                            let a = this.ctx,
+                        drawCircle(t, e, i, n, s = !0, o = !1, a = "") {
+                            let h = this.ctx,
                                 l = this.offsetX,
                                 g = this.offsetY;
-                            a.save(), a.lineWidth = 1.5, a.beginPath(), a.arc(t + l, e + g, i, 0, r.twoPI, !0), a.closePath(), o ? (s ? (a.fillStyle = "#f00", a.fill()) : (a.strokeStyle = "#f00", a.stroke()), this.drawDebugText(t, e, h)) : s ? (a.fillStyle = n, a.fill()) : (a.strokeStyle = n, a.stroke()), a.restore()
+                            h.save(), h.lineWidth = 1.5, h.beginPath(), h.arc(t + l, e + g, i, 0, r.twoPI, !0), h.closePath(), o ? (s ? (h.fillStyle = "#f00", h.fill()) : (h.strokeStyle = "#f00", h.stroke()), this.drawDebugText(t, e, a)) : s ? (h.fillStyle = n, h.fill()) : (h.strokeStyle = n, h.stroke()), h.restore()
                         }
                         drawLine(t, e = !1, i = 1) {
                             let r = this.ctx,
                                 n = this.offsetX,
                                 s = this.offsetY,
                                 o = t.clone().shorten(4),
-                                h = o.getLeftVector().clone(),
-                                a = o.getRightVector().clone();
-                            h.x += n, h.y += s, a.x += n, a.y += s, e || (r.save(), r.globalCompositeOperation = "destination-out", r.beginPath(), r.moveTo(h.x, h.y), r.lineTo(a.x, a.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness + 1.2, r.strokeStyle = this.themeManager.getColor("BACKGROUND"), r.stroke(), r.globalCompositeOperation = "source-over", r.restore()), h = t.getLeftVector().clone(), a = t.getRightVector().clone(), h.x += n, h.y += s, a.x += n, a.y += s, r.save(), r.beginPath(), r.moveTo(h.x, h.y), r.lineTo(a.x, a.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness;
-                            let l = this.ctx.createLinearGradient(h.x, h.y, a.x, a.y);
+                                a = o.getLeftVector().clone(),
+                                h = o.getRightVector().clone();
+                            a.x += n, a.y += s, h.x += n, h.y += s, e || (r.save(), r.globalCompositeOperation = "destination-out", r.beginPath(), r.moveTo(a.x, a.y), r.lineTo(h.x, h.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness + 1.2, r.strokeStyle = this.themeManager.getColor("BACKGROUND"), r.stroke(), r.globalCompositeOperation = "source-over", r.restore()), a = t.getLeftVector().clone(), h = t.getRightVector().clone(), a.x += n, a.y += s, h.x += n, h.y += s, r.save(), r.beginPath(), r.moveTo(a.x, a.y), r.lineTo(h.x, h.y), r.lineCap = "round", r.lineWidth = this.opts.bondThickness;
+                            let l = this.ctx.createLinearGradient(a.x, a.y, h.x, h.y);
                             l.addColorStop(.4, this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), l.addColorStop(.6, this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C")), e && (r.setLineDash([1, 1.5]), r.lineWidth = this.opts.bondThickness / 1.5), i < 1 && (r.globalAlpha = i), r.strokeStyle = l, r.stroke(), r.restore()
                         }
                         drawWedge(t, e = 1) {
                             if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
                             let i = this.ctx,
                                 r = this.offsetX,
                                 s = this.offsetY,
                                 o = t.clone().shorten(5),
-                                h = o.getLeftVector().clone(),
-                                a = o.getRightVector().clone();
-                            h.x += r, h.y += s, a.x += r, a.y += s, h = t.getLeftVector().clone(), a = t.getRightVector().clone(), h.x += r, h.y += s, a.x += r, a.y += s, i.save();
-                            let l = n.normals(h, a);
+                                a = o.getLeftVector().clone(),
+                                h = o.getRightVector().clone();
+                            a.x += r, a.y += s, h.x += r, h.y += s, a = t.getLeftVector().clone(), h = t.getRightVector().clone(), a.x += r, a.y += s, h.x += r, h.y += s, i.save();
+                            let l = n.normals(a, h);
                             l[0].normalize(), l[1].normalize();
-                            let g = h,
-                                d = a;
-                            t.getRightChiral() && (g = a, d = h);
+                            let g = a,
+                                d = h;
+                            t.getRightChiral() && (g = h, d = a);
                             let u = n.add(g, n.multiplyScalar(l[0], this.halfBondThickness)),
                                 c = n.add(d, n.multiplyScalar(l[0], 1.5 + this.halfBondThickness)),
                                 p = n.add(d, n.multiplyScalar(l[1], 1.5 + this.halfBondThickness)),
                                 f = n.add(g, n.multiplyScalar(l[1], this.halfBondThickness));
                             i.beginPath(), i.moveTo(u.x, u.y), i.lineTo(c.x, c.y), i.lineTo(p.x, p.y), i.lineTo(f.x, f.y);
-                            let v = this.ctx.createRadialGradient(a.x, a.y, this.opts.bondLength, a.x, a.y, 0);
+                            let v = this.ctx.createRadialGradient(h.x, h.y, this.opts.bondLength, h.x, h.y, 0);
                             v.addColorStop(.4, this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), v.addColorStop(.6, this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C")), i.fillStyle = v, i.fill(), i.restore()
                         }
                         drawDashedWedge(t) {
                             if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
                             let e = this.ctx,
                                 i = this.offsetX,
                                 r = this.offsetY,
                                 s = t.getLeftVector().clone(),
                                 o = t.getRightVector().clone();
                             s.x += i, s.y += r, o.x += i, o.y += r, e.save();
-                            let h = n.normals(s, o);
-                            h[0].normalize(), h[1].normalize();
-                            let a, l, g, d, u = t.getRightChiral(),
+                            let a = n.normals(s, o);
+                            a[0].normalize(), a[1].normalize();
+                            let h, l, g, d, u = t.getRightChiral(),
                                 c = t.clone();
-                            u ? (a = o, l = s, c.shortenRight(1), g = c.getRightVector().clone(), d = c.getLeftVector().clone()) : (a = s, l = o, c.shortenLeft(1), g = c.getLeftVector().clone(), d = c.getRightVector().clone()), g.x += i, g.y += r, d.x += i, d.y += r;
-                            let p = n.subtract(l, a).normalize();
+                            u ? (h = o, l = s, c.shortenRight(1), g = c.getRightVector().clone(), d = c.getLeftVector().clone()) : (h = s, l = o, c.shortenLeft(1), g = c.getLeftVector().clone(), d = c.getRightVector().clone()), g.x += i, g.y += r, d.x += i, d.y += r;
+                            let p = n.subtract(l, h).normalize();
                             e.strokeStyle = this.themeManager.getColor("C"), e.lineCap = "round", e.lineWidth = this.opts.bondThickness, e.beginPath();
                             let f = t.getLength(),
                                 v = 1.25 / (f / (3 * this.opts.bondThickness)),
                                 m = !1;
                             for (var b = 0; b < 1; b += v) {
                                 let i = n.multiplyScalar(p, b * f),
-                                    r = n.add(a, i),
+                                    r = n.add(h, i),
                                     s = 1.5 * b,
-                                    o = n.multiplyScalar(h[0], s);
+                                    o = n.multiplyScalar(a[0], s);
                                 !m && b > .5 && (e.stroke(), e.beginPath(), e.strokeStyle = this.themeManager.getColor(t.getRightElement()) || this.themeManager.getColor("C"), m = !0), r.subtract(o), e.moveTo(r.x, r.y), r.add(n.multiplyScalar(o, 2)), e.lineTo(r.x, r.y)
                             }
                             e.stroke(), e.restore()
                         }
                         drawDebugText(t, e, i) {
                             let r = this.ctx;
                             r.save(), r.font = "5px Droid Sans, sans-serif", r.textAlign = "start", r.textBaseline = "top", r.fillStyle = "#ff0000", r.fillText(i, t + this.offsetX, e + this.offsetY), r.restore()
@@ -581,70 +616,70 @@
                         }
                         drawPoint(t, e, i) {
                             let n = this.ctx,
                                 s = this.offsetX,
                                 o = this.offsetY;
                             n.save(), n.globalCompositeOperation = "destination-out", n.beginPath(), n.arc(t + s, e + o, 1.5, 0, r.twoPI, !0), n.closePath(), n.fill(), n.globalCompositeOperation = "source-over", n.beginPath(), n.arc(t + this.offsetX, e + this.offsetY, .75, 0, r.twoPI, !1), n.fillStyle = this.themeManager.getColor(i), n.fill(), n.restore()
                         }
-                        drawText(t, e, i, n, o, h, a, l, g, d = {}) {
-                            let u = this.ctx,
-                                c = this.offsetX,
-                                p = this.offsetY;
-                            u.save(), u.textAlign = "start", u.textBaseline = "alphabetic";
-                            let f = "",
-                                v = 0;
-                            a && (f = s(a), u.font = this.fontSmall, v = u.measureText(f).width);
-                            let m = "0",
-                                b = 0;
-                            l > 0 && (m = l.toString(), u.font = this.fontSmall, b = u.measureText(m).width), 1 === a && "N" === i && d.hasOwnProperty("0O") && d.hasOwnProperty("0O-1") && (d = {
+                        drawText(t, e, i, n, o, a, h, l, g = {}) {
+                            let d = this.ctx,
+                                u = this.offsetX,
+                                c = this.offsetY;
+                            d.save(), d.textAlign = "start", d.textBaseline = "alphabetic";
+                            let p = "",
+                                f = 0;
+                            h && (p = s(h), d.font = this.fontSmall, f = d.measureText(p).width);
+                            let v = "0",
+                                m = 0;
+                            l > 0 && (v = l.toString(), d.font = this.fontSmall, m = d.measureText(v).width), 1 === h && "N" === i && g.hasOwnProperty("0O") && g.hasOwnProperty("0O-1") && (g = {
                                 "0O": {
                                     element: "O",
                                     count: 2,
                                     hydrogenCount: 0,
                                     previousElement: "C",
                                     charge: ""
                                 }
-                            }, a = 0), u.font = this.fontLarge, u.fillStyle = this.themeManager.getColor("BACKGROUND");
-                            let y = u.measureText(i);
-                            y.totalWidth = y.width + v, y.height = parseInt(this.fontLarge, 10);
-                            let x = y.width > this.opts.fontSizeLarge ? y.width : this.opts.fontSizeLarge;
-                            x /= 1.5, u.globalCompositeOperation = "destination-out", u.beginPath(), u.arc(t + c, e + p, x, 0, r.twoPI, !0), u.closePath(), u.fill(), u.globalCompositeOperation = "source-over";
-                            let S = -y.width / 2,
-                                A = -y.width / 2;
-                            u.fillStyle = this.themeManager.getColor(i), u.fillText(i, t + c + S, e + this.opts.halfFontSizeLarge + p), S += y.width, a && (u.font = this.fontSmall, u.fillText(f, t + c + S, e - this.opts.fifthFontSizeSmall + p), S += v), l > 0 && (u.font = this.fontSmall, u.fillText(m, t + c + A - b, e - this.opts.fifthFontSizeSmall + p), A -= b), u.font = this.fontLarge;
-                            let C = 0,
-                                R = 0;
+                            }, h = 0), d.font = this.fontLarge, d.fillStyle = this.themeManager.getColor("BACKGROUND");
+                            let b = d.measureText(i);
+                            b.totalWidth = b.width + f, b.height = parseInt(this.fontLarge, 10);
+                            let y = b.width > this.opts.fontSizeLarge ? b.width : this.opts.fontSizeLarge;
+                            y /= 1.5, d.globalCompositeOperation = "destination-out", d.beginPath(), d.arc(t + u, e + c, y, 0, r.twoPI, !0), d.closePath(), d.fill(), d.globalCompositeOperation = "source-over";
+                            let S = -b.width / 2,
+                                w = -b.width / 2;
+                            d.fillStyle = this.themeManager.getColor(i), d.fillText(i, t + u + S, e + this.opts.halfFontSizeLarge + c), S += b.width, h && (d.font = this.fontSmall, d.fillText(p, t + u + S, e - this.opts.fifthFontSizeSmall + c), S += f), l > 0 && (d.font = this.fontSmall, d.fillText(v, t + u + w - m, e - this.opts.fifthFontSizeSmall + c), w -= m), d.font = this.fontLarge;
+                            let x = 0,
+                                A = 0;
                             if (1 === n) {
-                                let i = t + c,
-                                    r = e + p + this.opts.halfFontSizeLarge;
-                                C = this.hydrogenWidth, A -= C, "left" === o ? i += A : "right" === o || "up" === o && h || "down" === o && h ? i += S : "up" !== o || h ? "down" !== o || h || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), u.fillText("H", i, r), S += C
+                                let i = t + u,
+                                    r = e + c + this.opts.halfFontSizeLarge;
+                                x = this.hydrogenWidth, w -= x, "left" === o ? i += w : "right" === o || "up" === o && a || "down" === o && a ? i += S : "up" !== o || a ? "down" !== o || a || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), d.fillText("H", i, r), S += x
                             } else if (n > 1) {
-                                let i = t + c,
-                                    r = e + p + this.opts.halfFontSizeLarge;
-                                C = this.hydrogenWidth, u.font = this.fontSmall, R = u.measureText(n).width, A -= C + R, "left" === o ? i += A : "right" === o || "up" === o && h || "down" === o && h ? i += S : "up" !== o || h ? "down" !== o || h || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), u.font = this.fontLarge, u.fillText("H", i, r), u.font = this.fontSmall, u.fillText(n, i + this.halfHydrogenWidth + R, r + this.opts.fifthFontSizeSmall), S += C + this.halfHydrogenWidth + R
+                                let i = t + u,
+                                    r = e + c + this.opts.halfFontSizeLarge;
+                                x = this.hydrogenWidth, d.font = this.fontSmall, A = d.measureText(n).width, w -= x + A, "left" === o ? i += w : "right" === o || "up" === o && a || "down" === o && a ? i += S : "up" !== o || a ? "down" !== o || a || (r += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth) : (r -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge, i -= this.halfHydrogenWidth), d.font = this.fontLarge, d.fillText("H", i, r), d.font = this.fontSmall, d.fillText(n, i + this.halfHydrogenWidth + A, r + this.opts.fifthFontSizeSmall), S += x + this.halfHydrogenWidth + A
                             }
-                            for (let i in d) {
-                                if (!d.hasOwnProperty(i)) continue;
+                            for (let i in g) {
+                                if (!g.hasOwnProperty(i)) continue;
                                 let r = 0,
                                     n = 0,
-                                    h = d[i].element,
-                                    a = d[i].count,
-                                    l = d[i].hydrogenCount,
-                                    g = d[i].charge;
-                                u.font = this.fontLarge, a > 1 && l > 0 && (r = u.measureText("(").width, n = u.measureText(")").width);
-                                let f = u.measureText(h).width,
+                                    a = g[i].element,
+                                    h = g[i].count,
+                                    l = g[i].hydrogenCount,
+                                    p = g[i].charge;
+                                d.font = this.fontLarge, h > 1 && l > 0 && (r = d.measureText("(").width, n = d.measureText(")").width);
+                                let f = d.measureText(a).width,
                                     v = 0,
                                     m = "",
                                     b = 0;
-                                C = 0, l > 0 && (C = this.hydrogenWidth), u.font = this.fontSmall, a > 1 && (v = u.measureText(a).width), 0 !== g && (m = s(g), b = u.measureText(m).width), R = 0, l > 1 && (R = u.measureText(l).width), u.font = this.fontLarge;
-                                let y = t + c,
-                                    x = e + p + this.opts.halfFontSizeLarge;
-                                u.fillStyle = this.themeManager.getColor(h), a > 0 && (A -= v), a > 1 && l > 0 && ("left" === o ? (A -= n, u.fillText(")", y + A, x)) : (u.fillText("(", y + S, x), S += r)), "left" === o ? (A -= f, u.fillText(h, y + A, x)) : (u.fillText(h, y + S, x), S += f), l > 0 && ("left" === o ? (A -= C + R, u.fillText("H", y + A, x), l > 1 && (u.font = this.fontSmall, u.fillText(l, y + A + C, x + this.opts.fifthFontSizeSmall))) : (u.fillText("H", y + S, x), S += C, l > 1 && (u.font = this.fontSmall, u.fillText(l, y + S, x + this.opts.fifthFontSizeSmall), S += R))), u.font = this.fontLarge, a > 1 && l > 0 && ("left" === o ? (A -= r, u.fillText("(", y + A, x)) : (u.fillText(")", y + S, x), S += n)), u.font = this.fontSmall, a > 1 && ("left" === o ? u.fillText(a, y + A + r + n + C + R + f, x + this.opts.fifthFontSizeSmall) : (u.fillText(a, y + S, x + this.opts.fifthFontSizeSmall), S += v)), 0 !== g && ("left" === o ? u.fillText(m, y + A + r + n + C + R + f, e - this.opts.fifthFontSizeSmall + p) : (u.fillText(m, y + S, e - this.opts.fifthFontSizeSmall + p), S += b))
+                                x = 0, l > 0 && (x = this.hydrogenWidth), d.font = this.fontSmall, h > 1 && (v = d.measureText(h).width), 0 !== p && (m = s(p), b = d.measureText(m).width), A = 0, l > 1 && (A = d.measureText(l).width), d.font = this.fontLarge;
+                                let y = t + u,
+                                    C = e + c + this.opts.halfFontSizeLarge;
+                                d.fillStyle = this.themeManager.getColor(a), h > 0 && (w -= v), h > 1 && l > 0 && ("left" === o ? (w -= n, d.fillText(")", y + w, C)) : (d.fillText("(", y + S, C), S += r)), "left" === o ? (w -= f, d.fillText(a, y + w, C)) : (d.fillText(a, y + S, C), S += f), l > 0 && ("left" === o ? (w -= x + A, d.fillText("H", y + w, C), l > 1 && (d.font = this.fontSmall, d.fillText(l, y + w + x, C + this.opts.fifthFontSizeSmall))) : (d.fillText("H", y + S, C), S += x, l > 1 && (d.font = this.fontSmall, d.fillText(l, y + S, C + this.opts.fifthFontSizeSmall), S += A))), d.font = this.fontLarge, h > 1 && l > 0 && ("left" === o ? (w -= r, d.fillText("(", y + w, C)) : (d.fillText(")", y + S, C), S += n)), d.font = this.fontSmall, h > 1 && ("left" === o ? d.fillText(h, y + w + r + n + x + A + f, C + this.opts.fifthFontSizeSmall) : (d.fillText(h, y + S, C + this.opts.fifthFontSizeSmall), S += v)), 0 !== p && ("left" === o ? d.fillText(m, y + w + r + n + x + A + f, e - this.opts.fifthFontSizeSmall + c) : (d.fillText(m, y + S, e - this.opts.fifthFontSizeSmall + c), S += b))
                             }
-                            u.restore()
+                            d.restore()
                         }
                         getChargeText(t) {
                             return 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
                         }
                         drawDebugPoint(t, e, i = "", r = "#f00") {
                             this.drawCircle(t, e, 2, r, !0, !0, i)
                         }
@@ -654,50 +689,47 @@
                             e.save(), e.strokeStyle = this.themeManager.getColor("C"), e.lineWidth = this.opts.bondThickness, e.beginPath(), e.arc(t.center.x + this.offsetX, t.center.y + this.offsetY, i - this.opts.bondSpacing, 0, 2 * Math.PI, !0), e.closePath(), e.stroke(), e.restore()
                         }
                         clear() {
                             this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight)
                         }
                     }
                 },
-                237: (t, e, i) => {
+                881: (t, e, i) => {
                     const r = i(474),
                         n = i(348),
                         s = i(614),
                         o = i(929),
-                        h = (i(843), i(826)),
-                        a = i(427),
+                        a = (i(843), i(826)),
+                        h = i(427),
                         l = i(421),
                         g = i(333),
                         d = i(841),
                         u = i(707),
                         c = i(473),
-                        p = i(654),
-                        f = i(207);
+                        p = i(654);
                     t.exports = class {
                         constructor(t) {
                             this.graph = null, this.doubleBondConfigCount = 0, this.doubleBondConfig = null, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.canvasWrapper = null, this.totalOverlapScore = 0, this.defaultOptions = {
                                 width: 500,
                                 height: 500,
-                                scale: 0,
-                                bondThickness: 1,
-                                bondLength: 30,
-                                shortBondLength: .8,
-                                bondSpacing: .17 * 30,
+                                bondThickness: .6,
+                                bondLength: 15,
+                                shortBondLength: .85,
+                                bondSpacing: .18 * 15,
                                 atomVisualization: "default",
                                 isomeric: !0,
                                 debug: !1,
                                 terminalCarbons: !1,
                                 explicitHydrogens: !0,
                                 overlapSensitivity: .42,
                                 overlapResolutionIterations: 1,
                                 compactDrawing: !0,
-                                fontFamily: "Arial, Helvetica, sans-serif",
-                                fontSizeLarge: 11,
+                                fontSizeLarge: 5,
                                 fontSizeSmall: 3,
-                                padding: 10,
+                                padding: 20,
                                 experimentalSSSR: !1,
                                 kkThreshold: .1,
                                 kkInnerThreshold: .1,
                                 kkMaxIteration: 2e4,
                                 kkMaxInnerIteration: 50,
                                 kkMaxEnergy: 1e9,
                                 themes: {
@@ -709,184 +741,47 @@
                                         CL: "#16a085",
                                         BR: "#d35400",
                                         I: "#8e44ad",
                                         P: "#d35400",
                                         S: "#f1c40f",
                                         B: "#e67e22",
                                         SI: "#e67e22",
-                                        H: "#aaa",
+                                        H: "#fff",
                                         BACKGROUND: "#141414"
                                     },
                                     light: {
                                         C: "#222",
                                         O: "#e74c3c",
                                         N: "#3498db",
                                         F: "#27ae60",
                                         CL: "#16a085",
                                         BR: "#d35400",
                                         I: "#8e44ad",
                                         P: "#d35400",
                                         S: "#f1c40f",
                                         B: "#e67e22",
                                         SI: "#e67e22",
-                                        H: "#666",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    oldschool: {
-                                        C: "#000",
-                                        O: "#000",
-                                        N: "#000",
-                                        F: "#000",
-                                        CL: "#000",
-                                        BR: "#000",
-                                        I: "#000",
-                                        P: "#000",
-                                        S: "#000",
-                                        B: "#000",
-                                        SI: "#000",
-                                        H: "#000",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    solarized: {
-                                        C: "#586e75",
-                                        O: "#dc322f",
-                                        N: "#268bd2",
-                                        F: "#859900",
-                                        CL: "#16a085",
-                                        BR: "#cb4b16",
-                                        I: "#6c71c4",
-                                        P: "#d33682",
-                                        S: "#b58900",
-                                        B: "#2aa198",
-                                        SI: "#2aa198",
-                                        H: "#657b83",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    "solarized-dark": {
-                                        C: "#93a1a1",
-                                        O: "#dc322f",
-                                        N: "#268bd2",
-                                        F: "#859900",
-                                        CL: "#16a085",
-                                        BR: "#cb4b16",
-                                        I: "#6c71c4",
-                                        P: "#d33682",
-                                        S: "#b58900",
-                                        B: "#2aa198",
-                                        SI: "#2aa198",
-                                        H: "#839496",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    matrix: {
-                                        C: "#678c61",
-                                        O: "#2fc079",
-                                        N: "#4f7e7e",
-                                        F: "#90d762",
-                                        CL: "#82d967",
-                                        BR: "#23755a",
-                                        I: "#409931",
-                                        P: "#c1ff8a",
-                                        S: "#faff00",
-                                        B: "#50b45a",
-                                        SI: "#409931",
-                                        H: "#426644",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    github: {
-                                        C: "#24292f",
-                                        O: "#cf222e",
-                                        N: "#0969da",
-                                        F: "#2da44e",
-                                        CL: "#6fdd8b",
-                                        BR: "#bc4c00",
-                                        I: "#8250df",
-                                        P: "#bf3989",
-                                        S: "#d4a72c",
-                                        B: "#fb8f44",
-                                        SI: "#bc4c00",
-                                        H: "#57606a",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    carbon: {
-                                        C: "#161616",
-                                        O: "#da1e28",
-                                        N: "#0f62fe",
-                                        F: "#198038",
-                                        CL: "#007d79",
-                                        BR: "#fa4d56",
-                                        I: "#8a3ffc",
-                                        P: "#ff832b",
-                                        S: "#f1c21b",
-                                        B: "#8a3800",
-                                        SI: "#e67e22",
-                                        H: "#525252",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    cyberpunk: {
-                                        C: "#ea00d9",
-                                        O: "#ff3131",
-                                        N: "#0abdc6",
-                                        F: "#00ff9f",
-                                        CL: "#00fe00",
-                                        BR: "#fe9f20",
-                                        I: "#ff00ff",
-                                        P: "#fe7f00",
-                                        S: "#fcee0c",
-                                        B: "#ff00ff",
-                                        SI: "#ffffff",
-                                        H: "#913cb1",
-                                        BACKGROUND: "#fff"
-                                    },
-                                    gruvbox: {
-                                        C: "#665c54",
-                                        O: "#cc241d",
-                                        N: "#458588",
-                                        F: "#98971a",
-                                        CL: "#79740e",
-                                        BR: "#d65d0e",
-                                        I: "#b16286",
-                                        P: "#af3a03",
-                                        S: "#d79921",
-                                        B: "#689d6a",
-                                        SI: "#427b58",
-                                        H: "#7c6f64",
-                                        BACKGROUND: "#fbf1c7"
-                                    },
-                                    "gruvbox-dark": {
-                                        C: "#ebdbb2",
-                                        O: "#cc241d",
-                                        N: "#458588",
-                                        F: "#98971a",
-                                        CL: "#b8bb26",
-                                        BR: "#d65d0e",
-                                        I: "#b16286",
-                                        P: "#fe8019",
-                                        S: "#d79921",
-                                        B: "#8ec07c",
-                                        SI: "#83a598",
-                                        H: "#bdae93",
-                                        BACKGROUND: "#282828"
-                                    },
-                                    custom: {
-                                        C: "#222",
-                                        O: "#e74c3c",
-                                        N: "#3498db",
-                                        F: "#27ae60",
-                                        CL: "#16a085",
-                                        BR: "#d35400",
-                                        I: "#8e44ad",
-                                        P: "#d35400",
-                                        S: "#f1c40f",
-                                        B: "#e67e22",
-                                        SI: "#e67e22",
-                                        H: "#666",
+                                        H: "#222",
                                         BACKGROUND: "#fff"
                                     }
                                 }
-                            }, this.opts = f.extend(!0, this.defaultOptions, t), this.opts.halfBondSpacing = this.opts.bondSpacing / 2, this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength, this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2, this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4, this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5, this.theme = this.opts.themes.dark
+                            }, this.opts = this.extend(!0, this.defaultOptions, t), this.opts.halfBondSpacing = this.opts.bondSpacing / 2, this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength, this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2, this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4, this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5, this.theme = this.opts.themes.dark
+                        }
+                        extend() {
+                            let t = this,
+                                e = {},
+                                i = !1,
+                                r = 0,
+                                n = arguments.length;
+                            "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (i = arguments[0], r++);
+                            let s = function(r) {
+                                for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (i && "[object Object]" === Object.prototype.toString.call(r[n]) ? e[n] = t.extend(!0, e[n], r[n]) : e[n] = r[n])
+                            };
+                            for (; r < n; r++) s(arguments[r]);
+                            return e
                         }
                         draw(t, e, i = "light", r = !1) {
                             this.initDraw(t, i, r), this.infoOnly || (this.themeManager = new p(this.opts.themes, i), this.canvasWrapper = new d(e, this.themeManager, this.opts)), r || (this.processGraph(), this.canvasWrapper.scale(this.graph.vertices), this.drawEdges(this.opts.debug), this.drawVertices(this.opts.debug), this.canvasWrapper.reset(), this.opts.debug && (console.log(this.graph), console.log(this.rings), console.log(this.ringConnections)))
                         }
                         edgeRingCount(t) {
                             let e = this.graph.edges[t],
                                 i = this.graph.vertices[e.sourceId],
@@ -922,16 +817,16 @@
                                 i = 0;
                             for (var r = 0; r < this.graph.vertices.length; r++) {
                                 let s = this.graph.vertices[r];
                                 if (s.value.isDrawn)
                                     for (var n = r + 1; n < this.graph.vertices.length; n++) {
                                         let o = this.graph.vertices[n];
                                         if (!o.value.isDrawn) continue;
-                                        let h = s.position.distanceSq(o.position);
-                                        h > i && (i = h, t = r, e = n)
+                                        let a = s.position.distanceSq(o.position);
+                                        a > i && (i = a, t = r, e = n)
                                     }
                             }
                             let o = -s.subtract(this.graph.vertices[t].position, this.graph.vertices[e].position).angle();
                             if (!isNaN(o)) {
                                 let t = o % .523599;
                                 for (t < .2617995 ? o -= t : o += .523599 - t, r = 0; r < this.graph.vertices.length; r++) r !== e && this.graph.vertices[r].position.rotateAround(o, this.graph.vertices[e].position);
                                 for (r = 0; r < this.rings.length; r++) this.rings[r].center.rotateAround(o, this.graph.vertices[e].position)
@@ -947,49 +842,48 @@
                             return this.bridgedRing
                         }
                         getHeavyAtomCount() {
                             let t = 0;
                             for (var e = 0; e < this.graph.vertices.length; e++) "H" !== this.graph.vertices[e].value.element && t++;
                             return t
                         }
-                        getMolecularFormula(t = null) {
-                            let e = "",
-                                i = new Map,
-                                r = null === t ? this.graph : new u(t, this.opts.isomeric);
-                            for (var n = 0; n < r.vertices.length; n++) {
-                                let t = r.vertices[n].value;
-                                if (i.has(t.element) ? i.set(t.element, i.get(t.element) + 1) : i.set(t.element, 1), t.bracket && !t.bracket.chirality && (i.has("H") ? i.set("H", i.get("H") + t.bracket.hcount) : i.set("H", t.bracket.hcount)), !t.bracket) {
-                                    let e = a.maxBonds[t.element] - t.bondCount;
-                                    t.isPartOfAromaticRing && e--, i.has("H") ? i.set("H", i.get("H") + e) : i.set("H", e)
-                                }
-                            }
-                            if (i.has("C")) {
-                                let t = i.get("C");
-                                e += "C" + (t > 1 ? t : ""), i.delete("C")
-                            }
-                            if (i.has("H")) {
-                                let t = i.get("H");
-                                e += "H" + (t > 1 ? t : ""), i.delete("H")
-                            }
-                            return Object.keys(a.atomicNumbers).sort().map((t => {
-                                if (i.has(t)) {
-                                    let r = i.get(t);
-                                    e += t + (r > 1 ? r : "")
+                        getMolecularFormula() {
+                            let t = "",
+                                e = new Map;
+                            for (var i = 0; i < this.graph.vertices.length; i++) {
+                                let t = this.graph.vertices[i].value;
+                                if (e.has(t.element) ? e.set(t.element, e.get(t.element) + 1) : e.set(t.element, 1), t.bracket && !t.bracket.chirality && (e.has("H") ? e.set("H", e.get("H") + t.bracket.hcount) : e.set("H", t.bracket.hcount)), !t.bracket) {
+                                    let i = h.maxBonds[t.element] - t.bondCount;
+                                    t.isPartOfAromaticRing && i--, e.has("H") ? e.set("H", e.get("H") + i) : e.set("H", i)
+                                }
+                            }
+                            if (e.has("C")) {
+                                let i = e.get("C");
+                                t += "C" + (i > 1 ? i : ""), e.delete("C")
+                            }
+                            if (e.has("H")) {
+                                let i = e.get("H");
+                                t += "H" + (i > 1 ? i : ""), e.delete("H")
+                            }
+                            return Object.keys(h.atomicNumbers).sort().map((i => {
+                                if (e.has(i)) {
+                                    let r = e.get(i);
+                                    t += i + (r > 1 ? r : "")
                                 }
-                            })), e
+                            })), t
                         }
                         getRingbondType(t, e) {
                             if (t.value.getRingbondCount() < 1 || e.value.getRingbondCount() < 1) return null;
                             for (var i = 0; i < t.value.ringbonds.length; i++)
                                 for (var r = 0; r < e.value.ringbonds.length; r++)
                                     if (t.value.ringbonds[i].id === e.value.ringbonds[r].id) return "-" === t.value.ringbonds[i].bondType ? e.value.ringbonds[r].bond : t.value.ringbonds[i].bond;
                             return null
                         }
-                        initDraw(t, e, i, r) {
-                            this.data = t, this.infoOnly = i, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.graph = new u(t, this.opts.isomeric), this.rings = Array(), this.ringConnections = Array(), this.originalRings = Array(), this.originalRingConnections = Array(), this.bridgedRing = !1, this.doubleBondConfigCount = null, this.doubleBondConfig = null, this.highlight_atoms = r, this.initRings(), this.initHydrogens()
+                        initDraw(t, e, i) {
+                            this.data = t, this.infoOnly = i, this.ringIdCounter = 0, this.ringConnectionIdCounter = 0, this.graph = new u(t, this.opts.isomeric), this.rings = Array(), this.ringConnections = Array(), this.originalRings = Array(), this.originalRingConnections = Array(), this.bridgedRing = !1, this.doubleBondConfigCount = null, this.doubleBondConfig = null, this.initRings(), this.initHydrogens()
                         }
                         processGraph() {
                             this.position(), this.restoreRingInformation(), this.resolvePrimaryOverlaps();
                             let t = this.getOverlapScore();
                             this.totalOverlapScore = this.getOverlapScore().total;
                             for (var e = 0; e < this.opts.overlapResolutionIterations; e++)
                                 for (var i = 0; i < this.graph.edges.length; i++) {
@@ -1016,16 +910,16 @@
                                                 if (1 === t.value.rings.length && 1 === s.value.rings.length) {
                                                     if (t.value.rings[0] !== s.value.rings[0]) continue
                                                 } else {
                                                     if (0 !== t.value.rings.length || 0 !== s.value.rings.length) continue; {
                                                         let n = t.position.getRotateAwayFromAngle(e.position, i.position, r.toRad(120)),
                                                             o = s.position.getRotateAwayFromAngle(e.position, i.position, r.toRad(120));
                                                         this.rotateSubtree(t.id, i.id, n, i.position), this.rotateSubtree(s.id, i.id, o, i.position);
-                                                        let h = this.getOverlapScore().total;
-                                                        h > this.totalOverlapScore ? (this.rotateSubtree(t.id, i.id, -n, i.position), this.rotateSubtree(s.id, i.id, -o, i.position)) : this.totalOverlapScore = h
+                                                        let a = this.getOverlapScore().total;
+                                                        a > this.totalOverlapScore ? (this.rotateSubtree(t.id, i.id, -n, i.position), this.rotateSubtree(s.id, i.id, -o, i.position)) : this.totalOverlapScore = a
                                                     }
                                                 }
                                             }
                                             t = this.getOverlapScore()
                                         }
                                     }
                                 }
@@ -1038,17 +932,17 @@
                                 if (0 !== r.value.ringbonds.length)
                                     for (var i = 0; i < r.value.ringbonds.length; i++) {
                                         let e = r.value.ringbonds[i].id,
                                             n = r.value.ringbonds[i].bond;
                                         if (t.has(e)) {
                                             let s = r.id,
                                                 o = t.get(e)[0],
-                                                a = t.get(e)[1],
-                                                l = new h(s, o, 1);
-                                            l.setBondType(a || n || "-");
+                                                h = t.get(e)[1],
+                                                l = new a(s, o, 1);
+                                            l.setBondType(h || n || "-");
                                             let g = this.graph.addEdge(l),
                                                 d = this.graph.vertices[o];
                                             r.addRingbondChild(o, i), r.value.addNeighbouringElement(d.value.element), d.addRingbondChild(s, i), d.value.addNeighbouringElement(r.value.element), r.edges.push(g), d.edges.push(g), t.delete(e)
                                         } else t.set(e, [r.id, n])
                                     }
                             }
                             let r = c.getRings(this.graph, this.opts.experimentalSSSR);
@@ -1115,46 +1009,46 @@
                         createBridgedRing(t, e) {
                             let i = new Set,
                                 r = new Set,
                                 s = new Set;
                             for (var o = 0; o < t.length; o++) {
                                 let e = this.getRing(t[o]);
                                 e.isPartOfBridged = !0;
-                                for (var h = 0; h < e.members.length; h++) r.add(e.members[h]);
-                                for (h = 0; h < e.neighbours.length; h++) {
-                                    let i = e.neighbours[h]; - 1 === t.indexOf(i) && s.add(e.neighbours[h])
+                                for (var a = 0; a < e.members.length; a++) r.add(e.members[a]);
+                                for (a = 0; a < e.neighbours.length; a++) {
+                                    let i = e.neighbours[a]; - 1 === t.indexOf(i) && s.add(e.neighbours[a])
                                 }
                             }
-                            let a = new Set;
+                            let h = new Set;
                             for (let e of r) {
                                 let r = this.graph.vertices[e],
                                     s = n.intersection(t, r.value.rings);
-                                1 === r.value.rings.length || 1 === s.length ? i.add(r.id) : a.add(r.id)
+                                1 === r.value.rings.length || 1 === s.length ? i.add(r.id) : h.add(r.id)
                             }
                             Array();
                             let g = Array();
-                            for (let t of a) {
+                            for (let t of h) {
                                 let e = this.graph.vertices[t],
                                     r = !1;
                                 for (let t = 0; t < e.edges.length; t++) 1 === this.edgeRingCount(e.edges[t]) && (r = !0);
                                 r ? (e.value.isBridgeNode = !0, i.add(e.id)) : (e.value.isBridge = !0, i.add(e.id))
                             }
                             let d = new l([...i]);
                             for (this.addRing(d), d.isBridged = !0, d.neighbours = [...s], o = 0; o < t.length; o++) d.rings.push(this.getRing(t[o]).clone());
                             for (o = 0; o < d.members.length; o++) this.graph.vertices[d.members[o]].value.bridgedRing = d.id;
                             for (o = 0; o < g.length; o++) this.graph.vertices[g[o]].value.rings = Array();
                             for (let e of i) {
                                 let i = this.graph.vertices[e];
                                 i.value.rings = n.removeAll(i.value.rings, t), i.value.rings.push(d.id)
                             }
                             for (o = 0; o < t.length; o++)
-                                for (h = o + 1; h < t.length; h++) this.removeRingConnectionsBetween(t[o], t[h]);
+                                for (a = o + 1; a < t.length; a++) this.removeRingConnectionsBetween(t[o], t[a]);
                             for (let e of s) {
                                 let i = this.getRingConnections(e, t);
-                                for (h = 0; h < i.length; h++) this.getRingConnection(i[h]).updateOther(d.id, e);
+                                for (a = 0; a < i.length; a++) this.getRingConnection(i[a]).updateOther(d.id, e);
                                 this.getRing(e).neighbours.push(d.id)
                             }
                             return d
                         }
                         areVerticesInSameRing(t, e) {
                             for (var i = 0; i < t.value.rings.length; i++)
                                 for (var r = 0; r < e.value.rings.length; r++)
@@ -1254,17 +1148,17 @@
                                 e = new Float32Array(this.graph.vertices.length);
                             for (var i = 0; i < this.graph.vertices.length; i++) e[i] = 0;
                             for (i = 0; i < this.graph.vertices.length; i++)
                                 for (var r = this.graph.vertices.length; --r > i;) {
                                     let n = this.graph.vertices[i],
                                         o = this.graph.vertices[r];
                                     if (!n.value.isDrawn || !o.value.isDrawn) continue;
-                                    let h = s.subtract(n.position, o.position).lengthSq();
-                                    if (h < this.opts.bondLengthSq) {
-                                        let n = (this.opts.bondLength - Math.sqrt(h)) / this.opts.bondLength;
+                                    let a = s.subtract(n.position, o.position).lengthSq();
+                                    if (a < this.opts.bondLengthSq) {
+                                        let n = (this.opts.bondLength - Math.sqrt(a)) / this.opts.bondLength;
                                         t += n, e[i] += n, e[r] += n
                                     }
                                 }
                             let n = Array();
                             for (i = 0; i < this.graph.vertices.length; i++) n.push({
                                 id: i,
                                 score: e[i]
@@ -1277,27 +1171,27 @@
                                 vertexScores: e
                             }
                         }
                         chooseSide(t, e, i) {
                             let r = t.getNeighbours(e.id),
                                 s = e.getNeighbours(t.id),
                                 o = r.length,
-                                h = s.length,
-                                a = n.merge(r, s),
+                                a = s.length,
+                                h = n.merge(r, s),
                                 l = [0, 0];
-                            for (var g = 0; g < a.length; g++) this.graph.vertices[a[g]].position.sameSideAs(t.position, e.position, i[0]) ? l[0]++ : l[1]++;
+                            for (var g = 0; g < h.length; g++) this.graph.vertices[h[g]].position.sameSideAs(t.position, e.position, i[0]) ? l[0]++ : l[1]++;
                             let d = [0, 0];
                             for (g = 0; g < this.graph.vertices.length; g++) this.graph.vertices[g].position.sameSideAs(t.position, e.position, i[0]) ? d[0]++ : d[1]++;
                             return {
                                 totalSideCount: d,
                                 totalPosition: d[0] > d[1] ? 0 : 1,
                                 sideCount: l,
                                 position: l[0] > l[1] ? 0 : 1,
                                 anCount: o,
-                                bnCount: h
+                                bnCount: a
                             }
                         }
                         setRingCenter(t) {
                             let e = t.getSize(),
                                 i = new s(0, 0);
                             for (var r = 0; r < e; r++) i.add(this.graph.vertices[t.members[r]].position);
                             t.center = i.divide(e)
@@ -1324,32 +1218,32 @@
                                     let t = this.rings[r];
                                     this.isRingAromatic(t) && this.canvasWrapper.drawAromaticityRing(t)
                                 }
                         }
                         drawEdge(t, e) {
                             let i = this,
                                 r = this.graph.edges[t],
-                                h = this.graph.vertices[r.sourceId],
-                                a = this.graph.vertices[r.targetId],
-                                l = h.value.element,
-                                g = a.value.element;
-                            if (!(h.value.isDrawn && a.value.isDrawn || "default" !== this.opts.atomVisualization)) return;
-                            let d = h.position,
-                                u = a.position,
+                                a = this.graph.vertices[r.sourceId],
+                                h = this.graph.vertices[r.targetId],
+                                l = a.value.element,
+                                g = h.value.element;
+                            if (!(a.value.isDrawn && h.value.isDrawn || "default" !== this.opts.atomVisualization)) return;
+                            let d = a.position,
+                                u = h.position,
                                 c = this.getEdgeNormals(r),
                                 p = n.clone(c);
-                            if (p[0].multiplyScalar(10).add(d), p[1].multiplyScalar(10).add(d), "=" === r.bondType || "=" === this.getRingbondType(h, a) || r.isPartOfAromaticRing && this.bridgedRing) {
-                                let t = this.areVerticesInSameRing(h, a),
-                                    e = this.chooseSide(h, a, p);
+                            if (p[0].multiplyScalar(10).add(d), p[1].multiplyScalar(10).add(d), "=" === r.bondType || "=" === this.getRingbondType(a, h) || r.isPartOfAromaticRing && this.bridgedRing) {
+                                let t = this.areVerticesInSameRing(a, h),
+                                    e = this.chooseSide(a, h, p);
                                 if (t) {
-                                    let t = this.getLargestOrAromaticCommonRing(h, a).center;
+                                    let t = this.getLargestOrAromaticCommonRing(a, h).center;
                                     c[0].multiplyScalar(i.opts.bondSpacing), c[1].multiplyScalar(i.opts.bondSpacing);
                                     let e = null;
-                                    e = t.sameSideAs(h.position, a.position, s.add(d, c[0])) ? new o(s.add(d, c[0]), s.add(u, c[0]), l, g) : new o(s.add(d, c[1]), s.add(u, c[1]), l, g), e.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength), r.isPartOfAromaticRing ? this.canvasWrapper.drawLine(e, !0) : this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
-                                } else if (r.center || h.isTerminal() && a.isTerminal()) {
+                                    e = t.sameSideAs(a.position, h.position, s.add(d, c[0])) ? new o(s.add(d, c[0]), s.add(u, c[0]), l, g) : new o(s.add(d, c[1]), s.add(u, c[1]), l, g), e.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength), r.isPartOfAromaticRing ? this.canvasWrapper.drawLine(e, !0) : this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
+                                } else if (r.center || a.isTerminal() && h.isTerminal()) {
                                     c[0].multiplyScalar(i.opts.halfBondSpacing), c[1].multiplyScalar(i.opts.halfBondSpacing);
                                     let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
                                         e = new o(s.add(d, c[1]), s.add(u, c[1]), l, g);
                                     this.canvasWrapper.drawLine(t), this.canvasWrapper.drawLine(e)
                                 } else if (0 == e.anCount && e.bnCount > 1 || 0 == e.bnCount && e.anCount > 1) {
                                     c[0].multiplyScalar(i.opts.halfBondSpacing), c[1].multiplyScalar(i.opts.halfBondSpacing);
                                     let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
@@ -1375,38 +1269,38 @@
                             } else if ("#" === r.bondType) {
                                 c[0].multiplyScalar(i.opts.bondSpacing / 1.5), c[1].multiplyScalar(i.opts.bondSpacing / 1.5);
                                 let t = new o(s.add(d, c[0]), s.add(u, c[0]), l, g),
                                     e = new o(s.add(d, c[1]), s.add(u, c[1]), l, g);
                                 this.canvasWrapper.drawLine(t), this.canvasWrapper.drawLine(e), this.canvasWrapper.drawLine(new o(d, u, l, g))
                             } else if ("." === r.bondType);
                             else {
-                                let t = h.value.isStereoCenter,
-                                    e = a.value.isStereoCenter;
+                                let t = a.value.isStereoCenter,
+                                    e = h.value.isStereoCenter;
                                 "up" === r.wedge ? this.canvasWrapper.drawWedge(new o(d, u, l, g, t, e)) : "down" === r.wedge ? this.canvasWrapper.drawDashedWedge(new o(d, u, l, g, t, e)) : this.canvasWrapper.drawLine(new o(d, u, l, g, t, e))
                             }
                             if (e) {
                                 let e = s.midpoint(d, u);
                                 this.canvasWrapper.drawDebugText(e.x, e.y, "e: " + t)
                             }
                         }
                         drawVertices(t) {
                             var e = this.graph.vertices.length;
                             for (e = 0; e < this.graph.vertices.length; e++) {
                                 let i = this.graph.vertices[e],
                                     r = i.value,
                                     o = 0,
-                                    h = 0,
+                                    a = 0,
                                     l = i.value.bondCount,
                                     g = r.element,
-                                    d = a.maxBonds[g] - l,
+                                    d = h.maxBonds[g] - l,
                                     u = i.getTextDirection(this.graph.vertices),
                                     c = !(!this.opts.terminalCarbons && "C" === g && !r.hasAttachedPseudoElements) && i.isTerminal(),
                                     p = "C" === r.element;
-                                if ("N" === r.element && r.isPartOfAromaticRing && (d = 0), r.bracket && (d = r.bracket.hcount, o = r.bracket.charge, h = r.bracket.isotope), "allballs" === this.opts.atomVisualization) this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
-                                else if (r.isDrawn && (!p || r.drawExplicit || c || r.hasAttachedPseudoElements) || 1 === this.graph.vertices.length) "default" === this.opts.atomVisualization ? this.canvasWrapper.drawText(i.position.x, i.position.y, g, d, u, c, o, h, this.graph.vertices.length, r.getAttachedPseudoElements()) : "balls" === this.opts.atomVisualization && this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
+                                if ("N" === r.element && r.isPartOfAromaticRing && (d = 0), r.bracket && (d = r.bracket.hcount, o = r.bracket.charge, a = r.bracket.isotope), "allballs" === this.opts.atomVisualization) this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
+                                else if (r.isDrawn && (!p || r.drawExplicit || c || r.hasAttachedPseudoElements) || 1 === this.graph.vertices.length) "default" === this.opts.atomVisualization ? this.canvasWrapper.drawText(i.position.x, i.position.y, g, d, u, c, o, a, r.getAttachedPseudoElements()) : "balls" === this.opts.atomVisualization && this.canvasWrapper.drawBall(i.position.x, i.position.y, g);
                                 else if (2 === i.getNeighbourCount() && 1 == i.forcePositioned) {
                                     let t = this.graph.vertices[i.neighbours[0]].position,
                                         e = this.graph.vertices[i.neighbours[1]].position,
                                         r = s.threePointangle(i.position, t, e);
                                     Math.abs(Math.PI - r) < .1 && this.canvasWrapper.drawPoint(i.position.x, i.position.y, g)
                                 }
                                 if (t) {
@@ -1422,20 +1316,16 @@
                         }
                         position() {
                             let t = null;
                             for (var e = 0; e < this.graph.vertices.length; e++)
                                 if (null !== this.graph.vertices[e].value.bridgedRing) {
                                     t = this.graph.vertices[e];
                                     break
-                                } if (null === t)
-                                for (e = 0; e < this.rings.length; e++)
-                                    if (this.rings[e].isBridged) {
-                                        t = this.graph.vertices[this.rings[e].members[0]];
-                                        break
-                                    } null === t && this.rings.length > 0 && (t = this.graph.vertices[this.rings[0].members[0]]), null === t && (t = this.graph.vertices[0]), this.createNextBond(t, null, 0)
+                                } for (e = 0; e < this.rings.length; e++) this.rings[e].isBridged && (t = this.graph.vertices[this.rings[e].members[0]]);
+                            this.rings.length > 0 && null === t && (t = this.graph.vertices[this.rings[0].members[0]]), null === t && (t = this.graph.vertices[0]), this.createNextBond(t, null, 0)
                         }
                         backupRingInformation() {
                             this.originalRings = Array(), this.originalRingConnections = Array();
                             for (var t = 0; t < this.rings.length; t++) this.originalRings.push(this.rings[t]);
                             for (t = 0; t < this.ringConnections.length; t++) this.originalRingConnections.push(this.ringConnections[t]);
                             for (t = 0; t < this.graph.vertices.length; t++) this.graph.vertices[t].value.backupRings()
                         }
@@ -1453,53 +1343,53 @@
                             for (e = 0; e < this.originalRingConnections.length; e++) this.ringConnections.push(this.originalRingConnections[e]);
                             for (e = 0; e < this.graph.vertices.length; e++) this.graph.vertices[e].value.restoreRings()
                         }
                         createRing(t, e = null, i = null, n = null) {
                             if (t.positioned) return;
                             e = e || new s(0, 0);
                             let o = t.getOrderedNeighbours(this.ringConnections),
-                                h = i ? s.subtract(i.position, e).angle() : 0,
-                                a = r.polyCircumradius(this.opts.bondLength, t.getSize()),
+                                a = i ? s.subtract(i.position, e).angle() : 0,
+                                h = r.polyCircumradius(this.opts.bondLength, t.getSize()),
                                 l = r.centralAngle(t.getSize());
                             t.centralAngle = l;
-                            let d = h,
+                            let d = a,
                                 u = this,
                                 c = i ? i.id : null;
                             if (-1 === t.members.indexOf(c) && (i && (i.positioned = !1), c = t.members[0]), t.isBridged) {
                                 this.graph.kkLayout(t.members.slice(), e, i.id, t, this.opts.bondLength, this.opts.kkThreshold, this.opts.kkInnerThreshold, this.opts.kkMaxIteration, this.opts.kkMaxInnerIteration, this.opts.kkMaxEnergy), t.positioned = !0, this.setRingCenter(t), e = t.center;
                                 for (var p = 0; p < t.rings.length; p++) this.setRingCenter(t.rings[p])
                             } else t.eachMember(this.graph.vertices, (function(i) {
                                 let r = u.graph.vertices[i];
-                                r.positioned || r.setPosition(e.x + Math.cos(d) * a, e.y + Math.sin(d) * a), d += l, (!t.isBridged || t.rings.length < 3) && (r.angle = d, r.positioned = !0)
+                                r.positioned || r.setPosition(e.x + Math.cos(d) * h, e.y + Math.sin(d) * h), d += l, (!t.isBridged || t.rings.length < 3) && (r.angle = d, r.positioned = !0)
                             }), c, n ? n.id : null);
                             for (t.positioned = !0, t.center = e, p = 0; p < o.length; p++) {
                                 let i = this.getRing(o[p].neighbour);
                                 if (i.positioned) continue;
                                 let n = g.getVertices(this.ringConnections, t.id, i.id);
                                 if (2 === n.length) {
                                     t.isFused = !0, i.isFused = !0;
                                     let o = this.graph.vertices[n[0]],
-                                        h = this.graph.vertices[n[1]],
-                                        a = s.midpoint(o.position, h.position),
-                                        l = s.normals(o.position, h.position);
+                                        a = this.graph.vertices[n[1]],
+                                        h = s.midpoint(o.position, a.position),
+                                        l = s.normals(o.position, a.position);
                                     l[0].normalize(), l[1].normalize();
                                     let g = r.polyCircumradius(this.opts.bondLength, i.getSize()),
                                         d = r.apothem(g, i.getSize());
-                                    l[0].multiplyScalar(d).add(a), l[1].multiplyScalar(d).add(a);
+                                    l[0].multiplyScalar(d).add(h), l[1].multiplyScalar(d).add(h);
                                     let u = l[0];
                                     s.subtract(e, l[1]).lengthSq() > s.subtract(e, l[0]).lengthSq() && (u = l[1]);
                                     let c = s.subtract(o.position, u),
-                                        p = s.subtract(h.position, u); - 1 === c.clockwise(p) ? i.positioned || this.createRing(i, u, o, h) : i.positioned || this.createRing(i, u, h, o)
+                                        p = s.subtract(a.position, u); - 1 === c.clockwise(p) ? i.positioned || this.createRing(i, u, o, a) : i.positioned || this.createRing(i, u, a, o)
                                 } else if (1 === n.length) {
                                     t.isSpiro = !0, i.isSpiro = !0;
                                     let o = this.graph.vertices[n[0]],
-                                        h = s.subtract(e, o.position);
-                                    h.invert(), h.normalize();
-                                    let a = r.polyCircumradius(this.opts.bondLength, i.getSize());
-                                    h.multiplyScalar(a), h.add(o.position), i.positioned || this.createRing(i, h, o)
+                                        a = s.subtract(e, o.position);
+                                    a.invert(), a.normalize();
+                                    let h = r.polyCircumradius(this.opts.bondLength, i.getSize());
+                                    a.multiplyScalar(h), a.add(o.position), i.positioned || this.createRing(i, a, o)
                                 }
                             }
                             for (p = 0; p < t.members.length; p++) {
                                 let e = this.graph.vertices[t.members[p]],
                                     i = e.neighbours;
                                 for (var f = 0; f < i.length; f++) {
                                     let t = this.graph.vertices[i[f]];
@@ -1517,23 +1407,23 @@
                                 }
                             }))
                         }
                         getSubtreeOverlapScore(t, e, i) {
                             let r = this,
                                 n = 0,
                                 o = new s(0, 0),
-                                h = 0;
+                                a = 0;
                             return this.graph.traverseTree(t, e, (function(t) {
                                 if (!t.value.isDrawn) return;
                                 let e = i[t.id];
-                                e > r.opts.overlapSensitivity && (n += e, h++);
+                                e > r.opts.overlapSensitivity && (n += e, a++);
                                 let s = r.graph.vertices[t.id].position.clone();
                                 s.multiplyScalar(e), o.add(s)
                             })), o.divide(n), {
-                                value: n / h,
+                                value: n / a,
                                 center: o
                             }
                         }
                         getCurrentCenterOfMass() {
                             let t = new s(0, 0),
                                 e = 0;
                             for (var i = 0; i < this.graph.vertices.length; i++) {
@@ -1588,16 +1478,16 @@
                                         i = e.vertices[1];
                                     if (!t.value.isDrawn || !i.value.isDrawn) continue;
                                     let r = (2 * Math.PI - this.getRing(e.rings[0]).getAngle()) / 6;
                                     this.rotateSubtree(t.id, e.common.id, r, e.common.position), this.rotateSubtree(i.id, e.common.id, -r, e.common.position);
                                     let n = this.getOverlapScore(),
                                         s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores),
                                         o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores),
-                                        h = s.value + o.value;
-                                    this.rotateSubtree(t.id, e.common.id, -2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, 2 * r, e.common.position), n = this.getOverlapScore(), s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores), o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores), s.value + o.value > h && (this.rotateSubtree(t.id, e.common.id, 2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, -2 * r, e.common.position))
+                                        a = s.value + o.value;
+                                    this.rotateSubtree(t.id, e.common.id, -2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, 2 * r, e.common.position), n = this.getOverlapScore(), s = this.getSubtreeOverlapScore(t.id, e.common.id, n.vertexScores), o = this.getSubtreeOverlapScore(i.id, e.common.id, n.vertexScores), s.value + o.value > a && (this.rotateSubtree(t.id, e.common.id, 2 * r, e.common.position), this.rotateSubtree(i.id, e.common.id, -2 * r, e.common.position))
                                 } else 1 === e.vertices.length && e.rings.length
                             }
                         }
                         resolveSecondaryOverlaps(t) {
                             for (var e = 0; e < t.length; e++)
                                 if (t[e].score > this.opts.overlapSensitivity) {
                                     let i = this.graph.vertices[t[e].id];
@@ -1614,22 +1504,22 @@
                         }
                         getLastVertexWithAngle(t) {
                             let e = 0,
                                 i = null;
                             for (; !e && t;) i = this.graph.vertices[t], e = i.angle, t = i.parentVertexId;
                             return i
                         }
-                        createNextBond(t, e = null, i = 0, o = !1, h = !1) {
-                            if (t.positioned && !h) return;
-                            let a = !1;
+                        createNextBond(t, e = null, i = 0, o = !1, a = !1) {
+                            if (t.positioned && !a) return;
+                            let h = !1;
                             if (e) {
                                 let i = this.graph.getEdge(t.id, e.id);
-                                "/" !== i.bondType && "\\" !== i.bondType || ++this.doubleBondConfigCount % 2 != 1 || null === this.doubleBondConfig && (this.doubleBondConfig = i.bondType, a = !0, null === e.parentVertexId && t.value.branchBond && ("/" === this.doubleBondConfig ? this.doubleBondConfig = "\\" : "\\" === this.doubleBondConfig && (this.doubleBondConfig = "/")))
+                                "/" !== i.bondType && "\\" !== i.bondType || ++this.doubleBondConfigCount % 2 != 1 || null === this.doubleBondConfig && (this.doubleBondConfig = i.bondType, h = !0, null === e.parentVertexId && t.value.branchBond && ("/" === this.doubleBondConfig ? this.doubleBondConfig = "\\" : "\\" === this.doubleBondConfig && (this.doubleBondConfig = "/")))
                             }
-                            if (!h)
+                            if (!a)
                                 if (e)
                                     if (e.value.rings.length > 0) {
                                         let i = e.neighbours,
                                             r = null,
                                             o = new s(0, 0);
                                         if (null === e.value.bridgedRing && e.value.rings.length > 1)
                                             for (var l = 0; l < i.length; l++) {
@@ -1670,74 +1560,74 @@
                                     i.invert(), i.normalize();
                                     let n = r.polyCircumradius(this.opts.bondLength, e.getSize());
                                     i.multiplyScalar(n), i.add(t.position), this.createRing(e, i, t)
                                 }
                             } else {
                                 t.value.isStereoCenter;
                                 let i = t.getNeighbours(),
-                                    h = Array();
-                                for (l = 0; l < i.length; l++) this.graph.vertices[i[l]].value.isDrawn && h.push(i[l]);
-                                e && (h = n.remove(h, e.id));
+                                    a = Array();
+                                for (l = 0; l < i.length; l++) this.graph.vertices[i[l]].value.isDrawn && a.push(i[l]);
+                                e && (a = n.remove(a, e.id));
                                 let g = t.getAngle();
-                                if (1 === h.length) {
-                                    let i = this.graph.vertices[h[0]];
+                                if (1 === a.length) {
+                                    let i = this.graph.vertices[a[0]];
                                     if ("#" === t.value.bondType || e && "#" === e.value.bondType || "=" === t.value.bondType && e && 0 === e.value.rings.length && "=" === e.value.bondType && "-" !== t.value.branchBond) t.value.drawExplicit = !1, e && (this.graph.getEdge(t.id, e.id).center = !0), this.graph.getEdge(t.id, i.id).center = !0, ("#" === t.value.bondType || e && "#" === e.value.bondType) && (i.angle = 0), i.drawExplicit = !0, this.createNextBond(i, t, g + i.angle);
                                     else if (e && e.value.rings.length > 0) {
                                         let e = r.toRad(60),
                                             n = -e,
                                             o = new s(this.opts.bondLength, 0),
-                                            h = new s(this.opts.bondLength, 0);
-                                        o.rotate(e).add(t.position), h.rotate(n).add(t.position);
-                                        let a = this.getCurrentCenterOfMass(),
-                                            l = o.distanceSq(a),
-                                            d = h.distanceSq(a);
+                                            a = new s(this.opts.bondLength, 0);
+                                        o.rotate(e).add(t.position), a.rotate(n).add(t.position);
+                                        let h = this.getCurrentCenterOfMass(),
+                                            l = o.distanceSq(h),
+                                            d = a.distanceSq(h);
                                         i.angle = l < d ? n : e, this.createNextBond(i, t, g + i.angle)
                                     } else {
                                         let r = t.angle;
-                                        if (e && e.neighbours.length > 3 ? r = r > 0 ? Math.min(1.0472, r) : r < 0 ? Math.max(-1.0472, r) : 1.0472 : r || (r = this.getLastVertexWithAngle(t.id).angle, r || (r = 1.0472)), e && !a) {
+                                        if (e && e.neighbours.length > 3 ? r = r > 0 ? Math.min(1.0472, r) : r < 0 ? Math.max(-1.0472, r) : 1.0472 : r || (r = this.getLastVertexWithAngle(t.id).angle, r || (r = 1.0472)), e && !h) {
                                             let e = this.graph.getEdge(t.id, i.id).bondType;
                                             "/" === e ? ("/" === this.doubleBondConfig || "\\" === this.doubleBondConfig && (r = -r), this.doubleBondConfig = null) : "\\" === e && ("/" === this.doubleBondConfig ? r = -r : this.doubleBondConfig, this.doubleBondConfig = null)
                                         }
                                         i.angle = o ? r : -r, this.createNextBond(i, t, g + i.angle)
                                     }
-                                } else if (2 === h.length) {
+                                } else if (2 === a.length) {
                                     let i = t.angle;
                                     i || (i = 1.0472);
-                                    let r = this.graph.getTreeDepth(h[0], t.id),
-                                        n = this.graph.getTreeDepth(h[1], t.id),
-                                        s = this.graph.vertices[h[0]],
-                                        o = this.graph.vertices[h[1]];
+                                    let r = this.graph.getTreeDepth(a[0], t.id),
+                                        n = this.graph.getTreeDepth(a[1], t.id),
+                                        s = this.graph.vertices[a[0]],
+                                        o = this.graph.vertices[a[1]];
                                     s.value.subtreeDepth = r, o.value.subtreeDepth = n;
-                                    let a = this.graph.getTreeDepth(e ? e.id : null, t.id);
-                                    e && (e.value.subtreeDepth = a);
+                                    let h = this.graph.getTreeDepth(e ? e.id : null, t.id);
+                                    e && (e.value.subtreeDepth = h);
                                     let l = 0,
                                         d = 1;
                                     "C" === o.value.element && "C" !== s.value.element && n > 1 && r < 5 ? (l = 1, d = 0) : "C" !== o.value.element && "C" === s.value.element && r > 1 && n < 5 ? (l = 0, d = 1) : n > r && (l = 1, d = 0);
-                                    let u = this.graph.vertices[h[l]],
-                                        c = this.graph.vertices[h[d]],
+                                    let u = this.graph.vertices[a[l]],
+                                        c = this.graph.vertices[a[d]],
                                         p = (this.graph.getEdge(t.id, u.id), this.graph.getEdge(t.id, c.id), !1);
-                                    a < r && a < n && (p = !0), c.angle = i, u.angle = -i, "\\" === this.doubleBondConfig ? "\\" === c.value.branchBond && (c.angle = -i, u.angle = i) : "/" === this.doubleBondConfig && "/" === c.value.branchBond && (c.angle = -i, u.angle = i), this.createNextBond(c, t, g + c.angle, p), this.createNextBond(u, t, g + u.angle, p)
-                                } else if (3 === h.length) {
-                                    let i = this.graph.getTreeDepth(h[0], t.id),
-                                        n = this.graph.getTreeDepth(h[1], t.id),
-                                        s = this.graph.getTreeDepth(h[2], t.id),
-                                        o = this.graph.vertices[h[0]],
-                                        a = this.graph.vertices[h[1]],
-                                        l = this.graph.vertices[h[2]];
-                                    o.value.subtreeDepth = i, a.value.subtreeDepth = n, l.value.subtreeDepth = s, n > i && n > s ? (o = this.graph.vertices[h[1]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[2]]) : s > i && s > n && (o = this.graph.vertices[h[2]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]]), e && e.value.rings.length < 1 && o.value.rings.length < 1 && a.value.rings.length < 1 && l.value.rings.length < 1 && 1 === this.graph.getTreeDepth(a.id, t.id) && 1 === this.graph.getTreeDepth(l.id, t.id) && this.graph.getTreeDepth(o.id, t.id) > 1 ? (o.angle = -t.angle, t.angle >= 0 ? (a.angle = r.toRad(30), l.angle = r.toRad(90)) : (a.angle = -r.toRad(30), l.angle = -r.toRad(90)), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle)) : (o.angle = 0, a.angle = r.toRad(90), l.angle = -r.toRad(90), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle))
-                                } else if (4 === h.length) {
-                                    let e = this.graph.getTreeDepth(h[0], t.id),
-                                        i = this.graph.getTreeDepth(h[1], t.id),
-                                        n = this.graph.getTreeDepth(h[2], t.id),
-                                        s = this.graph.getTreeDepth(h[3], t.id),
-                                        o = this.graph.vertices[h[0]],
-                                        a = this.graph.vertices[h[1]],
-                                        l = this.graph.vertices[h[2]],
-                                        d = this.graph.vertices[h[3]];
-                                    o.value.subtreeDepth = e, a.value.subtreeDepth = i, l.value.subtreeDepth = n, d.value.subtreeDepth = s, i > e && i > n && i > s ? (o = this.graph.vertices[h[1]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[2]], d = this.graph.vertices[h[3]]) : n > e && n > i && n > s ? (o = this.graph.vertices[h[2]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]], d = this.graph.vertices[h[3]]) : s > e && s > i && s > n && (o = this.graph.vertices[h[3]], a = this.graph.vertices[h[0]], l = this.graph.vertices[h[1]], d = this.graph.vertices[h[2]]), o.angle = -r.toRad(36), a.angle = r.toRad(36), l.angle = -r.toRad(108), d.angle = r.toRad(108), this.createNextBond(o, t, g + o.angle), this.createNextBond(a, t, g + a.angle), this.createNextBond(l, t, g + l.angle), this.createNextBond(d, t, g + d.angle)
+                                    h < r && h < n && (p = !0), c.angle = i, u.angle = -i, "\\" === this.doubleBondConfig ? "\\" === c.value.branchBond && (c.angle = -i, u.angle = i) : "/" === this.doubleBondConfig && "/" === c.value.branchBond && (c.angle = -i, u.angle = i), this.createNextBond(c, t, g + c.angle, p), this.createNextBond(u, t, g + u.angle, p)
+                                } else if (3 === a.length) {
+                                    let i = this.graph.getTreeDepth(a[0], t.id),
+                                        n = this.graph.getTreeDepth(a[1], t.id),
+                                        s = this.graph.getTreeDepth(a[2], t.id),
+                                        o = this.graph.vertices[a[0]],
+                                        h = this.graph.vertices[a[1]],
+                                        l = this.graph.vertices[a[2]];
+                                    o.value.subtreeDepth = i, h.value.subtreeDepth = n, l.value.subtreeDepth = s, n > i && n > s ? (o = this.graph.vertices[a[1]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[2]]) : s > i && s > n && (o = this.graph.vertices[a[2]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]]), e && e.value.rings.length < 1 && o.value.rings.length < 1 && h.value.rings.length < 1 && l.value.rings.length < 1 && 1 === this.graph.getTreeDepth(h.id, t.id) && 1 === this.graph.getTreeDepth(l.id, t.id) && this.graph.getTreeDepth(o.id, t.id) > 1 ? (o.angle = -t.angle, t.angle >= 0 ? (h.angle = r.toRad(30), l.angle = r.toRad(90)) : (h.angle = -r.toRad(30), l.angle = -r.toRad(90)), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle)) : (o.angle = 0, h.angle = r.toRad(90), l.angle = -r.toRad(90), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle))
+                                } else if (4 === a.length) {
+                                    let e = this.graph.getTreeDepth(a[0], t.id),
+                                        i = this.graph.getTreeDepth(a[1], t.id),
+                                        n = this.graph.getTreeDepth(a[2], t.id),
+                                        s = this.graph.getTreeDepth(a[3], t.id),
+                                        o = this.graph.vertices[a[0]],
+                                        h = this.graph.vertices[a[1]],
+                                        l = this.graph.vertices[a[2]],
+                                        d = this.graph.vertices[a[3]];
+                                    o.value.subtreeDepth = e, h.value.subtreeDepth = i, l.value.subtreeDepth = n, d.value.subtreeDepth = s, i > e && i > n && i > s ? (o = this.graph.vertices[a[1]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[2]], d = this.graph.vertices[a[3]]) : n > e && n > i && n > s ? (o = this.graph.vertices[a[2]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]], d = this.graph.vertices[a[3]]) : s > e && s > i && s > n && (o = this.graph.vertices[a[3]], h = this.graph.vertices[a[0]], l = this.graph.vertices[a[1]], d = this.graph.vertices[a[2]]), o.angle = -r.toRad(36), h.angle = r.toRad(36), l.angle = -r.toRad(108), d.angle = r.toRad(108), this.createNextBond(o, t, g + o.angle), this.createNextBond(h, t, g + h.angle), this.createNextBond(l, t, g + l.angle), this.createNextBond(d, t, g + d.angle)
                                 }
                             }
                         }
                         getCommonRingbondNeighbour(t) {
                             let e = t.neighbours;
                             for (var i = 0; i < e.length; i++) {
                                 let r = this.graph.vertices[e[i]];
@@ -1786,91 +1676,91 @@
                             return e
                         }
                         annotateStereochemistry() {
                             for (var t = 0; t < this.graph.vertices.length; t++) {
                                 let s = this.graph.vertices[t];
                                 if (!s.value.isStereoCenter) continue;
                                 let o = s.getNeighbours(),
-                                    h = o.length,
-                                    a = Array(h);
-                                for (var e = 0; e < h; e++) {
+                                    a = o.length,
+                                    h = Array(a);
+                                for (var e = 0; e < a; e++) {
                                     let t = new Uint8Array(this.graph.vertices.length),
                                         r = Array(Array());
                                     t[s.id] = 1, this.visitStereochemistry(o[e], s.id, t, r, 10, 0);
                                     for (var i = 0; i < r.length; i++) r[i].sort((function(t, e) {
                                         return e - t
                                     }));
-                                    a[e] = [e, r]
+                                    h[e] = [e, r]
                                 }
                                 let l = 0,
                                     g = 0;
-                                for (e = 0; e < a.length; e++)
-                                    for (a[e][1].length > l && (l = a[e][1].length), i = 0; i < a[e][1].length; i++) a[e][1][i].length > g && (g = a[e][1][i].length);
-                                for (e = 0; e < a.length; e++) {
-                                    let t = l - a[e][1].length;
-                                    for (i = 0; i < t; i++) a[e][1].push([]);
-                                    for (a[e][1].push([o[e]]), i = 0; i < a[e][1].length; i++) {
-                                        let t = g - a[e][1][i].length;
-                                        for (var n = 0; n < t; n++) a[e][1][i].push(0)
+                                for (e = 0; e < h.length; e++)
+                                    for (h[e][1].length > l && (l = h[e][1].length), i = 0; i < h[e][1].length; i++) h[e][1][i].length > g && (g = h[e][1][i].length);
+                                for (e = 0; e < h.length; e++) {
+                                    let t = l - h[e][1].length;
+                                    for (i = 0; i < t; i++) h[e][1].push([]);
+                                    for (h[e][1].push([o[e]]), i = 0; i < h[e][1].length; i++) {
+                                        let t = g - h[e][1][i].length;
+                                        for (var n = 0; n < t; n++) h[e][1][i].push(0)
                                     }
                                 }
-                                a.sort((function(t, e) {
+                                h.sort((function(t, e) {
                                     for (var i = 0; i < t[1].length; i++)
                                         for (var r = 0; r < t[1][i].length; r++) {
                                             if (t[1][i][r] > e[1][i][r]) return -1;
                                             if (t[1][i][r] < e[1][i][r]) return 1
                                         }
                                     return 0
                                 }));
-                                let d = new Uint8Array(h);
-                                for (e = 0; e < h; e++) d[e] = a[e][0], s.value.priority = e;
+                                let d = new Uint8Array(a);
+                                for (e = 0; e < a; e++) d[e] = h[e][0], s.value.priority = e;
                                 let u = this.graph.vertices[o[d[0]]].position,
                                     c = this.graph.vertices[o[d[1]]].position,
                                     p = this.graph.vertices[o[d[2]]].position,
                                     f = u.relativeClockwise(c, s.position),
                                     v = (u.relativeClockwise(p, s.position), -1 === f),
                                     m = "@" === s.value.bracket.chirality ? -1 : 1,
                                     b = r.parityOfPermutation(d) * m == 1 ? "R" : "S",
                                     y = "down",
-                                    x = "up";
-                                (v && "R" !== b || !v && "S" !== b) && (s.value.hydrogenDirection = "up", y = "up", x = "down"), s.value.hasHydrogen && (this.graph.getEdge(s.id, o[d[d.length - 1]]).wedge = y);
-                                let S = new Array(o.length - 1),
-                                    A = s.value.rings.length > 1 && s.value.hasHydrogen,
-                                    C = s.value.hasHydrogen ? 1 : 0;
-                                for (e = 0; e < d.length - C; e++) {
-                                    S[e] = new Uint32Array(2);
+                                    S = "up";
+                                (v && "R" !== b || !v && "S" !== b) && (s.value.hydrogenDirection = "up", y = "up", S = "down"), s.value.hasHydrogen && (this.graph.getEdge(s.id, o[d[d.length - 1]]).wedge = y);
+                                let w = new Array(o.length - 1),
+                                    x = s.value.rings.length > 1 && s.value.hasHydrogen,
+                                    A = s.value.hasHydrogen ? 1 : 0;
+                                for (e = 0; e < d.length - A; e++) {
+                                    w[e] = new Uint32Array(2);
                                     let t = this.graph.vertices[o[d[e]]];
-                                    S[e][0] += t.value.isStereoCenter ? 0 : 1e5, S[e][0] += this.areVerticesInSameRing(t, s) ? 0 : 1e4, S[e][0] += t.value.isHeteroAtom() ? 1e3 : 0, S[e][0] -= 0 === t.value.subtreeDepth ? 1e3 : 0, S[e][0] += 1e3 - t.value.subtreeDepth, S[e][1] = o[d[e]]
+                                    w[e][0] += t.value.isStereoCenter ? 0 : 1e5, w[e][0] += this.areVerticesInSameRing(t, s) ? 0 : 1e4, w[e][0] += t.value.isHeteroAtom() ? 1e3 : 0, w[e][0] -= 0 === t.value.subtreeDepth ? 1e3 : 0, w[e][0] += 1e3 - t.value.subtreeDepth, w[e][1] = o[d[e]]
                                 }
-                                if (S.sort((function(t, e) {
+                                if (w.sort((function(t, e) {
                                         return t[0] > e[0] ? -1 : t[0] < e[0] ? 1 : 0
-                                    })), !A) {
-                                    let t = S[0][1];
-                                    if (s.value.hasHydrogen) this.graph.getEdge(s.id, t).wedge = x;
+                                    })), !x) {
+                                    let t = w[0][1];
+                                    if (s.value.hasHydrogen) this.graph.getEdge(s.id, t).wedge = S;
                                     else {
-                                        let i = x;
-                                        for (e = d.length - 1; e >= 0 && (i = i === y ? x : y, o[d[e]] !== t); e--);
+                                        let i = S;
+                                        for (e = d.length - 1; e >= 0 && (i = i === y ? S : y, o[d[e]] !== t); e--);
                                         this.graph.getEdge(s.id, t).wedge = i
                                     }
                                 }
                                 s.value.chirality = b
                             }
                         }
                         visitStereochemistry(t, e, i, r, n, s, o = 0) {
                             i[t] = 1;
-                            let h = this.graph.vertices[t],
-                                a = h.value.getAtomicNumber();
+                            let a = this.graph.vertices[t],
+                                h = a.value.getAtomicNumber();
                             r.length <= s && r.push(Array());
-                            for (var l = 0; l < this.graph.getEdge(t, e).weight; l++) r[s].push(1e3 * o + a);
+                            for (var l = 0; l < this.graph.getEdge(t, e).weight; l++) r[s].push(1e3 * o + h);
                             let g = this.graph.vertices[t].neighbours;
-                            for (l = 0; l < g.length; l++) 1 !== i[g[l]] && s < n - 1 && this.visitStereochemistry(g[l], t, i.slice(), r, n, s + 1, a);
+                            for (l = 0; l < g.length; l++) 1 !== i[g[l]] && s < n - 1 && this.visitStereochemistry(g[l], t, i.slice(), r, n, s + 1, h);
                             if (s < n - 1) {
                                 let e = 0;
                                 for (l = 0; l < g.length; l++) e += this.graph.getEdge(t, g[l]).weight;
-                                for (l = 0; l < h.value.getMaxBonds() - e; l++) r.length <= s + 1 && r.push(Array()), r[s + 1].push(1e3 * a + 1)
+                                for (l = 0; l < a.value.getMaxBonds() - e; l++) r.length <= s + 1 && r.push(Array()), r[s + 1].push(1e3 * h + 1)
                             }
                         }
                         initPseudoElements() {
                             for (var t = 0; t < this.graph.vertices.length; t++) {
                                 const i = this.graph.vertices[t],
                                     r = i.neighbours;
                                 let n = Array(r.length);
@@ -1883,26 +1773,26 @@
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e],
                                         i = t.value.element,
                                         r = t.getNeighbourCount();
                                     "C" !== i && "H" !== i && 1 === r && s++, r > 1 && o++
                                 }
                                 if (o > 1 || s < 2) continue;
-                                let h = null;
+                                let a = null;
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e];
-                                    t.getNeighbourCount() > 1 && (h = t)
+                                    t.getNeighbourCount() > 1 && (a = t)
                                 }
                                 for (e = 0; e < n.length; e++) {
                                     let t = n[e];
                                     if (t.getNeighbourCount() > 1) continue;
                                     t.value.isDrawn = !1;
-                                    let r = a.maxBonds[t.value.element] - t.value.bondCount,
+                                    let r = h.maxBonds[t.value.element] - t.value.bondCount,
                                         s = "";
-                                    t.value.bracket && (r = t.value.bracket.hcount, s = t.value.bracket.charge || 0), i.value.attachPseudoElement(t.value.element, h ? h.value.element : null, r, s)
+                                    t.value.bracket && (r = t.value.bracket.hcount, s = t.value.bracket.charge || 0), i.value.attachPseudoElement(t.value.element, a ? a.value.element : null, r, s)
                                 }
                             }
                             for (t = 0; t < this.graph.vertices.length; t++) {
                                 const i = this.graph.vertices[t],
                                     r = i.value,
                                     n = r.element;
                                 if ("C" === n || "H" === n || !r.isDrawn) continue;
@@ -1941,48 +1831,48 @@
                     t.exports = e
                 },
                 707: (t, e, i) => {
                     const r = i(474),
                         n = (i(614), i(843)),
                         s = i(826),
                         o = (i(421), i(427));
-                    class h {
+                    class a {
                         constructor(t, e = !1) {
                             this.vertices = Array(), this.edges = Array(), this.vertexIdsToEdgeId = {}, this.isomeric = e, this._time = 0, this._init(t)
                         }
                         _init(t, e = 0, i = null, r = !1) {
-                            let h = new o(t.atom.element ? t.atom.element : t.atom, t.bond);
-                            h.branchBond = t.branchBond, h.ringbonds = t.ringbonds, h.bracket = t.atom.element ? t.atom : null, h.class = t.atom.class;
-                            let a = new n(h),
+                            let a = new o(t.atom.element ? t.atom.element : t.atom, t.bond);
+                            a.branchBond = t.branchBond, a.ringbonds = t.ringbonds, a.bracket = t.atom.element ? t.atom : null;
+                            let h = new n(a),
                                 l = this.vertices[i];
-                            if (this.addVertex(a), null !== i) {
-                                a.setParentVertexId(i), a.value.addNeighbouringElement(l.value.element), l.addChild(a.id), l.value.addNeighbouringElement(h.element), l.spanningTreeChildren.push(a.id);
-                                let t = new s(i, a.id, 1),
+                            if (this.addVertex(h), null !== i) {
+                                h.setParentVertexId(i), h.value.addNeighbouringElement(l.value.element), l.addChild(h.id), l.value.addNeighbouringElement(a.element), l.spanningTreeChildren.push(h.id);
+                                let t = new s(i, h.id, 1),
                                     e = null;
-                                r ? (t.setBondType(a.value.branchBond || "-"), e = a.id, t.setBondType(a.value.branchBond || "-"), e = a.id) : (t.setBondType(l.value.bondType || "-"), e = l.id), this.addEdge(t)
+                                r ? (t.setBondType(h.value.branchBond || "-"), e = h.id, t.setBondType(h.value.branchBond || "-"), e = h.id) : (t.setBondType(l.value.bondType || "-"), e = l.id), this.addEdge(t)
                             }
                             let g = t.ringbondCount + 1;
-                            h.bracket && (g += h.bracket.hcount);
+                            a.bracket && (g += a.bracket.hcount);
                             let d = 0;
-                            if (h.bracket && h.bracket.chirality) {
-                                h.isStereoCenter = !0, d = h.bracket.hcount;
+                            if (a.bracket && a.bracket.chirality) {
+                                a.isStereoCenter = !0, d = a.bracket.hcount;
                                 for (var u = 0; u < d; u++) this._init({
                                     atom: "H",
                                     isBracket: "false",
                                     branches: Array(),
                                     branchCount: 0,
                                     ringbonds: Array(),
                                     ringbondCount: !1,
                                     next: null,
                                     hasNext: !1,
                                     bond: "-"
-                                }, u, a.id, !0)
+                                }, u, h.id, !0)
                             }
-                            for (u = 0; u < t.branchCount; u++) this._init(t.branches[u], u + g, a.id, !0);
-                            t.hasNext && this._init(t.next, t.branchCount + g, a.id)
+                            for (u = 0; u < t.branchCount; u++) this._init(t.branches[u], u + g, h.id, !0);
+                            t.hasNext && this._init(t.next, t.branchCount + g, h.id)
                         }
                         clear() {
                             this.vertices = Array(), this.edges = Array(), this.vertexIdsToEdgeId = {}
                         }
                         addVertex(t) {
                             return t.id = this.vertices.length, this.vertices.push(t), t.id
                         }
@@ -2092,15 +1982,15 @@
                                 e = new Array(t),
                                 i = new Array(t),
                                 r = new Array(t),
                                 n = new Array(t),
                                 s = this.getAdjacencyList(),
                                 o = Array();
                             e.fill(!1), n.fill(null), this._time = 0;
-                            for (var h = 0; h < t; h++) e[h] || this._bridgeDfs(h, e, i, r, n, s, o);
+                            for (var a = 0; a < t; a++) e[a] || this._bridgeDfs(a, e, i, r, n, s, o);
                             return o
                         }
                         traverseBF(t, e) {
                             let i = this.vertices.length,
                                 r = new Array(i);
                             r.fill(!1);
                             for (var n = [t]; n.length > 0;) {
@@ -2123,139 +2013,139 @@
                                 s > r && (r = s)
                             }
                             return r + 1
                         }
                         traverseTree(t, e, i, r = 999999, n = !1, s = 1, o = null) {
                             if (null === o && (o = new Uint8Array(this.vertices.length)), s > r + 1 || 1 === o[t]) return;
                             o[t] = 1;
-                            let h = this.vertices[t],
-                                a = h.getNeighbours(e);
-                            (!n || s > 1) && i(h);
-                            for (var l = 0; l < a.length; l++) this.traverseTree(a[l], t, i, r, n, s + 1, o)
+                            let a = this.vertices[t],
+                                h = a.getNeighbours(e);
+                            (!n || s > 1) && i(a);
+                            for (var l = 0; l < h.length; l++) this.traverseTree(h[l], t, i, r, n, s + 1, o)
                         }
-                        kkLayout(t, e, i, n, s, o = .1, h = .1, a = 2e3, l = 50, g = 1e9) {
+                        kkLayout(t, e, i, n, s, o = .1, a = .1, h = 2e3, l = 50, g = 1e9) {
                             let d = s;
                             for (var u = t.length; u--;) var c = this.vertices[t[u]].neighbours.length;
                             let p = this.getSubgraphDistanceMatrix(t),
                                 f = t.length,
                                 v = r.polyCircumradius(500, f),
                                 m = r.centralAngle(f),
                                 b = 0,
                                 y = new Float32Array(f),
-                                x = new Float32Array(f),
-                                S = Array(f);
+                                S = new Float32Array(f),
+                                w = Array(f);
                             for (u = f; u--;) {
                                 let i = this.vertices[t[u]];
-                                i.positioned ? (y[u] = i.position.x, x[u] = i.position.y) : (y[u] = e.x + Math.cos(b) * v, x[u] = e.y + Math.sin(b) * v), S[u] = i.positioned, b += m
+                                i.positioned ? (y[u] = i.position.x, S[u] = i.position.y) : (y[u] = e.x + Math.cos(b) * v, S[u] = e.y + Math.sin(b) * v), w[u] = i.positioned, b += m
                             }
-                            let A = Array(f);
+                            let x = Array(f);
                             for (u = f; u--;)
-                                for (A[u] = new Array(f), c = f; c--;) A[u][c] = s * p[u][c];
-                            let C = Array(f);
+                                for (x[u] = new Array(f), c = f; c--;) x[u][c] = s * p[u][c];
+                            let A = Array(f);
                             for (u = f; u--;)
-                                for (C[u] = Array(f), c = f; c--;) C[u][c] = d * Math.pow(p[u][c], -2);
-                            let R, w, T, B, I, P, L, N = Array(f),
-                                O = new Float32Array(f),
+                                for (A[u] = Array(f), c = f; c--;) A[u][c] = d * Math.pow(p[u][c], -2);
+                            let C, R, N, T, L, P, B, I = Array(f),
+                                E = new Float32Array(f),
                                 M = new Float32Array(f);
-                            for (u = f; u--;) N[u] = Array(f);
+                            for (u = f; u--;) I[u] = Array(f);
                             for (u = f; u--;) {
-                                R = y[u], w = x[u], T = 0, B = 0;
+                                C = y[u], R = S[u], N = 0, T = 0;
                                 let t = f;
-                                for (; t--;) u !== t && (I = y[t], P = x[t], L = 1 / Math.sqrt((R - I) * (R - I) + (w - P) * (w - P)), N[u][t] = [C[u][t] * (R - I - A[u][t] * (R - I) * L), C[u][t] * (w - P - A[u][t] * (w - P) * L)], N[t][u] = N[u][t], T += N[u][t][0], B += N[u][t][1]);
-                                O[u] = T, M[u] = B
+                                for (; t--;) u !== t && (L = y[t], P = S[t], B = 1 / Math.sqrt((C - L) * (C - L) + (R - P) * (R - P)), I[u][t] = [A[u][t] * (C - L - x[u][t] * (C - L) * B), A[u][t] * (R - P - x[u][t] * (R - P) * B)], I[t][u] = I[u][t], N += I[u][t][0], T += I[u][t][1]);
+                                E[u] = N, M[u] = T
                             }
                             let k = function(t) {
-                                    return [O[t] * O[t] + M[t] * M[t], O[t], M[t]]
+                                    return [E[t] * E[t] + M[t] * M[t], E[t], M[t]]
                                 },
-                                E = function() {
+                                O = function() {
                                     let t = 0,
                                         e = 0,
                                         i = 0,
                                         r = 0;
                                     for (u = f; u--;) {
                                         let [n, s, o] = k(u);
-                                        n > t && !1 === S[u] && (t = n, e = u, i = s, r = o)
+                                        n > t && !1 === w[u] && (t = n, e = u, i = s, r = o)
                                     }
                                     return [e, t, i, r]
                                 },
                                 D = function(t, e, i) {
                                     let r = 0,
                                         n = 0,
                                         s = 0,
                                         o = y[t],
+                                        a = S[t],
                                         h = x[t],
-                                        a = A[t],
-                                        l = C[t];
+                                        l = A[t];
                                     for (u = f; u--;) {
                                         if (u === t) continue;
                                         let e = y[u],
-                                            i = x[u],
-                                            g = a[u],
+                                            i = S[u],
+                                            g = h[u],
                                             d = l[u],
                                             c = (o - e) * (o - e),
-                                            p = 1 / Math.pow(c + (h - i) * (h - i), 1.5);
-                                        r += d * (1 - g * (h - i) * (h - i) * p), n += d * (1 - g * c * p), s += d * (g * (o - e) * (h - i) * p)
+                                            p = 1 / Math.pow(c + (a - i) * (a - i), 1.5);
+                                        r += d * (1 - g * (a - i) * (a - i) * p), n += d * (1 - g * c * p), s += d * (g * (o - e) * (a - i) * p)
                                     }
                                     0 === r && (r = .1), 0 === n && (n = .1), 0 === s && (s = .1);
                                     let g = e / r + i / s;
                                     g /= s / r - n / s;
                                     let d = -(s * g + e) / r;
-                                    y[t] += d, x[t] += g;
-                                    let c, p, v, m, b, S = N[t];
-                                    for (e = 0, i = 0, o = y[t], h = x[t], u = f; u--;) t !== u && (c = y[u], p = x[u], v = S[u][0], m = S[u][1], b = 1 / Math.sqrt((o - c) * (o - c) + (h - p) * (h - p)), d = l[u] * (o - c - a[u] * (o - c) * b), g = l[u] * (h - p - a[u] * (h - p) * b), S[u] = [d, g], e += d, i += g, O[u] += d - v, M[u] += g - m);
-                                    O[t] = e, M[t] = i
+                                    y[t] += d, S[t] += g;
+                                    let c, p, v, m, b, w = I[t];
+                                    for (e = 0, i = 0, o = y[t], a = S[t], u = f; u--;) t !== u && (c = y[u], p = S[u], v = w[u][0], m = w[u][1], b = 1 / Math.sqrt((o - c) * (o - c) + (a - p) * (a - p)), d = l[u] * (o - c - h[u] * (o - c) * b), g = l[u] * (a - p - h[u] * (a - p) * b), w[u] = [d, g], e += d, i += g, E[u] += d - v, M[u] += g - m);
+                                    E[t] = e, M[t] = i
                                 },
-                                F = 0,
                                 z = 0,
-                                H = 0,
                                 V = 0,
+                                F = 0,
+                                H = 0,
                                 W = 0,
-                                U = 0;
-                            for (; g > o && a > W;)
-                                for (W++, [F, g, z, H] = E(), V = g, U = 0; V > h && l > U;) U++, D(F, z, H), [V, z, H] = k(F);
+                                q = 0;
+                            for (; g > o && h > W;)
+                                for (W++, [z, g, V, F] = O(), H = g, q = 0; H > a && l > q;) q++, D(z, V, F), [H, V, F] = k(z);
                             for (u = f; u--;) {
                                 let e = t[u],
                                     i = this.vertices[e];
-                                i.position.x = y[u], i.position.y = x[u], i.positioned = !0, i.forcePositioned = !0
+                                i.position.x = y[u], i.position.y = S[u], i.positioned = !0, i.forcePositioned = !0
                             }
                         }
                         _bridgeDfs(t, e, i, r, n, s, o) {
                             e[t] = !0, i[t] = r[t] = ++this._time;
-                            for (var h = 0; h < s[t].length; h++) {
-                                let a = s[t][h];
-                                e[a] ? a !== n[t] && (r[t] = Math.min(r[t], i[a])) : (n[a] = t, this._bridgeDfs(a, e, i, r, n, s, o), r[t] = Math.min(r[t], r[a]), r[a] > i[t] && o.push([t, a]))
+                            for (var a = 0; a < s[t].length; a++) {
+                                let h = s[t][a];
+                                e[h] ? h !== n[t] && (r[t] = Math.min(r[t], i[h])) : (n[h] = t, this._bridgeDfs(h, e, i, r, n, s, o), r[t] = Math.min(r[t], r[h]), r[h] > i[t] && o.push([t, h]))
                             }
                         }
                         static getConnectedComponents(t) {
                             let e = t.length,
                                 i = new Array(e),
                                 r = new Array;
                             i.fill(!1);
                             for (var n = 0; n < e; n++)
                                 if (!i[n]) {
                                     let e = Array();
-                                    i[n] = !0, e.push(n), h._ccGetDfs(n, i, t, e), e.length > 1 && r.push(e)
+                                    i[n] = !0, e.push(n), a._ccGetDfs(n, i, t, e), e.length > 1 && r.push(e)
                                 } return r
                         }
                         static getConnectedComponentCount(t) {
                             let e = t.length,
                                 i = new Array(e),
                                 r = 0;
                             i.fill(!1);
-                            for (var n = 0; n < e; n++) i[n] || (i[n] = !0, r++, h._ccCountDfs(n, i, t));
+                            for (var n = 0; n < e; n++) i[n] || (i[n] = !0, r++, a._ccCountDfs(n, i, t));
                             return r
                         }
                         static _ccCountDfs(t, e, i) {
-                            for (var r = 0; r < i[t].length; r++) i[t][r] && !e[r] && t !== r && (e[r] = !0, h._ccCountDfs(r, e, i))
+                            for (var r = 0; r < i[t].length; r++) i[t][r] && !e[r] && t !== r && (e[r] = !0, a._ccCountDfs(r, e, i))
                         }
                         static _ccGetDfs(t, e, i, r) {
-                            for (var n = 0; n < i[t].length; n++) i[t][n] && !e[n] && t !== n && (e[n] = !0, r.push(n), h._ccGetDfs(n, e, i, r))
+                            for (var n = 0; n < i[t].length; n++) i[t][n] && !e[n] && t !== n && (e[n] = !0, r.push(n), a._ccGetDfs(n, e, i, r))
                         }
                     }
-                    t.exports = h
+                    t.exports = a
                 },
                 929: (t, e, i) => {
                     const r = i(614);
                     class n {
                         constructor(t = new r(0, 0), e = new r(0, 0), i = null, n = null, s = !1, o = !1) {
                             this.from = t, this.to = e, this.elementFrom = i, this.elementTo = n, this.chiralFrom = s, this.chiralTo = o
                         }
@@ -2376,31 +2266,14 @@
                         }
                         static get twoPI() {
                             return 2 * Math.PI
                         }
                     }
                     t.exports = e
                 },
-                207: t => {
-                    t.exports = class {
-                        static extend() {
-                            let t = this,
-                                e = {},
-                                i = !1,
-                                r = 0,
-                                n = arguments.length;
-                            "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (i = arguments[0], r++);
-                            let s = function(r) {
-                                for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (i && "[object Object]" === Object.prototype.toString.call(r[n]) ? e[n] = t.extend(!0, e[n], r[n]) : e[n] = r[n])
-                            };
-                            for (; r < n; r++) s(arguments[r]);
-                            return e
-                        }
-                    }
-                },
                 19: t => {
                     t.exports = function() {
                         "use strict";
 
                         function t(e, i, r, n) {
                             this.message = e, this.expected = i, this.found = r, this.location = n, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, t)
                         }
@@ -2466,82 +2339,82 @@
                                 }
                             }(t) + " but " + function(t) {
                                 return t ? '"' + n(t) + '"' : "end of input"
                             }(e) + " found."
                         }, {
                             SyntaxError: t,
                             parse: function(e, i) {
-                                if (i = void 0 !== i ? i : {}, e.split("(").length - 1 != e.split(")").length - 1) throw ht("The number of opening parentheses does not match the number of closing parentheses.", 0);
-                                var r, n, s, o, h = {},
-                                    a = {
-                                        chain: at
+                                if (i = void 0 !== i ? i : {}, e.split("(").length - 1 != e.split(")").length - 1) throw at("The number of opening parentheses does not match the number of closing parentheses.", 0);
+                                var r, n, s, o, a = {},
+                                    h = {
+                                        chain: ht
                                     },
-                                    l = at,
+                                    l = ht,
                                     g = it("(", !1),
                                     d = it(")", !1),
                                     u = /^[\-=#$:\/\\.]/,
                                     c = rt(["-", "=", "#", "$", ":", "/", "\\", "."], !1, !1),
                                     p = it("[", !1),
                                     f = it("se", !1),
                                     v = it("as", !1),
                                     m = it("]", !1),
                                     b = it("B", !1),
                                     y = it("r", !1),
-                                    x = it("C", !1),
-                                    S = it("l", !1),
-                                    A = /^[NOPSFI]/,
-                                    C = rt(["N", "O", "P", "S", "F", "I"], !1, !1),
-                                    R = /^[bcnops]/,
-                                    w = rt(["b", "c", "n", "o", "p", "s"], !1, !1),
-                                    T = it("*", !1),
-                                    B = /^[A-Z]/,
-                                    I = rt([
+                                    S = it("C", !1),
+                                    w = it("l", !1),
+                                    x = /^[NOPSFI]/,
+                                    A = rt(["N", "O", "P", "S", "F", "I"], !1, !1),
+                                    C = /^[bcnops]/,
+                                    R = rt(["b", "c", "n", "o", "p", "s"], !1, !1),
+                                    N = it("*", !1),
+                                    T = /^[A-Z]/,
+                                    L = rt([
                                         ["A", "Z"]
                                     ], !1, !1),
                                     P = /^[a-z]/,
-                                    L = rt([
+                                    B = rt([
                                         ["a", "z"]
                                     ], !1, !1),
-                                    N = it("%", !1),
-                                    O = /^[1-9]/,
+                                    I = it("%", !1),
+                                    E = /^[1-9]/,
                                     M = rt([
                                         ["1", "9"]
                                     ], !1, !1),
                                     k = /^[0-9]/,
-                                    E = rt([
+                                    O = rt([
                                         ["0", "9"]
                                     ], !1, !1),
                                     D = it("@", !1),
-                                    F = it("TH", !1),
-                                    z = /^[12]/,
-                                    H = rt(["1", "2"], !1, !1),
-                                    V = it("AL", !1),
+                                    z = it("TH", !1),
+                                    V = /^[12]/,
+                                    F = rt(["1", "2"], !1, !1),
+                                    H = it("AL", !1),
                                     W = it("SP", !1),
-                                    U = /^[1-3]/,
-                                    q = rt([
+                                    q = /^[1-3]/,
+                                    j = rt([
                                         ["1", "3"]
                                     ], !1, !1),
-                                    j = it("TB", !1),
-                                    _ = it("OH", !1),
-                                    G = it("+", !1),
-                                    X = it("-", !1),
-                                    K = it("H", !1),
-                                    Y = it(":", !1),
-                                    Z = /^[0]/,
-                                    $ = rt(["0"], !1, !1),
+                                    U = it("TB", !1),
+                                    X = it("OH", !1),
+                                    _ = it("+", !1),
+                                    Y = it("-", !1),
+                                    $ = it("H", !1),
+                                    G = it(":", !1),
+                                    K = /^[0]/,
+                                    Z = rt(["0"], !1, !1),
                                     J = 0,
                                     Q = [{
                                         line: 1,
                                         column: 1
                                     }],
                                     tt = 0,
                                     et = [];
                                 if ("startRule" in i) {
-                                    if (!(i.startRule in a)) throw new Error("Can't start parsing from rule \"" + i.startRule + '".');
-                                    l = a[i.startRule]
+                                    if (!(i.startRule in h)) throw new Error("Can't start parsing from rule \"" + i.startRule + '".');
+                                    l = h[i.startRule]
                                 }
 
                                 function it(t, e) {
                                     return {
                                         type: "literal",
                                         text: t,
                                         ignoreCase: e
@@ -2585,85 +2458,85 @@
                                     }
                                 }
 
                                 function ot(t) {
                                     J < tt || (J > tt && (tt = J, et = []), et.push(t))
                                 }
 
-                                function ht(e, i) {
+                                function at(e, i) {
                                     return new t(e, null, null, i)
                                 }
 
-                                function at() {
-                                    var t, i, r, n, s, o, a, l, g;
-                                    if (J, t = J, i = function() {
+                                function ht() {
+                                    var t, i, r, n, s, o, h, l, g;
+                                    if (J, t = J, (i = function() {
                                             var t;
-                                            return J, t = function() {
+                                            return J, (t = function() {
                                                 var t, i, r, n;
-                                                return J, t = J, 66 === e.charCodeAt(J) ? (i = "B", J++) : (i = h, ot(b)), i !== h ? (114 === e.charCodeAt(J) ? (r = "r", J++) : (r = h, ot(y)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t === h && (t = J, 67 === e.charCodeAt(J) ? (i = "C", J++) : (i = h, ot(x)), i !== h ? (108 === e.charCodeAt(J) ? (r = "l", J++) : (r = h, ot(S)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t === h && (A.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(C)))), t !== h && (t = (n = t).length > 1 ? n.join("") : n), t
-                                            }(), t === h && (t = dt()) === h && (t = function() {
-                                                var t, i, r, n, s, o, a, l, g, d;
-                                                return J, t = J, 91 === e.charCodeAt(J) ? (i = "[", J++) : (i = h, ot(p)), i !== h ? (r = function() {
+                                                return J, t = J, 66 === e.charCodeAt(J) ? (i = "B", J++) : (i = a, ot(b)), i !== a ? (114 === e.charCodeAt(J) ? (r = "r", J++) : (r = a, ot(y)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t === a && (t = J, 67 === e.charCodeAt(J) ? (i = "C", J++) : (i = a, ot(S)), i !== a ? (108 === e.charCodeAt(J) ? (r = "l", J++) : (r = a, ot(w)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t === a && (x.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(A)))), t !== a && (t = (n = t).length > 1 ? n.join("") : n), t
+                                            }()) === a && (t = dt()) === a && (t = function() {
+                                                var t, i, r, n, s, o, h, l, g, d;
+                                                return J, t = J, 91 === e.charCodeAt(J) ? (i = "[", J++) : (i = a, ot(p)), i !== a ? ((r = function() {
                                                     var t, i, r, n;
-                                                    return J, t = J, O.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = h, ot(M)), i !== h ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(E)), r === h && (r = null), r !== h ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(E)), n === h && (n = null), n !== h ? t = i = [i, r, n] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (t = Number(t.join(""))), t
-                                                }(), r === h && (r = null), r !== h ? ("se" === e.substr(J, 2) ? (n = "se", J += 2) : (n = h, ot(f)), n === h && ("as" === e.substr(J, 2) ? (n = "as", J += 2) : (n = h, ot(v)), n === h && (n = dt()) === h && (n = function() {
+                                                    return J, t = J, E.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = a, ot(M)), i !== a ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(O)), r === a && (r = null), r !== a ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(O)), n === a && (n = null), n !== a ? t = i = [i, r, n] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (t = Number(t.join(""))), t
+                                                }()) === a && (r = null), r !== a ? ("se" === e.substr(J, 2) ? (n = "se", J += 2) : (n = a, ot(f)), n === a && ("as" === e.substr(J, 2) ? (n = "as", J += 2) : (n = a, ot(v)), n === a && (n = dt()) === a && (n = function() {
                                                     var t, i, r;
-                                                    return J, t = J, B.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = h, ot(I)), i !== h ? (P.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(L)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = t.join("")), t
-                                                }(), n === h && (n = ut()))), n !== h ? (s = function() {
-                                                    var t, i, r, n, s, o, a;
-                                                    return J, t = J, 64 === e.charCodeAt(J) ? (i = "@", J++) : (i = h, ot(D)), i !== h ? (64 === e.charCodeAt(J) ? (r = "@", J++) : (r = h, ot(D)), r === h && (r = J, "TH" === e.substr(J, 2) ? (n = "TH", J += 2) : (n = h, ot(F)), n !== h ? (z.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(H)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "AL" === e.substr(J, 2) ? (n = "AL", J += 2) : (n = h, ot(V)), n !== h ? (z.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(H)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "SP" === e.substr(J, 2) ? (n = "SP", J += 2) : (n = h, ot(W)), n !== h ? (U.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(q)), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "TB" === e.substr(J, 2) ? (n = "TB", J += 2) : (n = h, ot(j)), n !== h ? (O.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(M)), s !== h ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)), o === h && (o = null), o !== h ? r = n = [n, s, o] : (J = r, r = h)) : (J = r, r = h)) : (J = r, r = h), r === h && (r = J, "OH" === e.substr(J, 2) ? (n = "OH", J += 2) : (n = h, ot(_)), n !== h ? (O.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(M)), s !== h ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)), o === h && (o = null), o !== h ? r = n = [n, s, o] : (J = r, r = h)) : (J = r, r = h)) : (J = r, r = h)))))), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (a = t)[1] ? "@" == a[1] ? "@@" : a[1].join("").replace(",", "") : "@"), t
-                                                }(), s === h && (s = null), s !== h ? (o = function() {
+                                                    return J, t = J, T.test(e.charAt(J)) ? (i = e.charAt(J), J++) : (i = a, ot(L)), i !== a ? (P.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(B)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = t.join("")), t
+                                                }()) === a && (n = ut())), n !== a ? ((s = function() {
+                                                    var t, i, r, n, s, o, h;
+                                                    return J, t = J, 64 === e.charCodeAt(J) ? (i = "@", J++) : (i = a, ot(D)), i !== a ? (64 === e.charCodeAt(J) ? (r = "@", J++) : (r = a, ot(D)), r === a && (r = J, "TH" === e.substr(J, 2) ? (n = "TH", J += 2) : (n = a, ot(z)), n !== a ? (V.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(F)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "AL" === e.substr(J, 2) ? (n = "AL", J += 2) : (n = a, ot(H)), n !== a ? (V.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(F)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "SP" === e.substr(J, 2) ? (n = "SP", J += 2) : (n = a, ot(W)), n !== a ? (q.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(j)), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "TB" === e.substr(J, 2) ? (n = "TB", J += 2) : (n = a, ot(U)), n !== a ? (E.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(M)), s !== a ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)), o === a && (o = null), o !== a ? r = n = [n, s, o] : (J = r, r = a)) : (J = r, r = a)) : (J = r, r = a), r === a && (r = J, "OH" === e.substr(J, 2) ? (n = "OH", J += 2) : (n = a, ot(X)), n !== a ? (E.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(M)), s !== a ? (k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)), o === a && (o = null), o !== a ? r = n = [n, s, o] : (J = r, r = a)) : (J = r, r = a)) : (J = r, r = a)))))), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (h = t)[1] ? "@" == h[1] ? "@@" : h[1].join("").replace(",", "") : "@"), t
+                                                }()) === a && (s = null), s !== a ? ((o = function() {
                                                     var t, i, r, n;
-                                                    return J, t = J, 72 === e.charCodeAt(J) ? (i = "H", J++) : (i = h, ot(K)), i !== h ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(E)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (n = t)[1] ? Number(n[1]) : 1), t
-                                                }(), o === h && (o = null), o !== h ? (a = function() {
+                                                    return J, t = J, 72 === e.charCodeAt(J) ? (i = "H", J++) : (i = a, ot($)), i !== a ? (k.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(O)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (n = t)[1] ? Number(n[1]) : 1), t
+                                                }()) === a && (o = null), o !== a ? ((h = function() {
                                                     var t;
-                                                    return J, t = function() {
+                                                    return J, (t = function() {
                                                         var t, i, r, n, s, o;
-                                                        return J, t = J, 43 === e.charCodeAt(J) ? (i = "+", J++) : (i = h, ot(G)), i !== h ? (43 === e.charCodeAt(J) ? (r = "+", J++) : (r = h, ot(G)), r === h && (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(E)), s === h && (s = null), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (o = t)[1] ? "+" != o[1] ? Number(o[1].join("")) : 2 : 1), t
-                                                    }(), t === h && (t = function() {
+                                                        return J, t = J, 43 === e.charCodeAt(J) ? (i = "+", J++) : (i = a, ot(_)), i !== a ? (43 === e.charCodeAt(J) ? (r = "+", J++) : (r = a, ot(_)), r === a && (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(O)), s === a && (s = null), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (o = t)[1] ? "+" != o[1] ? Number(o[1].join("")) : 2 : 1), t
+                                                    }()) === a && (t = function() {
                                                         var t, i, r, n, s, o;
-                                                        return J, t = J, 45 === e.charCodeAt(J) ? (i = "-", J++) : (i = h, ot(X)), i !== h ? (45 === e.charCodeAt(J) ? (r = "-", J++) : (r = h, ot(X)), r === h && (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = h, ot(E)), s === h && (s = null), s !== h ? r = n = [n, s] : (J = r, r = h)) : (J = r, r = h)), r === h && (r = null), r !== h ? t = i = [i, r] : (J = t, t = h)) : (J = t, t = h), t !== h && (t = (o = t)[1] ? "-" != o[1] ? -Number(o[1].join("")) : -2 : -1), t
-                                                    }()), t
-                                                }(), a === h && (a = null), a !== h ? (l = function() {
-                                                    var t, i, r, n, s, o, a;
-                                                    if (J, t = J, 58 === e.charCodeAt(J) ? (i = ":", J++) : (i = h, ot(Y)), i !== h) {
-                                                        if (r = J, O.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(M)), n !== h) {
-                                                            for (s = [], k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E)); o !== h;) s.push(o), k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = h, ot(E));
-                                                            s !== h ? r = n = [n, s] : (J = r, r = h)
-                                                        } else J = r, r = h;
-                                                        r === h && (Z.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot($))), r !== h ? t = i = [i, r] : (J = t, t = h)
-                                                    } else J = t, t = h;
-                                                    return t !== h && (a = t, t = Number(a[1][0] + a[1][1].join(""))), t
-                                                }(), l === h && (l = null), l !== h ? (93 === e.charCodeAt(J) ? (g = "]", J++) : (g = h, ot(m)), g !== h ? t = i = [i, r, n, s, o, a, l, g] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (t = {
+                                                        return J, t = J, 45 === e.charCodeAt(J) ? (i = "-", J++) : (i = a, ot(Y)), i !== a ? (45 === e.charCodeAt(J) ? (r = "-", J++) : (r = a, ot(Y)), r === a && (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a ? (k.test(e.charAt(J)) ? (s = e.charAt(J), J++) : (s = a, ot(O)), s === a && (s = null), s !== a ? r = n = [n, s] : (J = r, r = a)) : (J = r, r = a)), r === a && (r = null), r !== a ? t = i = [i, r] : (J = t, t = a)) : (J = t, t = a), t !== a && (t = (o = t)[1] ? "-" != o[1] ? -Number(o[1].join("")) : -2 : -1), t
+                                                    }()), t !== a && (t = t), t
+                                                }()) === a && (h = null), h !== a ? ((l = function() {
+                                                    var t, i, r, n, s, o, h;
+                                                    if (J, t = J, 58 === e.charCodeAt(J) ? (i = ":", J++) : (i = a, ot(G)), i !== a) {
+                                                        if (r = J, E.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(M)), n !== a) {
+                                                            for (s = [], k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O)); o !== a;) s.push(o), k.test(e.charAt(J)) ? (o = e.charAt(J), J++) : (o = a, ot(O));
+                                                            s !== a ? r = n = [n, s] : (J = r, r = a)
+                                                        } else J = r, r = a;
+                                                        r === a && (K.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(Z))), r !== a ? t = i = [i, r] : (J = t, t = a)
+                                                    } else J = t, t = a;
+                                                    return t !== a && (h = t, t = Number(h[1][0] + h[1][1].join(""))), t
+                                                }()) === a && (l = null), l !== a ? (93 === e.charCodeAt(J) ? (g = "]", J++) : (g = a, ot(m)), g !== a ? t = i = [i, r, n, s, o, h, l, g] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (t = {
                                                     isotope: (d = t)[1],
                                                     element: d[2],
                                                     chirality: d[3],
                                                     hcount: d[4],
                                                     charge: d[5],
                                                     class: d[6]
                                                 }), t
-                                            }(), t === h && (t = ut())), t
-                                        }(), i !== h) {
-                                        for (r = [], n = lt(); n !== h;) r.push(n), n = lt();
-                                        if (r !== h) {
-                                            for (n = [], s = J, (o = gt()) === h && (o = null), o !== h && (a = ct()) !== h ? s = o = [o, a] : (J = s, s = h); s !== h;) n.push(s), s = J, (o = gt()) === h && (o = null), o !== h && (a = ct()) !== h ? s = o = [o, a] : (J = s, s = h);
-                                            if (n !== h) {
-                                                for (s = [], o = lt(); o !== h;) s.push(o), o = lt();
-                                                if (s !== h)
-                                                    if ((o = gt()) === h && (o = null), o !== h)
-                                                        if ((a = at()) === h && (a = null), a !== h) {
-                                                            for (l = [], g = lt(); g !== h;) l.push(g), g = lt();
-                                                            l !== h ? t = i = [i, r, n, s, o, a, l] : (J = t, t = h)
-                                                        } else J = t, t = h;
-                                                else J = t, t = h;
-                                                else J = t, t = h
-                                            } else J = t, t = h
-                                        } else J = t, t = h
-                                    } else J = t, t = h;
-                                    return t !== h && (t = function(t) {
+                                            }()) === a && (t = ut()), t !== a && (t = t), t
+                                        }()) !== a) {
+                                        for (r = [], n = lt(); n !== a;) r.push(n), n = lt();
+                                        if (r !== a) {
+                                            for (n = [], s = J, (o = gt()) === a && (o = null), o !== a && (h = ct()) !== a ? s = o = [o, h] : (J = s, s = a); s !== a;) n.push(s), s = J, (o = gt()) === a && (o = null), o !== a && (h = ct()) !== a ? s = o = [o, h] : (J = s, s = a);
+                                            if (n !== a) {
+                                                for (s = [], o = lt(); o !== a;) s.push(o), o = lt();
+                                                if (s !== a)
+                                                    if ((o = gt()) === a && (o = null), o !== a)
+                                                        if ((h = ht()) === a && (h = null), h !== a) {
+                                                            for (l = [], g = lt(); g !== a;) l.push(g), g = lt();
+                                                            l !== a ? t = i = [i, r, n, s, o, h, l] : (J = t, t = a)
+                                                        } else J = t, t = a;
+                                                else J = t, t = a;
+                                                else J = t, t = a
+                                            } else J = t, t = a
+                                        } else J = t, t = a
+                                    } else J = t, t = a;
+                                    return t !== a && (t = function(t) {
                                         for (var e = [], i = [], r = 0; r < t[1].length; r++) e.push(t[1][r]);
                                         for (r = 0; r < t[2].length; r++) {
                                             var n = t[2][r][0] ? t[2][r][0] : "-";
                                             i.push({
                                                 bond: n,
                                                 id: t[2][r][1]
                                             })
@@ -2681,43 +2554,43 @@
                                             next: t[5],
                                             hasNext: !!t[5]
                                         }
                                     }(t)), t
                                 }
 
                                 function lt() {
-                                    var t, i, r, n, s, o, a;
-                                    return J, t = J, 40 === e.charCodeAt(J) ? (i = "(", J++) : (i = h, ot(g)), i !== h ? ((r = gt()) === h && (r = null), r !== h && (n = at()) !== h ? (41 === e.charCodeAt(J) ? (s = ")", J++) : (s = h, ot(d)), s !== h ? t = i = [i, r, n, s] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t !== h && (a = (o = t)[1] ? o[1] : "-", o[2].branchBond = a, t = o[2]), t
+                                    var t, i, r, n, s, o, h;
+                                    return J, t = J, 40 === e.charCodeAt(J) ? (i = "(", J++) : (i = a, ot(g)), i !== a ? ((r = gt()) === a && (r = null), r !== a && (n = ht()) !== a ? (41 === e.charCodeAt(J) ? (s = ")", J++) : (s = a, ot(d)), s !== a ? t = i = [i, r, n, s] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t !== a && (h = (o = t)[1] ? o[1] : "-", o[2].branchBond = h, t = o[2]), t
                                 }
 
                                 function gt() {
                                     var t;
                                     if (J, u.test(e.charAt(J))) {
-                                        if ((t = e.charAt(J)) === e.charAt(J + 1)) throw t = h, ht("The parser encountered a bond repetition.", J + 1);
+                                        if ((t = e.charAt(J)) === e.charAt(J + 1)) throw t = a, at("The parser encountered a bond repetition.", J + 1);
                                         J++
-                                    } else t = h, ot(c);
-                                    return t
+                                    } else t = a, ot(c);
+                                    return t !== a && (t = t), t
                                 }
 
                                 function dt() {
                                     var t;
-                                    return J, R.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(w)), t
+                                    return J, C.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(R)), t !== a && (t = t), t
                                 }
 
                                 function ut() {
                                     var t;
-                                    return J, 42 === e.charCodeAt(J) ? (t = "*", J++) : (t = h, ot(T)), t
+                                    return J, 42 === e.charCodeAt(J) ? (t = "*", J++) : (t = a, ot(N)), t !== a && (t = t), t
                                 }
 
                                 function ct() {
                                     var t, i, r, n, s;
-                                    return J, t = J, 37 === e.charCodeAt(J) ? (i = "%", J++) : (i = h, ot(N)), i !== h ? (O.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = h, ot(M)), r !== h ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = h, ot(E)), n !== h ? t = i = [i, r, n] : (J = t, t = h)) : (J = t, t = h)) : (J = t, t = h), t === h && (k.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = h, ot(E))), t !== h && (t = 1 == (s = t).length ? Number(s) : Number(s.join("").replace("%", ""))), t
+                                    return J, t = J, 37 === e.charCodeAt(J) ? (i = "%", J++) : (i = a, ot(I)), i !== a ? (E.test(e.charAt(J)) ? (r = e.charAt(J), J++) : (r = a, ot(M)), r !== a ? (k.test(e.charAt(J)) ? (n = e.charAt(J), J++) : (n = a, ot(O)), n !== a ? t = i = [i, r, n] : (J = t, t = a)) : (J = t, t = a)) : (J = t, t = a), t === a && (k.test(e.charAt(J)) ? (t = e.charAt(J), J++) : (t = a, ot(O))), t !== a && (t = 1 == (s = t).length ? Number(s) : Number(s.join("").replace("%", ""))), t
                                 }
-                                if ((r = l()) !== h && J === e.length) return r;
-                                throw r !== h && J < e.length && ot({
+                                if ((r = l()) !== a && J === e.length) return r;
+                                throw r !== a && J < e.length && ot({
                                     type: "end"
                                 }), n = et, s = tt < e.length ? e.charAt(tt) : null, o = tt < e.length ? st(tt, tt + 1) : st(tt, tt), new t(t.buildMessage(n, s), n, s, o)
                             }
                         }
                     }()
                 },
                 421: (t, e, i) => {
@@ -2835,43 +2708,43 @@
                     const r = i(707);
                     class n {
                         static getRings(t, e = !1) {
                             let i = t.getComponentsAdjacencyMatrix();
                             if (0 === i.length) return null;
                             let s = r.getConnectedComponents(i),
                                 o = Array();
-                            for (var h = 0; h < s.length; h++) {
-                                let i = s[h],
+                            for (var a = 0; a < s.length; a++) {
+                                let i = s[a],
                                     r = t.getSubgraphAdjacencyMatrix([...i]),
                                     g = new Uint16Array(r.length),
                                     d = new Uint16Array(r.length);
-                                for (var a = 0; a < r.length; a++) {
-                                    d[a] = 0, g[a] = 0;
-                                    for (var l = 0; l < r[a].length; l++) g[a] += r[a][l]
+                                for (var h = 0; h < r.length; h++) {
+                                    d[h] = 0, g[h] = 0;
+                                    for (var l = 0; l < r[h].length; l++) g[h] += r[h][l]
                                 }
                                 let u = 0;
-                                for (a = 0; a < r.length; a++)
-                                    for (l = a + 1; l < r.length; l++) u += r[a][l];
+                                for (h = 0; h < r.length; h++)
+                                    for (l = h + 1; l < r.length; l++) u += r[h][l];
                                 let c = u - r.length + 1,
                                     p = !0;
-                                for (a = 0; a < g.length; a++) 3 !== g[a] && (p = !1);
+                                for (h = 0; h < g.length; h++) 3 !== g[h] && (p = !1);
                                 if (p && (c = 2 + u - r.length), 1 === c) {
                                     o.push([...i]);
                                     continue
                                 }
                                 e && (c = 999);
                                 let {
                                     d: f,
                                     pe: v,
                                     pe_prime: m
                                 } = n.getPathIncludedDistanceMatrices(r), b = n.getRingCandidates(f, v, m), y = n.getSSSR(b, f, r, v, m, g, d, c);
-                                for (a = 0; a < y.length; a++) {
-                                    let t = Array(y[a].size),
+                                for (h = 0; h < y.length; h++) {
+                                    let t = Array(y[h].size),
                                         e = 0;
-                                    for (let r of y[a]) t[e++] = i[r];
+                                    for (let r of y[h]) t[e++] = i[r];
                                     o.push(t)
                                 }
                             }
                             return o
                         }
                         static matrixToString(t) {
                             let e = "";
@@ -2882,95 +2755,95 @@
                             return e
                         }
                         static getPathIncludedDistanceMatrices(t) {
                             let e = t.length,
                                 i = Array(e),
                                 r = Array(e),
                                 n = Array(e);
-                            for (var s = 0, o = 0, h = 0, a = e; a--;) {
-                                i[a] = Array(e), r[a] = Array(e), n[a] = Array(e);
-                                for (var l = e; l--;) i[a][l] = a === l || 1 === t[a][l] ? t[a][l] : Number.POSITIVE_INFINITY, 1 === i[a][l] ? r[a][l] = [
+                            for (var s = 0, o = 0, a = 0, h = e; h--;) {
+                                i[h] = Array(e), r[h] = Array(e), n[h] = Array(e);
+                                for (var l = e; l--;) i[h][l] = h === l || 1 === t[h][l] ? t[h][l] : Number.POSITIVE_INFINITY, 1 === i[h][l] ? r[h][l] = [
                                     [
-                                        [a, l]
+                                        [h, l]
                                     ]
-                                ] : r[a][l] = Array(), n[a][l] = Array()
+                                ] : r[h][l] = Array(), n[h][l] = Array()
                             }
                             for (var g = e; g--;)
-                                for (a = e; a--;)
+                                for (h = e; h--;)
                                     for (l = e; l--;) {
-                                        const t = i[a][l],
-                                            e = i[a][g] + i[g][l];
+                                        const t = i[h][l],
+                                            e = i[h][g] + i[g][l];
                                         if (t > e) {
                                             if (t === e + 1)
-                                                for (n[a][l] = [r[a][l].length], s = r[a][l].length; s--;)
-                                                    for (n[a][l][s] = [r[a][l][s].length], o = r[a][l][s].length; o--;)
-                                                        for (n[a][l][s][o] = [r[a][l][s][o].length], h = r[a][l][s][o].length; h--;) n[a][l][s][o][h] = [r[a][l][s][o][0], r[a][l][s][o][1]];
-                                            else n[a][l] = Array();
-                                            for (i[a][l] = e, r[a][l] = [
+                                                for (n[h][l] = [r[h][l].length], s = r[h][l].length; s--;)
+                                                    for (n[h][l][s] = [r[h][l][s].length], o = r[h][l][s].length; o--;)
+                                                        for (n[h][l][s][o] = [r[h][l][s][o].length], a = r[h][l][s][o].length; a--;) n[h][l][s][o][a] = [r[h][l][s][o][0], r[h][l][s][o][1]];
+                                            else n[h][l] = Array();
+                                            for (i[h][l] = e, r[h][l] = [
                                                     []
-                                                ], s = r[a][g][0].length; s--;) r[a][l][0].push(r[a][g][0][s]);
-                                            for (s = r[g][l][0].length; s--;) r[a][l][0].push(r[g][l][0][s])
+                                                ], s = r[h][g][0].length; s--;) r[h][l][0].push(r[h][g][0][s]);
+                                            for (s = r[g][l][0].length; s--;) r[h][l][0].push(r[g][l][0][s])
                                         } else if (t === e) {
-                                            if (r[a][g].length && r[g][l].length)
-                                                if (r[a][l].length) {
+                                            if (r[h][g].length && r[g][l].length)
+                                                if (r[h][l].length) {
                                                     let t = Array();
-                                                    for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                    for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                     for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                    r[a][l].push(t)
+                                                    r[h][l].push(t)
                                                 } else {
                                                     let t = Array();
-                                                    for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                    for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                     for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                    r[a][l][0] = t
+                                                    r[h][l][0] = t
                                                 }
                                         } else if (t === e - 1)
-                                            if (n[a][l].length) {
+                                            if (n[h][l].length) {
                                                 let t = Array();
-                                                for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                 for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                n[a][l].push(t)
+                                                n[h][l].push(t)
                                             } else {
                                                 let t = Array();
-                                                for (s = r[a][g][0].length; s--;) t.push(r[a][g][0][s]);
+                                                for (s = r[h][g][0].length; s--;) t.push(r[h][g][0][s]);
                                                 for (s = r[g][l][0].length; s--;) t.push(r[g][l][0][s]);
-                                                n[a][l][0] = t
+                                                n[h][l][0] = t
                                             }
                                     }
                             return {
                                 d: i,
                                 pe: r,
                                 pe_prime: n
                             }
                         }
                         static getRingCandidates(t, e, i) {
                             let r = t.length,
                                 n = Array(),
                                 s = 0;
                             for (let o = 0; o < r; o++)
-                                for (let h = 0; h < r; h++) 0 === t[o][h] || 1 === e[o][h].length && 0 === i[o][h] || (s = 0 !== i[o][h].length ? 2 * (t[o][h] + .5) : 2 * t[o][h], s !== 1 / 0 && n.push([s, e[o][h], i[o][h]]));
+                                for (let a = 0; a < r; a++) 0 === t[o][a] || 1 === e[o][a].length && 0 === i[o][a] || (s = 0 !== i[o][a].length ? 2 * (t[o][a] + .5) : 2 * t[o][a], s !== 1 / 0 && n.push([s, e[o][a], i[o][a]]));
                             return n.sort((function(t, e) {
                                 return t[0] - e[0]
                             })), n
                         }
-                        static getSSSR(t, e, i, r, s, o, h, a) {
+                        static getSSSR(t, e, i, r, s, o, a, h) {
                             let l = Array(),
                                 g = Array();
                             for (let e = 0; e < t.length; e++)
                                 if (t[e][0] % 2 != 0)
                                     for (let r = 0; r < t[e][2].length; r++) {
                                         let s = t[e][1][0].concat(t[e][2][r]);
                                         for (var d = 0; d < s.length; d++) s[d][0].constructor === Array && (s[d] = s[d][0]);
                                         let u = n.bondsToAtoms(s);
-                                        if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, h) || (l.push(u), g = g.concat(s)), l.length > a) return l
+                                        if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, a) || (l.push(u), g = g.concat(s)), l.length > h) return l
                                     } else
                                         for (let r = 0; r < t[e][1].length - 1; r++) {
                                             let s = t[e][1][r].concat(t[e][1][r + 1]);
                                             for (d = 0; d < s.length; d++) s[d][0].constructor === Array && (s[d] = s[d][0]);
                                             let u = n.bondsToAtoms(s);
-                                            if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, h) || (l.push(u), g = g.concat(s)), l.length > a) return l
+                                            if (n.getBondCount(u, i) !== u.size || n.pathSetsContain(l, u, s, g, o, a) || (l.push(u), g = g.concat(s)), l.length > h) return l
                                         }
                             return l
                         }
                         static getEdgeCount(t) {
                             let e = 0,
                                 i = t.length;
                             for (var r = i - 1; r--;)
@@ -2992,22 +2865,22 @@
                         static getBondCount(t, e) {
                             let i = 0;
                             for (let r of t)
                                 for (let n of t) r !== n && (i += e[r][n]);
                             return i / 2
                         }
                         static pathSetsContain(t, e, i, r, s, o) {
-                            for (var h = t.length; h--;) {
-                                if (n.isSupersetOf(e, t[h])) return !0;
-                                if (t[h].size === e.size && n.areSetsEqual(t[h], e)) return !0
+                            for (var a = t.length; a--;) {
+                                if (n.isSupersetOf(e, t[a])) return !0;
+                                if (t[a].size === e.size && n.areSetsEqual(t[a], e)) return !0
                             }
-                            let a = 0,
+                            let h = 0,
                                 l = !1;
-                            for (h = i.length; h--;)
-                                for (var g = r.length; g--;)(i[h][0] === r[g][0] && i[h][1] === r[g][1] || i[h][1] === r[g][0] && i[h][0] === r[g][1]) && a++, a === i.length && (l = !0);
+                            for (a = i.length; a--;)
+                                for (var g = r.length; g--;)(i[a][0] === r[g][0] && i[a][1] === r[g][1] || i[a][1] === r[g][0] && i[a][0] === r[g][1]) && h++, h === i.length && (l = !0);
                             let d = !1;
                             if (l)
                                 for (let t of e)
                                     if (o[t] < s[t]) {
                                         d = !0;
                                         break
                                     } if (l && !d) return !0;
@@ -3024,14 +2897,363 @@
                             for (var i of e)
                                 if (!t.has(i)) return !1;
                             return !0
                         }
                     }
                     t.exports = n
                 },
+                479: (t, e, i) => {
+                    const r = i(348),
+                        n = i(427),
+                        s = i(881),
+                        o = (i(707), i(929)),
+                        a = i(36),
+                        h = i(654),
+                        l = i(614);
+                    t.exports = class {
+                        constructor(t) {
+                            this.preprocessor = new s(t)
+                        }
+                        draw(t, e, i = "light", r = !1) {
+                            let n = this.preprocessor;
+                            return n.initDraw(t, i, r), r || (this.themeManager = new h(this.preprocessor.opts.themes, i), this.svgWrapper = new a(this.themeManager, e, this.preprocessor.opts)), n.processGraph(), this.svgWrapper.determineDimensions(n.graph.vertices), this.drawEdges(n.opts.debug), this.drawVertices(n.opts.debug), n.opts.debug && (console.log(n.graph), console.log(n.rings), console.log(n.ringConnections)), this.svgWrapper.constructSvg()
+                        }
+                        drawAromaticityRing(t) {
+                            let e = this.ctx,
+                                i = MathHelper.apothemFromSideLength(this.opts.bondLength, t.getSize());
+                            e.save(), e.strokeStyle = this.getColor("C"), e.lineWidth = this.opts.bondThickness, e.beginPath(), e.arc(t.center.x + this.offsetX, t.center.y + this.offsetY, i - this.opts.bondSpacing, 0, 2 * Math.PI, !0), e.closePath(), e.stroke(), e.restore()
+                        }
+                        drawEdges(t) {
+                            let e = this.preprocessor,
+                                i = e.graph,
+                                r = e.rings,
+                                n = Array(this.preprocessor.graph.edges.length);
+                            if (n.fill(!1), i.traverseBF(0, (e => {
+                                    let r = i.getEdges(e.id);
+                                    for (var s = 0; s < r.length; s++) {
+                                        let e = r[s];
+                                        n[e] || (n[e] = !0, this.drawEdge(e, t))
+                                    }
+                                })), !this.bridgedRing)
+                                for (var s = 0; s < r.length; s++) {
+                                    let t = r[s];
+                                    e.isRingAromatic(t) && this.drawAromaticityRing(t)
+                                }
+                        }
+                        drawEdge(t, e) {
+                            let i = this.preprocessor,
+                                n = i.opts,
+                                s = this.svgWrapper,
+                                a = i.graph.edges[t],
+                                h = i.graph.vertices[a.sourceId],
+                                g = i.graph.vertices[a.targetId],
+                                d = h.value.element,
+                                u = g.value.element;
+                            if (!(h.value.isDrawn && g.value.isDrawn || "default" !== i.opts.atomVisualization)) return;
+                            let c = h.position,
+                                p = g.position,
+                                f = i.getEdgeNormals(a),
+                                v = r.clone(f);
+                            if (v[0].multiplyScalar(10).add(c), v[1].multiplyScalar(10).add(c), "=" === a.bondType || "=" === i.getRingbondType(h, g) || a.isPartOfAromaticRing && i.bridgedRing) {
+                                let t = i.areVerticesInSameRing(h, g),
+                                    e = i.chooseSide(h, g, v);
+                                if (t) {
+                                    let t = i.getLargestOrAromaticCommonRing(h, g).center;
+                                    f[0].multiplyScalar(n.bondSpacing), f[1].multiplyScalar(n.bondSpacing);
+                                    let e = null;
+                                    e = t.sameSideAs(h.position, g.position, l.add(c, f[0])) ? new o(l.add(c, f[0]), l.add(p, f[0]), d, u) : new o(l.add(c, f[1]), l.add(p, f[1]), d, u), e.shorten(n.bondLength - n.shortBondLength * n.bondLength), a.isPartOfAromaticRing ? s.drawLine(e, !0) : s.drawLine(e), s.drawLine(new o(c, p, d, u))
+                                } else if (a.center || h.isTerminal() && g.isTerminal() || 0 == e.anCount && e.bnCount > 1 || 0 == e.bnCount && e.anCount > 1) {
+                                    this.multiplyNormals(f, n.halfBondSpacing);
+                                    let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u),
+                                        e = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                    s.drawLine(t), s.drawLine(e)
+                                } else if (e.sideCount[0] > e.sideCount[1] || e.totalSideCount[0] > e.totalSideCount[1]) {
+                                    this.multiplyNormals(f, n.bondSpacing);
+                                    let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u);
+                                    t.shorten(n.bondLength - n.shortBondLength * n.bondLength), s.drawLine(t), s.drawLine(new o(c, p, d, u))
+                                } else if (e.sideCount[0] < e.sideCount[1] || e.totalSideCount[0] <= e.totalSideCount[1]) {
+                                    this.multiplyNormals(f, n.bondSpacing);
+                                    let t = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                    t.shorten(n.bondLength - n.shortBondLength * n.bondLength), s.drawLine(t), s.drawLine(new o(c, p, d, u))
+                                }
+                            } else if ("#" === a.bondType) {
+                                f[0].multiplyScalar(n.bondSpacing / 1.5), f[1].multiplyScalar(n.bondSpacing / 1.5);
+                                let t = new o(l.add(c, f[0]), l.add(p, f[0]), d, u),
+                                    e = new o(l.add(c, f[1]), l.add(p, f[1]), d, u);
+                                s.drawLine(t), s.drawLine(e), s.drawLine(new o(c, p, d, u))
+                            } else if ("." === a.bondType);
+                            else {
+                                let t = h.value.isStereoCenter,
+                                    e = g.value.isStereoCenter;
+                                "up" === a.wedge ? s.drawWedge(new o(c, p, d, u, t, e)) : "down" === a.wedge ? s.drawDashedWedge(new o(c, p, d, u, t, e)) : s.drawLine(new o(c, p, d, u, t, e))
+                            }
+                            if (e) {
+                                let e = l.midpoint(c, p);
+                                s.drawDebugText(e.x, e.y, "e: " + t)
+                            }
+                        }
+                        drawVertices(t) {
+                            let e = this.preprocessor,
+                                i = e.opts,
+                                s = e.graph,
+                                o = e.rings,
+                                a = this.svgWrapper;
+                            var h = s.vertices.length;
+                            for (h = 0; h < s.vertices.length; h++) {
+                                let e = s.vertices[h],
+                                    o = e.value,
+                                    g = 0,
+                                    d = 0,
+                                    u = e.value.bondCount,
+                                    c = o.element,
+                                    p = n.maxBonds[c] - u,
+                                    f = e.getTextDirection(s.vertices),
+                                    v = !(!i.terminalCarbons && "C" === c && !o.hasAttachedPseudoElements) && e.isTerminal(),
+                                    m = "C" === o.element;
+                                if ("N" === o.element && o.isPartOfAromaticRing && (p = 0), o.bracket && (p = o.bracket.hcount, g = o.bracket.charge, d = o.bracket.isotope), "allballs" === i.atomVisualization) a.drawBall(e.position.x, e.position.y, c);
+                                else if (o.isDrawn && (!m || o.drawExplicit || v || o.hasAttachedPseudoElements) || 1 === s.vertices.length) "default" === i.atomVisualization ? a.drawText(e.position.x, e.position.y, c, p, f, v, g, d, o.getAttachedPseudoElements()) : "balls" === i.atomVisualization && a.drawBall(e.position.x, e.position.y, c);
+                                else if (2 === e.getNeighbourCount() && 1 == e.forcePositioned) {
+                                    let t = s.vertices[e.neighbours[0]].position,
+                                        i = s.vertices[e.neighbours[1]].position,
+                                        r = l.threePointangle(e.position, t, i);
+                                    Math.abs(Math.PI - r) < .1 && a.drawPoint(e.position.x, e.position.y, c)
+                                }
+                                if (t) {
+                                    let t = "v: " + e.id + " " + r.print(o.ringbonds);
+                                    a.drawDebugText(e.position.x, e.position.y, t)
+                                } else a.drawDebugText(e.position.x, e.position.y, e.value.chirality)
+                            }
+                            if (i.debug)
+                                for (h = 0; h < o.length; h++) {
+                                    let t = o[h].center;
+                                    a.drawDebugPoint(t.x, t.y, "r: " + o[h].id)
+                                }
+                        }
+                        getTotalOverlapScore() {
+                            return this.preprocessor.getTotalOverlapScore()
+                        }
+                        getMolecularFormula() {
+                            return this.preprocessor.getMolecularFormula()
+                        }
+                        multiplyNormals(t, e) {
+                            t[0].multiplyScalar(e), t[1].multiplyScalar(e)
+                        }
+                    }
+                },
+                36: (t, e, i) => {
+                    const {
+                        getChargeText: r
+                    } = i(537), n = i(929), s = i(614);
+                    t.exports = class {
+                        constructor(t, e, i) {
+                            this.svg = document.getElementById(e), this.opts = i, this.gradientId = 0, this.paths = [], this.vertices = [], this.gradients = [], this.offsetX = 0, this.offsetY = 0, this.drawingWidth = 0, this.drawingHeight = 0, this.halfBondThickness = this.opts.bondThickness / 2, this.themeManager = t, this.maskElements = [];
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
+                            for (r.setAttributeNS(null, "x", 0), r.setAttributeNS(null, "y", 0), r.setAttributeNS(null, "width", "100%"), r.setAttributeNS(null, "height", "100%"), r.setAttributeNS(null, "fill", "white"), this.maskElements.push(r); this.svg.firstChild;) this.svg.removeChild(this.svg.firstChild)
+                        }
+                        constructSvg() {
+                            let t = document.createElementNS("http://www.w3.org/2000/svg", "defs"),
+                                e = document.createElementNS("http://www.w3.org/2000/svg", "mask"),
+                                i = document.createElementNS("http://www.w3.org/2000/svg", "style"),
+                                r = document.createElementNS("http://www.w3.org/2000/svg", "g"),
+                                n = document.createElementNS("http://www.w3.org/2000/svg", "g"),
+                                s = this.paths;
+                            e.setAttributeNS(null, "id", "text-mask"), i.appendChild(document.createTextNode(`\n                .element {\n                    font: ${this.opts.fontSizeLarge}pt Helvetica, Arial, sans-serif;\n                    alignment-baseline: 'middle';\n                }\n                .sub {\n                    font: ${this.opts.fontSizeSmall}pt Helvetica, Arial, sans-serif;\n                }\n            `));
+                            for (let t of s) r.appendChild(t);
+                            for (let t of this.vertices) n.appendChild(t);
+                            for (let t of this.maskElements) e.appendChild(t);
+                            for (let e of this.gradients) t.appendChild(e);
+                            if (r.setAttributeNS(null, "mask", "url(#text-mask)"), this.svg) return this.svg.appendChild(t), this.svg.appendChild(e), this.svg.appendChild(i), this.svg.appendChild(r), this.svg.appendChild(n), this.svg; {
+                                let s = document.createElementNS("http://www.w3.org/2000/svg", "g");
+                                return s.appendChild(t), s.appendChild(e), s.appendChild(i), s.appendChild(r), s.appendChild(n), s
+                            }
+                        }
+                        createGradient(t) {
+                            let e = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"),
+                                i = "line-" + this.gradientId++,
+                                r = t.getLeftVector(),
+                                n = t.getRightVector(),
+                                s = r.x + this.offsetX,
+                                o = r.y + this.offsetY,
+                                a = n.x + this.offsetX,
+                                h = n.y + this.offsetY;
+                            e.setAttributeNS(null, "id", i), e.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), e.setAttributeNS(null, "x1", s), e.setAttributeNS(null, "y1", o), e.setAttributeNS(null, "x2", a), e.setAttributeNS(null, "y2", h);
+                            let l = document.createElementNS("http://www.w3.org/2000/svg", "stop");
+                            l.setAttributeNS(null, "stop-color", this.themeManager.getColor(t.getLeftElement()) || this.themeManager.getColor("C")), l.setAttributeNS(null, "offset", "20%");
+                            let g = document.createElementNS("http://www.w3.org/2000/svg", "stop");
+                            return g.setAttributeNS(null, "stop-color", this.themeManager.getColor(t.getRightElement() || this.themeManager.getColor("C"))), g.setAttributeNS(null, "offset", "100%"), e.appendChild(l), e.appendChild(g), this.gradients.push(e), i
+                        }
+                        createSubSuperScripts(t, e) {
+                            let i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                            return i.setAttributeNS(null, "baseline-shift", e), i.appendChild(document.createTextNode(t)), i.setAttributeNS(null, "class", "sub"), i
+                        }
+                        determineDimensions(t) {
+                            let e = -Number.MAX_VALUE,
+                                i = -Number.MAX_VALUE,
+                                r = Number.MAX_VALUE,
+                                n = Number.MAX_VALUE;
+                            for (var s = 0; s < t.length; s++) {
+                                if (!t[s].value.isDrawn) continue;
+                                let o = t[s].position;
+                                e < o.x && (e = o.x), i < o.y && (i = o.y), r > o.x && (r = o.x), n > o.y && (n = o.y)
+                            }
+                            let o = this.opts.padding;
+                            e += o, i += o, r -= o, n -= o, this.drawingWidth = e - r, this.drawingHeight = i - n;
+                            let a = this.svg.clientWidth / this.drawingWidth,
+                                h = this.svg.clientHeight / this.drawingHeight,
+                                l = a < h ? a : h,
+                                g = Math.round(this.drawingWidth > this.drawingHeight ? this.drawingWidth : this.drawingHeight);
+                            this.svg.setAttributeNS(null, "viewBox", `0 0 ${g} ${g}`), this.offsetX = -r, this.offsetY = -n, a < h ? this.offsetY += this.svg.clientHeight / (2 * l) - this.drawingHeight / 2 : this.offsetX += this.svg.clientWidth / (2 * l) - this.drawingWidth / 2
+                        }
+                        drawBall(t, e, i) {
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            r.setAttributeNS(null, "cx", t + this.offsetX), r.setAttributeNS(null, "cy", e + this.offsetY), r.setAttributeNS(null, "r", this.opts.bondLength / 4.5), r.setAttributeNS(null, "fill", this.themeManager.getColor(i)), this.vertices.push(r)
+                        }
+                        drawDashedWedge(t) {
+                            if (isNaN(t.from.x) || isNaN(t.from.y) || isNaN(t.to.x) || isNaN(t.to.y)) return;
+                            this.offsetX, this.offsetY;
+                            let e, i, r = t.getLeftVector().clone(),
+                                o = t.getRightVector().clone(),
+                                a = s.normals(r, o);
+                            a[0].normalize(), a[1].normalize(), t.getRightChiral() ? (e = o, i = r) : (e = r, i = o);
+                            let h = s.subtract(i, e).normalize(),
+                                l = t.getLength(),
+                                g = 1.25 / (l / (3 * this.opts.bondThickness)),
+                                d = this.createGradient(t);
+                            for (let t = 0; t < 1; t += g) {
+                                let i = s.multiplyScalar(h, t * l),
+                                    r = s.add(e, i),
+                                    o = 1.5 * t,
+                                    g = s.multiplyScalar(a[0], o);
+                                r.subtract(g);
+                                let u = r.clone();
+                                u.add(s.multiplyScalar(g, 2)), this.drawLine(new n(r, u), null, d)
+                            }
+                        }
+                        drawDebugPoint(t, e, i = "", r = "#f00") {
+                            let n = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            n.setAttributeNS(null, "cx", t + this.offsetX), n.setAttributeNS(null, "cy", e + this.offsetY), n.setAttributeNS(null, "r", "2"), n.setAttributeNS(null, "fill", "#f00"), this.vertices.push(n), this.drawDebugText(t, e, i)
+                        }
+                        drawDebugText(t, e, i) {
+                            let r = document.createElementNS("http://www.w3.org/2000/svg", "text");
+                            r.setAttributeNS(null, "x", t + this.offsetX), r.setAttributeNS(null, "y", e + this.offsetY), r.setAttributeNS(null, "class", "debug"), r.setAttributeNS(null, "fill", "#ff0000"), r.setAttributeNS(null, "style", "\n                font: 5px Droid Sans, sans-serif;\n            "), r.appendChild(document.createTextNode(i)), this.vertices.push(r)
+                        }
+                        drawLine(t, e = !1, i = null) {
+                            this.opts;
+                            let r = [
+                                    ["stroke-linecap", "round"],
+                                    ["stroke-dasharray", e ? "5, 5" : "none"]
+                                ],
+                                n = t.getLeftVector(),
+                                s = t.getRightVector(),
+                                o = n.x + this.offsetX,
+                                a = n.y + this.offsetY,
+                                h = s.x + this.offsetX,
+                                l = s.y + this.offsetY,
+                                g = r.map((t => t.join(":"))).join(";"),
+                                d = document.createElementNS("http://www.w3.org/2000/svg", "line");
+                            d.setAttributeNS(null, "x1", o), d.setAttributeNS(null, "y1", a), d.setAttributeNS(null, "x2", h), d.setAttributeNS(null, "y2", l), d.setAttributeNS(null, "style", g), this.paths.push(d), null == i && (i = this.createGradient(t, o, a, h, l)), d.setAttributeNS(null, "stroke", `url('#${i}')`)
+                        }
+                        drawPoint(t, e, i) {
+                            this.ctx;
+                            let r = this.offsetX,
+                                n = this.offsetY,
+                                s = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            s.setAttributeNS(null, "cx", t + r), s.setAttributeNS(null, "cy", e + n), s.setAttributeNS(null, "r", "1.5"), s.setAttributeNS(null, "fill", "black"), this.maskElements.push(s);
+                            let o = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            o.setAttributeNS(null, "cx", t + r), o.setAttributeNS(null, "cy", e + n), o.setAttributeNS(null, "r", "0.75"), o.setAttributeNS(null, "fill", this.themeManager.getColor(i)), this.vertices.push(o)
+                        }
+                        drawText(t, e, i, n, s, o, a, h, l = {}) {
+                            let g = {
+                                    x: t + this.offsetX,
+                                    y: e + this.offsetY
+                                },
+                                d = document.createElementNS("http://www.w3.org/2000/svg", "text"),
+                                u = "horizontal-tb",
+                                c = "normal",
+                                p = "mixed",
+                                f = "direction: ltr;",
+                                v = -2,
+                                m = 2.5,
+                                b = document.createElementNS("http://www.w3.org/2000/svg", "circle");
+                            b.setAttributeNS(null, "cx", g.x), b.setAttributeNS(null, "cy", g.y), b.setAttributeNS(null, "r", "3.5"), b.setAttributeNS(null, "fill", "black"), this.maskElements.push(b), /up|down/.test(s) && !o && (u = "vertical-rl", p = "upright", c = "-1px"), "down" !== s || o ? "up" !== s || o ? "left" === s && (v = 2) : v = .5 : (v = 0, m = -2), ("left" === s || "up" === s && !o) && (f = "direction: rtl; unicode-bidi: bidi-override;"), d.setAttributeNS(null, "x", g.x + v), d.setAttributeNS(null, "y", g.y + m), d.setAttributeNS(null, "class", "element"), d.setAttributeNS(null, "fill", this.themeManager.getColor(i)), d.setAttributeNS(null, "style", `\n                text-anchor: start;\n                writing-mode: ${u};\n                text-orientation: ${p};\n                letter-spacing: ${c};\n                ${f}\n            `);
+                            let y = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                            if (i.length > 1) {
+                                let t = /up|down/.test(s) ? "middle" : "start";
+                                y.setAttributeNS(null, "style", `\n                unicode-bidi: plaintext;\n                writing-mode: lr-tb;\n                letter-spacing: normal;\n                text-anchor: ${t};\n            `)
+                            }
+                            if (y.appendChild(document.createTextNode(i)), d.appendChild(y), a) {
+                                let t = this.createSubSuperScripts(r(a), "super");
+                                y.appendChild(t)
+                            }
+                            if (h > 0) {
+                                let t = this.createSubSuperScripts(h.toString(), "super");
+                                y.appendChild(t)
+                            }
+                            if (1 === a && "N" === i && l.hasOwnProperty("0O") && l.hasOwnProperty("0O-1") && (l = {
+                                    "0O": {
+                                        element: "O",
+                                        count: 2,
+                                        hydrogenCount: 0,
+                                        previousElement: "C",
+                                        charge: ""
+                                    }
+                                }, a = 0), n > 0) {
+                                let t = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                if (t.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), t.appendChild(document.createTextNode("H")), d.appendChild(t), n > 1) {
+                                    let e = this.createSubSuperScripts(n, "sub");
+                                    t.appendChild(e)
+                                }
+                            }
+                            for (let t in l) {
+                                if (!l.hasOwnProperty(t)) continue;
+                                let e = l[t].element,
+                                    i = l[t].count,
+                                    n = l[t].hydrogenCount,
+                                    s = l[t].charge,
+                                    o = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                if (o.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), o.appendChild(document.createTextNode(e)), o.setAttributeNS(null, "fill", this.themeManager.getColor(e)), 0 !== s) {
+                                    let t = this.createSubSuperScripts(r(s), "super");
+                                    o.appendChild(t)
+                                }
+                                if (n > 0) {
+                                    let t = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
+                                    if (t.setAttributeNS(null, "style", "unicode-bidi: plaintext;"), t.appendChild(document.createTextNode("H")), o.appendChild(t), n > 1) {
+                                        let e = this.createSubSuperScripts(n, "sub");
+                                        t.appendChild(e)
+                                    }
+                                }
+                                if (i > 1) {
+                                    let t = this.createSubSuperScripts(i, "sub");
+                                    o.appendChild(t)
+                                }
+                                d.appendChild(o)
+                            }
+                            this.vertices.push(d)
+                        }
+                        drawWedge(t) {
+                            let e = this.offsetX,
+                                i = this.offsetY,
+                                r = t.getLeftVector().clone(),
+                                n = t.getRightVector().clone();
+                            r.x += e, r.y += i, n.x += e, n.y += i;
+                            let o = s.normals(r, n);
+                            o[0].normalize(), o[1].normalize();
+                            let a = r,
+                                h = n;
+                            t.getRightChiral() && (a = n, h = r);
+                            let l = s.add(a, s.multiplyScalar(o[0], this.halfBondThickness)),
+                                g = s.add(h, s.multiplyScalar(o[0], 1.5 + this.halfBondThickness)),
+                                d = s.add(h, s.multiplyScalar(o[1], 1.5 + this.halfBondThickness)),
+                                u = s.add(a, s.multiplyScalar(o[1], this.halfBondThickness)),
+                                c = document.createElementNS("http://www.w3.org/2000/svg", "polygon"),
+                                p = this.createGradient(t, r.x, r.y, n.x, n.y);
+                            c.setAttributeNS(null, "points", `${l.x},${l.y} ${g.x},${g.y} ${d.x},${d.y} ${u.x},${u.y}`), c.setAttributeNS(null, "fill", `url('#${p}')`), this.paths.push(c)
+                        }
+                    }
+                },
                 654: t => {
                     t.exports = class {
                         constructor(t, e) {
                             this.colors = t, this.theme = this.colors[e]
                         }
                         getColor(t) {
                             return t && (t = t.toUpperCase()) in this.theme ? this.theme[t] : this.theme.C
@@ -3040,15 +3262,15 @@
                             this.colors.hasOwnProperty(t) && (this.theme = this.colors[t])
                         }
                     }
                 },
                 537: t => {
                     t.exports = {
                         getChargeText: function(t) {
-                            return 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
+                            return console.log("in the utility version of getChargeText"), 1 === t ? "+" : 2 === t ? "2+" : -1 === t ? "-" : -2 === t ? "2-" : ""
                         }
                     }
                 },
                 614: t => {
                     class e {
                         constructor(t, e) {
                             0 == arguments.length ? (this.x = 0, this.y = 0) : 1 == arguments.length ? (this.x = t.x, this.y = t.y) : (this.x = t, this.y = e)
@@ -3201,16 +3423,16 @@
                             let r = e.dot(t, i);
                             return Math.acos(r / (t.length() * i.length()))
                         }
                         static threePointangle(t, i, r) {
                             let n = e.subtract(i, t),
                                 s = e.subtract(r, i),
                                 o = t.distance(i),
-                                h = i.distance(r);
-                            return Math.acos(e.dot(n, s) / (o * h))
+                                a = i.distance(r);
+                            return Math.acos(e.dot(n, s) / (o * a))
                         }
                         static scalarProjection(t, i) {
                             let r = i.normalized();
                             return e.dot(t, r)
                         }
                         static averageDirection(t) {
                             let i = new e(0, 0);
@@ -3264,15 +3486,14 @@
                         getAngle(t = null, e = !1) {
                             let i = null;
                             return i = t ? s.subtract(this.position, t) : s.subtract(this.position, this.previousPosition), e ? r.toDeg(i.angle()) : i.angle()
                         }
                         getTextDirection(t) {
                             let e = this.getDrawnNeighbours(t),
                                 i = Array();
-                            if (1 === t.length) return "right";
                             for (let r = 0; r < e.length; r++) i.push(this.getAngle(t[e[r]].position));
                             let n = r.meanAngle(i),
                                 s = Math.PI / 2;
                             return n = Math.round(Math.round(n / s) * s), 2 === n ? "down" : -2 === n ? "up" : 0 === n || -0 === n ? "right" : 3 === n || -3 === n ? "left" : "down"
                         }
                         getNeighbours(t = null) {
                             if (null === t) return this.neighbours.slice();
@@ -3310,20 +3531,15 @@
         function i(r) {
             if (e[r]) return e[r].exports;
             var n = e[r] = {
                 exports: {}
             };
             return t[r](n, n.exports, i), n.exports
         }
-        i.n = t => {
-            var e = t && t.__esModule ? () => t.default : () => t;
-            return i.d(e, {
-                a: e
-            }), e
-        }, i.d = (t, e) => {
+        i.d = (t, e) => {
             for (var r in e) i.o(e, r) && !i.o(t, r) && Object.defineProperty(t, r, {
                 enumerable: !0,
                 get: e[r]
             })
         }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => {
             "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                 value: "Module"
@@ -3331,29 +3547,31 @@
                 value: !0
             })
         };
         var r = {};
         return (() => {
             "use strict";
             i.r(r), i.d(r, {
-                clean2d: () => o
+                clean2d: () => s
+            });
+            const {
+                Parser: t,
+                Drawer: e
+            } = i(261), n = new e({
+                debug: !1,
+                atomVisualization: "default"
             });
-            var t = i(237),
-                e = i.n(t),
-                n = i(19),
-                s = i.n(n);
 
-            function o(t) {
-                const i = new(e())({}),
-                    r = s().parse(t);
-                i.initDraw(r, "light", !1), i.processGraph();
-                let n = i.graph.vertices,
-                    o = Array();
-                for (let t = 0; t < n.length; t++) {
-                    let e = n[t].position;
-                    o.push([e.x, e.y])
+            function s(e) {
+                let i = t.parse(e);
+                n.initDraw(i, "light", !1), n.processGraph();
+                let r = n.graph.vertices,
+                    s = Array();
+                for (let t = 0; t < r.length; t++) {
+                    let e = r[t].position;
+                    s.push([e.x, e.y])
                 }
-                return o
+                return s
             }
         })(), r
     })()
 }));
```

### Comparing `chython-1.67/chython/algorithms/fingerprints/__init__.py` & `chython-1.8/chython/algorithms/fingerprints/pharmacophore/test/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,28 +1,19 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .linear import *
-from .morgan import *
-
-
-class Fingerprints(LinearFingerprint, MorganFingerprint):
-    __slots__ = ()
-
-
-__all__ = ['Fingerprints']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Aleksandr Sizov <murkyrussian@gmail.com>
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.67/chython/algorithms/mapping/__init__.py` & `chython-1.8/chython/algorithms/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .attention import Attention
-from .fixmapper import FixMapper
-from .groups import GroupsFix
-
-
-class Mapping(GroupsFix, Attention, FixMapper):
-    __slots__ = ()
-
-
-__all__ = ['Mapping']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.67/chython/algorithms/mcs.py` & `chython-1.8/chython/algorithms/mcs.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from itertools import product, combinations, islice
-from typing import Dict, Set, Iterator, Tuple
-from ..containers import molecule
-
-
-class MCS:
-    __slots__ = ()
-
-    def get_mcs_mapping(self, other: 'molecule.MoleculeContainer', /, *, limit=10000) -> Iterator[Dict[int, int]]:
-        """
-        Find maximum common substructure. Based on clique searching in product graph.
-
-        :param limit: limit tested cliques
-        """
-        if not isinstance(other, molecule.MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-
-        core_product, full_product = self.__get_product(other)
-        if not core_product:
-            return
-
-        # search maximum bonded substructures
-        hits = []
-        max_atoms = 0
-        max_bonds = 0
-        for mapping in islice(_clique(full_product), limit):
-            if len(mapping) < max_atoms:
-                continue
-            # search bonds count
-            bonds = 0
-            seen = set()
-            for n in mapping:
-                seen.add(n)
-                for m in core_product[n]:
-                    if m not in seen and m in mapping:
-                        bonds += 1
-            if bonds > max_bonds:
-                max_bonds = bonds
-                max_atoms = len(mapping) - 1  # -1 is ad-hoc
-                hits = [mapping]
-            elif bonds == max_bonds:
-                hits.append(mapping)
-
-        # search maximal components in substructures
-        hits2 = []
-        max_component = 0
-        for mapping in hits:
-            # search components
-            components = []
-            atoms = mapping.copy()
-            while atoms:
-                n = atoms.pop()
-                seen = {n}
-                queue = [n]
-                component = []
-                while queue:
-                    n = queue.pop(0)
-                    component.append(n)
-                    for m in core_product[n]:
-                        if m not in seen and m in mapping:
-                            queue.append(m)
-                            seen.add(m)
-
-                components.append(component)
-                atoms.difference_update(component)
-
-            # get max component
-            component = max(len(x) for x in components)
-            if component > max_component:
-                max_component = component
-                hits2 = [mapping]
-            elif component == max_component:
-                hits2.append(mapping)
-        yield from (dict(x) for x in hits2)
-
-    def __get_product(self: 'molecule.MoleculeContainer', other: 'molecule.MoleculeContainer'):
-        bonds = self._bonds
-        o_bonds = other._bonds
-
-        s_equal = defaultdict(list)  # equal self atoms
-        for n, atom in self._atoms.items():
-            s_equal[atom].append(n)
-        p_equal = defaultdict(list)  # equal other atoms
-        for n, atom in other._atoms.items():
-            p_equal[atom].append(n)
-
-        full_product = {}
-        core_product = {}
-        equal_atoms = {}
-        for atom, ns in s_equal.items():
-            ms = p_equal[atom]
-            if ms:
-                for nm in product(ns, ms):
-                    full_product[nm] = set()
-                    core_product[nm] = set()
-                for n in ns:
-                    equal_atoms[n] = ms  # memory save
-
-        seen = set()
-        for n, o_ns in equal_atoms.items():
-            seen.add(n)
-            for m, b in bonds[n].items():
-                if m in equal_atoms and m not in seen:
-                    o_ms = equal_atoms[m]
-                    for o_n in o_ns:
-                        node1 = (n, o_n)
-                        fms = full_product[node1]
-                        cms = core_product[node1]
-                        for o_m, o_b in o_bonds[o_n].items():
-                            if o_m in o_ms and b == o_b:
-                                node2 = (m, o_m)
-                                full_product[node2].add(node1)
-                                core_product[node2].add(node1)
-                                fms.add(node2)
-                                cms.add(node2)
-
-        atoms = core_product
-        while atoms:
-            new_atoms = set()
-            for n in atoms:
-                core = core_product[n]
-                for nm1, nm2 in combinations(full_product[n], 2):
-                    n1, m1 = nm1
-                    n2, m2 = nm2
-                    if n1 == n2 or m1 == m2:
-                        continue
-                    if nm1 in full_product[nm2]:
-                        continue
-                    if nm1 not in core and nm2 not in core:
-                        continue
-
-                    full_product[nm1].add(nm2)
-                    full_product[nm2].add(nm1)
-                    new_atoms.add(nm1)
-                    new_atoms.add(nm2)
-            atoms = new_atoms
-
-        return core_product, full_product
-
-
-def _clique(graph) -> Iterator[Set[Tuple[int, int]]]:
-    """
-    clique search
-
-    adopted from networkx algorithms.clique.find_cliques
-    """
-    subgraph = {x for x, y in graph.items() if y}  # skip isolated nodes
-    if not subgraph:
-        return  # empty or fully disconnected
-    elif len(subgraph) == 2:  # dimer
-        yield set(subgraph)
-        return
-
-    stack = []
-    clique_atoms = [None]
-    candidates = subgraph.copy()
-    roots = candidates - graph[max(subgraph, key=lambda x: len(graph[x]))]
-
-    while True:
-        if roots:
-            root = roots.pop()
-            candidates.remove(root)
-            clique_atoms[-1] = root
-            neighbors = graph[root]
-            neighbors_subgraph = subgraph & neighbors
-            if not neighbors_subgraph:
-                yield set(clique_atoms)
-            else:
-                neighbors_candidates = candidates & neighbors
-                if neighbors_candidates:
-                    stack.append((subgraph, candidates, roots))
-                    clique_atoms.append(None)
-                    subgraph = neighbors_subgraph
-                    candidates = neighbors_candidates
-                    roots = candidates - graph[max(subgraph, key=lambda x: len(candidates & graph[x]))]
-        elif not stack:
-            return
-        else:
-            clique_atoms.pop()
-            subgraph, candidates, roots = stack.pop()
-
-
-__all__ = ['MCS']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from itertools import product, combinations, islice
+from typing import Dict, Set, Iterator, Tuple
+from ..containers import molecule
+
+
+class MCS:
+    __slots__ = ()
+
+    def get_mcs_mapping(self, other: 'molecule.MoleculeContainer', /, *, limit=10000) -> Iterator[Dict[int, int]]:
+        """
+        Find maximum common substructure. Based on clique searching in product graph.
+
+        :param limit: limit tested cliques
+        """
+        if not isinstance(other, molecule.MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+
+        core_product, full_product = self.__get_product(other)
+        if not core_product:
+            return
+
+        # search maximum bonded substructures
+        hits = []
+        max_atoms = 0
+        max_bonds = 0
+        for mapping in islice(_clique(full_product), limit):
+            if len(mapping) < max_atoms:
+                continue
+            # search bonds count
+            bonds = 0
+            seen = set()
+            for n in mapping:
+                seen.add(n)
+                for m in core_product[n]:
+                    if m not in seen and m in mapping:
+                        bonds += 1
+            if bonds > max_bonds:
+                max_bonds = bonds
+                max_atoms = len(mapping) - 1  # -1 is ad-hoc
+                hits = [mapping]
+            elif bonds == max_bonds:
+                hits.append(mapping)
+
+        # search maximal components in substructures
+        hits2 = []
+        max_component = 0
+        for mapping in hits:
+            # search components
+            components = []
+            atoms = mapping.copy()
+            while atoms:
+                n = atoms.pop()
+                seen = {n}
+                queue = [n]
+                component = []
+                while queue:
+                    n = queue.pop(0)
+                    component.append(n)
+                    for m in core_product[n]:
+                        if m not in seen and m in mapping:
+                            queue.append(m)
+                            seen.add(m)
+
+                components.append(component)
+                atoms.difference_update(component)
+
+            # get max component
+            component = max(len(x) for x in components)
+            if component > max_component:
+                max_component = component
+                hits2 = [mapping]
+            elif component == max_component:
+                hits2.append(mapping)
+        yield from (dict(x) for x in hits2)
+
+    def __get_product(self: 'molecule.MoleculeContainer', other: 'molecule.MoleculeContainer'):
+        bonds = self._bonds
+        o_bonds = other._bonds
+
+        s_equal = defaultdict(list)  # equal self atoms
+        for n, atom in self._atoms.items():
+            s_equal[atom].append(n)
+        p_equal = defaultdict(list)  # equal other atoms
+        for n, atom in other._atoms.items():
+            p_equal[atom].append(n)
+
+        full_product = {}
+        core_product = {}
+        equal_atoms = {}
+        for atom, ns in s_equal.items():
+            ms = p_equal[atom]
+            if ms:
+                for nm in product(ns, ms):
+                    full_product[nm] = set()
+                    core_product[nm] = set()
+                for n in ns:
+                    equal_atoms[n] = ms  # memory save
+
+        seen = set()
+        for n, o_ns in equal_atoms.items():
+            seen.add(n)
+            for m, b in bonds[n].items():
+                if m in equal_atoms and m not in seen:
+                    o_ms = equal_atoms[m]
+                    for o_n in o_ns:
+                        node1 = (n, o_n)
+                        fms = full_product[node1]
+                        cms = core_product[node1]
+                        for o_m, o_b in o_bonds[o_n].items():
+                            if o_m in o_ms and b == o_b:
+                                node2 = (m, o_m)
+                                full_product[node2].add(node1)
+                                core_product[node2].add(node1)
+                                fms.add(node2)
+                                cms.add(node2)
+
+        atoms = core_product
+        while atoms:
+            new_atoms = set()
+            for n in atoms:
+                core = core_product[n]
+                for nm1, nm2 in combinations(full_product[n], 2):
+                    n1, m1 = nm1
+                    n2, m2 = nm2
+                    if n1 == n2 or m1 == m2:
+                        continue
+                    if nm1 in full_product[nm2]:
+                        continue
+                    if nm1 not in core and nm2 not in core:
+                        continue
+
+                    full_product[nm1].add(nm2)
+                    full_product[nm2].add(nm1)
+                    new_atoms.add(nm1)
+                    new_atoms.add(nm2)
+            atoms = new_atoms
+
+        return core_product, full_product
+
+
+def _clique(graph) -> Iterator[Set[Tuple[int, int]]]:
+    """
+    clique search
+
+    adopted from networkx algorithms.clique.find_cliques
+    """
+    subgraph = {x for x, y in graph.items() if y}  # skip isolated nodes
+    if not subgraph:
+        return  # empty or fully disconnected
+    elif len(subgraph) == 2:  # dimer
+        yield set(subgraph)
+        return
+
+    stack = []
+    clique_atoms = [None]
+    candidates = subgraph.copy()
+    roots = candidates - graph[max(subgraph, key=lambda x: len(graph[x]))]
+
+    while True:
+        if roots:
+            root = roots.pop()
+            candidates.remove(root)
+            clique_atoms[-1] = root
+            neighbors = graph[root]
+            neighbors_subgraph = subgraph & neighbors
+            if not neighbors_subgraph:
+                yield set(clique_atoms)
+            else:
+                neighbors_candidates = candidates & neighbors
+                if neighbors_candidates:
+                    stack.append((subgraph, candidates, roots))
+                    clique_atoms.append(None)
+                    subgraph = neighbors_subgraph
+                    candidates = neighbors_candidates
+                    roots = candidates - graph[max(subgraph, key=lambda x: len(candidates & graph[x]))]
+        elif not stack:
+            return
+        else:
+            clique_atoms.pop()
+            subgraph, candidates, roots = stack.pop()
+
+
+__all__ = ['MCS']
```

### Comparing `chython-1.67/chython/algorithms/morgan.py` & `chython-1.8/chython/algorithms/morgan.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,84 +1,81 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from functools import cached_property
-from itertools import groupby
-from logging import getLogger
-from operator import itemgetter
-from typing import Dict, TYPE_CHECKING
-
-
-logger = getLogger('chython.morgan')
-
-
-if TYPE_CHECKING:
-    from chython.containers.graph import Graph
-
-
-class Morgan:
-    __slots__ = ()
-
-    @cached_property
-    def atoms_order(self: 'Graph') -> Dict[int, int]:
-        """
-        Morgan like algorithm for graph nodes ordering
-
-        :return: dict of atom-order pairs
-        """
-        atoms = self._atoms
-        if not atoms:  # for empty containers
-            return {}
-        elif len(atoms) == 1:  # optimize single atom containers
-            return dict.fromkeys(atoms, 1)
-        ring = self.ring_atoms
-        return _morgan({n: hash((hash(a), n in ring)) for n, a in atoms.items()}, self.int_adjacency)
-
-    @cached_property
-    def int_adjacency(self: 'Graph') -> Dict[int, Dict[int, int]]:
-        """
-        Adjacency with integer-coded bonds.
-        """
-        return {n: {m: hash(b) for m, b in mb.items()} for n, mb in self._bonds.items()}
-
-
-def _morgan(atoms: Dict[int, int], bonds: Dict[int, Dict[int, int]]) -> Dict[int, int]:
-    tries = len(atoms) - 1
-    numb = len(set(atoms.values()))
-    stab = old_numb = 0
-
-    for _ in range(tries):
-        atoms = {n: hash((atoms[n], *(x for x in sorted((atoms[m], b) for m, b in ms.items()) for x in x)))
-                 for n, ms in bonds.items()}
-        old_numb, numb = numb, len(set(atoms.values()))
-        if numb == len(atoms):  # each atom now unique
-            break
-        elif numb == old_numb:  # not changed. molecules like benzene
-            if stab == 3:
-                break
-            stab += 1
-        elif stab:  # changed unique atoms number. reset stability check.
-            stab = 0
-    else:
-        if numb < old_numb:
-            logger.warning('number of attempts exceeded. uniqueness has decreased.')
-
-    return {n: i for i, (_, g) in enumerate(groupby(sorted(atoms.items(), key=itemgetter(1)), key=itemgetter(1)),
-                                            start=1) for n, _ in g}
-
-
-__all__ = ['Morgan']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from functools import cached_property
+from itertools import groupby
+from logging import warning
+from operator import itemgetter
+from typing import Dict, TYPE_CHECKING
+
+
+if TYPE_CHECKING:
+    from chython.containers.graph import Graph
+
+
+class Morgan:
+    __slots__ = ()
+
+    @cached_property
+    def atoms_order(self: 'Graph') -> Dict[int, int]:
+        """
+        Morgan like algorithm for graph nodes ordering
+
+        :return: dict of atom-order pairs
+        """
+        atoms = self._atoms
+        if not atoms:  # for empty containers
+            return {}
+        elif len(atoms) == 1:  # optimize single atom containers
+            return dict.fromkeys(atoms, 1)
+        ring = self.ring_atoms
+        return _morgan({n: hash((hash(a), n in ring)) for n, a in atoms.items()}, self.int_adjacency)
+
+    @cached_property
+    def int_adjacency(self: 'Graph') -> Dict[int, Dict[int, int]]:
+        """
+        Adjacency with integer-coded bonds.
+        """
+        return {n: {m: int(b) for m, b in mb.items()} for n, mb in self._bonds.items()}
+
+
+def _morgan(atoms: Dict[int, int], bonds: Dict[int, Dict[int, int]]) -> Dict[int, int]:
+    tries = len(atoms) - 1
+    numb = len(set(atoms.values()))
+    stab = old_numb = 0
+
+    for _ in range(tries):
+        atoms = {n: hash((atoms[n], *(x for x in sorted((atoms[m], b) for m, b in ms.items()) for x in x)))
+                 for n, ms in bonds.items()}
+        old_numb, numb = numb, len(set(atoms.values()))
+        if numb == len(atoms):  # each atom now unique
+            break
+        elif numb == old_numb:  # not changed. molecules like benzene
+            if stab == 3:
+                break
+            stab += 1
+        elif stab:  # changed unique atoms number. reset stability check.
+            stab = 0
+    else:
+        if numb < old_numb:
+            warning('morgan. number of attempts exceeded. uniqueness has decreased.')
+
+    return {n: i for i, (_, g) in enumerate(groupby(sorted(atoms.items(), key=itemgetter(1)), key=itemgetter(1)),
+                                            start=1) for n, _ in g}
+
+
+__all__ = ['Morgan']
```

### Comparing `chython-1.67/chython/algorithms/rings.py` & `chython-1.8/chython/algorithms/rings.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,566 +1,559 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_args_method
-from collections import defaultdict, deque
-from functools import cached_property
-from itertools import combinations
-from operator import itemgetter
-from typing import Any, Dict, List, Optional, Set, Tuple, TYPE_CHECKING, Union
-from ..exceptions import ImplementationError
-
-
-if TYPE_CHECKING:
-    from chython.containers.graph import Graph
-
-
-class Rings:
-    __slots__ = ()
-
-    @cached_property
-    def sssr(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Smallest Set of Smallest Rings. Special bonds ignored.
-
-        Based on idea of PID matrices from:
-        Lee, C. J., Kang, Y.-M., Cho, K.-H., & No, K. T. (2009).
-        A robust method for searching the smallest set of smallest rings with a path-included distance matrix.
-        Proceedings of the National Academy of Sciences of the United States of America, 106(41), 17355–17358.
-        https://doi.org/10.1073/pnas.0813040106
-
-        :return rings atoms numbers
-        """
-        if self.rings_count:
-            return _sssr(self.not_special_connectivity, self.rings_count)
-        return ()
-
-    @cached_property
-    def atoms_rings(self) -> Dict[int, Tuple[Tuple[int, ...]]]:
-        """
-        Dict of atoms rings which contains it.
-        """
-        rings = defaultdict(list)
-        for r in self.sssr:
-            for n in r:
-                rings[n].append(r)
-        return {n: tuple(rs) for n, rs in rings.items()}
-
-    @cached_property
-    def atoms_rings_sizes(self) -> Dict[int, Tuple[int, ...]]:
-        """
-        Sizes of rings containing atom.
-        """
-        return {n: tuple(len(r) for r in rs) for n, rs in self.atoms_rings.items()}
-
-    @cached_args_method
-    def is_ring_bond(self: 'Graph', n: int, m: int, /) -> bool:
-        """
-        Check is bond in any ring.
-        """
-        self.bond(n, m)  # check if bond exists
-        try:
-            return not set(self.atoms_rings[n]).isdisjoint(self.atoms_rings[m])
-        except KeyError:
-            return False
-
-    @cached_property
-    def ring_atoms(self):
-        """
-        Atoms in rings. Not SSSR based fast algorithm.
-        """
-        bonds = _skin_graph(self.not_special_connectivity)
-        if not bonds:
-            return set()
-
-        in_rings = set()
-        atoms = set(bonds)
-        while atoms:
-            stack = deque([(atoms.pop(), 0, 0)])
-            path = []
-            seen = set()
-            while stack:
-                c, p, d = stack.pop()
-                if len(path) > d:
-                    path = path[:d]
-                if c in in_rings:
-                    continue
-                path.append(c)
-                seen.add(c)
-
-                d += 1
-                for n in bonds[c]:
-                    if n == p:
-                        continue
-                    elif n in seen:
-                        in_rings.update(path[path.index(n):])
-                    else:
-                        stack.append((n, c, d))
-
-            atoms.difference_update(seen)
-        return in_rings
-
-    @cached_property
-    def rings_count(self) -> int:
-        """
-        SSSR rings count. Ignored rings with special bonds.
-        """
-        bonds = self.not_special_connectivity
-        return sum(len(x) for x in bonds.values()) // 2 - len(bonds) + len(_connected_components(bonds))
-
-    @cached_property
-    def not_special_connectivity(self: 'Graph') -> Dict[int, Set[int]]:
-        """
-        Graph connectivity without special bonds.
-        """
-        bonds = {}
-        for n, ms in self._bonds.items():
-            bonds[n] = ngb = set()
-            for m, b in ms.items():
-                if b != 8:
-                    ngb.add(m)
-        return bonds
-
-    @cached_property
-    def connected_components(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
-        """
-        Isolated components of single graph. E.g. salts as ion pair.
-        """
-        if not self._atoms:
-            return ()
-        return tuple(tuple(x) for x in self._connected_components)
-
-    @property
-    def connected_components_count(self) -> int:
-        """
-        Number of components in graph
-        """
-        return len(self.connected_components)
-
-    @cached_property
-    def skin_graph(self: 'Graph') -> Dict[int, Set[int]]:
-        """
-        Graph without terminal atoms. Only rings and linkers
-        """
-        return _skin_graph(self._bonds)
-
-    @cached_property
-    def _connected_components(self: 'Graph') -> List[Set[int]]:
-        return _connected_components(self._bonds)
-
-
-def _sssr(bonds: Dict[int, Union[Set[int], Dict[int, Any]]], n_sssr: int) -> Tuple[Tuple[int, ...], ...]:
-    """
-    Smallest Set of Smallest Rings of any adjacency matrix.
-    Number of rings required.
-    """
-    bonds = _skin_graph(bonds)
-    paths = _bfs(bonds)
-    pid1, pid2, dist = _make_pid(paths)
-    return _rings_filter(_c_set(pid1, pid2, dist), n_sssr)
-
-
-def _connected_components(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> List[Set[int]]:
-    atoms = set(bonds)
-    components = []
-    while atoms:
-        start = atoms.pop()
-        seen = {start}
-        queue = deque([start])
-        while queue:
-            current = queue.popleft()
-            for i in bonds[current]:
-                if i not in seen:
-                    queue.append(i)
-                    seen.add(i)
-        components.append(seen)
-        atoms.difference_update(seen)
-    return components
-
-
-def _skin_graph(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> Dict[int, Set[int]]:
-    """
-    Graph without terminal nodes. Only rings and linkers
-    """
-    bonds = {n: set(ms) for n, ms in bonds.items() if ms}
-    while True:  # skip not-cycle chains
-        try:
-            n = next(n for n, ms in bonds.items() if len(ms) <= 1)
-        except StopIteration:
-            break
-        for m in bonds.pop(n):
-            bonds[m].discard(n)
-    return bonds
-
-
-def _bfs(bonds):
-    atoms = set(bonds)
-    terminated = []
-    tail = atoms.pop()
-    next_stack = {x: [tail, x] for x in bonds[tail]}
-
-    while True:
-        next_front = set()
-        found_odd = set()
-        stack, next_stack = next_stack, {}
-        for tail, path in stack.items():
-            neighbors = bonds[tail] & atoms
-            next_front.add(tail)
-
-            if len(neighbors) == 1:
-                n = neighbors.pop()
-                if n in found_odd:
-                    if len(path) != 1:
-                        terminated.append(tuple(path))  # save second ring closure
-                    next_stack[n] = [n]  # maybe we have another path?
-                else:
-                    path.append(n)
-                    if n in stack:  # odd rings
-                        found_odd.add(tail)
-                        terminated.append(tuple(path))  # found ring closure. save path.
-                    elif n in next_stack:  # even rings
-                        terminated.append(tuple(path))
-                        if len(next_stack[n]) != 1:  # prevent bicycle case
-                            terminated.append(tuple(next_stack[n]))
-                            next_stack[n] = [n]
-                    else:
-                        next_stack[n] = path  # grow must go on
-            elif neighbors:
-                if len(path) != 1:
-                    terminated.append(tuple(path))  # save path.
-                for n in neighbors:
-                    if n in found_odd:
-                        if n in stack:
-                            if n in next_stack:
-                                del next_stack[n]
-                        else:
-                            next_stack[n] = [n]
-                    else:
-                        path = [tail, n]
-                        if n in stack:  # odd rings
-                            found_odd.add(tail)
-                            terminated.append(tuple(path))
-                        elif n in next_stack:  # even rings
-                            terminated.append(tuple(path))
-                            if len(next_stack[n]) != 1:  # prevent bicycle case
-                                terminated.append(tuple(next_stack[n]))
-                                next_stack[n] = [n]
-                        else:
-                            next_stack[n] = path
-
-        atoms.difference_update(next_front)
-        if not atoms:
-            break
-        elif not next_stack:
-            tail = atoms.pop()
-            next_stack = {x: [tail, x] for x in bonds[tail] & atoms}
-    return terminated
-
-
-def _make_pid(paths: List[List[int]]):
-    pid1 = defaultdict(lambda: defaultdict(dict))
-    pid2 = defaultdict(lambda: defaultdict(dict))
-    distances = defaultdict(lambda: defaultdict(lambda: 1e9))
-    chains = sorted(paths, key=len)
-    for c in chains:
-        di = len(c) - 1
-        n, m = c[0], c[-1]
-        nn, mm = c[1], c[-2]
-        if n in distances and m in distances[n] and distances[n][m] != di:
-            pid2[n][m][(nn, mm)] = c
-            pid2[m][n][(mm, nn)] = c[::-1]
-        else:
-            pid1[n][m][(nn, mm)] = c
-            pid1[m][n][(mm, nn)] = c[::-1]
-            distances[n][m] = distances[m][n] = di
-
-    for k in pid1:
-        new_distances = defaultdict(dict)
-        dk = distances[k]
-        ndk = new_distances[k]
-        for i in pid1:
-            if i == k:
-                continue
-            di = distances[i]
-            ndi = new_distances[i]
-            ndk[i] = ndi[k] = di[k]
-            for j in pid1:
-                if j == k or j == i:
-                    continue
-                ij = di[j]
-                ikj = di[k] + dk[j]
-                if ij - ikj == 1:  # A new shortest path == previous shortest path - 1
-                    pid2[i][j] = pid1[i][j]
-                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                  zip(pid1[i][k].items(), pid1[k][j].items())}
-                    ndi[j] = ikj
-                elif ij > ikj:  # A new shortest path
-                    pid2[i][j] = {}
-                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                  zip(pid1[i][k].items(), pid1[k][j].items())}
-                    ndi[j] = ikj
-                elif ij == ikj:  # Another shortest path
-                    pid1[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                       zip(pid1[i][k].items(), pid1[k][j].items())})
-                    ndi[j] = ij
-                elif ikj - ij == 1:  # Shortest+1 path
-                    pid2[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
-                                       zip(pid1[i][k].items(), pid1[k][j].items())})
-                    ndi[j] = ij
-                else:
-                    ndi[j] = ij
-        distances = new_distances
-    return pid1, pid2, distances
-
-
-def _c_set(pid1, pid2, pid1l):
-    c_set = []
-    seen = set()
-    for i, p1i in pid1.items():
-        seen.add(i)
-        di = pid1l[i]
-        p2i = pid2[i]
-
-        for j, p1ij in p1i.items():
-            if j in seen:
-                continue
-            p1ij = list(p1ij.values())
-            p2ij = list(p2i[j].values())
-            dij = di[j] * 2
-
-            if len(p1ij) == 1:  # one shortest
-                if not p2ij:  # need shortest + 1 path
-                    continue
-                c_set.append((dij + 1, p1ij, p2ij))
-            elif not p2ij:  # one or more odd rings
-                c_set.append((dij, p1ij, None))
-            else:  # odd and even rings found (e.g. bicycle)
-                c_set.append((dij, p1ij, None))
-                c_set.append((dij + 1, p1ij, p2ij))
-
-    for c_num, p1ij, p2ij in sorted(c_set, key=itemgetter(0)):
-        if c_num % 2:  # odd rings
-            for c1 in p1ij:
-                for c2 in p2ij:
-                    c = c1 + c2[-2:0:-1]
-                    if len(c) == len(set(c)):
-                        yield _canonic_ring(c)
-        else:
-            for c1, c2 in zip(p1ij, p1ij[1:]):
-                c = c1 + c2[-2:0:-1]
-                if len(c) == len(set(c)):
-                    yield _canonic_ring(c)
-
-
-def _canonic_ring(ring: Tuple[int, ...]) -> Tuple[int, ...]:
-    n = min(ring)
-    ndx = ring.index(n)
-    if ndx == 0:
-        if ring[-1] < ring[1]:
-            return n, *ring[:0:-1]
-        return ring
-    elif ndx == len(ring) - 1:
-        if ring[0] > ring[-2]:
-            return ring[::-1]
-        return n, *ring[:-1]
-    if ring[ndx + 1] > ring[ndx - 1]:
-        return *ring[ndx::-1], *ring[:ndx:-1]
-    return *ring[ndx:], *ring[:ndx]
-
-
-def _ring_scissors(ring: Tuple[int, ...], n: int, m: int) -> Tuple[int, ...]:
-    ndx = ring.index(n)
-    mdx = ring.index(m)
-    if ndx == 0:
-        if mdx == 1:
-            return n, *ring[:0:-1]
-        return ring
-    elif ndx == len(ring) - 1:
-        if mdx == 0:
-            return ring[::-1]
-        return n, *ring[:-1]
-    if ndx < mdx:
-        return *ring[ndx::-1], *ring[:ndx:-1]
-    return *ring[ndx:], *ring[:ndx]
-
-
-def _ring_adjacency(ring: Tuple[int, ...]) -> Dict[int, List[int]]:
-    adj = {ring[0]: [ring[-1]]}  # ring adjacency matrix
-    for n, m in zip(ring, ring[1:]):
-        adj[n].append(m)
-        adj[m] = [n]
-    adj[m].append(ring[0])
-    return adj
-
-
-def _is_condensed_ring(c, sssr, seen_rings):
-    # create graph of connected neighbour rings
-    ck = seen_rings[c]
-    neighbors = {x: set() for x in sssr if len(seen_rings[x].keys() & ck.keys()) > 1}
-    if len(neighbors) > 1:
-        for (i, iv), (j, jv) in combinations(neighbors.items(), 2):
-            if len(seen_rings[i].keys() & seen_rings[j].keys()) > 1:
-                iv.add(j)
-                jv.add(i)
-        # check if hold rings is combination of existing. (123654) is combo of (1254) and (2365)
-        #
-        # 1--2--3
-        # |  |  |
-        # 4--5--6
-        #
-        # modified NX.dfs_labeled_edges
-        # https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.\
-        # traversal.depth_first_search.dfs_labeled_edges.html
-        depth_limit = len(neighbors) - 1
-        for start, nbrs in neighbors.items():
-            if not nbrs:
-                continue
-            stack = [(start, seen_rings[start], depth_limit, iter(nbrs), {start})]
-            while stack:
-                parent, p_adj, depth_now, children, seen = stack[-1]
-                try:
-                    child = next(children)
-                except StopIteration:
-                    stack.pop()
-                else:
-                    if child not in seen:
-                        common = p_adj.keys() & seen_rings[child].keys()
-                        if len(common) > 2:  # only terminal common atoms required
-                            term = {n for n in common if len(common.intersection(p_adj[n])) == 1}
-                            if len(term) != 2:  # skip multiple contacts
-                                continue
-                            common.difference_update(term)
-                            n, m = term
-                            mc = _canonic_ring(
-                                    (*_ring_scissors(tuple(x for x in parent if x not in common), n, m),
-                                     *_ring_scissors(tuple(x for x in child if x not in common), m, n)[1:-1]))
-                        elif len(common) == 2:
-                            n, m = common
-                            mc = _canonic_ring((*_ring_scissors(parent, n, m), *_ring_scissors(child, m, n)[1:-1]))
-                        else:  # point connections
-                            continue
-                        if c == mc:  # macrocycle found
-                            return True
-                        elif depth_now and 2 < len(mc) <= len(c) + 1:
-                            stack.append((mc, _ring_adjacency(mc), depth_now - 1, iter(neighbors[child]),
-                                          {child} | seen))
-    return False
-
-
-def _get_unique_chord(ring: Tuple[int, ...], common: Set[int]) -> Optional[Tuple[int, ...]]:
-    lc = len(common)
-    if len(ring) == lc:
-        if common == set(ring):
-            return ()
-    else:
-        if common == set(ring[:lc]):
-            return *ring[lc - 1:], ring[0]
-        for _ in range(len(ring) - 1):
-            ring = (*ring[1:], ring[0])
-            if common == set(ring[:lc]):
-                return *ring[lc - 1:], ring[0]
-
-
-def _connected_rings(rings, seen_rings):
-    rings = rings.copy()
-    out = []
-    for i in range(len(rings)):
-        c = rings[i]
-        ck = seen_rings[c]
-        for j in range(i + 1, len(rings)):
-            r = rings[j]
-            rk = seen_rings[r]
-            common = rk.keys() & ck.keys()
-            if len(common) == 2:  # one common bond
-                n, m = common
-                if m in ck[n] and m in rk[n]:  # only common bond!
-                    c = _canonic_ring((*_ring_scissors(c, n, m), *_ring_scissors(r, m, n)[1:-1]))
-                    ck = _ring_adjacency(c)
-                    rings[j] = c
-                    seen_rings[c] = ck
-                    break
-            elif len(common) > 2:
-                cc = _get_unique_chord(c, common)
-                if cc is None:  # skip multitouched rings
-                    continue
-                r = _get_unique_chord(r, common)
-                if r is None:
-                    continue
-                if cc:
-                    if r:
-                        if r[0] == cc[0]:
-                            r = r[::-1]
-                        c = _canonic_ring((*cc, *r[1:-1]))
-                        ck = _ring_adjacency(c)
-                        rings[j] = c
-                        seen_rings[c] = ck
-                        break
-                    else:
-                        c = _canonic_ring(cc)
-                        ck = _ring_adjacency(c)
-                        rings[j] = c
-                        seen_rings[c] = ck
-                        break
-                elif r:
-                    c = _canonic_ring(r)
-                    ck = _ring_adjacency(c)
-                    rings[j] = c
-                    seen_rings[c] = ck
-                    break
-        else:  # isolated ring[s] found
-            out.append(c)
-    return out
-
-
-def _rings_filter(rings, n_sssr):
-    c = next(rings)
-    if n_sssr == 1:
-        return c,
-
-    seen_rings = {c}
-    sssr_atoms = set(c)
-    sssr = [c]
-    hold = []
-    for c in rings:
-        if c in seen_rings:
-            continue
-        seen_rings.add(c)
-        if sssr_atoms.issuperset(c):  # potentially condensed ring
-            hold.append(c)
-            continue
-        sssr_atoms.update(c)
-        sssr.append(c)
-        if len(sssr) == n_sssr:
-            return tuple(sssr)
-
-    # now we have set of plug rings (cuban fullerene), besiege rings and condensed trash
-    seen_rings = {c: _ring_adjacency(c) for c in seen_rings}  # prepare adjacency
-    condensed_rings = _connected_rings(sssr, seen_rings)  # collection of contours of condensed rings
-
-    for c in hold:
-        if c in condensed_rings or _is_condensed_ring(c, sssr, seen_rings):
-            continue
-        condensed_rings.insert(0, c)
-        condensed_rings = _connected_rings(condensed_rings, seen_rings)
-        sssr.append(c)
-        if len(sssr) == n_sssr:
-            return tuple(sorted(sssr, key=len))
-
-    raise ImplementationError('SSSR count not reached')
-
-
-__all__ = ['Rings']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, deque
+from functools import cached_property
+from itertools import combinations
+from operator import itemgetter
+from typing import Any, Dict, List, Optional, Set, Tuple, TYPE_CHECKING, Union
+from ..exceptions import ImplementationError
+
+
+if TYPE_CHECKING:
+    from chython.containers.graph import Graph
+
+
+class Rings:
+    __slots__ = ()
+
+    @cached_property
+    def sssr(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        Smallest Set of Smallest Rings. Special bonds ignored.
+
+        Based on idea of PID matrices from:
+        Lee, C. J., Kang, Y.-M., Cho, K.-H., & No, K. T. (2009).
+        A robust method for searching the smallest set of smallest rings with a path-included distance matrix.
+        Proceedings of the National Academy of Sciences of the United States of America, 106(41), 17355–17358.
+        https://doi.org/10.1073/pnas.0813040106
+
+        :return rings atoms numbers
+        """
+        if self.rings_count:
+            return _sssr(self.not_special_connectivity, self.rings_count)
+        return ()
+
+    @cached_property
+    def aromatic_rings(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
+        """
+        Aromatic rings atoms numbers
+        """
+        bonds = self._bonds
+        return tuple(ring for ring in self.sssr if bonds[ring[0]][ring[-1]] == 4
+                     and all(bonds[n][m] == 4 for n, m in zip(ring, ring[1:])))
+
+    @cached_property
+    def atoms_rings(self) -> Dict[int, Tuple[Tuple[int, ...]]]:
+        """
+        Dict of atoms rings which contains it.
+        """
+        rings = defaultdict(list)
+        for r in self.sssr:
+            for n in r:
+                rings[n].append(r)
+        return {n: tuple(rs) for n, rs in rings.items()}
+
+    @cached_property
+    def atoms_rings_sizes(self) -> Dict[int, Tuple[int, ...]]:
+        """
+        Sizes of rings containing atom.
+        """
+        return {n: tuple(len(r) for r in rs) for n, rs in self.atoms_rings.items()}
+
+    @cached_property
+    def ring_atoms(self):
+        """
+        Atoms in rings. Not SSSR based fast algorithm.
+        """
+        bonds = _skin_graph(self.not_special_connectivity)
+        if not bonds:
+            return set()
+
+        in_rings = set()
+        atoms = set(bonds)
+        while atoms:
+            stack = deque([(atoms.pop(), 0, 0)])
+            path = []
+            seen = set()
+            while stack:
+                c, p, d = stack.pop()
+                if len(path) > d:
+                    path = path[:d]
+                if c in in_rings:
+                    continue
+                path.append(c)
+                seen.add(c)
+
+                d += 1
+                for n in bonds[c]:
+                    if n == p:
+                        continue
+                    elif n in seen:
+                        in_rings.update(path[path.index(n):])
+                    else:
+                        stack.append((n, c, d))
+
+            atoms.difference_update(seen)
+        return in_rings
+
+    @cached_property
+    def rings_count(self) -> int:
+        """
+        SSSR rings count. Ignored rings with special bonds.
+        """
+        bonds = self.not_special_connectivity
+        return sum(len(x) for x in bonds.values()) // 2 - len(bonds) + len(_connected_components(bonds))
+
+    @cached_property
+    def not_special_connectivity(self: 'Graph') -> Dict[int, Set[int]]:
+        """
+        Graph connectivity without special bonds.
+        """
+        bonds = {}
+        for n, ms in self._bonds.items():
+            bonds[n] = ngb = set()
+            for m, b in ms.items():
+                if b != 8:
+                    ngb.add(m)
+        return bonds
+
+    @cached_property
+    def connected_components(self: 'Graph') -> Tuple[Tuple[int, ...], ...]:
+        """
+        Isolated components of single graph. E.g. salts as ion pair.
+        """
+        if not self._atoms:
+            return ()
+        return tuple(tuple(x) for x in _connected_components(self._bonds))
+
+    @property
+    def connected_components_count(self) -> int:
+        """
+        Number of components in graph
+        """
+        return len(self.connected_components)
+
+    @cached_property
+    def skin_graph(self: 'Graph') -> Dict[int, Set[int]]:
+        """
+        Graph without terminal atoms. Only rings and linkers
+        """
+        return _skin_graph(self._bonds)
+
+
+def _sssr(bonds: Dict[int, Union[Set[int], Dict[int, Any]]], n_sssr: int) -> Tuple[Tuple[int, ...], ...]:
+    """
+    Smallest Set of Smallest Rings of any adjacency matrix.
+    Number of rings required.
+    """
+    bonds = _skin_graph(bonds)
+    paths = _bfs(bonds)
+    pid1, pid2, dist = _make_pid(paths)
+    return _rings_filter(_c_set(pid1, pid2, dist), n_sssr)
+
+
+def _connected_components(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> List[Set[int]]:
+    atoms = set(bonds)
+    components = []
+    while atoms:
+        start = atoms.pop()
+        seen = {start}
+        queue = deque([start])
+        while queue:
+            current = queue.popleft()
+            for i in bonds[current]:
+                if i not in seen:
+                    queue.append(i)
+                    seen.add(i)
+        components.append(seen)
+        atoms.difference_update(seen)
+    return components
+
+
+def _skin_graph(bonds: Dict[int, Union[Set[int], Dict[int, Any]]]) -> Dict[int, Set[int]]:
+    """
+    Graph without terminal nodes. Only rings and linkers
+    """
+    bonds = {n: set(ms) for n, ms in bonds.items() if ms}
+    while True:  # skip not-cycle chains
+        try:
+            n = next(n for n, ms in bonds.items() if len(ms) <= 1)
+        except StopIteration:
+            break
+        for m in bonds.pop(n):
+            bonds[m].discard(n)
+    return bonds
+
+
+def _bfs(bonds):
+    atoms = set(bonds)
+    terminated = []
+    tail = atoms.pop()
+    next_stack = {x: [tail, x] for x in bonds[tail]}
+
+    while True:
+        next_front = set()
+        found_odd = set()
+        stack, next_stack = next_stack, {}
+        for tail, path in stack.items():
+            neighbors = bonds[tail] & atoms
+            next_front.add(tail)
+
+            if len(neighbors) == 1:
+                n = neighbors.pop()
+                if n in found_odd:
+                    if len(path) != 1:
+                        terminated.append(tuple(path))  # save second ring closure
+                    next_stack[n] = [n]  # maybe we have another path?
+                else:
+                    path.append(n)
+                    if n in stack:  # odd rings
+                        found_odd.add(tail)
+                        terminated.append(tuple(path))  # found ring closure. save path.
+                    elif n in next_stack:  # even rings
+                        terminated.append(tuple(path))
+                        if len(next_stack[n]) != 1:  # prevent bicycle case
+                            terminated.append(tuple(next_stack[n]))
+                            next_stack[n] = [n]
+                    else:
+                        next_stack[n] = path  # grow must go on
+            elif neighbors:
+                if len(path) != 1:
+                    terminated.append(tuple(path))  # save path.
+                for n in neighbors:
+                    if n in found_odd:
+                        if n in stack:
+                            if n in next_stack:
+                                del next_stack[n]
+                        else:
+                            next_stack[n] = [n]
+                    else:
+                        path = [tail, n]
+                        if n in stack:  # odd rings
+                            found_odd.add(tail)
+                            terminated.append(tuple(path))
+                        elif n in next_stack:  # even rings
+                            terminated.append(tuple(path))
+                            if len(next_stack[n]) != 1:  # prevent bicycle case
+                                terminated.append(tuple(next_stack[n]))
+                                next_stack[n] = [n]
+                        else:
+                            next_stack[n] = path
+
+        atoms.difference_update(next_front)
+        if not atoms:
+            break
+        elif not next_stack:
+            tail = atoms.pop()
+            next_stack = {x: [tail, x] for x in bonds[tail] & atoms}
+    return terminated
+
+
+def _make_pid(paths: List[List[int]]):
+    pid1 = defaultdict(lambda: defaultdict(dict))
+    pid2 = defaultdict(lambda: defaultdict(dict))
+    distances = defaultdict(lambda: defaultdict(lambda: 1e9))
+    chains = sorted(paths, key=len)
+    for c in chains:
+        di = len(c) - 1
+        n, m = c[0], c[-1]
+        nn, mm = c[1], c[-2]
+        if n in distances and m in distances[n] and distances[n][m] != di:
+            pid2[n][m][(nn, mm)] = c
+            pid2[m][n][(mm, nn)] = c[::-1]
+        else:
+            pid1[n][m][(nn, mm)] = c
+            pid1[m][n][(mm, nn)] = c[::-1]
+            distances[n][m] = distances[m][n] = di
+
+    for k in pid1:
+        new_distances = defaultdict(dict)
+        dk = distances[k]
+        ndk = new_distances[k]
+        for i in pid1:
+            if i == k:
+                continue
+            di = distances[i]
+            ndi = new_distances[i]
+            ndk[i] = ndi[k] = di[k]
+            for j in pid1:
+                if j == k or j == i:
+                    continue
+                ij = di[j]
+                ikj = di[k] + dk[j]
+                if ij - ikj == 1:  # A new shortest path == previous shortest path - 1
+                    pid2[i][j] = pid1[i][j]
+                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                  zip(pid1[i][k].items(), pid1[k][j].items())}
+                    ndi[j] = ikj
+                elif ij > ikj:  # A new shortest path
+                    pid2[i][j] = {}
+                    pid1[i][j] = {(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                  zip(pid1[i][k].items(), pid1[k][j].items())}
+                    ndi[j] = ikj
+                elif ij == ikj:  # Another shortest path
+                    pid1[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                       zip(pid1[i][k].items(), pid1[k][j].items())})
+                    ndi[j] = ij
+                elif ikj - ij == 1:  # Shortest+1 path
+                    pid2[i][j].update({(ni, mj): ip[:-1] + jp for ((ni, _), ip), ((_, mj), jp) in
+                                       zip(pid1[i][k].items(), pid1[k][j].items())})
+                    ndi[j] = ij
+                else:
+                    ndi[j] = ij
+        distances = new_distances
+    return pid1, pid2, distances
+
+
+def _c_set(pid1, pid2, pid1l):
+    c_set = []
+    seen = set()
+    for i, p1i in pid1.items():
+        seen.add(i)
+        di = pid1l[i]
+        p2i = pid2[i]
+
+        for j, p1ij in p1i.items():
+            if j in seen:
+                continue
+            p1ij = list(p1ij.values())
+            p2ij = list(p2i[j].values())
+            dij = di[j] * 2
+
+            if len(p1ij) == 1:  # one shortest
+                if not p2ij:  # need shortest + 1 path
+                    continue
+                c_set.append((dij + 1, p1ij, p2ij))
+            elif not p2ij:  # one or more odd rings
+                c_set.append((dij, p1ij, None))
+            else:  # odd and even rings found (e.g. bicycle)
+                c_set.append((dij, p1ij, None))
+                c_set.append((dij + 1, p1ij, p2ij))
+
+    for c_num, p1ij, p2ij in sorted(c_set, key=itemgetter(0)):
+        if c_num % 2:  # odd rings
+            for c1 in p1ij:
+                for c2 in p2ij:
+                    c = c1 + c2[-2:0:-1]
+                    if len(c) == len(set(c)):
+                        yield _canonic_ring(c)
+        else:
+            for c1, c2 in zip(p1ij, p1ij[1:]):
+                c = c1 + c2[-2:0:-1]
+                if len(c) == len(set(c)):
+                    yield _canonic_ring(c)
+
+
+def _canonic_ring(ring: Tuple[int, ...]) -> Tuple[int, ...]:
+    n = min(ring)
+    ndx = ring.index(n)
+    if ndx == 0:
+        if ring[-1] < ring[1]:
+            return n, *ring[:0:-1]
+        return ring
+    elif ndx == len(ring) - 1:
+        if ring[0] > ring[-2]:
+            return ring[::-1]
+        return n, *ring[:-1]
+    if ring[ndx + 1] > ring[ndx - 1]:
+        return *ring[ndx::-1], *ring[:ndx:-1]
+    return *ring[ndx:], *ring[:ndx]
+
+
+def _ring_scissors(ring: Tuple[int, ...], n: int, m: int) -> Tuple[int, ...]:
+    ndx = ring.index(n)
+    mdx = ring.index(m)
+    if ndx == 0:
+        if mdx == 1:
+            return n, *ring[:0:-1]
+        return ring
+    elif ndx == len(ring) - 1:
+        if mdx == 0:
+            return ring[::-1]
+        return n, *ring[:-1]
+    if ndx < mdx:
+        return *ring[ndx::-1], *ring[:ndx:-1]
+    return *ring[ndx:], *ring[:ndx]
+
+
+def _ring_adjacency(ring: Tuple[int, ...]) -> Dict[int, List[int]]:
+    adj = {ring[0]: [ring[-1]]}  # ring adjacency matrix
+    for n, m in zip(ring, ring[1:]):
+        adj[n].append(m)
+        adj[m] = [n]
+    adj[m].append(ring[0])
+    return adj
+
+
+def _is_condensed_ring(c, sssr, seen_rings):
+    # create graph of connected neighbour rings
+    ck = seen_rings[c]
+    neighbors = {x: set() for x in sssr if len(seen_rings[x].keys() & ck.keys()) > 1}
+    if len(neighbors) > 1:
+        for (i, iv), (j, jv) in combinations(neighbors.items(), 2):
+            if len(seen_rings[i].keys() & seen_rings[j].keys()) > 1:
+                iv.add(j)
+                jv.add(i)
+        # check if hold rings is combination of existing. (123654) is combo of (1254) and (2365)
+        #
+        # 1--2--3
+        # |  |  |
+        # 4--5--6
+        #
+        # modified NX.dfs_labeled_edges
+        # https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.\
+        # traversal.depth_first_search.dfs_labeled_edges.html
+        depth_limit = len(neighbors) - 1
+        for start, nbrs in neighbors.items():
+            if not nbrs:
+                continue
+            stack = [(start, seen_rings[start], depth_limit, iter(nbrs), {start})]
+            while stack:
+                parent, p_adj, depth_now, children, seen = stack[-1]
+                try:
+                    child = next(children)
+                except StopIteration:
+                    stack.pop()
+                else:
+                    if child not in seen:
+                        common = p_adj.keys() & seen_rings[child].keys()
+                        if len(common) > 2:  # only terminal common atoms required
+                            term = {n for n in common if len(common.intersection(p_adj[n])) == 1}
+                            if len(term) != 2:  # skip multiple contacts
+                                continue
+                            common.difference_update(term)
+                            n, m = term
+                            mc = _canonic_ring(
+                                    (*_ring_scissors(tuple(x for x in parent if x not in common), n, m),
+                                     *_ring_scissors(tuple(x for x in child if x not in common), m, n)[1:-1]))
+                        elif len(common) == 2:
+                            n, m = common
+                            mc = _canonic_ring((*_ring_scissors(parent, n, m), *_ring_scissors(child, m, n)[1:-1]))
+                        else:  # point connections
+                            continue
+                        if c == mc:  # macrocycle found
+                            return True
+                        elif depth_now and 2 < len(mc) <= len(c) + 1:
+                            stack.append((mc, _ring_adjacency(mc), depth_now - 1, iter(neighbors[child]),
+                                          {child} | seen))
+    return False
+
+
+def _get_unique_chord(ring: Tuple[int, ...], common: Set[int]) -> Optional[Tuple[int, ...]]:
+    lc = len(common)
+    if len(ring) == lc:
+        if common == set(ring):
+            return ()
+    else:
+        if common == set(ring[:lc]):
+            return *ring[lc - 1:], ring[0]
+        for _ in range(len(ring) - 1):
+            ring = (*ring[1:], ring[0])
+            if common == set(ring[:lc]):
+                return *ring[lc - 1:], ring[0]
+
+
+def _connected_rings(rings, seen_rings):
+    rings = rings.copy()
+    out = []
+    for i in range(len(rings)):
+        c = rings[i]
+        ck = seen_rings[c]
+        for j in range(i + 1, len(rings)):
+            r = rings[j]
+            rk = seen_rings[r]
+            common = rk.keys() & ck.keys()
+            if len(common) == 2:  # one common bond
+                n, m = common
+                if m in ck[n] and m in rk[n]:  # only common bond!
+                    c = _canonic_ring((*_ring_scissors(c, n, m), *_ring_scissors(r, m, n)[1:-1]))
+                    ck = _ring_adjacency(c)
+                    rings[j] = c
+                    seen_rings[c] = ck
+                    break
+            elif len(common) > 2:
+                cc = _get_unique_chord(c, common)
+                if cc is None:  # skip multitouched rings
+                    continue
+                r = _get_unique_chord(r, common)
+                if r is None:
+                    continue
+                if cc:
+                    if r:
+                        if r[0] == cc[0]:
+                            r = r[::-1]
+                        c = _canonic_ring((*cc, *r[1:-1]))
+                        ck = _ring_adjacency(c)
+                        rings[j] = c
+                        seen_rings[c] = ck
+                        break
+                    else:
+                        c = _canonic_ring(cc)
+                        ck = _ring_adjacency(c)
+                        rings[j] = c
+                        seen_rings[c] = ck
+                        break
+                elif r:
+                    c = _canonic_ring(r)
+                    ck = _ring_adjacency(c)
+                    rings[j] = c
+                    seen_rings[c] = ck
+                    break
+        else:  # isolated ring[s] found
+            out.append(c)
+    return out
+
+
+def _rings_filter(rings, n_sssr):
+    c = next(rings)
+    if n_sssr == 1:
+        return c,
+
+    seen_rings = {c}
+    sssr_atoms = set(c)
+    sssr = [c]
+    hold = []
+    for c in rings:
+        if c in seen_rings:
+            continue
+        seen_rings.add(c)
+        if sssr_atoms.issuperset(c):  # potentially condensed ring
+            hold.append(c)
+            continue
+        sssr_atoms.update(c)
+        sssr.append(c)
+        if len(sssr) == n_sssr:
+            return tuple(sssr)
+
+    # now we have set of plug rings (cuban fullerene), besiege rings and condensed trash
+    seen_rings = {c: _ring_adjacency(c) for c in seen_rings}  # prepare adjacency
+    condensed_rings = _connected_rings(sssr, seen_rings)  # collection of contours of condensed rings
+
+    for c in hold:
+        if c in condensed_rings or _is_condensed_ring(c, sssr, seen_rings):
+            continue
+        condensed_rings.insert(0, c)
+        condensed_rings = _connected_rings(condensed_rings, seen_rings)
+        sssr.append(c)
+        if len(sssr) == n_sssr:
+            return tuple(sorted(sssr, key=len))
+
+    raise ImplementationError('SSSR count not reached')
+
+
+__all__ = ['Rings']
```

### Comparing `chython-1.67/chython/algorithms/standardize/__init__.py` & `chython-1.8/chython/files/test/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,30 +1,18 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .molecule import *
-from .reaction import *
-from .resonance import *
-from .salts import *
-from .saturation import *
-
-
-class StandardizeMolecule(Standardize, Resonance, Saturation, Salts):
-    __slots__ = ()
-
-
-__all__ = ['StandardizeMolecule', 'StandardizeReaction']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
```

### Comparing `chython-1.67/chython/algorithms/standardize/_groups.py` & `chython-1.8/chython/algorithms/standardize/_groups.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,1049 +1,916 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from lazy_object_proxy import Proxy
-from ...periodictable import ListElement
-
-
-def _rules_single():
-    """
-    rules without overlapping. these rules can match once to same set of atoms.
-    """
-    from ... import smarts
-    from ...containers import QueryContainer
-
-    rules = []
-    raw_rules = []
-
-    #
-    #  [A*] - [A*] >> A = A or [A*] = [A*] >> A # A
-    #
-    # atoms = ({'atom': 'A', 'is_radical': True}, {'atom': 'A', 'is_radical': True})
-    # bonds = ((1, 2, 1),)
-    # atom_fix = {1: (0, False), 2: (0, False)}
-    # bonds_fix = ((1, 2, 2),)
-    # raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-    # bonds = ((1, 2, 2),)
-    # bonds_fix = ((1, 2, 3),)
-    # raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A         A
-    #     |         |
-    #     P    >>  [P+]
-    #   / | \     / | \
-    #  A  A  A   A  A  A
-    #
-    q = smarts('[P;D4;x0;z1]')
-    atom_fix = {1: (1, None)}
-    bonds_fix = ()
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    # A   H   A     A     H   A
-    #  \ / \ /       \  .. \ /
-    #   B   B    >>   B     B
-    #  / \ / \       / \  .. \
-    # A   H   A     A   H     A
-    #
-    q = smarts('[B;z1:1]1[H;D2:3][B;z1:2][H;D2:4]1')
-    atom_fix = {}
-    bonds_fix = ((1, 3, 8), (2, 4, 8))
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    # OGB DS
-    #
-    # O*  A  [O-]  A
-    #  \ /     \  /
-    #   N  >>  [N+]
-    #   |       ||
-    #  C,N*     C,N
-    #
-    q = smarts('[O;D1;z1][N;D3;z1][C,N;z1] |^1:0,2|')
-    atom_fix = {1: (-1, False), 2: (1, None), 3: (0, False)}
-    bonds_fix = ((2, 3, 2),)
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    #       |            |
-    # O* -- S -- O* >> O=S=O
-    #       |            |
-    #
-    q = smarts('[O,S;D1;z1][S;D4;z1][O;D1;z1] |^1:0,2|')
-    atom_fix = {1: (0, False), 3: (0, False)}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    rules.append((q, atom_fix, bonds_fix, False))
-
-    #
-    #      A         A
-    #     //        //
-    # B - N >> B .. N
-    #     \          \
-    #      A          A
-    #
-    atoms = ({'atom': 'B'}, {'atom': 'N', 'neighbors': 3, 'hybridization': 2})
-    bonds = ((1, 2, 1),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A             A
-    #     |             |
-    # B = N - A >> B .. N - A
-    #     |             |
-    #     A             A
-    #
-    atoms = ({'atom': 'B', 'hybridization': (1, 2)}, {'atom': 'N', 'neighbors': 4, 'hybridization': (1, 2)})
-    bonds = ((1, 2, (1, 2)),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # R2S - B >> R2S .. B
-    #
-    atoms = ({'atom': 'B', 'hybridization': 1}, {'atom': ListElement(['O', 'S']), 'hybridization': 1, 'neighbors': 3})
-    bonds = ((1, 2, 1),)
-    atom_fix = {}
-    bonds_fix = ((1, 2, 8),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [B-] = [N+] >>  B - N
-    #
-    atoms = ({'atom': 'B', 'charge': -1, 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 2})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #        [A-]                 A
-    #         |                   |
-    # [A-] - [B+3] - [A-] >> A - [B-] - A
-    #         |                   |
-    #        [A-]                 A
-    #
-    atoms = ({'atom': 'B', 'charge': 3, 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1},
-             {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
-    atom_fix = {1: (-4, None), 2: (1, None), 3: (1, None), 4: (1, None), 5: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #        A             A
-    #        |             |
-    # [A-] - B - A >> A - [B-] - A
-    #        |             |
-    #        A             A
-    #
-    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1}, {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      A             A
-    #      |             |
-    # A -  B - A >> A - [B-] - A
-    #      |             |
-    #      A             A
-    #
-    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A         A
-    #     |         |
-    #     N    >>  [N+]
-    #   / | \     / | \
-    #  A  A  A   A  A  A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #  aci-nitro
-    #      O          O
-    #     //         //
-    # C = N  >> C - [N+]
-    #      \         \
-    #       OH       [O-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 4, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #            O               [O-]
-    #           //               /
-    # [C,N,O] = N  >> [C,N,O] = [N+]
-    #           \                \
-    #            A                A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['C', 'N', 'O'])},
-             {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix aci-nitro
-    #       [O-]          [O-]
-    #       /             /
-    # C = [N+ ] >>  C - [N+]
-    #      \             \\
-    #       OH            O
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 3, 2), (1, 4, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    # fix CN(=O)=N(=O)C
-    #
-    # [N+] = N = O >> [N+] = [N+] - O-
-    #        |                |
-    #        A                A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Fix CN(=O)=N(=N)C
-    # [N+] = N = N - ? >> [N+] = [N+] - [N-] - ?
-    #        |                    |
-    #        A                    A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # For N-case not unique!
-    #          N             [N-]
-    #         //             /
-    # [C,N] = N  >> [C,N] = [N+]
-    #         \              \
-    #          A              A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': ListElement(['C', 'N'])}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] - [N+] = O >> N = [N+] - [O-]
-    #         |               |
-    #         A               A
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'charge': -1, 'hybridization': 1, 'neighbors': (1, 2)})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #         O              [O-]
-    #        //              /
-    # [A-] - N   >> [A-] - [N+]
-    #        \\             \\
-    #         O              O
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A', 'charge': -1})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # O : N : O      O = [N+] - [O-]
-    #     |      >>       |
-    #     A               A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 4), (1, 3, 4), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Nitrite
-    #
-    #   O        [O-]
-    #  //        /
-    # [N-]  >>  N
-    #  \\       \\
-    #   O        O
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'charge': -1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [O,C,N] = N # N >> [O,C,N] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': ListElement(['O', 'C', 'N'])})
-    bonds = ((1, 2, 3), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [C,N,O-] - [N+] # N  >> [C,N,O] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1},
-             {'atom': ListElement(['N', 'C', 'O']), 'charge': -1, 'hybridization': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  A - [N+] # N = [N-]  >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'N', 'charge': -1, 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 3), (1, 3, 2), (2, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - N = N = N >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 2},
-             {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 2))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - NH - N # N >> A - N = [N+] = [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 3))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] # N = N - A >> [N-] == [N+] == N - A
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1},
-             {'atom': 'N', 'hybridization': 2, 'neighbors': 2})
-    bonds = ((1, 2, 3), (1, 3, 2))
-    atom_fix = {1: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [N-] == N # N >> [N-] == [N+] == [N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 3))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 3, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - C # N = NH >> A - [CH] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'C', 'neighbors': (1, 2)}, {'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 3), (2, 3, 2))
-    atom_fix = {2: (1, None), 3: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # note: order dependent
-    # A - C # N = [O,N] >> A - C # [N+] - [O,N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 2), (1, 3, 3))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [NH2,OH,SH] - N # C - A >> [NH,O,S-] - [N+] # C - A
-    #
-    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # A - [NH] - N # C >> A - [N-] - [N+] # C
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # [NH2,OH,SH] - [N+] # [C-] >> [NH,O,S-] - [N+] # [CH]
-    #
-    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'C', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 3: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # A - [NH] - [N+] # [C-] >> A - [N-] - [N+] # [CH]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
-             {'atom': 'C', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {1: (-1, None), 3: (1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # A - N # C >> A - [N+] # [C-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'C', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix old diazo rule
-    #
-    # A - [C-] = [N+] = [NH] >> A - [CH] = [N+] = [N-]
-    #
-    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
-    bonds = ((1, 2, 2), (2, 3, 2))
-    atom_fix = {1: (1, None), 3: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    |           |
-    #  - N -   >> - [N+] -
-    #    \\          |
-    #    [O,N]      [O,N-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # N-oxide radical
-    #
-    #    |         |
-    #  - N*  >>  - N
-    #    \\        |
-    #     O        O*
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (0, False), 2: (0, True)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # false N-oxide radical
-    #
-    #    |        |
-    #  = N  >> = [N+]
-    #     \        \
-    #      O*       [O-]
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1, 'is_radical': True})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, False), 2: (-1, False)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # C           C
-    #  \           \
-    #   N # N >>   [N+] = [N-]
-    #  /           /
-    # C           C
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': 1}, {'atom': 'C'}, {'atom': 'C'})
-    bonds = ((1, 2, 3), (1, 3, 1), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  C - N = [N+]  >>  C - [N+] # N
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 1}, {'atom': 'C'})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [N+] - [C-] = O  >>  N = C = O
-    #
-    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': 2},
-             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  N # C - OH  >>  HN = C = O
-    #
-    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #  N # C - [O-]  >>  [N-] = C = O
-    #
-    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 3), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    # - [N+] - [O-]  >>  - N = O
-    #
-    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     [O+]R         [O]R
-    #     //            /
-    # N - C  >> [N+] = C
-    #
-    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': 'O', 'neighbors': 2, 'hybridization': 2, 'charge': 1},
-             {'atom': 'N', 'hybridization': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      [O,S]H    [O,S]
-    #      /         //
-    # N = C  >> NH - C
-    #
-    q = smarts('[N;z2]=[C;D2,D3;z2]-[O,S;D1]')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (2, 3, 2))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    #
-    # fix pyridin-2-one. note: only after amide rule
-    #
-    q = smarts('[O,S;D1;z2;x0]=[C;D3;r6]1[N;D2;z1][A;z2]=[A;z2][A;z2]=[A;z2]1')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (2, 3, 2))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    # todo:
-    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5]=,:[C:6][C:7](=[O:1])[C:8]=,:[C:9]1
-    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5](=[O:1])[C:6]=,:[C:7]-,:[C:8]=,:[C:9]1
-
-    #
-    #       OH          O
-    #      /           //
-    # C = C    >> C - C
-    #      \           \
-    #      [O,N]       [O,N]
-    #
-    q = smarts('[O;D1;x0;z1]-[C;D3;z2;x2](-[O,N])=C')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (2, 4, 1))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    #
-    # fix pyridin. note: don't move.
-    #
-    q = smarts('[O;D1;z2;x0]=[C;D3;r6]1[N;D2;z2]=[A;z2][A;z2]-,=[A;z2][C;D2,D3;z1]1')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (2, 7, 2))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    #
-    #       A                   A
-    #       |                   |
-    #  A - [P+] - [O-]  >>  A - P = O
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'P', 'charge': 1, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       A                   A
-    #       |                   |
-    #  A - [P-] - [C+]  >>  A - P = C
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #   F   F         F   F
-    #    \ /           \ /
-    # F - P - F >> F - [P-] - F
-    #    / \           / \
-    #   F   F         F   F
-    #
-    atoms = ({'atom': 'P', 'neighbors': 6}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
-             {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
-             {'atom': 'F', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (1, 6, 1), (1, 7, 1))
-    atom_fix = {1: (-1, None)}
-    bonds_fix = ()
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O               O
-    #     \\              \\
-    # A - [P-] - A  >> A - P - A
-    #     //              /
-    #     O              [O-]
-    #
-    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1), (1, 5, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O           [O-]
-    #     \\            \
-    # A -  P - A  >> A - P - A
-    #     /             //
-    #   [S-]            S
-    #
-    atoms = ({'atom': 'P', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O'},
-             {'atom': 'S', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O           [OH]
-    #     \\            \
-    # A -  P - A  >> A - P - A
-    #     /             //
-    #   [SH]            S
-    #
-    atoms = ({'atom': 'P', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O'},
-             {'atom': 'S', 'neighbors': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #     A                A
-    #     \\               \\
-    # A -  S - [S-]  >> A - S - [O-]
-    #     //               //
-    #     O                S
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O'}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
-             {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 2), (1, 5, 1))
-    atom_fix = {2: (-1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     A                A
-    #     \\               \
-    # A -  S - [SH]  >> A - S - [OH]
-    #     //               //
-    #     O                S
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O'}, {'atom': 'S', 'neighbors': 1}, {'atom': 'A'}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 2), (1, 5, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 1), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    #           A                   A
-    #          /                   /
-    # [O-] - [S,Si,Se+]  >>  O = [S,Si,Se]
-    #          \                   \
-    #           A                   A
-    #
-    atoms = ({'atom': ListElement(['S', 'Se', 'Si']), 'charge': 1, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       A?                  A?
-    #       |                   |
-    #  A = [S+] - [O-]  >>  A = S = O
-    #       |                   |
-    #       A?                  A?
-    #
-    atoms = ({'atom': 'S', 'charge': 1, 'neighbors': (2, 4), 'hybridization': 2},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #       [O-]          O
-    #       /            //
-    # A = [S+2]  >>  A = S
-    #       \            \\
-    #       [O-]          O
-    #
-    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 3, 'hybridization': 2},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #          A                  A
-    #          |                  |
-    # [O-] - [S+2] - [O-] >>  O = S = O
-    #          |                  |
-    #          A                  A
-    #
-    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  A - [S-] - [C+]  >>  A - S = C
-    #       |                   |
-    #       A                   A
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  O              O
-    #  \\             \\
-    #  [S-] - A  >>    S - A
-    #  //             /
-    #  O            [O-]
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #     O             [O-]
-    #     \\             \
-    # A - [S-] = O >> A - S = O
-    #     //             //
-    #     O              O
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
-    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 2), (1, 5, 1))
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  O              [O-]
-    #  \\              \
-    #  [S-] - [S-] >>   S = S
-    #  //              /
-    #  O              [O-]
-    #
-    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
-    atom_fix = {1: (1, None), 2: (1, None), 3: (-1, None), 4: (-1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 1), (1, 4, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    A            A
-    #    \            \
-    # A - S = O >> A - S = O
-    #    /            //
-    #  [OH]           O
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #    A            A
-    #    \            \
-    # A - S = O >> A - S = O
-    #    /            //
-    #  [NH]           N
-    #
-    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 1})
-    bonds = ((1, 2, 2), (1, 3, 1))
-    atom_fix = {}
-    bonds_fix = ((1, 3, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #      A{1,3}               A{1,3}
-    #      |                    |
-    #  N = S - [OH]  >>  [NH] - S = O
-    #
-    atoms = ({'atom': 'S', 'neighbors': (3, 5), 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
-             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2})
-    bonds = ((1, 2, 1), (1, 3, 2))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 1))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # C # C - [O,NH,S]H  >> C=C=[O,NH,S]
-    #
-    atoms = ({'atom': ListElement(['O', 'S', 'N']), 'neighbors': 1}, {'atom': 'C', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    #
-    # C # C - [NH]R  >> C=C=NR
-    #
-    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'C', 'neighbors': 2},
-             {'atom': 'C', 'neighbors': (1, 2)})
-    bonds = ((1, 2, 1), (2, 3, 3))
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (2, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, True))
-
-    # Carbon Monoxide
-    #
-    # [CX1] = O  >> [С-] # [O+]
-    #
-    atoms = ({'atom': 'C', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (-1, False), 2: (1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Ozone
-    #
-    # [O*] -- O -- [O*]  >>  O == [O+] -- [O-]
-    #
-    atoms = ({'atom': 'O', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 2},
-             {'atom': 'O', 'neighbors': 1, 'is_radical': True})
-    bonds = ((1, 2, 1), (2, 3, 1))
-    atom_fix = {1: (0, False), 2: (1, None), 3: (-1, False)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # only after [A-] - [C+] rules!
-    #  [C+] - N(R2)  >> C = [N+](R2)
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1, 'heteroatoms': 0},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # low priority for hetero-N
-    #  [C+] - N(X2)  >> C = [N+](X2)
-    #
-    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    #
-    #  [C+] = N(R)  >>  C # [N+](R)
-    #
-    atoms = ({'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
-             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 2, 'heteroatoms': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 3),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # Br-ion + I-ion
-    #
-    #        A           A
-    #        |           |
-    # [Br-].[I+] >> Br - I
-    #        |           |
-    #        A           A
-    #
-    atoms = ({'atom': 'Br', 'charge': -1, 'neighbors': 0},
-             {'atom': 'I', 'charge': 1, 'neighbors': 2, 'hybridization': 1},)
-    bonds = ()
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # [Cl,Br,I+] - [O-] >> X = O
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 1, 'neighbors': 2, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1),)
-    atom_fix = {1: (-1, None), 2: (1, None)}
-    bonds_fix = ((1, 2, 2),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # A-[Hal+2]([O-])2
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 2, 'neighbors': 3, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1))
-    atom_fix = {1: (-3, None), 2: (1, None), 3: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix rdkit
-    # A-[Hal+3]([O-])3
-    #
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': 3, 'neighbors': 4, 'hybridization': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'charge': -1, 'neighbors': 1})
-    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1))
-    atom_fix = {1: (-3, None), 2: (1, None), 3: (1, None), 4: (1, None)}
-    bonds_fix = ((1, 2, 2), (1, 3, 2), (1, 4, 2))
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    # fix reaxys [Cl-]=O > Cl-[O-]
-    atoms = ({'atom': ListElement(['Cl', 'Br', 'I']), 'charge': -1, 'neighbors': 1},
-             {'atom': 'O', 'neighbors': 1})
-    bonds = ((1, 2, 2),)
-    atom_fix = {1: (1, None), 2: (-1, None)}
-    bonds_fix = ((1, 2, 1),)
-    raw_rules.append((atoms, bonds, atom_fix, bonds_fix, False))
-
-    compiled_rules = []
-    for atoms, bonds, atom_fix, bonds_fix, is_tautomer in raw_rules:
-        q = QueryContainer()
-        for a in atoms:
-            q.add_atom(**a)
-        for n, m, b in bonds:
-            q.add_bond(n, m, b)
-
-        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
-        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms, is_tautomer))
-
-    return [(q, atom_fix, bonds_fix,
-             [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix], is_tautomer)
-            for q, atom_fix, bonds_fix, is_tautomer in rules] + compiled_rules  # todo: remove compiled
-
-
-def _rules_double():
-    from ... import smarts
-
-    rules = []
-
-    #
-    #     [OH]                O
-    #      |                 //
-    #  N = S = A  >>  [NH] - S = A
-    #      |                 |
-    #      A                 A
-    #
-    q = smarts('[S;D4;z3:1]([O;D1:2])(=[N;D1,D2;z2:3])(=[A])[A]')
-    atom_fix = {}
-    bonds_fix = ((1, 2, 2), (1, 3, 1))
-    rules.append((q, atom_fix, bonds_fix, True))
-
-    return [(q, atom_fix, bonds_fix,
-             [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix], is_tautomer)
-            for q, atom_fix, bonds_fix, is_tautomer in rules]
-
-
-single_rules = Proxy(_rules_single)
-double_rules = Proxy(_rules_double)
-
-
-__all__ = ['single_rules', 'double_rules']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from lazy_object_proxy import Proxy
+from ...periodictable import ListElement
+
+
+def _rules_single():
+    """
+    rules without overlapping. these rules can match once to same set of atoms.
+    """
+    from ...containers import QueryContainer
+
+    raw_rules = []
+
+    #
+    #  [A*] - [A*] >> A = A or [A*] = [A*] >> A # A
+    #
+    atoms = ({'atom': 'A', 'is_radical': True}, {'atom': 'A', 'is_radical': True})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (0, False), 2: (0, False)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+    bonds = ((1, 2, 2),)
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A   H   A     A     H   A
+    #  \ / \ /       \  .. \ /
+    #   B   B    >>   B     B
+    #  / \ / \       / \  .. \
+    # A   H   A     A   H     A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1}, {'atom': 'B', 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'H', 'neighbors': 2}, {'atom': 'H', 'neighbors': 2})
+    bonds = ((1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 8), (2, 4, 8))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A            A
+    #     //           //
+    # B - N >> [B-] - [N+]
+    #     \            \
+    #      A            A
+    #
+    atoms = ({'atom': 'B'}, {'atom': 'N', 'neighbors': 3, 'hybridization': 2})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     A   A             A      A
+    #     |   |             |      |
+    # A - B = N - A >> A - [B-] - [N+] - A
+    #     |   |             |      |
+    #     A   A             A      A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 2}, {'atom': 'N', 'neighbors': 4, 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #   A      A       A   A
+    #   |      |       |   |
+    #  [B-] = [N+] >>  B - N
+    #   |      |       |   |
+    #   A      A       A   A
+    #
+    atoms = ({'atom': 'B', 'charge': -1, 'neighbors': 3, 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #        [A-]                 A
+    #         |                   |
+    # [A-] - [B+3] - [A-] >> A - [B-] - A
+    #         |                   |
+    #        [A-]                 A
+    #
+    atoms = ({'atom': 'B', 'charge': 3, 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1},
+             {'atom': 'A', 'charge': -1}, {'atom': 'A', 'charge': -1})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (-4, None), 2: (1, None), 3: (1, None), 4: (1, None), 5: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #        A             A
+    #        |             |
+    # [A-] - B - A >> A - [B-] - A
+    #        |             |
+    #        A             A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4}, {'atom': 'A', 'charge': -1}, {'atom': 'A'}, {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A             A
+    #      |             |
+    # A -  B - A >> A - [B-] - A
+    #      |             |
+    #      A             A
+    #
+    atoms = ({'atom': 'B', 'neighbors': 4, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     A         A
+    #     |         |
+    #     N    >>  [N+]
+    #   / | \     / | \
+    #  A  A  A   A  A  A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #  aci-nitro
+    #      O          O
+    #     //         //
+    # C = N  >> C - [N+]
+    #      \         \
+    #       OH       [O-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 4, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #            O               [O-]
+    #           //               /
+    # [C,N,O] = N  >> [C,N,O] = [N+]
+    #           \                \
+    #            A                A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['C', 'N', 'O'])},
+             {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix aci-nitro
+    #       [O-]          [O-]
+    #       /             /
+    # C = [N+ ] >>  C - [N+]
+    #      \             \\
+    #       OH            O
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3}, {'atom': 'O', 'charge': -1, 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2), (1, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix CN(=O)=N(=O)C
+    #
+    # [N+] = N = O >> [N+] = [N+] - O-
+    #        |                |
+    #        A                A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Fix CN(=O)=N(=N)C
+    # [N+] = N = N - ? >> [N+] = [N+] - [N-] - ?
+    #        |                    |
+    #        A                    A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'hybridization': 2, 'neighbors': 3}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # For N-case not unique!
+    #          N             [N-]
+    #         //             /
+    # [C,N] = N  >> [C,N] = [N+]
+    #         \              \
+    #          A              A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': ListElement(['C', 'N'])}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] - [N+] = O >> N = [N+] - [O-]
+    #         |               |
+    #         A               A
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 3, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'charge': -1, 'hybridization': 1, 'neighbors': (1, 2)})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #         O              [O-]
+    #        //              /
+    # [A-] - N   >> [A-] - [N+]
+    #        \\             \\
+    #         O              O
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A', 'charge': -1})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # O : N : O      O = [N+] - [O-]
+    #     |      >>       |
+    #     A               A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 4), (1, 3, 4), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Nitrite
+    #
+    #   O        [O-]
+    #  //        /
+    # [N-]  >>  N
+    #  \\       \\
+    #   O        O
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'charge': -1}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [O,C,N] = N # N >> [O,C,N] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': ListElement(['O', 'C', 'N'])})
+    bonds = ((1, 2, 3), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [C,N,O-] - [N+] # N  >> [C,N,O] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1},
+             {'atom': ListElement(['N', 'C', 'O']), 'charge': -1, 'hybridization': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  A - [N+] # N = [N-]  >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'N', 'charge': -1, 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 3), (1, 3, 2), (2, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - N = N = N >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 2},
+             {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 2))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - NH - N # N >> A - N = [N+] = [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 2, 'hybridization': 1},
+             {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 3))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] # N = N - A >> [N-] == [N+] == N - A
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1},
+             {'atom': 'N', 'hybridization': 2, 'neighbors': 2})
+    bonds = ((1, 2, 3), (1, 3, 2))
+    atom_fix = {1: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [N-] == N # N >> [N-] == [N+] == [N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1, 'charge': -1}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (1, 3, 3))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 3, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - C # N = NH >> A - [CH] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'C', 'neighbors': (1, 2)}, {'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 3), (2, 3, 2))
+    atom_fix = {2: (1, None), 3: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # note: order dependent
+    # A - C # N = [O,N] >> A - C # [N+] - [O,N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 2), (1, 3, 3))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [NH2,OH,SH] - N # C - A >> [NH,O,S-] - [N+] # C
+    #
+    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - [NH] - N # C >> A - [N-] - [N+] # C
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # [NH2,OH,SH] - [N+] # [C-] >> [NH,O,S-] - [N+] # [CH]
+    #
+    atoms = ({'atom': ListElement(['O', 'N', 'S']), 'neighbors': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'C', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 3: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - [NH] - [N+] # [C-] >> A - [N-] - [N+] # [CH]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'N', 'charge': 1, 'neighbors': 2},
+             {'atom': 'C', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {1: (-1, None), 3: (1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # A - N # C >> A - [N+] # [C-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'C', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # fix old diazo rule
+    #
+    # A - [C-] = [N+] = [NH] >> A - [CH] = [N+] = [N-]
+    #
+    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': 2}, {'atom': 'N', 'neighbors': 1})
+    bonds = ((1, 2, 2), (2, 3, 2))
+    atom_fix = {1: (1, None), 3: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    |           |
+    #  - N -   >> - [N+] -
+    #    \\          |
+    #    [O,N]      [O,N-]
+    #
+    atoms = ({'atom': 'N', 'neighbors': 4, 'hybridization': 2}, {'atom': ListElement(['O', 'N']), 'hybridization': 2})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # N-oxide radical
+    #
+    #    |         |
+    #  - N*  >>  - N
+    #    \\        |
+    #     O        O*
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 2, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (0, False), 2: (0, True)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C           C
+    #  \           \
+    #   N # N >>   [N+] = [N-]
+    #  /           /
+    # C           C
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3}, {'atom': 'N', 'neighbors': 1}, {'atom': 'C'}, {'atom': 'C'})
+    bonds = ((1, 2, 3), (1, 3, 1), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  C - N = [N+]  >>  C - [N+] # N
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2}, {'atom': 'N', 'charge': 1, 'neighbors': 1}, {'atom': 'C'})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [N+] - [C-] = O  >>  N = C = O
+    #
+    atoms = ({'atom': 'C', 'charge': -1, 'neighbors': 2},
+             {'atom': 'N', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  N # C - OH  >>  HN = C = O
+    #
+    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  N # C - [O-]  >>  [N-] = C = O
+    #
+    atoms = ({'atom': 'C', 'neighbors': 2}, {'atom': 'N', 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 3), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # - [N+] - [O-]  >>  - N = O
+    #
+    atoms = ({'atom': 'N', 'charge': 1, 'neighbors': 2, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     [O+]R         [O]R
+    #     //            /
+    # N - C  >> [N+] = C
+    #
+    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': 'O', 'neighbors': 2, 'hybridization': 2, 'charge': 1},
+             {'atom': 'N', 'hybridization': 1})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {2: (-1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      [O,S]H    [O,S]
+    #      /         //
+    # N = C  >> NH - C
+    #
+    atoms = ({'atom': 'C', 'hybridization': 2}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
+             {'atom': 'N', 'hybridization': 2})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # fix pyridin-2-one. note: only after amide rule
+    #
+    atoms = ({'atom': 'C', 'neighbors': 3}, {'atom': ListElement(['O', 'S']), 'neighbors': 1},
+             {'atom': 'N', 'neighbors': 2}, {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2},
+             {'atom': 'A', 'hybridization': 2}, {'atom': 'A', 'hybridization': 2})
+    bonds = ((1, 2, 2), (1, 3, 1), (1, 4, 1), (3, 7, 1), (4, 5, (1, 2)), (5, 6, (1, 2)), (6, 7, (1, 2)))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 1), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # todo:
+    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5]=,:[C:6][C:7](=[O:1])[C:8]=,:[C:9]1
+    # [C;a:10][N;H:2][N:3]=[C:4]1[C:5](=[O:1])[C:6]=,:[C:7]-,:[C:8]=,:[C:9]1
+
+    #
+    #       OH          O
+    #      /           //
+    # C = C    >> C - C
+    #      \           \
+    #      [O,N]       [O,N]
+    #
+    atoms = ({'atom': 'O', 'neighbors': 1}, {'atom': ListElement(['O', 'N'])}, {'atom': 'C'}, {'atom': 'C'})
+    bonds = ((1, 3, 1), (2, 3, 1), (3, 4, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2), (3, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A                   A
+    #       |                   |
+    #  A - [P+] - [O-]  >>  A - P = O
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'P', 'charge': 1, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A                   A
+    #       |                   |
+    #  A - [P-] - [C+]  >>  A - P = C
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2, 3), 'hybridization': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #   F   F         F   F
+    #    \ /           \ /
+    # F - P - F >> F - [P-] - F
+    #    / \           / \
+    #   F   F         F   F
+    #
+    atoms = ({'atom': 'P', 'neighbors': 6}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
+             {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1}, {'atom': 'F', 'neighbors': 1},
+             {'atom': 'F', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (1, 6, 1), (1, 7, 1))
+    atom_fix = {1: (-1, None)}
+    bonds_fix = ()
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     O               O
+    #     \\              \\
+    # A - [P-] - A  >> A - P - A
+    #     //              /
+    #     O              [O-]
+    #
+    atoms = ({'atom': 'P', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1), (1, 5, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #           A                   A
+    #          /                   /
+    # [O-] - [S,Si,Se+]  >>  O = [S,Si,Se]
+    #          \                   \
+    #           A                   A
+    #
+    atoms = ({'atom': ListElement(['S', 'Se', 'Si']), 'charge': 1, 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       A?                  A?
+    #       |                   |
+    #  A = [S+] - [O-]  >>  A = S = O
+    #       |                   |
+    #       A?                  A?
+    #
+    atoms = ({'atom': 'S', 'charge': 1, 'neighbors': (2, 4), 'hybridization': 2},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #       [O-]          O
+    #       /            //
+    # A = [S+2]  >>  A = S
+    #       \            \\
+    #       [O-]          O
+    #
+    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 3, 'hybridization': 2},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1))
+    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #          A                  A
+    #          |                  |
+    # [O-] - [S+2] - [O-] >>  O = S = O
+    #          |                  |
+    #          A                  A
+    #
+    atoms = ({'atom': 'S', 'charge': 2, 'neighbors': 4, 'hybridization': 1},
+             {'atom': 'O', 'charge': -1, 'neighbors': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 1))
+    atom_fix = {1: (-2, None), 2: (1, None), 3: (1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  A - [S-] - [C+]  >>  A - S = C
+    #       |                   |
+    #       A                   A
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  O              O
+    #  \\             \\
+    #  [S-] - A  >>    S - A
+    #  //             /
+    #  O            [O-]
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #     O             [O-]
+    #     \\             \
+    # A - [S-] = O >> A - S = O
+    #     //             //
+    #     O              O
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 4}, {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'A'})
+    bonds = ((1, 2, 2), (1, 3, 2), (1, 4, 2), (1, 5, 1))
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  O              [O-]
+    #  \\              \
+    #  [S-] - [S-] >>   S = S
+    #  //              /
+    #  O              [O-]
+    #
+    atoms = ({'atom': 'S', 'charge': -1, 'neighbors': 3}, {'atom': 'S', 'charge': -1, 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2))
+    atom_fix = {1: (1, None), 2: (1, None), 3: (-1, None), 4: (-1, None)}
+    bonds_fix = ((1, 2, 2), (1, 3, 1), (1, 4, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    A            A
+    #    \            \
+    # A - S = O >> A - S = O
+    #    /            //
+    #  [OH]           O
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #    A            A
+    #    \            \
+    # A - S = O >> A - S = O
+    #    /            //
+    #  [NH]           N
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4, 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 1})
+    bonds = ((1, 2, 2), (1, 3, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 3, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #      A{1,3}               A{1,3}
+    #      |                    |
+    #  N = S - [OH]  >>  [NH] - S = O
+    #
+    atoms = ({'atom': 'S', 'neighbors': (3, 5), 'hybridization': 2}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2})
+    bonds = ((1, 2, 1), (1, 3, 2))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C # C - [O,NH,S]H  >> C=C=[O,NH,S]
+    #
+    atoms = ({'atom': ListElement(['O', 'S', 'N']), 'neighbors': 1}, {'atom': 'C', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (2, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    # C # C - [NH]R  >> C=C=NR
+    #
+    atoms = ({'atom': 'N', 'neighbors': 2, 'hybridization': 1}, {'atom': 'C', 'neighbors': 2},
+             {'atom': 'C', 'neighbors': (1, 2)})
+    bonds = ((1, 2, 1), (2, 3, 3))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (2, 3, 2))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Carbon Monoxide
+    #
+    # [CX1] = O  >> [С-] # [O+]
+    #
+    atoms = ({'atom': 'C', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (-1, False), 2: (1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Ozone
+    #
+    # [O*] -- O -- [O*]  >>  O == [O+] -- [O-]
+    #
+    atoms = ({'atom': 'O', 'neighbors': 1, 'is_radical': True}, {'atom': 'O', 'neighbors': 2},
+             {'atom': 'O', 'neighbors': 1, 'is_radical': True})
+    bonds = ((1, 2, 1), (2, 3, 1))
+    atom_fix = {1: (0, False), 2: (1, None), 3: (-1, False)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # only after [A-] - [C+] rules!
+    #  [C+] - N(R2)  >> C = [N+](R2)
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1, 'heteroatoms': 0},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # low priority for hetero-N
+    #  [C+] - N(X2)  >> C = [N+](R2)
+    #
+    atoms = ({'atom': 'N', 'neighbors': 3, 'hybridization': 1},
+             {'atom': 'C', 'charge': 1, 'hybridization': 1, 'neighbors': (1, 2, 3)})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [C+] = N(R)  >>  C # [N+](R)
+    #
+    atoms = ({'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2},
+             {'atom': 'C', 'charge': 1, 'neighbors': (1, 2), 'hybridization': 2, 'heteroatoms': 1})
+    bonds = ((1, 2, 2),)
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 3),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    # Br-ion + I-ion
+    #
+    #        A           A
+    #        |           |
+    # [Br-].[I+] >> Br - I
+    #        |           |
+    #        A           A
+    #
+    atoms = ({'atom': 'Br', 'charge': -1, 'neighbors': 0},
+             {'atom': 'I', 'charge': 1, 'neighbors': 2, 'hybridization': 1},)
+    bonds = ()
+    atom_fix = {1: (1, None), 2: (-1, None)}
+    bonds_fix = ((1, 2, 1),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    #
+    #  [I+] - [O-] >> I = O
+    #
+    atoms = ({'atom': 'I', 'charge': 1}, {'atom': 'O', 'charge': -1, 'neighbors': 1})
+    bonds = ((1, 2, 1),)
+    atom_fix = {1: (-1, None), 2: (1, None)}
+    bonds_fix = ((1, 2, 2),)
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    compiled_rules = []
+    for atoms, bonds, atom_fix, bonds_fix in raw_rules:
+        q = QueryContainer()
+        for a in atoms:
+            q.add_atom(**a)
+        for n, m, b in bonds:
+            q.add_bond(n, m, b)
+
+        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
+        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms))
+    return compiled_rules
+
+
+def _rules_double():
+    from ...containers import QueryContainer
+
+    raw_rules = []
+
+    #
+    #     [OH]                O
+    #      |                 //
+    #  N = S = A  >>  [NH] - S = A
+    #      |                 |
+    #      A                 A
+    #
+    atoms = ({'atom': 'S', 'neighbors': 4}, {'atom': 'O', 'neighbors': 1},
+             {'atom': 'N', 'neighbors': (1, 2), 'hybridization': 2}, {'atom': 'A'}, {'atom': 'A'})
+    bonds = ((1, 2, 1), (1, 3, 2), (1, 4, 2), (1, 5, 1))
+    atom_fix = {}
+    bonds_fix = ((1, 2, 2), (1, 3, 1))
+    raw_rules.append((atoms, bonds, atom_fix, bonds_fix))
+
+    compiled_rules = []
+    for atoms, bonds, atom_fix, bonds_fix in raw_rules:
+        q = QueryContainer()
+        for a in atoms:
+            q.add_atom(**a)
+        for n, m, b in bonds:
+            q.add_bond(n, m, b)
+
+        any_atoms = [n for n, a in q.atoms() if a.atomic_symbol == 'A' and n not in atom_fix]
+        compiled_rules.append((q, atom_fix, bonds_fix, any_atoms))
+    return compiled_rules
+
+
+single_rules = Proxy(_rules_single)
+double_rules = Proxy(_rules_double)
+
+
+__all__ = ['single_rules', 'double_rules']
```

### Comparing `chython-1.67/chython/algorithms/standardize/resonance.py` & `chython-1.8/chython/algorithms/standardize/resonance.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,187 +1,172 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from typing import List, TYPE_CHECKING, Union
-from ...exceptions import ValenceError
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-class Resonance:
-    __slots__ = ()
-
-    def fix_resonance(self: Union['MoleculeContainer', 'Resonance'], *, logging=False,
-                      _fix_stereo=True) -> Union[bool, List[int]]:
-        """
-        Transform biradical or dipole resonance structures into neutral form. Return True if structure form changed.
-
-        :param logging: return list of changed atoms.
-        """
-        atoms = self._atoms
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        calc_implicit = self._calc_implicit
-        entries, exits, rads, constrains, nitrogen_cat, nitrogen_ani, sulfur_cat = self.__entries()
-        hs = set()
-        while len(rads) > 1:
-            n = rads.pop()
-            for path in self.__find_delocalize_path(n, rads, constrains, True):
-                radicals[n] = False
-                hs.add(n)
-                for n, m, b in path:
-                    hs.add(m)
-                    bonds[n][m]._Bond__order = b  # noqa
-                radicals[m] = False  # noqa
-                rads.discard(m)
-                break  # path found
-            # path not found. atom n keep as is
-        while entries and exits:
-            n = entries.pop()
-            for path in self.__find_delocalize_path(n, exits, constrains, False):
-                l, m, b = path[-1]
-                if n in nitrogen_cat and m in nitrogen_ani:
-                    continue
-
-                c_m = charges[m] - 1
-                if m in sulfur_cat:  # prevent X-[S+]=X >> X=S=X
-                    if b != 1:
-                        continue
-                else:  # check cations end valence.
-                    try:
-                        atoms[m].valence_rules(c_m, radicals[m], sum(int(y) for x, y in bonds[m].items() if x != l) + b)
-                    except ValenceError:
-                        continue
-
-                charges[n] += 1
-                hs.add(n)
-                for n, m, b in path:
-                    hs.add(m)
-                    bonds[n][m]._Bond__order = b  # noqa
-                charges[m] = c_m
-                exits.discard(m)
-                break  # path from negative atom to positive atom found.
-            # path not found. keep negative atom n as is
-        if hs:
-            for n in hs:
-                calc_implicit(n)
-            self.flush_cache()
-            if _fix_stereo:
-                self.fix_stereo()
-            if logging:
-                return list(hs)
-            return True
-        elif logging:
-            return []
-        return False
-
-    def __find_delocalize_path(self: 'MoleculeContainer', start, finish, constrains, odd_only):
-        bonds = self._bonds
-        stack = [(start, n, 0, b.order + 1) for n, b in bonds[start].items() if n in constrains and b.order < 3]
-        path = []
-        seen = {start}
-        while stack:
-            last, current, depth, order = stack.pop()
-            if len(path) > depth:
-                seen.difference_update(x for _, x, _ in path[depth:])
-                path = path[:depth]
-
-            path.append((last, current, order))
-
-            if current in finish:
-                if odd_only:  # radicals!
-                    if len(path) % 2:
-                        yield path
-                    else:  # invalid path
-                        continue
-                elif depth:  # one bonded ignored. we search double bond transfer! A=A-A >> A-A=A.
-                    yield path
-
-            depth += 1
-            seen.add(current)
-            diff = -1 if depth % 2 else 1
-            stack.extend((current, n, depth, bo) for n, b in bonds[current].items()
-                         if n not in seen and n in constrains and 1 <= (bo := b.order + diff) <= 3)
-
-    def __entries(self: 'MoleculeContainer'):
-        hybridization = self.hybridization
-        neighbors = self.neighbors
-        charges = self._charges
-        radicals = self._radicals
-        bonds = self._bonds
-        atoms = self._atoms
-        errors = {n for n, h in self._hydrogens.items() if h is None}
-
-        transfer = set()
-        entries = set()
-        exits = set()
-        rads = set()
-        nitrogen_cat = set()
-        nitrogen_ani = set()
-        sulfur_cat = set()
-        for n, a in atoms.items():
-            if a.atomic_number not in {5, 6, 7, 8, 14, 15, 16, 33, 34, 52}:
-                # filter non-organic set, halogens and aromatics
-                continue
-            elif radicals[n]:
-                rads.add(n)
-            elif charges[n] == -1:
-                if (lb := len(bonds[n])) == 4 and a.atomic_number == 5:  # skip boron
-                    continue
-                elif lb == 6 and a.atomic_number == 15:  # skip [P-]X6
-                    continue
-                if n in errors:  # only valid anions accepted
-                    continue
-                entries.add(n)
-            elif charges[n] == 1:
-                lb = len(bonds[n])
-                if a.atomic_number == 7:
-                    if lb == 4:  # skip ammonia
-                        continue
-                    elif lb == 2 and hybridization(n) == 3:  # skip Azide
-                        (n1, b1), (n2, b2) = bonds[n].items()
-                        if b1.order == b2.order == 2 and (charges[n1] == -1 and atoms[n1].atomic_number == 7 or
-                                                          charges[n2] == -1 and atoms[n2].atomic_number == 7):
-                            continue
-                    elif lb == 3 and hybridization(n) == 2:  # X=[N+](-X)-X - prevent N-N migration
-                        nitrogen_ani.add(n)
-                elif a.atomic_number == 15 and lb == 4:  # skip [P+]R4
-                    continue
-                elif a.atomic_number == 16:
-                    if lb == 2 and hybridization(n) == 2:  # ad-hoc for X-[S+]=X
-                        sulfur_cat.add(n)
-                    elif lb == 3 and hybridization(n) == 1:  # ad-hoc for X-[S+](-X)-X
-                        continue
-                exits.add(n)
-            transfer.add(n)
-
-        if exits or entries:  # try to move cation to nitrogen. saturation fixup.
-            for n, a in self._atoms.items():
-                if a.atomic_number == 7 and not charges[n]:
-                    if hybridization(n) == 1 and neighbors(n) <= 3:  # any amine - potential e-donor
-                        entries.add(n)
-                        nitrogen_cat.add(n)
-                    elif hybridization(n) == 3 and neighbors(n) == 1:  # N#X-[X-] >> [N-]=X=X
-                        exits.add(n)
-                        nitrogen_ani.add(n)
-        return entries, exits, rads, transfer, nitrogen_cat, nitrogen_ani, sulfur_cat
-
-
-__all__ = ['Resonance']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from typing import List, TYPE_CHECKING, Union
+from ...exceptions import ValenceError
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+class Resonance:
+    __slots__ = ()
+
+    def fix_resonance(self: Union['MoleculeContainer', 'Resonance'], *, logging=False) ->\
+            Union[bool, List[int]]:
+        """
+        Transform biradical or dipole resonance structures into neutral form. Return True if structure form changed.
+
+        :param logging: return list of changed atoms.
+        """
+        atoms = self._atoms
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        entries, exits, rads, constrains, nitrogen_cat, nitrogen_ani, sulfur_cat = self.__entries()
+        hs = set()
+        while len(rads) > 1:
+            n = rads.pop()
+            for path in self.__find_delocalize_path(n, rads, constrains, True):
+                radicals[n] = False
+                hs.add(n)
+                for n, m, b in path:
+                    hs.add(m)
+                    bonds[n][m]._Bond__order = b
+                radicals[m] = False
+                rads.discard(m)
+                break  # path found
+            # path not found. atom n keep as is
+        while entries and exits:
+            n = entries.pop()
+            for path in self.__find_delocalize_path(n, exits, constrains, False):
+                l, m, b = path[-1]
+                if n in nitrogen_cat:
+                    if m in nitrogen_ani:
+                        continue
+                    c_n = 1
+                else:
+                    c_n = 0
+                c_m = -1 if m in nitrogen_ani else 0
+                if m in sulfur_cat:  # prevent X-[S+]=X >> X=S=X
+                    if b != 1:
+                        continue
+                else:  # check cations end valence.
+                    try:
+                        atoms[m].valence_rules(c_m, radicals[m], sum(int(y) for x, y in bonds[m].items() if x != l) + b)
+                    except ValenceError:
+                        continue
+
+                charges[n] = c_n
+                hs.add(n)
+                for n, m, b in path:
+                    hs.add(m)
+                    bonds[n][m]._Bond__order = b
+                charges[m] = c_m
+                exits.discard(m)
+                break  # path from negative atom to positive atom found.
+            # path not found. keep negative atom n as is
+        if hs:
+            for n in hs:
+                self._calc_implicit(n)
+            self.flush_cache()
+            if logging:
+                return list(hs)
+            return True
+        if logging:
+            return []
+        return False
+
+    def __find_delocalize_path(self: 'MoleculeContainer', start, finish, constrains, odd_only):
+        bonds = self._bonds
+        stack = [(start, n, 0, b.order + 1) for n, b in bonds[start].items() if n in constrains and b.order < 3]
+        path = []
+        seen = {start}
+        while stack:
+            last, current, depth, order = stack.pop()
+            if len(path) > depth:
+                seen.difference_update(x for _, x, _ in path[depth:])
+                path = path[:depth]
+
+            path.append((last, current, order))
+
+            if current in finish:
+                if odd_only:  # radicals!
+                    if len(path) % 2:
+                        yield path
+                    else:  # invalid path
+                        continue
+                elif depth:  # one bonded ignored. we search double bond transfer! A=A-A >> A-A=A.
+                    yield path
+
+            depth += 1
+            seen.add(current)
+            diff = -1 if depth % 2 else 1
+            stack.extend((current, n, depth, bo) for n, b in bonds[current].items()
+                         if n not in seen and n in constrains and 1 <= (bo := b.order + diff) <= 3)
+
+    def __entries(self: 'MoleculeContainer'):
+        hybridization = self.hybridization
+        neighbors = self.neighbors
+        charges = self._charges
+        radicals = self._radicals
+        bonds = self._bonds
+        errors = set(self.check_valence())
+
+        transfer = set()
+        entries = set()
+        exits = set()
+        rads = set()
+        nitrogen_cat = set()
+        nitrogen_ani = set()
+        sulfur_cat = set()
+        for n, a in self._atoms.items():
+            if a.atomic_number not in {5, 6, 7, 8, 14, 15, 16, 33, 34, 52}:
+                # filter non-organic set, halogens and aromatics
+                continue
+            elif radicals[n]:
+                rads.add(n)
+            elif charges[n] == -1:
+                if (lb := len(bonds[n])) == 4 and a.atomic_number == 5:  # skip boron
+                    continue
+                elif lb == 6 and a.atomic_number == 15:  # skip [P-]X6
+                    continue
+                if n in errors:  # only valid anions accepted
+                    continue
+                entries.add(n)
+            elif charges[n] == 1:
+                if (lb := len(bonds[n])) == 4 and a.atomic_number == 7:  # skip ammonia
+                    continue
+                if a.atomic_number == 16 and lb == 2 and hybridization(n) == 2:  # ad-hoc for X-[S+]=X
+                    sulfur_cat.add(n)
+                exits.add(n)
+            transfer.add(n)
+
+        if exits or entries:  # try to move cation to nitrogen. saturation fixup.
+            for n, a in self._atoms.items():
+                if a.atomic_number == 7 and not charges[n]:
+                    if hybridization(n) == 1 and neighbors(n) == 3:
+                        entries.add(n)
+                        nitrogen_cat.add(n)
+                    elif hybridization(n) == 3 and neighbors(n) == 1:  # N#X-[X-] >> [N-]=X=X
+                        exits.add(n)
+                        nitrogen_ani.add(n)
+        return entries, exits, rads, transfer, nitrogen_cat, nitrogen_ani, sulfur_cat
+
+
+__all__ = ['Resonance']
```

### Comparing `chython-1.67/chython/algorithms/standardize/saturation.py` & `chython-1.8/chython/algorithms/standardize/saturation.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,372 +1,369 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021, 2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from itertools import product
-from operator import itemgetter
-from random import shuffle
-from typing import TYPE_CHECKING, Dict, Optional, Union, List
-from ...containers.bonds import Bond
-from ...exceptions import ValenceError
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-# atom, charge, unsaturation
-tuned_priority = {(7, 0, 0): -3,  # amine
-                  (7, 0, 1): -3,  # X=N-X
-                  (7, 0, 2): -3,  # X#N
-                  (7, 1, 1): -2,  # X=[N+](-X)-X
-                  (7, 1, 2): -2,  # X=[N+]=X
-                  (7, -1, 0): -1,  # X-[N-]-X
-                  (7, -1, 1): -1,  # X=[N-]
-                  (8, 0, 0): -2,  # X-O-X
-                  (8, 0, 1): -2,  # X=O
-                  (8, -1, 0): -1,  # X-[O-]
-                  (8, 1, 1): -1,  # X=[O+]-X
-                  (16, 0, 0): -3,  # X-S-X
-                  (16, 0, 2): -2,  # X-S(-X)(=X)=X
-                  (16, 0, 1): -2,  # X-S(-X)(=X)
-                  (16, 0, 2): -2,  # X=S=X
-                  (16, 0, 0): -1,  # X-S(-X)(-X)-X
-                  (16, 0, 1): -1,  # X-[S+](-X)(-X)
-                  (16, 1, 1): -1,  # X=[S+]-X
-                  }
-charge_priority = {0: 0, -1: 1, 1: 2, 2: 3, 3: 4, -2: 5, 4: 6, -3: 7, -4: 8}
-
-
-class Saturation:
-    __slots__ = ()
-
-    def saturate(self: 'MoleculeContainer', neighbors_distances: Optional[Dict[int, Dict[int, float]]] = None,
-                 reset_electrons: bool = True, expected_charge: int = 0, expected_radicals_count: int = 0,
-                 allow_errors: bool = True, logging: bool = False) -> Union[bool, List[str]]:
-        """
-        Saturate molecules with double and triple bonds and charges and radical states to correct valences of atoms.
-        Note: works only with fully explicit hydrogens!
-
-        :param neighbors_distances: If given longest bonds can be removed if need.
-        :param reset_electrons: Can change charges and radicals if need.
-        :param expected_charge: Reset charge to given. Works only with reset_electrons=True.
-        :param expected_radicals_count: Reset radical atoms count to given. Works only with reset_electrons=True.
-        :param allow_errors: allow unbalanced result.
-        :param logging: return log.
-        """
-        if any(b != 1 for _, _, b in self.bonds()):
-            raise ValenceError('only single bonded skeleton can be saturated')
-        atoms = self._atoms
-        if not reset_electrons:
-            expected_radicals_count = any(self._radicals.values())
-            expected_charge = int(self)
-
-        sat, adjacency = _find_possible_valences(atoms, neighbors_distances or self._bonds,
-                                                 {x: None for x in self._atoms} if reset_electrons else self._charges,
-                                                 {x: None for x in self._atoms} if reset_electrons else self._radicals,
-                                                 neighbors_distances is not None)
-        charges = {}  # new charge states
-        radicals = {}  # new radical states
-        bonds = {n: {} for n in atoms}  # new bonds
-
-        seen = set()
-        unsaturated = {}
-        for n, env in adjacency.items():  # set single bonds in molecule. collect unsaturated atoms
-            s = sat[n]
-            if len(s) == 1:
-                c, r, h = s.pop()
-                if not h:
-                    seen.add(n)
-                    charges[n] = c
-                    radicals[n] = r
-                    for m in env:
-                        if m not in seen:
-                            bonds[n][m] = bonds[m][n] = b = Bond(1)
-                            b._attach_graph(self, n, m)
-                else:
-                    unsaturated[n] = [(c, r, h)]
-            else:
-                # radicals have the lowest priority
-                # tuned priority
-                # multiple bonds have higher priority
-                # charges priority: 0>-1>1>2>3>-2>4>-3>-4
-                unsaturated[n] = sorted(s, key=lambda x: (x[1],
-                                                          tuned_priority.get((atoms[n].atomic_number, x[0], x[2]), 0),
-                                                          -x[2], charge_priority[x[0]]))
-
-        log = []
-        if (need_radicals := expected_radicals_count - sum(radicals.values())) < 0:
-            log.append('Radical state not balanced')
-            if not allow_errors:
-                if logging:
-                    return log
-                return False
-            need_radicals = 0  # reset to zero
-
-        if unsaturated:
-            # create graph of unsaturated atoms
-            bonds_graph = {n: {m for m in adjacency[n] if m in unsaturated} for n in unsaturated}
-            order = list(unsaturated)
-            # try to saturate with different random states
-            for _ in range(len(unsaturated)):
-                shuffle(order)
-                sb, sa, log_ = _saturate({n: bonds_graph[n].copy() for n in order}, unsaturated, need_radicals,
-                                         expected_charge - sum(charges.values()))
-                if not log_:  # success
-                    break
-            else:  # failed
-                if log_ == 1:
-                    log.append('Charge state not balanced')
-                elif log_ == 2:
-                    log.append('Radical state not balanced')
-                else:
-                    log.append('Charge state not balanced')
-                    log.append('Radical state not balanced')
-                if not allow_errors:  # all attempts failed
-                    if logging:
-                        return log
-                    return False
-
-            for n, m, b in sb:
-                bonds[n][m] = bonds[m][n] = b = Bond(b)
-                b._attach_graph(self, n, m)
-            for n, c, r in sa:
-                charges[n] = c
-                radicals[n] = r
-        elif expected_charge != sum(charges.values()):  # check charge for saturated case
-            log.append('Charge state not balanced')
-            if not allow_errors:
-                if logging:
-                    return log
-                return False
-        # reset molecule
-        self._bonds = bonds
-        self._radicals = radicals
-        self._charges = charges
-        self._hydrogens = {x: 0 for x in atoms}  # reset invalid hydrogens counts.
-        self.flush_cache()
-        if logging:
-            if not log:  # check for errors
-                log.append('Saturated successfully')
-            else:
-                log.append('Saturated with errors')
-            return log
-        return True
-
-
-def _find_possible_valences(atoms, neighbors_distances, charges, radicals, allow_deleting=True):
-    if allow_deleting:
-        possible_bonds = {n: md.copy() for n, md in neighbors_distances.items()}
-    else:
-        possible_bonds = {n: list(md) for n, md in neighbors_distances.items()}
-    while True:
-        saturation = defaultdict(set)
-        for n, env in possible_bonds.items():
-            env_atoms = None
-            el = len(env)
-            dc = charges[n]
-            dr = radicals[n]
-            for charge, is_radical, valence, implicit, explicit_dict in atoms[n]._compiled_saturation_rules:
-                if valence < el or dc is not None and dc != charge or dr is not None and dr != is_radical:
-                    continue  # skip impossible rules
-                if explicit_dict:
-                    if env_atoms is None:  # lazy caching
-                        env_atoms = defaultdict(int)
-                        for m in env:
-                            env_atoms[atoms[m].atomic_number] += 1
-                    env_atoms_copy = env_atoms.copy()
-                    for (b, a), c in explicit_dict.items():  # stage 1. find explicit valence
-                        if env_atoms_copy[a] < c:  # `c` always > 0
-                            break  # rule not matched
-                        env_atoms_copy[a] -= c
-                    else:  # stage 2. find possible valence
-                        if unmatched := sum(env_atoms_copy.values()):  # number of atoms outside rule
-                            if implicit >= unmatched:
-                                # number of implicit H should be greater or equal to number of neighbors
-                                saturation[n].add((charge, is_radical, valence - el))
-                        else:  # pattern fully matched. difference bw valence and connectivity is unsaturation.
-                            saturation[n].add((charge, is_radical, valence - el))
-                else:   # unspecific rule. found possible valence
-                    saturation[n].add((charge, is_radical, valence - el))
-            if n not in saturation:  # valence not found
-                break
-        else:  # all atoms passed
-            break
-        if allow_deleting:
-            out = max(env.items(), key=itemgetter(1))[0]
-            del possible_bonds[out][n]
-            del possible_bonds[n][out]
-        else:
-            raise ValenceError('Structure has invalid atoms neighbors count and electron states')
-    return saturation, possible_bonds
-
-
-def _saturate(bonds, atoms, expected_radicals_count, expected_charge):
-    atoms = {k: v.copy() for k, v in atoms.items()}
-    dots = []
-    saturation = []
-    electrons = []
-    while True:
-        # get isolated atoms. atoms should be charged or radical
-        to_del = []
-        for n, env in bonds.items():
-            if not env:
-                es = [(n, c, r) for c, r, h in atoms[n] if not h]
-                if not es:
-                    raise ValenceError('Saturation impossible. '
-                                       f"Isolated atom ({n}) doesn't have appropriate charge-radical state")
-                to_del.append(n)
-                dots.append(es)
-        for n in to_del:
-            del bonds[n]
-        if not bonds:
-            break
-
-        try:  # get terminal atom
-            n = next(n for n, ms in bonds.items() if len(ms) == 1)
-        except StopIteration:
-            # get ring or linker atom
-            n, _ = min(bonds.items(), key=lambda x: len(x[1]))
-            m = bonds[n].pop()
-            bonds[m].discard(n)
-
-            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
-                if nh == mh:
-                    saturation.append((n, m, nh + 1))
-                    electrons.append((n, nc, nr))
-                    electrons.append((m, mc, mr))
-
-                    for x in bonds.pop(n):
-                        saturation.append((n, x, 1))
-                        bonds[x].discard(n)
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-                elif nh < mh:
-                    electrons.append((n, nc, nr))
-                    saturation.append((n, m, nh + 1))
-                    atoms[m].pop(i)
-                    atoms[m].insert(i, (mc, mr, mh - nh))
-
-                    for x in bonds.pop(n):
-                        saturation.append((n, x, 1))
-                        bonds[x].discard(n)
-                    break
-                elif nh > mh:
-                    electrons.append((m, mc, mr))
-                    saturation.append((n, m, mh + 1))
-                    atoms[n].pop(i)
-                    atoms[n].insert(i, (nc, nr, nh - mh))
-
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-        else:
-            m = bonds.pop(n).pop()
-            bonds[m].discard(n)
-
-            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
-                if nh == mh:
-                    saturation.append((n, m, nh + 1))
-                    electrons.append((n, nc, nr))
-                    electrons.append((m, mc, mr))
-                    for x in bonds.pop(m):
-                        saturation.append((m, x, 1))
-                        bonds[x].discard(m)
-                    break
-                elif nh < mh and bonds[m]:
-                    electrons.append((n, nc, nr))
-                    saturation.append((n, m, nh + 1))
-                    atoms[m].pop(i)
-                    atoms[m].insert(i, (mc, mr, mh - nh))
-                    break
-            else:
-                saturation.append((n, m, 1))
-                if not bonds[m]:
-                    del bonds[m]
-
-    combo_ua = []  # possible single atoms electron states
-    for s in dots:
-        if len(s) == 1:
-            electrons.extend(s)
-        elif s:
-            combo_ua.append(s)
-
-    # if < 0 - we already in bad situation
-    # if > 0 - we need more radicals
-    need_radical = expected_radicals_count - sum(x for _, _, x in electrons)
-    need_charge = expected_charge - sum(x for _, x, _ in electrons)
-    if combo_ua:
-        # try randomly set charges and radicals.
-        # first pick required radical states.
-        # second try to minimize charge delta.
-        for attempt in range(1, len(combo_ua) + 1):
-            shuffle(combo_ua)
-            charges_radicals = []
-            rad = []
-            chg = []
-            for atom in combo_ua:
-                if len(rad) < need_radical:  # pick radicals
-                    r = next((x for x in atom if x[2]), None)
-                    if r:  # pick random radical states
-                        rad.append(r)
-                    else:  # not radical
-                        chg.append(atom)
-                else:  # pick not radical states
-                    c = [x for x in atom if not x[2]]
-                    if len(c) > 1:
-                        chg.append(c)
-                    elif c:
-                        charges_radicals.extend(c)
-                    elif attempt == len(combo_ua):  # all states has radical. balancing impossible
-                        chg.append(atom)  # fuck it horse. we in last attempt
-                    else:  # do next attempt
-                        break
-            else:
-                charges_radicals.extend(rad)
-                current_charge = need_charge - sum(x for _, x, _ in charges_radicals)
-                current_radical = need_radical - len(rad)
-                for x in chg:
-                    n, c, r = min(x, key=lambda x: abs(current_charge - x[1]))
-                    charges_radicals.append((n, c, r))
-                    current_charge -= c
-                    current_radical -= r
-
-                if current_radical:  # radical unbalanced
-                    if current_charge:
-                        log = 3
-                    else:
-                        log = 2
-                elif current_charge:
-                    log = 1
-                else:  # balanced!
-                    log = 0
-                    break
-
-        electrons.extend(charges_radicals)
-    elif need_radical:
-        log = 3 if need_charge else 2
-    elif need_charge:
-        log = 1
-    else:
-        log = 0
-    return saturation, electrons, log
-
-
-__all__ = ['Saturation']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from itertools import product
+from operator import itemgetter
+from random import shuffle
+from typing import TYPE_CHECKING, Dict, Optional, Union, List
+from ...containers.bonds import Bond
+from ...exceptions import ValenceError
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+# atom, charge, unsaturation
+tuned_priority = {(7, 0, 0): -3,  # amine
+                  (7, 0, 1): -3,  # X=N-X
+                  (7, 0, 2): -3,  # X#N
+                  (7, 1, 1): -2,  # X=[N+](-X)-X
+                  (7, 1, 2): -2,  # X=[N+]=X
+                  (7, -1, 0): -1,  # X-[N-]-X
+                  (7, -1, 1): -1,  # X=[N-]
+                  (8, 0, 0): -2,  # X-O-X
+                  (8, 0, 1): -2,  # X=O
+                  (8, -1, 0): -1,  # X-[O-]
+                  (8, 1, 1): -1,  # X=[O+]-X
+                  (16, 0, 0): -3,  # X-S-X
+                  (16, 0, 2): -2,  # X-S(-X)(=X)=X
+                  (16, 0, 1): -2,  # X-S(-X)(=X)
+                  (16, 0, 2): -2,  # X=S=X
+                  (16, 0, 0): -1,  # X-S(-X)(-X)-X
+                  (16, 0, 1): -1,  # X-[S+](-X)(-X)
+                  (16, 1, 1): -1,  # X=[S+]-X
+                  }
+charge_priority = {0: 0, -1: 1, 1: 2, 2: 3, 3: 4, -2: 5, 4: 6, -3: 7, -4: 8}
+
+
+class Saturation:
+    __slots__ = ()
+
+    def saturate(self: 'MoleculeContainer', neighbors_distances: Optional[Dict[int, Dict[int, float]]] = None,
+                 reset_electrons: bool = True, expected_charge: int = 0, expected_radicals_count: int = 0,
+                 allow_errors: bool = True, logging: bool = False) -> Union[bool, List[str]]:
+        """
+        Saturate molecules with double and triple bonds and charges and radical states to correct valences of atoms.
+        Note: works only with fully explicit hydrogens!
+
+        :param neighbors_distances: If given longest bonds can be removed if need.
+        :param reset_electrons: Can change charges and radicals if need.
+        :param expected_charge: Reset charge to given. Works only with reset_electrons=True.
+        :param expected_radicals_count: Reset radical atoms count to given. Works only with reset_electrons=True.
+        :param allow_errors: allow unbalanced result.
+        :param logging: return log.
+        """
+        if any(b != 1 for _, _, b in self.bonds()):
+            raise ValenceError('only single bonded skeleton can be saturated')
+        atoms = self._atoms
+        if not reset_electrons:
+            expected_radicals_count = any(self._radicals.values())
+            expected_charge = int(self)
+
+        sat, adjacency = _find_possible_valences(atoms, neighbors_distances or self._bonds,
+                                                 {x: None for x in self._atoms} if reset_electrons else self._charges,
+                                                 {x: None for x in self._atoms} if reset_electrons else self._radicals,
+                                                 neighbors_distances is not None)
+        charges = {}  # new charge states
+        radicals = {}  # new radical states
+        bonds = {n: {} for n in atoms}  # new bonds
+
+        seen = set()
+        unsaturated = {}
+        for n, env in adjacency.items():  # set single bonds in molecule. collect unsaturated atoms
+            s = sat[n]
+            if len(s) == 1:
+                c, r, h = s.pop()
+                if not h:
+                    seen.add(n)
+                    charges[n] = c
+                    radicals[n] = r
+                    for m in env:
+                        if m not in seen:
+                            bonds[n][m] = bonds[m][n] = Bond(1)
+                else:
+                    unsaturated[n] = [(c, r, h)]
+            else:
+                # radicals have the lowest priority
+                # tuned priority
+                # multiple bonds have higher priority
+                # charges priority: 0>-1>1>2>3>-2>4>-3>-4
+                unsaturated[n] = sorted(s, key=lambda x: (x[1],
+                                                          tuned_priority.get((atoms[n].atomic_number, x[0], x[2]), 0),
+                                                          -x[2], charge_priority[x[0]]))
+
+        log = []
+        if (need_radicals := expected_radicals_count - sum(radicals.values())) < 0:
+            log.append('Radical state not balanced')
+            if not allow_errors:
+                if logging:
+                    return log
+                return False
+            need_radicals = 0  # reset to zero
+
+        if unsaturated:
+            # create graph of unsaturated atoms
+            bonds_graph = {n: {m for m in adjacency[n] if m in unsaturated} for n in unsaturated}
+            order = list(unsaturated)
+            # try to saturate with different random states
+            for _ in range(len(unsaturated)):
+                shuffle(order)
+                sb, sa, log_ = _saturate({n: bonds_graph[n].copy() for n in order}, unsaturated, need_radicals,
+                                         expected_charge - sum(charges.values()))
+                if not log_:  # success
+                    break
+            else:  # failed
+                if log_ == 1:
+                    log.append('Charge state not balanced')
+                elif log_ == 2:
+                    log.append('Radical state not balanced')
+                else:
+                    log.append('Charge state not balanced')
+                    log.append('Radical state not balanced')
+                if not allow_errors:  # all attempts failed
+                    if logging:
+                        return log
+                    return False
+
+            for n, m, b in sb:
+                bonds[n][m] = bonds[m][n] = Bond(b)
+            for n, c, r in sa:
+                charges[n] = c
+                radicals[n] = r
+        elif expected_charge != sum(charges.values()):  # check charge for saturated case
+            log.append('Charge state not balanced')
+            if not allow_errors:
+                if logging:
+                    return log
+                return False
+        # reset molecule
+        self._bonds = bonds
+        self._radicals = radicals
+        self._charges = charges
+        self._hydrogens = {x: 0 for x in atoms}  # reset invalid hydrogens counts.
+        self.flush_cache()
+        if logging:
+            if not log:  # check for errors
+                log.append('Saturated successfully')
+            else:
+                log.append('Saturated with errors')
+            return log
+        return True
+
+
+def _find_possible_valences(atoms, neighbors_distances, charges, radicals, allow_deleting=True):
+    if allow_deleting:
+        possible_bonds = {n: md.copy() for n, md in neighbors_distances.items()}
+    else:
+        possible_bonds = {n: list(md) for n, md in neighbors_distances.items()}
+    while True:
+        saturation = defaultdict(set)
+        for n, env in possible_bonds.items():
+            env_atoms = None
+            el = len(env)
+            dc = charges[n]
+            dr = radicals[n]
+            for charge, is_radical, valence, implicit, explicit_dict in atoms[n]._compiled_saturation_rules:
+                if valence < el or dc is not None and dc != charge or dr is not None and dr != is_radical:
+                    continue  # skip impossible rules
+                if explicit_dict:
+                    if env_atoms is None:  # lazy caching
+                        env_atoms = defaultdict(int)
+                        for m in env:
+                            env_atoms[atoms[m].atomic_number] += 1
+                    env_atoms_copy = env_atoms.copy()
+                    for (b, a), c in explicit_dict.items():  # stage 1. find explicit valence
+                        if env_atoms_copy[a] < c:  # `c` always > 0
+                            break  # rule not matched
+                        env_atoms_copy[a] -= c
+                    else:  # stage 2. find possible valence
+                        if unmatched := sum(env_atoms_copy.values()):  # number of atoms outside rule
+                            if implicit >= unmatched:
+                                # number of implicit H should be greater or equal to number of neighbors
+                                saturation[n].add((charge, is_radical, valence - el))
+                        else:  # pattern fully matched. difference bw valence and connectivity is unsaturation.
+                            saturation[n].add((charge, is_radical, valence - el))
+                else:   # unspecific rule. found possible valence
+                    saturation[n].add((charge, is_radical, valence - el))
+            if n not in saturation:  # valence not found
+                break
+        else:  # all atoms passed
+            break
+        if allow_deleting:
+            out = max(env.items(), key=itemgetter(1))[0]
+            del possible_bonds[out][n]
+            del possible_bonds[n][out]
+        else:
+            raise ValenceError('Structure has invalid atoms neighbors count and electron states')
+    return saturation, possible_bonds
+
+
+def _saturate(bonds, atoms, expected_radicals_count, expected_charge):
+    atoms = {k: v.copy() for k, v in atoms.items()}
+    dots = []
+    saturation = []
+    electrons = []
+    while True:
+        # get isolated atoms. atoms should be charged or radical
+        to_del = []
+        for n, env in bonds.items():
+            if not env:
+                es = [(n, c, r) for c, r, h in atoms[n] if not h]
+                if not es:
+                    return  # saturation impossible
+                to_del.append(n)
+                dots.append(es)
+        for n in to_del:
+            del bonds[n]
+        if not bonds:
+            break
+
+        try:  # get terminal atom
+            n = next(n for n, ms in bonds.items() if len(ms) == 1)
+        except StopIteration:
+            # get ring or linker atom
+            n, _ = min(bonds.items(), key=lambda x: len(x[1]))
+            m = bonds[n].pop()
+            bonds[m].discard(n)
+
+            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
+                if nh == mh:
+                    saturation.append((n, m, nh + 1))
+                    electrons.append((n, nc, nr))
+                    electrons.append((m, mc, mr))
+
+                    for x in bonds.pop(n):
+                        saturation.append((n, x, 1))
+                        bonds[x].discard(n)
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+                elif nh < mh:
+                    electrons.append((n, nc, nr))
+                    saturation.append((n, m, nh + 1))
+                    atoms[m].pop(i)
+                    atoms[m].insert(i, (mc, mr, mh - nh))
+
+                    for x in bonds.pop(n):
+                        saturation.append((n, x, 1))
+                        bonds[x].discard(n)
+                    break
+                elif nh > mh:
+                    electrons.append((m, mc, mr))
+                    saturation.append((n, m, mh + 1))
+                    atoms[n].pop(i)
+                    atoms[n].insert(i, (nc, nr, nh - mh))
+
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+        else:
+            m = bonds.pop(n).pop()
+            bonds[m].discard(n)
+
+            for (nc, nr, nh), (i, (mc, mr, mh)) in product(atoms[n], enumerate(atoms[m])):
+                if nh == mh:
+                    saturation.append((n, m, nh + 1))
+                    electrons.append((n, nc, nr))
+                    electrons.append((m, mc, mr))
+                    for x in bonds.pop(m):
+                        saturation.append((m, x, 1))
+                        bonds[x].discard(m)
+                    break
+                elif nh < mh and bonds[m]:
+                    electrons.append((n, nc, nr))
+                    saturation.append((n, m, nh + 1))
+                    atoms[m].pop(i)
+                    atoms[m].insert(i, (mc, mr, mh - nh))
+                    break
+            else:
+                saturation.append((n, m, 1))
+                if not bonds[m]:
+                    del bonds[m]
+
+    combo_ua = []  # possible single atoms electron states
+    for s in dots:
+        if len(s) == 1:
+            electrons.extend(s)
+        elif s:
+            combo_ua.append(s)
+
+    # if < 0 - we already in bad situation
+    # if > 0 - we need more radicals
+    need_radical = expected_radicals_count - sum(x for _, _, x in electrons)
+    need_charge = expected_charge - sum(x for _, x, _ in electrons)
+    if combo_ua:
+        # try randomly set charges and radicals.
+        # first pick required radical states.
+        # second try to minimize charge delta.
+        for attempt in range(1, len(combo_ua) + 1):
+            shuffle(combo_ua)
+            charges_radicals = []
+            rad = []
+            chg = []
+            for atom in combo_ua:
+                if len(rad) < need_radical:  # pick radicals
+                    r = next((x for x in atom if x[2]), None)
+                    if r:  # pick random radical states
+                        rad.append(r)
+                    else:  # not radical
+                        chg.append(atom)
+                else:  # pick not radical states
+                    c = [x for x in atom if not x[2]]
+                    if len(c) > 1:
+                        chg.append(c)
+                    elif c:
+                        charges_radicals.extend(c)
+                    elif attempt == len(combo_ua):  # all states has radical. balancing impossible
+                        chg.append(atom)  # fuck it horse. we in last attempt
+                    else:  # do next attempt
+                        break
+            else:
+                charges_radicals.extend(rad)
+                current_charge = need_charge - sum(x for _, x, _ in charges_radicals)
+                current_radical = need_radical - len(rad)
+                for x in chg:
+                    n, c, r = min(x, key=lambda x: abs(current_charge - x[1]))
+                    charges_radicals.append((n, c, r))
+                    current_charge -= c
+                    current_radical -= r
+
+                if current_radical:  # radical unbalanced
+                    if current_charge:
+                        log = 3
+                    else:
+                        log = 2
+                elif current_charge:
+                    log = 1
+                else:  # balanced!
+                    log = 0
+                    break
+
+        electrons.extend(charges_radicals)
+    elif need_radical:
+        log = 3 if need_charge else 2
+    elif need_charge:
+        log = 1
+    else:
+        log = 0
+    return saturation, electrons, log
+
+
+__all__ = ['Saturation']
```

### Comparing `chython-1.67/chython/algorithms/stereo/__init__.py` & `chython-1.8/chython/algorithms/stereo/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .graph import *
-from .molecule import *
-
-
-__all__ = ['MoleculeStereo', 'Stereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .graph import *
+from .molecule import *
+
+
+__all__ = ['MoleculeStereo', 'Stereo']
```

### Comparing `chython-1.67/chython/algorithms/stereo/graph.py` & `chython-1.8/chython/algorithms/stereo/graph.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,449 +1,435 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from functools import cached_property
-from typing import Dict, Optional, Tuple, TYPE_CHECKING, Union
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer, QueryContainer
-    Container = Union[MoleculeContainer, QueryContainer]
-
-
-_heteroatoms = {5, 6, 7, 8, 14, 15, 16, 17, 33, 34, 35, 52, 53}
-
-# 1  2
-#  \ |
-#   \|
-#    n---3
-#   /
-#  /
-# 0
-_tetrahedron_translate = {(0, 1, 2): False, (1, 2, 0): False, (2, 0, 1): False,
-                          (0, 2, 1): True, (1, 0, 2): True, (2, 1, 0): True,
-                          (0, 3, 1): False, (3, 1, 0): False, (1, 0, 3): False,
-                          (0, 1, 3): True, (1, 3, 0): True, (3, 0, 1): True,
-                          (0, 2, 3): False, (2, 3, 0): False, (3, 0, 2): False,
-                          (0, 3, 2): True, (3, 2, 0): True, (2, 0, 3): True,
-                          (1, 3, 2): False, (3, 2, 1): False, (2, 1, 3): False,
-                          (1, 2, 3): True, (2, 3, 1): True, (3, 1, 2): True}
-# 2       1
-#  \     /
-#   n---m
-#  /     \
-# 0       3
-_alkene_translate = {(0, 1): False, (1, 0): False, (0, 3): True, (3, 0): True,
-                     (2, 3): False, (3, 2): False, (2, 1): True, (1, 2): True}
-
-# allowed atoms. these atoms have stable covalent bonds.
-_organic_subset = {1, 5, 6, 7, 8, 9, 14, 15, 16, 17, 33, 34, 35, 52, 53}
-
-
-class Stereo:
-    __slots__ = ()
-
-    @cached_property
-    def cumulenes(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Alkenes, allenes and cumulenes atoms numbers.
-        """
-        return tuple(self._cumulenes())
-
-    @cached_property
-    def tetrahedrons(self: 'Container') -> Tuple[int, ...]:
-        """
-        Carbon sp3 atoms numbers.
-        """
-        atoms = self._atoms
-        bonds = self._bonds
-        charges = self._charges
-        radicals = self._radicals
-
-        tetra = []
-        for n, atom in atoms.items():
-            if atom.atomic_number == 6 and not charges[n] and not radicals[n]:
-                env = bonds[n]
-                if all(int(x) == 1 for x in env.values()):
-                    if sum(int(x) for x in env.values()) > 4:
-                        continue
-                    tetra.append(n)
-        return tuple(tetra)
-
-    def clean_stereo(self: 'Container'):
-        """
-        Remove stereo data.
-        """
-        self._atoms_stereo.clear()
-        self._allenes_stereo.clear()
-        self._cis_trans_stereo.clear()
-        self.flush_cache()
-
-    def get_mapping(self: 'Container', other: 'Container', **kwargs):
-        atoms_stereo = self._atoms_stereo
-        allenes_stereo = self._allenes_stereo
-        cis_trans_stereo = self._cis_trans_stereo
-        if atoms_stereo or allenes_stereo or cis_trans_stereo:
-            other_atoms_stereo = other._atoms_stereo
-            other_allenes_stereo = other._allenes_stereo
-            other_cis_trans_stereo = other._cis_trans_stereo
-            other_translate_tetrahedron_sign = other._translate_tetrahedron_sign
-            other_translate_allene_sign = other._translate_allene_sign
-            other_translate_cis_trans_sign = other._translate_cis_trans_sign
-
-            tetrahedrons = self._stereo_tetrahedrons
-            cis_trans = self._stereo_cis_trans
-            allenes = self._stereo_allenes
-
-            for mapping in super().get_mapping(other, **kwargs):
-                for n, s in atoms_stereo.items():
-                    m = mapping[n]
-                    if m not in other_atoms_stereo:  # self stereo atom not stereo in other
-                        break
-                    # translate stereo mark in other in order of self tetrahedron
-                    if other_translate_tetrahedron_sign(m, [mapping[x] for x in tetrahedrons[n]]) != s:
-                        break
-                else:
-                    for n, s in allenes_stereo.items():
-                        m = mapping[n]
-                        if m not in other_allenes_stereo:  # self stereo allene not stereo in other
-                            break
-                        # translate stereo mark in other in order of self allene
-                        nn, nm, *_ = allenes[n]
-                        if other_translate_allene_sign(m, mapping[nn], mapping[nm]) != s:
-                            break
-                    else:
-                        for nm, s in cis_trans_stereo.items():
-                            n, m = nm
-                            on, om = mapping[n], mapping[m]
-                            if (on, om) not in other_cis_trans_stereo:
-                                if (om, on) not in other_cis_trans_stereo:
-                                    break  # self stereo cis_trans not stereo in other
-                                else:
-                                    nn, nm, *_ = cis_trans[nm]
-                                    if other_translate_cis_trans_sign(om, on, mapping[nm], mapping[nn]) != s:
-                                        break
-                            else:
-                                nn, nm, *_ = cis_trans[nm]
-                                if other_translate_cis_trans_sign(on, om, mapping[nn], mapping[nm]) != s:
-                                    break
-                        else:
-                            yield mapping
-        else:
-            yield from super().get_mapping(other, **kwargs)
-
-    def _translate_tetrahedron_sign(self: 'Container', n, env, s=None):
-        """
-        Get sign of chiral tetrahedron atom for specified neighbors order
-
-        :param n: stereo atom
-        :param env: neighbors order
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            s = self._atoms_stereo[n]
-
-        order = self._stereo_tetrahedrons[n]
-        if len(order) == 3:
-            if len(env) == 4:  # hydrogen atom passed to env
-                atoms = self._atoms
-                # hydrogen always last in order
-                try:
-                    order = (*order, next(x for x in env if atoms[x].atomic_number == 1))  # see translate scheme
-                except StopIteration:
-                    raise KeyError
-            elif len(env) != 3:  # pyramid or tetrahedron expected
-                raise ValueError('invalid atoms list')
-        elif len(env) not in (3, 4):  # pyramid or tetrahedron expected
-            raise ValueError('invalid atoms list')
-
-        translate = tuple(order.index(x) for x in env[:3])
-        if _tetrahedron_translate[translate]:
-            return not s
-        return s
-
-    def _translate_cis_trans_sign(self: 'Container', n, m, nn, nm, s=None):
-        """
-        Get sign for specified opposite neighbors
-
-        :param n: first double bonded atom
-        :param m: last double bonded atom
-        :param nn: neighbor of first atom
-        :param nm: neighbor of last atom
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            try:
-                s = self._cis_trans_stereo[(n, m)]
-            except KeyError:
-                s = self._cis_trans_stereo[(m, n)]
-                n, m = m, n  # in alkenes sign not order depended
-                nn, nm = nm, nn
-
-        atoms = self._atoms
-        n0, n1, n2, n3 = self._stereo_cis_trans[(n, m)]
-        if nn == n0:  # same start
-            t0 = 0
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n1:
-            t0 = 1
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
-            t0 = 2
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
-            t0 = 3
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        else:
-            raise KeyError
-
-        if _alkene_translate[(t0, t1)]:
-            return not s
-        return s
-
-    def _translate_allene_sign(self: 'Container', c, nn, nm, s=None):
-        """
-        get sign for specified opposite neighbors
-
-        :param c: central double bonded atom
-        :param nn: neighbor of first double bonded atom
-        :param nm: neighbor of last double bonded atom
-        :param s: if None, use existing sign else translate given to molecule
-        """
-        if s is None:
-            s = self._allenes_stereo[c]
-
-        atoms = self._atoms
-        n0, n1, n2, n3 = self._stereo_allenes[c]
-        if nn == n0:  # same start
-            t0 = 0
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n1:
-            t0 = 1
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
-            t0 = 2
-            if nm == n1:
-                t1 = 1
-            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
-                t1 = 3
-            else:
-                raise KeyError
-        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
-            t0 = 3
-            if nm == n0:
-                t1 = 0
-            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
-                t1 = 2
-            else:
-                raise KeyError
-        else:
-            raise KeyError
-
-        if _alkene_translate[(t0, t1)]:
-            return not s
-        return s
-
-    def _cumulenes(self: 'Container', heteroatoms=False):
-        atoms = self._atoms
-        bonds = self._bonds
-
-        adj = defaultdict(set)  # double bonds adjacency matrix
-        if heteroatoms:
-            for n, atom in atoms.items():
-                if atom.atomic_number in _heteroatoms:
-                    adj_n = adj[n].add
-                    for m, bond in bonds[n].items():
-                        if int(bond) == 2 and atoms[m].atomic_number in _heteroatoms:
-                            adj_n(m)
-        else:
-            for n, atom in atoms.items():
-                if atom.atomic_number == 6:
-                    adj_n = adj[n].add
-                    for m, bond in bonds[n].items():
-                        if int(bond) == 2 and atoms[m].atomic_number == 6:
-                            adj_n(m)
-        if not adj:
-            return ()
-
-        terminals = [x for x, y in adj.items() if len(y) == 1]
-        cumulenes = []
-        while terminals:
-            n = terminals.pop(0)
-            m = adj[n].pop()
-            path = [n, m]
-            while m not in terminals:
-                adj_m = adj[m]
-                if len(adj_m) > 2:  # not cumulene. SO3 etc.
-                    cumulenes.extend(zip(path, path[1:]))  # keep single double bonds.
-                    break
-                adj_m.discard(n)
-                n, m = m, adj_m.pop()
-                path.append(m)
-            else:
-                terminals.remove(m)
-                adj[m].pop()
-                cumulenes.append(tuple(path))
-        return cumulenes
-
-    @cached_property
-    def _stereo_cumulenes(self: 'Container') -> Dict[Tuple[int, ...], Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Cumulenes which contains at least one non-hydrogen neighbor on both ends
-        """
-        # 5       4
-        #  \     /
-        #   2---3
-        #  /     \
-        # 1       6
-        bonds = self._bonds
-        atoms = self._atoms
-        cumulenes = {}
-        for path in self.cumulenes:
-            nf = bonds[path[0]]
-            nl = bonds[path[-1]]
-            n1, m1 = path[1], path[-2]
-            if any(b.order == 3 or atoms[m].atomic_number not in _organic_subset and b.order != 8
-                   for m, b in nf.items() if m != n1):
-                continue  # skip X=C=C structures and metal-carbon complexes
-            if any(b.order == 3 or atoms[m].atomic_number not in _organic_subset and b.order != 8
-                   for m, b in nl.items() if m != m1):
-                continue  # skip X=C=C structures and metal-carbon complexes
-            nn = [x for x, b in nf.items() if x != n1 and atoms[x].atomic_number != 1 and b.order != 8]
-            mn = [x for x, b in nl.items() if x != m1 and atoms[x].atomic_number != 1 and b.order != 8]
-            if nn and mn:
-                sn = nn[1] if len(nn) == 2 else None
-                sm = mn[1] if len(mn) == 2 else None
-                cumulenes[path] = (nn[0], mn[0], sn, sm)
-        return cumulenes
-
-    @cached_property
-    def _stereo_tetrahedrons(self: 'Container') -> Dict[int, Union[Tuple[int, int, int], Tuple[int, int, int, int]]]:
-        """
-        Tetrahedrons which contains at least 3 non-hydrogen neighbors
-        """
-        #    2
-        #    |
-        # 1--K--3
-        #    |
-        #    4?
-        atoms = self._atoms
-        bonds = self._bonds
-        tetrahedrons = {}
-        for n in self.tetrahedrons:
-            if any(atoms[x].atomic_number not in _organic_subset for x in bonds[n]):
-                continue  # skip metal-carbon complexes
-            env = tuple(x for x in bonds[n] if atoms[x].atomic_number != 1)
-            if len(env) in (3, 4):
-                tetrahedrons[n] = env
-        return tetrahedrons
-
-    @cached_property
-    def _stereo_cis_trans(self) -> Dict[Tuple[int, int], Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Cis-trans bonds which contains at least one non-hydrogen neighbor on both ends
-        """
-        return {(n, m): env for (n, *mid, m), env in self._stereo_cumulenes.items() if not len(mid) % 2}
-
-    @cached_property
-    def _stereo_cis_trans_paths(self) -> Dict[Tuple[int, int], Tuple[int, ...]]:
-        return {(path[0], path[-1]): path for path in self._stereo_cumulenes if not len(path) % 2}
-
-    @cached_property
-    def _stereo_cis_trans_terminals(self) -> Dict[int, Tuple[int, int]]:
-        """
-        Cis-Trans terminal atoms to cis-trans key mapping
-        """
-        terminals = {}
-        for nm in self._stereo_cis_trans_paths:
-            n, m = nm
-            terminals[n] = terminals[m] = nm
-        return terminals
-
-    @cached_property
-    def _stereo_cis_trans_counterpart(self) -> Dict[int, int]:
-        """
-        Cis-Trans terminal atoms counterparts
-        """
-        counterpart = {}
-        for nm in self._stereo_cis_trans_paths:
-            n, m = nm
-            counterpart[n] = m
-            counterpart[m] = n
-        return counterpart
-
-    @cached_property
-    def _stereo_allenes(self) -> Dict[int, Tuple[int, int, Optional[int], Optional[int]]]:
-        """
-        Allenes which contains at least one non-hydrogen neighbor on both ends
-        """
-        return {path[len(path) // 2]: env for path, env in self._stereo_cumulenes.items() if len(path) % 2}
-
-    @cached_property
-    def _stereo_allenes_centers(self) -> Dict[int, int]:
-        """
-        Allene terminal atom to center mapping
-        """
-        terminals = {}
-        for c, (n, m) in self._stereo_allenes_terminals.items():
-            terminals[n] = terminals[m] = c
-        return terminals
-
-    @cached_property
-    def _stereo_allenes_terminals(self) -> Dict[int, Tuple[int, int]]:
-        """
-        Allene center atom to terminals mapping
-        """
-        return {c: (path[0], path[-1]) for c, path in self._stereo_allenes_paths.items()}
-
-    @cached_property
-    def _stereo_allenes_paths(self) -> Dict[int, Tuple[int, ...]]:
-        return {path[len(path) // 2]: path for path in self._stereo_cumulenes if len(path) % 2}
-
-
-__all__ = ['Stereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from functools import cached_property
+from typing import Dict, Optional, Tuple, TYPE_CHECKING, Union
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer, QueryContainer
+    Container = Union[MoleculeContainer, QueryContainer]
+
+
+_heteroatoms = {5, 6, 7, 8, 14, 15, 16, 17, 33, 34, 35, 52, 53}
+
+# 1  2
+#  \ |
+#   \|
+#    n---3
+#   /
+#  /
+# 0
+_tetrahedron_translate = {(0, 1, 2): False, (1, 2, 0): False, (2, 0, 1): False,
+                          (0, 2, 1): True, (1, 0, 2): True, (2, 1, 0): True,
+                          (0, 3, 1): False, (3, 1, 0): False, (1, 0, 3): False,
+                          (0, 1, 3): True, (1, 3, 0): True, (3, 0, 1): True,
+                          (0, 2, 3): False, (2, 3, 0): False, (3, 0, 2): False,
+                          (0, 3, 2): True, (3, 2, 0): True, (2, 0, 3): True,
+                          (1, 3, 2): False, (3, 2, 1): False, (2, 1, 3): False,
+                          (1, 2, 3): True, (2, 3, 1): True, (3, 1, 2): True}
+# 2       1
+#  \     /
+#   n---m
+#  /     \
+# 0       3
+_alkene_translate = {(0, 1): False, (1, 0): False, (0, 3): True, (3, 0): True,
+                     (2, 3): False, (3, 2): False, (2, 1): True, (1, 2): True}
+
+# allowed atoms. these atoms have stable covalent bonds.
+_organic_subset = {1, 5, 6, 7, 8, 9, 14, 15, 16, 17, 33, 34, 35, 52, 53}
+
+
+class Stereo:
+    __slots__ = ()
+
+    @cached_property
+    def cumulenes(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        Alkenes, allenes and cumulenes atoms numbers.
+        """
+        return tuple(self._cumulenes())
+
+    @cached_property
+    def tetrahedrons(self: 'Container') -> Tuple[int, ...]:
+        """
+        Carbon sp3 atoms numbers.
+        """
+        atoms = self._atoms
+        bonds = self._bonds
+        charges = self._charges
+        radicals = self._radicals
+
+        tetra = []
+        for n, atom in atoms.items():
+            if atom.atomic_number == 6 and not charges[n] and not radicals[n]:
+                env = bonds[n]
+                if all(x == 1 for x in env.values()):
+                    if sum(int(x) for x in env.values()) > 4:
+                        continue
+                    tetra.append(n)
+        return tuple(tetra)
+
+    def clean_stereo(self: 'Container'):
+        """
+        Remove stereo data.
+        """
+        self._atoms_stereo.clear()
+        self._allenes_stereo.clear()
+        self._cis_trans_stereo.clear()
+        self.flush_cache()
+
+    def get_mapping(self: 'Container', other: 'Container', **kwargs):
+        atoms_stereo = self._atoms_stereo
+        allenes_stereo = self._allenes_stereo
+        cis_trans_stereo = self._cis_trans_stereo
+        if atoms_stereo or allenes_stereo or cis_trans_stereo:
+            other_atoms_stereo = other._atoms_stereo
+            other_allenes_stereo = other._allenes_stereo
+            other_cis_trans_stereo = other._cis_trans_stereo
+            other_translate_tetrahedron_sign = other._translate_tetrahedron_sign
+            other_translate_allene_sign = other._translate_allene_sign
+            other_translate_cis_trans_sign = other._translate_cis_trans_sign
+
+            tetrahedrons = self._stereo_tetrahedrons
+            cis_trans = self._stereo_cis_trans
+            allenes = self._stereo_allenes
+
+            for mapping in super().get_mapping(other, **kwargs):
+                for n, s in atoms_stereo.items():
+                    m = mapping[n]
+                    if m not in other_atoms_stereo:  # self stereo atom not stereo in other
+                        break
+                    # translate stereo mark in other in order of self tetrahedron
+                    if other_translate_tetrahedron_sign(m, [mapping[x] for x in tetrahedrons[n]]) != s:
+                        break
+                else:
+                    for n, s in allenes_stereo.items():
+                        m = mapping[n]
+                        if m not in other_allenes_stereo:  # self stereo allene not stereo in other
+                            break
+                        # translate stereo mark in other in order of self allene
+                        nn, nm, *_ = allenes[n]
+                        if other_translate_allene_sign(m, mapping[nn], mapping[nm]) != s:
+                            break
+                    else:
+                        for nm, s in cis_trans_stereo.items():
+                            n, m = nm
+                            on, om = mapping[n], mapping[m]
+                            if (on, om) not in other_cis_trans_stereo:
+                                if (om, on) not in other_cis_trans_stereo:
+                                    break  # self stereo cis_trans not stereo in other
+                                else:
+                                    nn, nm, *_ = cis_trans[nm]
+                                    if other_translate_cis_trans_sign(om, on, mapping[nm], mapping[nn]) != s:
+                                        break
+                            else:
+                                nn, nm, *_ = cis_trans[nm]
+                                if other_translate_cis_trans_sign(on, om, mapping[nn], mapping[nm]) != s:
+                                    break
+                        else:
+                            yield mapping
+        else:
+            yield from super().get_mapping(other, **kwargs)
+
+    def _translate_tetrahedron_sign(self: 'Container', n, env, s=None):
+        """
+        Get sign of chiral tetrahedron atom for specified neighbors order
+
+        :param n: stereo atom
+        :param env: neighbors order
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            s = self._atoms_stereo[n]
+
+        order = self._stereo_tetrahedrons[n]
+        if len(order) == 3:
+            if len(env) == 4:  # hydrogen atom passed to env
+                atoms = self._atoms
+                # hydrogen always last in order
+                try:
+                    order = (*order, next(x for x in env if atoms[x].atomic_number == 1))  # see translate scheme
+                except StopIteration:
+                    raise KeyError
+            elif len(env) != 3:  # pyramid or tetrahedron expected
+                raise ValueError('invalid atoms list')
+        elif len(env) not in (3, 4):  # pyramid or tetrahedron expected
+            raise ValueError('invalid atoms list')
+
+        translate = tuple(order.index(x) for x in env[:3])
+        if _tetrahedron_translate[translate]:
+            return not s
+        return s
+
+    def _translate_cis_trans_sign(self: 'Container', n, m, nn, nm, s=None):
+        """
+        Get sign for specified opposite neighbors
+
+        :param n: first double bonded atom
+        :param m: last double bonded atom
+        :param nn: neighbor of first atom
+        :param nm: neighbor of last atom
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            try:
+                s = self._cis_trans_stereo[(n, m)]
+            except KeyError:
+                s = self._cis_trans_stereo[(m, n)]
+                n, m = m, n  # in alkenes sign not order depended
+                nn, nm = nm, nn
+
+        atoms = self._atoms
+        n0, n1, n2, n3 = self._stereo_cis_trans[(n, m)]
+        if nn == n0:  # same start
+            t0 = 0
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n1:
+            t0 = 1
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
+            t0 = 2
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
+            t0 = 3
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        else:
+            raise KeyError
+
+        if _alkene_translate[(t0, t1)]:
+            return not s
+        return s
+
+    def _translate_allene_sign(self: 'Container', c, nn, nm, s=None):
+        """
+        get sign for specified opposite neighbors
+
+        :param c: central double bonded atom
+        :param nn: neighbor of first double bonded atom
+        :param nm: neighbor of last double bonded atom
+        :param s: if None, use existing sign else translate given to molecule
+        """
+        if s is None:
+            s = self._allenes_stereo[c]
+
+        atoms = self._atoms
+        n0, n1, n2, n3 = self._stereo_allenes[c]
+        if nn == n0:  # same start
+            t0 = 0
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n1:
+            t0 = 1
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        elif nn == n2 or n2 is None and atoms[nn].atomic_number == 1:
+            t0 = 2
+            if nm == n1:
+                t1 = 1
+            elif nm == n3 or n3 is None and atoms[nm].atomic_number == 1:
+                t1 = 3
+            else:
+                raise KeyError
+        elif nn == n3 or n3 is None and atoms[nn].atomic_number == 1:
+            t0 = 3
+            if nm == n0:
+                t1 = 0
+            elif nm == n2 or n2 is None and atoms[nm].atomic_number == 1:
+                t1 = 2
+            else:
+                raise KeyError
+        else:
+            raise KeyError
+
+        if _alkene_translate[(t0, t1)]:
+            return not s
+        return s
+
+    def _cumulenes(self: 'Container', heteroatoms=False):
+        atoms = self._atoms
+        bonds = self._bonds
+
+        adj = defaultdict(set)  # double bonds adjacency matrix
+        if heteroatoms:
+            for n, atom in atoms.items():
+                if atom.atomic_number in _heteroatoms:
+                    adj_n = adj[n].add
+                    for m, bond in bonds[n].items():
+                        if bond == 2 and atoms[m].atomic_number in _heteroatoms:
+                            adj_n(m)
+        else:
+            for n, atom in atoms.items():
+                if atom.atomic_number == 6:
+                    adj_n = adj[n].add
+                    for m, bond in bonds[n].items():
+                        if bond == 2 and atoms[m].atomic_number == 6:
+                            adj_n(m)
+        if not adj:
+            return ()
+
+        terminals = [x for x, y in adj.items() if len(y) == 1]
+        cumulenes = []
+        while terminals:
+            n = terminals.pop(0)
+            m = adj[n].pop()
+            path = [n, m]
+            while m not in terminals:
+                adj_m = adj[m]
+                if len(adj_m) > 2:  # not cumulene. SO3 etc.
+                    cumulenes.extend(zip(path, path[1:]))  # keep single double bonds.
+                    break
+                adj_m.discard(n)
+                n, m = m, adj_m.pop()
+                path.append(m)
+            else:
+                terminals.remove(m)
+                adj[m].pop()
+                cumulenes.append(tuple(path))
+        return cumulenes
+
+    @cached_property
+    def _stereo_cumulenes(self: 'Container') -> Dict[Tuple[int, ...], Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Cumulenes which contains at least one non-hydrogen neighbor on both ends
+        """
+        # 5       4
+        #  \     /
+        #   2---3
+        #  /     \
+        # 1       6
+        bonds = self._bonds
+        atoms = self._atoms
+        cumulenes = {}
+        for path in self.cumulenes:
+            nf = bonds[path[0]]
+            nl = bonds[path[-1]]
+            n1, m1 = path[1], path[-2]
+            if any(b not in (1, 4) and atoms[m].atomic_number not in _organic_subset for m, b in nf.items() if m != n1)\
+                    or any(b not in (1, 4) and atoms[m].atomic_number not in _organic_subset
+                           for m, b in nl.items() if m != m1):
+                continue  # skip X=C=C structures and metal-carbon complexes
+            nn = [x for x in nf if x != n1 and atoms[x].atomic_number != 1]
+            mn = [x for x in nl if x != m1 and atoms[x].atomic_number != 1]
+            if nn and mn:
+                sn = nn[1] if len(nn) == 2 else None
+                sm = mn[1] if len(mn) == 2 else None
+                cumulenes[path] = (nn[0], mn[0], sn, sm)
+        return cumulenes
+
+    @cached_property
+    def _stereo_tetrahedrons(self: 'Container') -> Dict[int, Union[Tuple[int, int, int], Tuple[int, int, int, int]]]:
+        """
+        Tetrahedrons which contains at least 3 non-hydrogen neighbors
+        """
+        #    2
+        #    |
+        # 1--K--3
+        #    |
+        #    4?
+        atoms = self._atoms
+        bonds = self._bonds
+        tetrahedrons = {}
+        for n in self.tetrahedrons:
+            if any(atoms[x].atomic_number not in _organic_subset for x in bonds[n]):
+                continue  # skip metal-carbon complexes
+            env = tuple(x for x in bonds[n] if atoms[x].atomic_number != 1)
+            if len(env) in (3, 4):
+                tetrahedrons[n] = env
+        return tetrahedrons
+
+    @cached_property
+    def _stereo_cis_trans(self) -> Dict[Tuple[int, int], Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Cis-trans bonds which contains at least one non-hydrogen neighbor on both ends
+        """
+        return {(n, m): env for (n, *mid, m), env in self._stereo_cumulenes.items() if not len(mid) % 2}
+
+    @cached_property
+    def _stereo_cis_trans_paths(self) -> Dict[Tuple[int, int], Tuple[int, ...]]:
+        return {(path[0], path[-1]): path for path in self._stereo_cumulenes if not len(path) % 2}
+
+    @cached_property
+    def _stereo_cis_trans_terminals(self) -> Dict[int, Tuple[int, int]]:
+        """
+        Cis-Trans terminal atoms to cis-trans key mapping
+        """
+        terminals = {}
+        for nm in self._stereo_cis_trans_paths:
+            n, m = nm
+            terminals[n] = terminals[m] = nm
+        return terminals
+
+    @cached_property
+    def _stereo_allenes(self) -> Dict[int, Tuple[int, int, Optional[int], Optional[int]]]:
+        """
+        Allenes which contains at least one non-hydrogen neighbor on both ends
+        """
+        return {path[len(path) // 2]: env for path, env in self._stereo_cumulenes.items() if len(path) % 2}
+
+    @cached_property
+    def _stereo_allenes_centers(self) -> Dict[int, int]:
+        """
+        Allene terminal atom to center mapping
+        """
+        terminals = {}
+        for c, (n, m) in self._stereo_allenes_terminals.items():
+            terminals[n] = terminals[m] = c
+        return terminals
+
+    @cached_property
+    def _stereo_allenes_terminals(self) -> Dict[int, Tuple[int, int]]:
+        """
+        Allene center atom to terminals mapping
+        """
+        return {c: (path[0], path[-1]) for c, path in self._stereo_allenes_paths.items()}
+
+    @cached_property
+    def _stereo_allenes_paths(self) -> Dict[int, Tuple[int, ...]]:
+        return {path[len(path) // 2]: path for path in self._stereo_cumulenes if len(path) % 2}
+
+
+__all__ = ['Stereo']
```

### Comparing `chython-1.67/chython/algorithms/stereo/molecule.py` & `chython-1.8/chython/algorithms/stereo/molecule.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,809 +1,754 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from functools import cached_property
-from itertools import combinations, product
-from logging import getLogger, INFO
-from typing import Dict, Set, Tuple, Union, TYPE_CHECKING
-from .graph import Stereo
-from ..morgan import _morgan
-from ...exceptions import AtomNotFound, IsChiral, NotChiral
-
-
-logger = getLogger('chython.stereo')
-logger.setLevel(INFO)
-
-
-if TYPE_CHECKING:
-    from chython import MoleculeContainer
-
-
-def _pyramid_sign(n, u, v, w):
-    #
-    #  |   n /
-    #  |   |\
-    #  |   | \
-    #  |  /|  \
-    #  | / u---v
-    #  |/___\_/___
-    #        w
-    #
-    nx, ny, nz = n
-    ux, uy, uz = u
-    vx, vy, vz = v
-    wx, wy, wz = w
-
-    q1x = ux - nx
-    q1y = uy - ny
-    q1z = uz - nz
-    q2x = vx - nx
-    q2y = vy - ny
-    q2z = vz - nz
-    q3x = wx - nx
-    q3y = wy - ny
-    q3z = wz - nz
-
-    vol = q1x * (q2y * q3z - q2z * q3y) + q1y * (q2z * q3x - q2x * q3z) + q1z * (q2x * q3y - q2y * q3x)
-    if vol > 0:
-        return 1
-    elif vol < 0:
-        return -1
-    return 0
-
-
-def _cis_trans_sign(n, u, v, w):
-    # n      w
-    #  \    /
-    #   u--v
-    #  /    \
-    # x      x
-    nx, ny = n
-    ux, uy = u
-    vx, vy = v
-    wx, wy = w
-
-    q1x = ux - nx
-    q1y = uy - ny
-    q2x = vx - ux
-    q2y = vy - uy
-    q3x = wx - vx
-    q3y = wy - vy
-
-    # cross vectors
-    q1q2z = q1x * q2y - q1y * q2x
-    q2q3z = q2x * q3y - q2y * q3x
-
-    dot = q1q2z * q2q3z
-    if dot > 0:
-        return 1
-    elif dot < 0:
-        return -1
-    return 0
-
-
-def _allene_sign(mark, u, v, w):
-    # n    w
-    # |   /
-    # u--v
-    ux, uy = u
-    vx, vy = v
-    wx, wy = w
-
-    q2x = vx - ux
-    q2y = vy - uy
-    q3x = wx - vx
-    q3y = wy - vy
-
-    # cross vectors
-    q2q3z = q2x * q3y - q2y * q3x
-
-    dot = -mark * q2q3z
-    if dot > 0:
-        return 1
-    elif dot < 0:
-        return -1
-    return 0
-
-
-class MoleculeStereo(Stereo):
-    __slots__ = ()
-
-    def add_wedge(self: 'MoleculeContainer', n: int, m: int, mark: int, *, clean_cache=True):
-        """
-        Add stereo data by wedge notation of bonds. Use it for tetrahedrons of allenes.
-
-        :param n: number of atom from which wedge bond started
-        :param m: number of atom to which wedge bond coming
-        :param mark: up bond is 1, down is -1
-        """
-        if n not in self._atoms:
-            raise AtomNotFound
-        if n in self._atoms_stereo:
-            raise IsChiral
-
-        plane = self._plane
-        if n in self._chiral_tetrahedrons:
-            if m not in self._bonds[n]:
-                raise AtomNotFound
-            th = self._stereo_tetrahedrons[n]
-            if self._atoms[m].atomic_number == 1:
-                s = _pyramid_sign((*plane[m], mark), *((*plane[x], 0) for x in th))
-            else:
-                order = [(*plane[x], mark if x == m else 0) for x in th]
-                if len(order) == 3:
-                    if len(self._bonds[n]) == 4:  # explicit hydrogen
-                        x = next(x for x in self._bonds[n] if x not in th)
-                        s = _pyramid_sign((*plane[x], 0), *order)
-                    else:
-                        s = _pyramid_sign((*plane[n], 0), *order)
-                else:
-                    s = _pyramid_sign(order[-1], *order[:3])
-            if s:
-                self._atoms_stereo[n] = s > 0
-                if clean_cache:
-                    self.flush_cache()
-        else:
-            c = self._stereo_allenes_centers.get(n)
-            if c:
-                if c in self._allenes_stereo:
-                    raise IsChiral
-                elif c not in self._chiral_allenes:
-                    raise NotChiral
-
-                t1, t2 = self._stereo_allenes_terminals[c]
-                order = self._stereo_allenes[c]
-                if self._atoms[m].atomic_number == 1:
-                    if t1 == n:
-                        m1 = order[1]
-                    else:
-                        t1, t2 = t2, t1
-                        m1 = order[0]
-                    r = True
-                else:
-                    w = order.index(m)
-                    if w == 0:
-                        m1 = order[1]
-                        r = False
-                    elif w == 1:
-                        m1 = order[0]
-                        t1, t2 = t2, t1
-                        r = False
-                    elif w == 2:
-                        m1 = order[1]
-                        r = True
-                    else:
-                        m1 = order[0]
-                        t1, t2 = t2, t1
-                        r = True
-                s = _allene_sign(mark, plane[t1], plane[t2], plane[m1])
-                if s:
-                    self._allenes_stereo[c] = s < 0 if r else s > 0
-                    if clean_cache:
-                        self.flush_cache()
-            else:
-                # only tetrahedrons and allenes supported
-                raise NotChiral
-
-    def calculate_cis_trans_from_2d(self: 'MoleculeContainer', *, clean_cache=True):
-        """
-        Calculate cis-trans stereo bonds from given 2d coordinates. Unusable for SMILES and INCHI.
-        """
-        cis_trans_stereo = self._cis_trans_stereo
-        plane = self._plane
-        flag = False
-        while self._chiral_cis_trans:
-            stereo = {}
-            for nm in self._chiral_cis_trans:
-                n, m = nm
-                n1, m1, *_ = self._stereo_cis_trans[nm]
-                s = _cis_trans_sign(plane[n1], plane[n], plane[m], plane[m1])
-                if s:
-                    stereo[nm] = s > 0
-            if stereo:
-                cis_trans_stereo.update(stereo)
-                flag = True
-                self.flush_stereo_cache()
-            else:
-                break
-        if flag and clean_cache:
-            self.flush_cache()
-
-    def add_atom_stereo(self: 'MoleculeContainer', n: int, env: Tuple[int, ...], mark: bool, *, clean_cache=True):
-        """
-        Add stereo data for specified neighbors bypass. Use it for tetrahedrons or allenes.
-
-        :param n: number of tetrahedron atom or central atom of allene.
-        :param env: numbers of atoms with specified bypass
-        :param mark: clockwise or anti bypass.
-
-        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html>
-        """
-        if n not in self._atoms:
-            raise AtomNotFound
-        if n in self._atoms_stereo or n in self._allenes_stereo:
-            raise IsChiral
-        if not isinstance(mark, bool):
-            raise TypeError('stereo mark should be bool')
-
-        if n in self._chiral_tetrahedrons:
-            self._atoms_stereo[n] = self._translate_tetrahedron_sign(n, env, mark)
-            if clean_cache:
-                self.flush_cache()
-        elif n in self._chiral_allenes:
-            self._allenes_stereo[n] = self._translate_allene_sign(n, *env, mark)
-            if clean_cache:
-                self.flush_cache()
-        else:  # only tetrahedrons supported
-            raise NotChiral
-
-    def add_cis_trans_stereo(self: 'MoleculeContainer', n: int, m: int, n1: int, n2: int, mark: bool, *,
-                             clean_cache=True):
-        """
-        Add stereo data to cis-trans double bonds (not allenes).
-
-        n1/n=m/n2
-
-        :param n: number of starting atom of double bonds chain (alkenes of cumulenes)
-        :param m: number of ending atom of double bonds chain (alkenes of cumulenes)
-        :param n1: number of neighboring atom of starting atom
-        :param n2: number of neighboring atom of ending atom
-        :param mark: cis or trans
-
-        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html
-        """
-        atoms = self._atoms
-        if n not in atoms or m not in atoms or n1 not in atoms or n2 not in atoms:
-            raise AtomNotFound
-        if not isinstance(mark, bool):
-            raise TypeError('stereo mark should be bool')
-        if (n, m) in self._cis_trans_stereo or (m, n) in self._cis_trans_stereo:
-            raise IsChiral
-
-        if (n, m) in self._chiral_cis_trans:
-            self._cis_trans_stereo[(n, m)] = self._translate_cis_trans_sign(n, m, n1, n2, mark)
-            if clean_cache:
-                self.flush_cache()
-        elif (m, n) in self._chiral_cis_trans:
-            self._cis_trans_stereo[(m, n)] = self._translate_cis_trans_sign(m, n, n2, n1, mark)
-            if clean_cache:
-                self.flush_cache()
-        else:
-            raise NotChiral
-
-    def flush_stereo_cache(self):
-        """
-        Flush chiral morgan and chiral centers cache.
-        """
-        self.__dict__.pop('_chiral_morgan', None)
-        self.__dict__.pop('_MoleculeStereo__chiral_centers', None)
-
-    def fix_stereo(self: 'MoleculeContainer'):
-        """
-        Reset stereo marks.
-        """
-        if self._atoms_stereo:  # filter tetrahedrons
-            stereo_tetrahedrons = self._stereo_tetrahedrons
-            atoms_stereo = {k: v for k, v in self._atoms_stereo.items() if k in stereo_tetrahedrons}
-            self._atoms_stereo = self_atoms_stereo = {}
-        else:
-            atoms_stereo = {}
-
-        if self._allenes_stereo:  # filter allenes
-            stereo_allenes = self._stereo_allenes
-            allenes_stereo = {k: v for k, v in self._allenes_stereo.items() if k in stereo_allenes}
-            self._allenes_stereo = self_allenes_stereo = {}
-        else:
-            allenes_stereo = {}
-
-        if self._cis_trans_stereo:  # filter cis-trans
-            stereo_cis_trans = self._stereo_cis_trans
-            cis_trans_stereo = {k: v for k, v in self._cis_trans_stereo.items() if k in stereo_cis_trans}
-            self._cis_trans_stereo = self_stereo_cis_trans = {}
-        else:
-            cis_trans_stereo = {}
-
-        old_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
-        while old_stereo:
-            chiral_tetrahedrons = self._chiral_tetrahedrons
-            chiral_allenes = self._chiral_allenes
-            chiral_cis_trans = self._chiral_cis_trans
-
-            tmp = {}
-            for n, s in atoms_stereo.items():
-                if n in chiral_tetrahedrons:
-                    self_atoms_stereo[n] = s
-                else:
-                    tmp[n] = s
-            atoms_stereo = tmp
-
-            tmp = {}
-            for n, s in allenes_stereo.items():
-                if n in chiral_allenes:
-                    self_allenes_stereo[n] = s
-                else:
-                    tmp[n] = s
-            allenes_stereo = tmp
-
-            tmp = {}
-            for n, s in cis_trans_stereo.items():
-                if n in chiral_cis_trans:
-                    self_stereo_cis_trans[n] = s
-                else:
-                    tmp[n] = s
-            cis_trans_stereo = tmp
-
-            fail_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
-            if fail_stereo == old_stereo:
-                break
-            old_stereo = fail_stereo
-            self.flush_stereo_cache()
-
-    @cached_property
-    def _wedge_map(self: Union['MoleculeContainer', 'MoleculeStereo']):
-        atoms_stereo = self._atoms_stereo
-        allenes_centers = self._stereo_allenes_centers
-        atoms = self._atoms
-
-        space = []
-        solved = []
-        seen = set()
-        for n, s in self._allenes_stereo.items():
-            env = self._stereo_allenes[n]
-            term = self._stereo_allenes_terminals[n]
-            orders = [(*env[:2], *term, n, True), (*env[1::-1], *term[::-1], n, True)]
-            if env[2]:
-                orders.append((env[2], env[1], *term, n, True))
-            if env[3]:
-                orders.append((env[3], env[0], *term[::-1], n, True))
-            space.append(orders)
-        for n, s in self._atoms_stereo.items():
-            order = list(self._stereo_tetrahedrons[n])
-            orders = [(*order, n, False)]
-            for _ in range(1, len(order)):
-                order = order.copy()
-                order.append(order.pop(0))
-                orders.append((*order, n, False))
-            space.append(orders)
-
-        while space:
-            ls = len(space)
-            unsolved = []
-            for orders in space:
-                good = []
-                if orders[0][-1]:
-                    for x in orders:
-                        if (x0 := x[0]) in seen or x0 not in atoms_stereo and x0 not in allenes_centers:
-                            good.append(x)
-                            seen.add(x[2])
-                    if good:
-                        solved.append(max(good, key=lambda x: (atoms[x[0]].in_ring, atoms[x[0]].atomic_number)))
-                    else:
-                        unsolved.append(orders)
-                else:
-                    for x in orders:
-                        if (x0 := x[0]) in seen or x0 not in atoms_stereo and x0 not in allenes_centers:
-                            good.append(x)
-                    if good:
-                        seen.add(x[-2])
-                        solved.append(max(good, key=lambda x: (atoms[x[0]].in_ring, atoms[x[0]].atomic_number)))
-                    else:
-                        unsolved.append(orders)
-            space = unsolved
-            if len(unsolved) == ls:
-                break
-
-        solved = [y for x in solved if (y := self.__wedge_sign(x))]
-        if not space:
-            return solved
-
-        for orders in product(*space):
-            used = set()
-            wedge = []
-            for order in orders:
-                if order[-1]:  # allene
-                    if (order[0], order[2]) in used:
-                        break
-                    used.add((order[2], order[0]))
-                    wedge.append(self.__wedge_sign(order))
-                else:  # TH
-                    n = order[-2]
-                    if (order[0], n) in used:
-                        break
-                    used.add((n, order[0]))
-                    wedge.append(self.__wedge_sign(order))
-            else:  # found
-                solved.extend(wedge)
-                return solved
-        logger.info('wedge stereo mapping failed')
-        return solved
-
-    def __wedge_sign(self: 'MoleculeContainer', order):
-        plane = self._plane
-
-        if order[-1]:  # allene
-            s = self._translate_allene_sign(order[-2], *order[:2])
-            v = _allene_sign(1, plane[order[2]], plane[order[3]], plane[order[1]])
-            if not v:
-                logger.info(f'need 2d clean. allenes wedge stereo ambiguous for atom {order[-2]}')
-            if s:
-                return order[2], order[0], v
-            else:
-                return order[2], order[0], -v
-        else:  # TH
-            n = order[-2]
-            s = self._translate_tetrahedron_sign(n, order[:-2])
-            # need recalculation if XY changed
-            if len(order) == 5:
-                v = _pyramid_sign((*plane[n], 0),
-                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
-            else:
-                v = _pyramid_sign((*plane[order[3]], 0),
-                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
-            if not v:
-                logger.info(f'need 2d clean. tetrahedron wedge stereo ambiguous for atom {n}')
-            if s:
-                return n, order[0], v
-            else:
-                return n, order[0], -v
-
-    @property
-    def _chiral_tetrahedrons(self) -> Set[int]:
-        return self.__chiral_centers[0]
-
-    @property
-    def _chiral_cis_trans(self) -> Set[Tuple[int, int]]:
-        return self.__chiral_centers[1]
-
-    @property
-    def _chiral_allenes(self) -> Set[int]:
-        return self.__chiral_centers[2]
-
-    @cached_property
-    def _chiral_morgan(self: Union['MoleculeContainer', 'MoleculeStereo']) -> Dict[int, int]:
-        if not self._atoms_stereo and not self._allenes_stereo and not self._cis_trans_stereo:
-            return self.atoms_order
-        morgan = self.atoms_order.copy()
-        atoms_stereo = set(self._atoms_stereo)
-        cis_trans_stereo = set(self._cis_trans_stereo)
-        allenes_stereo = set(self._allenes_stereo)
-        while True:
-            # try iteratively differentiate stereo atoms.
-            morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups = \
-                self.__differentiation(morgan, atoms_stereo, cis_trans_stereo, allenes_stereo)
-            if not atoms_groups and not cis_trans_groups and not allenes_groups:
-                break
-            # for some rings differentiation by morgan impossible. try randomly set new weights.
-            # sometimes this will lead to pseudo chiral centers and non-unique morgan.
-            for group in atoms_groups:
-                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            for group in cis_trans_groups:
-                for n, _ in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            for group in allenes_groups:
-                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
-                    morgan[n] = -morgan[n]
-            morgan = _morgan(morgan, self.int_adjacency)
-        return morgan
-
-    @cached_property
-    def _rings_tetrahedrons_linkers(self: 'MoleculeContainer') -> Dict[int, Tuple[int, int, int, int]]:
-        """
-        Ring-linkers tetrahedrons.
-
-        Values are neighbors in first and second rings.
-        """
-        out = {}
-        tetrahedrons = self._stereo_tetrahedrons
-        for n, r in self.atoms_rings.items():
-            if n in tetrahedrons:
-                for nr, mr in combinations(r, 2):
-                    if len(set(nr).intersection(mr)) == 1:
-                        ni = nr.index(n)
-                        mi = mr.index(n)
-                        out[n] = (nr[ni - 1], nr[ni - len(nr) + 1], mr[mi - 1], mr[mi - len(mr) + 1])
-                        break
-        return out
-
-    @cached_property
-    def _rings_tetrahedrons(self: 'MoleculeContainer') -> Dict[int, Union[Tuple[int, int], Tuple[int], Tuple]]:
-        """
-        Tetrahedrons in rings, except ring-linkers.
-
-        Values are out of ring atoms.
-        """
-        out = {}
-        atoms_rings = self.atoms_rings
-        tetrahedrons = self._stereo_tetrahedrons
-        points = self._rings_tetrahedrons_linkers
-        environment = self.not_special_connectivity
-        for n, r in atoms_rings.items():
-            if n in tetrahedrons and n not in points:
-                out[n] = tuple(environment[n].difference(atoms_rings))
-        return out
-
-    @cached_property
-    def _rings_cumulenes_linkers(self: 'MoleculeContainer') -> Dict[Tuple[int, int], Tuple[int, int, int, int]]:
-        """
-        Ring-linkers cumulenes except chords.
-
-        Values are neighbors in first and second rings.
-        """
-        out = {}
-        ar = self.atoms_rings
-        chord = self._rings_cumulenes
-        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if n in ar and m in ar and (n, m) not in chord:
-                out[(n, m)] = (n1, n2, m1, m2)
-        return out
-
-    @cached_property
-    def _rings_cumulenes(self: 'MoleculeContainer') -> Set[Tuple[int, int]]:
-        """
-        Cumulenes in rings always chiral.
-        """
-        out = set()
-        ar = self.atoms_rings
-        for n, *_, m in self._stereo_cumulenes:
-            if n in ar and m in ar and not set(ar[n]).isdisjoint(ar[m]):
-                out.add((n, m))
-        return out
-
-    @cached_property
-    def _rings_cumulenes_attached(self: 'MoleculeContainer') -> Dict[Tuple[int, int],
-                                                                     Union[Tuple[int, int], Tuple[int]]]:
-        """
-        Cumulenes attached to rings.
-
-        Values are out of ring atoms.
-        """
-        ar = self.atoms_rings
-        out = {}
-        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if n in ar:
-                if m in ar:
-                    continue
-                if m2:
-                    out[(n, m)] = (m1, m2)
-                else:
-                    out[(n, m)] = (m1,)
-            elif m in ar:
-                if n2:
-                    out[(n, m)] = (n1, n2)
-                else:
-                    out[(n, m)] = (n1,)
-        return out
-
-    @cached_property
-    def __chiral_centers(self: Union['MoleculeStereo', 'MoleculeContainer']):
-        atoms_rings = self.atoms_rings
-        tetrahedrons = self._stereo_tetrahedrons
-        cis_trans = self._stereo_cis_trans
-        allenes_centers = self._stereo_allenes_centers
-        cis_trans_terminals = self._stereo_cis_trans_terminals
-        morgan = self._chiral_morgan
-
-        # find new chiral atoms and bonds.
-        # tetrahedron is chiral if all its neighbors are unique.
-        chiral_t = {n for n, env in tetrahedrons.items() if len({morgan[x] for x in env}) == len(env)}
-        # tetrahedrons-linkers is chiral if in each rings neighbors are unique.
-        chiral_t.update(n for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items()
-                        if morgan[n1] != morgan[n2] and morgan[m1] != morgan[m2])
-
-        # required for axes detection.
-        graph = {}
-        stereogenic = set()
-        pseudo = {}
-
-        # double bond is chiral if neighbors of each terminal atom is unique.
-        # ring-linkers and rings-attached also takes into account.
-        chiral_c = set()
-        chiral_a = set()
-        for path, (n1, m1, n2, m2) in self._stereo_cumulenes.items():
-            if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                n, m = path[0], path[-1]
-                if len(path) % 2:
-                    chiral_a.add(path[len(path) // 2])
-                else:
-                    chiral_c.add((n, m))
-                stereogenic.add(n)
-                stereogenic.add(m)
-        # ring cumulenes always chiral. can be already added.
-        for nm in self._rings_cumulenes:
-            n, m = nm
-            if any(len(x) < 8 for x in atoms_rings[n]):  # skip small rings.
-                if nm in chiral_c:  # remove already added small rings cumulenes.
-                    chiral_c.discard(nm)
-                elif n in allenes_centers and (c := allenes_centers[n]) in chiral_a:
-                    chiral_a.discard(c)
-                continue
-            elif nm in cis_trans:
-                chiral_c.add(nm)
-            else:
-                chiral_a.add(allenes_centers[n])
-            pseudo[m] = n
-            graph[n] = set()
-            stereogenic.add(n)
-
-        # find chiral axes. build graph of stereogenic atoms in rings.
-        # atoms connected then located in same ring or cumulene.
-        for n, env in self._rings_tetrahedrons.items():
-            if len(env) == 2:  # one or zero non-ring neighbors stereogenic.
-                n1, n2 = env
-                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
-                    continue
-            graph[n] = set()
-            stereogenic.add(n)  # non-linker tetrahedrons in rings - stereogenic.
-        for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items():
-            graph[n] = set()
-            if morgan[n1] != morgan[n2] or morgan[m1] != morgan[m2]:
-                stereogenic.add(n)  # linkers with at least one unsymmetric ring.
-        for n, m in self._rings_cumulenes_linkers:
-            graph[n] = {m}
-            graph[m] = {n}
-            # stereogenic atoms already found.
-        for (n, m), env in self._rings_cumulenes_attached.items():
-            if len(env) == 2:
-                n1, n2 = env
-                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
-                    continue
-            if n in atoms_rings:
-                graph[n] = set()  # non ring endpoints not required.
-                stereogenic.add(n)  # mark as stereogenic
-            else:
-                graph[m] = set()
-                stereogenic.add(m)
-
-        if len(graph) > 1:  # add bonds to graph. bonds connects atoms in same rings and terminal atoms of cumulenes.
-            for n, ms in graph.items():
-                for r in atoms_rings[n]:
-                    for m in r:
-                        if n == m:
-                            continue
-                        elif m in graph:
-                            ms.add(m)
-                        elif m in pseudo and (m := pseudo[m]) != n:
-                            ms.add(m)
-            # remove not stereogenic terminals.
-            while True:
-                try:
-                    n = next(n for n, ms in graph.items() if not ms or len(ms) == 1 and n not in stereogenic)
-                except StopIteration:
-                    break
-                for m in graph.pop(n):
-                    graph[m].discard(n)
-            # update chiral atoms.
-            for n in graph:
-                if n in tetrahedrons:
-                    chiral_t.add(n)
-                elif n in allenes_centers:
-                    chiral_a.add(allenes_centers[n])
-                else:
-                    chiral_c.add(cis_trans_terminals[n])
-
-        # skip already marked.
-        chiral_t.difference_update(self._atoms_stereo)
-        chiral_a.difference_update(self._allenes_stereo)
-        chiral_c.difference_update(self._cis_trans_stereo)
-        return chiral_t, chiral_c, chiral_a
-
-    def __differentiation(self: Union['MoleculeStereo', 'MoleculeContainer'], morgan,
-                          atoms_stereo, cis_trans_stereo, allenes_stereo):
-        bonds = self.int_adjacency
-
-        tetrahedrons = self._stereo_tetrahedrons
-        cis_trans = self._stereo_cis_trans
-        allenes = self._stereo_allenes
-
-        translate_tetrahedron = self._translate_tetrahedron_sign
-        translate_cis_trans = self._translate_cis_trans_sign
-        translate_allene = self._translate_allene_sign
-
-        while True:
-            morgan_update = {}
-            atoms_groups = []
-            cis_trans_groups = []
-            allenes_groups = []
-            # recalculate morgan weights with taking into account existing stereo marks.
-            if atoms_stereo:
-                grouped_stereo = defaultdict(list)
-                for n in atoms_stereo:
-                    grouped_stereo[morgan[n]].append(n)  # collect equal stereo atoms.
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo atoms give new stereo center.
-                        # process only truly stereogenic.
-                        if len(env := tetrahedrons[group[0]]) == len({morgan[x] for x in env}):
-                            s = [n for n in group if translate_tetrahedron(n, sorted(tetrahedrons[n], key=morgan.get))]
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for m in s:
-                                    morgan_update[m] = -morgan[m]
-                            for n in group:  # prevent checks repeating.
-                                atoms_stereo.discard(n)
-                        else:  # stereo group in rings. unambiguous environment order impossible.
-                            atoms_groups.append(group)
-
-            if cis_trans_stereo:
-                grouped_stereo = defaultdict(list)
-                for nm in cis_trans_stereo:
-                    n, m = nm
-                    if (mn := morgan[n]) <= (mm := morgan[m]):
-                        grouped_stereo[mn].append((n, nm))
-                    else:
-                        grouped_stereo[mm].append((m, nm))
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
-                        n1, m1, n2, m2 = cis_trans[group[0][1]]
-                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                            s = []
-                            for x, nm in group:
-                                n, m = nm
-                                n1, m1, n2, m2 = cis_trans[nm]
-                                if n2 is None:
-                                    a = n1
-                                else:
-                                    a = min(n1, n2, key=morgan.get)
-                                if m2 is None:
-                                    b = m1
-                                else:
-                                    b = min(m1, m2, key=morgan.get)
-                                if translate_cis_trans(n, m, a, b):
-                                    s.append(x)
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for n in s:
-                                    morgan_update[n] = -morgan[n]
-                                for _, nm in group:
-                                    cis_trans_stereo.discard(nm)
-                        else:
-                            cis_trans_groups.append(group)
-
-            if allenes_stereo:
-                grouped_stereo = defaultdict(list)
-                for c in allenes_stereo:
-                    grouped_stereo[morgan[c]].append(c)
-                for group in grouped_stereo.values():
-                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
-                        n1, m1, n2, m2 = allenes[group[0]]
-                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
-                            s = []
-                            for c in group:
-                                n1, m1, n2, m2 = allenes[c]
-                                if n2 is None:
-                                    a = n1
-                                else:
-                                    a = min(n1, n2, key=morgan.get)
-                                if m2 is None:
-                                    b = m1
-                                else:
-                                    b = min(m1, m2, key=morgan.get)
-                                if translate_allene(c, a, b):
-                                    s.append(c)
-                            if 0 < len(s) < len(group):  # RS pair required.
-                                for c in s:
-                                    morgan_update[c] = -morgan[c]
-                                for c in group:
-                                    allenes_stereo.discard(c)
-                        else:
-                            allenes_groups.append(group)
-            if not morgan_update:
-                break
-            morgan = _morgan({**morgan, **morgan_update}, bonds)
-        return morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups
-
-
-__all__ = ['MoleculeStereo']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict
+from functools import cached_property
+from itertools import combinations
+from logging import info
+from typing import Dict, Set, Tuple, Union, TYPE_CHECKING
+from .graph import Stereo
+from ..morgan import _morgan
+from ...exceptions import AtomNotFound, IsChiral, NotChiral
+
+
+if TYPE_CHECKING:
+    from chython import MoleculeContainer
+
+
+def _pyramid_sign(n, u, v, w):
+    #
+    #  |   n /
+    #  |   |\
+    #  |   | \
+    #  |  /|  \
+    #  | / u---v
+    #  |/___\_/___
+    #        w
+    #
+    nx, ny, nz = n
+    ux, uy, uz = u
+    vx, vy, vz = v
+    wx, wy, wz = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q1z = uz - nz
+    q2x = vx - nx
+    q2y = vy - ny
+    q2z = vz - nz
+    q3x = wx - nx
+    q3y = wy - ny
+    q3z = wz - nz
+
+    vol = q1x * (q2y * q3z - q2z * q3y) + q1y * (q2z * q3x - q2x * q3z) + q1z * (q2x * q3y - q2y * q3x)
+    if vol > 0:
+        return 1
+    elif vol < 0:
+        return -1
+    return 0
+
+
+def _cis_trans_sign(n, u, v, w):
+    # n      w
+    #  \    /
+    #   u--v
+    #  /    \
+    # x      x
+    nx, ny = n
+    ux, uy = u
+    vx, vy = v
+    wx, wy = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q2x = vx - ux
+    q2y = vy - uy
+    q3x = wx - vx
+    q3y = wy - vy
+
+    # cross vectors
+    q1q2z = q1x * q2y - q1y * q2x
+    q2q3z = q2x * q3y - q2y * q3x
+
+    dot = q1q2z * q2q3z
+    if dot > 0:
+        return 1
+    elif dot < 0:
+        return -1
+    return 0
+
+
+def _allene_sign(n, u, v, w):
+    # n    w
+    # |   /
+    # u--v
+    nx, ny, nz = n
+    ux, uy = u
+    vx, vy = v
+    wx, wy, wz = w
+
+    q1x = ux - nx
+    q1y = uy - ny
+    q1z = -nz
+    q2x = vx - ux
+    q2y = vy - uy
+    q3x = wx - vx
+    q3y = wy - vy
+    q3z = wz
+
+    # cross vectors
+    q1q2x = -q1z * q2y
+    q1q2y = q1z * q2x
+    q1q2z = q1x * q2y - q1y * q2x
+    q2q3x = q2y * q3z
+    q2q3y = -q2x * q3z
+    q2q3z = q2x * q3y - q2y * q3x
+
+    q1q2q3x = q1q2y * q2q3z - q1q2z * q2q3y
+    q1q2q3y = q1q2z * q2q3x - q1q2x * q2q3z
+
+    dot = q1q2q3x * q2x + q1q2q3y * q2y
+    if dot > 0:
+        return 1
+    elif dot < 0:
+        return -1
+    return 0
+
+
+class MoleculeStereo(Stereo):
+    __slots__ = ()
+
+    def add_wedge(self: 'MoleculeContainer', n: int, m: int, mark: bool, *, clean_cache=True):
+        """
+        Add stereo data by wedge notation of bonds. Use it for tetrahedrons of allenes.
+
+        :param n: number of atom from which wedge bond started
+        :param m: number of atom to which wedge bond coming
+        :param mark: up bond is True, down is False
+        """
+        if n not in self._atoms:
+            raise AtomNotFound
+        if n in self._atoms_stereo:
+            raise IsChiral
+
+        plane = self._plane
+        if n in self._chiral_tetrahedrons:
+            if m not in self._bonds[n]:
+                raise AtomNotFound
+
+            if self._atoms[m].atomic_number == 1:
+                s = _pyramid_sign((*plane[m], mark), *((*plane[x], 0) for x in self._stereo_tetrahedrons[n]))
+            else:
+                order = [(*plane[x], mark if x == m else 0) for x in self._stereo_tetrahedrons[n]]
+                if len(order) == 3:
+                    s = _pyramid_sign((*plane[n], 0), *order)
+                else:
+                    s = _pyramid_sign(order[-1], *order[:3])
+            if s:
+                self._atoms_stereo[n] = s > 0
+                if clean_cache:
+                    self.flush_cache()
+        else:
+            c = self._stereo_allenes_centers.get(n)
+            if c:
+                if c in self._allenes_stereo:
+                    raise IsChiral
+                elif c not in self._chiral_allenes:
+                    raise NotChiral
+
+                order = self._stereo_allenes[c]
+                t1, t2 = self._stereo_allenes_terminals[c]
+                w = order.index(m)
+                if w == 0:
+                    m1 = order[1]
+                    r = False
+                elif w == 1:
+                    m1 = order[0]
+                    t1, t2 = t2, t1
+                    r = False
+                elif w == 2:
+                    m1 = order[1]
+                    r = True
+                else:
+                    m1 = order[0]
+                    t1, t2 = t2, t1
+                    r = True
+                s = _allene_sign((*plane[m], mark), plane[t1], plane[t2], (*plane[m1], 0))
+                if s:
+                    self._allenes_stereo[c] = s < 0 if r else s > 0
+                    if clean_cache:
+                        self.flush_cache()
+            else:
+                # only tetrahedrons and allenes supported
+                raise NotChiral
+
+    def calculate_cis_trans_from_2d(self: 'MoleculeContainer', *, clean_cache=True):
+        """
+        Calculate cis-trans stereo bonds from given 2d coordinates. Unusable for SMILES and INCHI.
+        """
+        cis_trans_stereo = self._cis_trans_stereo
+        plane = self._plane
+        flag = False
+        while self._chiral_cis_trans:
+            stereo = {}
+            for nm in self._chiral_cis_trans:
+                n, m = nm
+                n1, m1, *_ = self._stereo_cis_trans[nm]
+                s = _cis_trans_sign(plane[n1], plane[n], plane[m], plane[m1])
+                if s:
+                    stereo[nm] = s > 0
+            if stereo:
+                cis_trans_stereo.update(stereo)
+                flag = True
+                self.flush_stereo_cache()
+            else:
+                break
+        if flag and clean_cache:
+            self.flush_cache()
+
+    def add_atom_stereo(self: 'MoleculeContainer', n: int, env: Tuple[int, ...], mark: bool, *, clean_cache=True):
+        """
+        Add stereo data for specified neighbors bypass. Use it for tetrahedrons of allenes.
+
+        :param n: number of tetrahedron atom or central atom of allene.
+        :param env: numbers of atoms with specified bypass
+        :param mark: clockwise or anti bypass.
+
+        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html>
+        """
+        if n not in self._atoms:
+            raise AtomNotFound
+        if n in self._atoms_stereo or n in self._allenes_stereo:
+            raise IsChiral
+        if not isinstance(mark, bool):
+            raise TypeError('stereo mark should be bool')
+
+        if n in self._chiral_tetrahedrons:
+            self._atoms_stereo[n] = self._translate_tetrahedron_sign(n, env, mark)
+            if clean_cache:
+                self.flush_cache()
+        elif n in self._chiral_allenes:
+            self._allenes_stereo[n] = self._translate_allene_sign(n, *env, mark)
+            if clean_cache:
+                self.flush_cache()
+        else:  # only tetrahedrons supported
+            raise NotChiral
+
+    def add_cis_trans_stereo(self: 'MoleculeContainer', n: int, m: int, n1: int, n2: int, mark: bool, *,
+                             clean_cache=True):
+        """
+        Add stereo data to cis-trans double bonds (not allenes).
+
+        n1/n=m/n2
+
+        :param n: number of starting atom of double bonds chain (alkenes of cumulenes)
+        :param m: number of ending atom of double bonds chain (alkenes of cumulenes)
+        :param n1: number of neighboring atom of starting atom
+        :param n2: number of neighboring atom of ending atom
+        :param mark: cis or trans
+
+        See <https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html> and <http://opensmiles.org/opensmiles.html
+        """
+        atoms = self._atoms
+        if n not in atoms or m not in atoms or n1 not in atoms or n2 not in atoms:
+            raise AtomNotFound
+        if not isinstance(mark, bool):
+            raise TypeError('stereo mark should be bool')
+        if (n, m) in self._cis_trans_stereo or (m, n) in self._cis_trans_stereo:
+            raise IsChiral
+
+        if (n, m) in self._chiral_cis_trans:
+            self._cis_trans_stereo[(n, m)] = self._translate_cis_trans_sign(n, m, n1, n2, mark)
+            if clean_cache:
+                self.flush_cache()
+        elif (m, n) in self._chiral_cis_trans:
+            self._cis_trans_stereo[(m, n)] = self._translate_cis_trans_sign(m, n, n2, n1, mark)
+            if clean_cache:
+                self.flush_cache()
+        else:
+            raise NotChiral
+
+    def flush_stereo_cache(self):
+        """
+        Flush chiral morgan and chiral centers cache.
+        """
+        self.__dict__.pop('_chiral_morgan', None)
+        self.__dict__.pop('_MoleculeStereo__chiral_centers', None)
+
+    def fix_stereo(self: 'MoleculeContainer'):
+        """
+        Reset stereo marks.
+        """
+        if self._atoms_stereo:  # filter tetrahedrons
+            stereo_tetrahedrons = self._stereo_tetrahedrons
+            atoms_stereo = {k: v for k, v in self._atoms_stereo.items() if k in stereo_tetrahedrons}
+            self._atoms_stereo = self_atoms_stereo = {}
+        else:
+            atoms_stereo = {}
+
+        if self._allenes_stereo:  # filter allenes
+            stereo_allenes = self._stereo_allenes
+            allenes_stereo = {k: v for k, v in self._allenes_stereo.items() if k in stereo_allenes}
+            self._allenes_stereo = self_allenes_stereo = {}
+        else:
+            allenes_stereo = {}
+
+        if self._cis_trans_stereo:  # filter cis-trans
+            stereo_cis_trans = self._stereo_cis_trans
+            cis_trans_stereo = {k: v for k, v in self._cis_trans_stereo.items() if k in stereo_cis_trans}
+            self._cis_trans_stereo = self_stereo_cis_trans = {}
+        else:
+            cis_trans_stereo = {}
+
+        old_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
+        while old_stereo:
+            chiral_tetrahedrons = self._chiral_tetrahedrons
+            chiral_allenes = self._chiral_allenes
+            chiral_cis_trans = self._chiral_cis_trans
+
+            tmp = {}
+            for n, s in atoms_stereo.items():
+                if n in chiral_tetrahedrons:
+                    self_atoms_stereo[n] = s
+                else:
+                    tmp[n] = s
+            atoms_stereo = tmp
+
+            tmp = {}
+            for n, s in allenes_stereo.items():
+                if n in chiral_allenes:
+                    self_allenes_stereo[n] = s
+                else:
+                    tmp[n] = s
+            allenes_stereo = tmp
+
+            tmp = {}
+            for n, s in cis_trans_stereo.items():
+                if n in chiral_cis_trans:
+                    self_stereo_cis_trans[n] = s
+                else:
+                    tmp[n] = s
+            cis_trans_stereo = tmp
+
+            fail_stereo = len(atoms_stereo) + len(allenes_stereo) + len(cis_trans_stereo)
+            if fail_stereo == old_stereo:
+                break
+            old_stereo = fail_stereo
+            self.flush_stereo_cache()
+
+    @cached_property
+    def _wedge_map(self: 'MoleculeContainer'):
+        plane = self._plane
+        atoms_stereo = self._atoms_stereo
+        allenes_centers = self._stereo_allenes_centers
+        atoms = self._atoms
+        used = set()
+        wedge = []
+        for n, s in self._allenes_stereo.items():
+            env = self._stereo_allenes[n]
+            term = self._stereo_allenes_terminals[n]
+            order = [(*env[:2], *term), (*env[1::-1], *term[::-1])]
+            if env[2]:
+                order.append((env[2], env[1], *term))
+                order.append((env[1], env[2], *term[::-1]))
+            if env[3]:
+                order.append((env[3], env[0], *term[::-1]))
+                order.append((env[0], env[3], *term))
+            order = sorted(order, key=lambda x: (x[0] in atoms_stereo, x[0] in allenes_centers,
+                                                 -atoms[x[0]].atomic_number))
+            while (order[0][0], order[0][2]) in used:
+                order.append(order.pop(0))
+            order = order[0]
+            used.add((order[2], order[0]))
+            s = self._translate_allene_sign(n, *order[:2])
+            v = _allene_sign((*plane[order[0]], 1), plane[order[2]], plane[order[3]], (*plane[order[1]], 0))
+            if not v:
+                info(f'need 2d clean. wedge stereo ambiguous for atom {{{n}}}')
+            if s:
+                wedge.append((order[2], order[0], v))
+            else:
+                wedge.append((order[2], order[0], -v))
+
+        for n, s in atoms_stereo.items():
+            order = sorted(self._stereo_tetrahedrons[n], key=lambda x: (x in atoms_stereo, x in allenes_centers,
+                                                                        -atoms[x].atomic_number, atoms[x].in_ring))
+            while (order[0], n) in used:
+                order.append(order.pop(0))
+            used.add((n, order[0]))
+
+            s = self._translate_tetrahedron_sign(n, order)
+            # need recalculation if XY changed
+            if len(order) == 3:
+                v = _pyramid_sign((*plane[n], 0),
+                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
+            else:
+                v = _pyramid_sign((*plane[order[3]], 0),
+                                  (*plane[order[0]], 1), (*plane[order[1]], 0), (*plane[order[2]], 0))
+            if not v:
+                info(f'need 2d clean. wedge stereo ambiguous for atom {{{n}}}')
+            if s:
+                wedge.append((n, order[0], v))
+            else:
+                wedge.append((n, order[0], -v))
+        return tuple(wedge)
+
+    @property
+    def _chiral_tetrahedrons(self) -> Set[int]:
+        return self.__chiral_centers[0]
+
+    @property
+    def _chiral_cis_trans(self) -> Set[Tuple[int, int]]:
+        return self.__chiral_centers[1]
+
+    @property
+    def _chiral_allenes(self) -> Set[int]:
+        return self.__chiral_centers[2]
+
+    @cached_property
+    def _chiral_morgan(self: Union['MoleculeContainer', 'MoleculeStereo']) -> Dict[int, int]:
+        if not self._atoms_stereo and not self._allenes_stereo and not self._cis_trans_stereo:
+            return self.atoms_order
+        morgan = self.atoms_order.copy()
+        atoms_stereo = set(self._atoms_stereo)
+        cis_trans_stereo = set(self._cis_trans_stereo)
+        allenes_stereo = set(self._allenes_stereo)
+        while True:
+            # try iteratively differentiate stereo atoms.
+            morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups = \
+                self.__differentiation(morgan, atoms_stereo, cis_trans_stereo, allenes_stereo)
+            if not atoms_groups and not cis_trans_groups and not allenes_groups:
+                break
+            # for some rings differentiation by morgan impossible. try randomly set new weights.
+            # sometimes this will lead to pseudo chiral centers and non-unique morgan.
+            for group in atoms_groups:
+                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            for group in cis_trans_groups:
+                for n, _ in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            for group in allenes_groups:
+                for n in group[:len(group) // 2]:  # set new weight in half of group randomly.
+                    morgan[n] = -morgan[n]
+            morgan = _morgan(morgan, self.int_adjacency)
+        return morgan
+
+    @cached_property
+    def _rings_tetrahedrons_linkers(self: 'MoleculeContainer') -> Dict[int, Tuple[int, int, int, int]]:
+        """
+        Ring-linkers tetrahedrons.
+
+        Values are neighbors in first and second rings.
+        """
+        out = {}
+        tetrahedrons = self._stereo_tetrahedrons
+        for n, r in self.atoms_rings.items():
+            if n in tetrahedrons:
+                for nr, mr in combinations(r, 2):
+                    if len(set(nr).intersection(mr)) == 1:
+                        ni = nr.index(n)
+                        mi = mr.index(n)
+                        out[n] = (nr[ni - 1], nr[ni - len(nr) + 1], mr[mi - 1], mr[mi - len(mr) + 1])
+                        break
+        return out
+
+    @cached_property
+    def _rings_tetrahedrons(self: 'MoleculeContainer') -> Dict[int, Union[Tuple[int, int], Tuple[int], Tuple]]:
+        """
+        Tetrahedrons in rings, except ring-linkers.
+
+        Values are out of ring atoms.
+        """
+        out = {}
+        atoms_rings = self.atoms_rings
+        tetrahedrons = self._stereo_tetrahedrons
+        points = self._rings_tetrahedrons_linkers
+        environment = self.not_special_connectivity
+        for n, r in atoms_rings.items():
+            if n in tetrahedrons and n not in points:
+                out[n] = tuple(environment[n].difference(atoms_rings))
+        return out
+
+    @cached_property
+    def _rings_cumulenes_linkers(self: 'MoleculeContainer') -> Dict[Tuple[int, int], Tuple[int, int, int, int]]:
+        """
+        Ring-linkers cumulenes except chords.
+
+        Values are neighbors in first and second rings.
+        """
+        out = {}
+        ar = self.atoms_rings
+        chord = self._rings_cumulenes
+        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if n in ar and m in ar and (n, m) not in chord:
+                out[(n, m)] = (n1, n2, m1, m2)
+        return out
+
+    @cached_property
+    def _rings_cumulenes(self: 'MoleculeContainer') -> Set[Tuple[int, int]]:
+        """
+        Cumulenes in rings always chiral.
+        """
+        out = set()
+        ar = self.atoms_rings
+        for n, *_, m in self._stereo_cumulenes:
+            if n in ar and m in ar and not set(ar[n]).isdisjoint(ar[m]):
+                out.add((n, m))
+        return out
+
+    @cached_property
+    def _rings_cumulenes_attached(self: 'MoleculeContainer') -> Dict[Tuple[int, int],
+                                                                     Union[Tuple[int, int], Tuple[int]]]:
+        """
+        Cumulenes attached to rings.
+
+        Values are out of ring atoms.
+        """
+        ar = self.atoms_rings
+        out = {}
+        for (n, *_, m), (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if n in ar:
+                if m in ar:
+                    continue
+                if m2:
+                    out[(n, m)] = (m1, m2)
+                else:
+                    out[(n, m)] = (m1,)
+            elif m in ar:
+                if n2:
+                    out[(n, m)] = (n1, n2)
+                else:
+                    out[(n, m)] = (n1,)
+        return out
+
+    @cached_property
+    def __chiral_centers(self: Union['MoleculeStereo', 'MoleculeContainer']):
+        atoms_rings = self.atoms_rings
+        tetrahedrons = self._stereo_tetrahedrons
+        cis_trans = self._stereo_cis_trans
+        allenes_centers = self._stereo_allenes_centers
+        cis_trans_terminals = self._stereo_cis_trans_terminals
+        morgan = self._chiral_morgan
+
+        # find new chiral atoms and bonds.
+        # tetrahedron is chiral if all its neighbors are unique.
+        chiral_t = {n for n, env in tetrahedrons.items() if len({morgan[x] for x in env}) == len(env)}
+        # tetrahedrons-linkers is chiral if in each rings neighbors are unique.
+        chiral_t.update(n for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items()
+                        if morgan[n1] != morgan[n2] and morgan[m1] != morgan[m2])
+
+        # required for axes detection.
+        graph = {}
+        stereogenic = set()
+        pseudo = {}
+
+        # double bond is chiral if neighbors of each terminal atom is unique.
+        # ring-linkers and rings-attached also takes into account.
+        chiral_c = set()
+        chiral_a = set()
+        for path, (n1, m1, n2, m2) in self._stereo_cumulenes.items():
+            if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                n, m = path[0], path[-1]
+                if len(path) % 2:
+                    chiral_a.add(path[len(path) // 2])
+                else:
+                    chiral_c.add((n, m))
+                stereogenic.add(n)
+                stereogenic.add(m)
+        # ring cumulenes always chiral. can be already added.
+        for nm in self._rings_cumulenes:
+            n, m = nm
+            if any(len(x) < 8 for x in atoms_rings[n]):  # skip small rings.
+                if nm in chiral_c:  # remove already added small rings cumulenes.
+                    chiral_c.discard(nm)
+                elif (c := allenes_centers[n]) in chiral_a:
+                    chiral_a.discard(c)
+                continue
+            elif nm in cis_trans:
+                chiral_c.add(nm)
+            else:
+                chiral_a.add(allenes_centers[n])
+            pseudo[m] = n
+            graph[n] = set()
+            stereogenic.add(n)
+
+        # find chiral axes. build graph of stereogenic atoms in rings.
+        # atoms connected then located in same ring or cumulene.
+        for n, env in self._rings_tetrahedrons.items():
+            if len(env) == 2:  # one or zero non-ring neighbors stereogenic.
+                n1, n2 = env
+                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
+                    continue
+            graph[n] = set()
+            stereogenic.add(n)  # non-linker tetrahedrons in rings - stereogenic.
+        for n, (n1, n2, m1, m2) in self._rings_tetrahedrons_linkers.items():
+            graph[n] = set()
+            if morgan[n1] != morgan[n2] or morgan[m1] != morgan[m2]:
+                stereogenic.add(n)  # linkers with at least one unsymmetric ring.
+        for n, m in self._rings_cumulenes_linkers:
+            graph[n] = {m}
+            graph[m] = {n}
+            # stereogenic atoms already found.
+        for (n, m), env in self._rings_cumulenes_attached.items():
+            if len(env) == 2:
+                n1, n2 = env
+                if morgan[n1] == morgan[n2]:  # only unique non-ring members required.
+                    continue
+            if n in atoms_rings:
+                graph[n] = set()  # non ring endpoints not required.
+                stereogenic.add(n)  # mark as stereogenic
+            else:
+                graph[m] = set()
+                stereogenic.add(m)
+
+        if len(graph) > 1:  # add bonds to graph. bonds connects atoms in same rings and terminal atoms of cumulenes.
+            for n, ms in graph.items():
+                for r in atoms_rings[n]:
+                    for m in r:
+                        if n == m:
+                            continue
+                        elif m in graph:
+                            ms.add(m)
+                        elif m in pseudo and (m := pseudo[m]) != n:
+                            ms.add(m)
+            # remove not stereogenic terminals.
+            while True:
+                try:
+                    n = next(n for n, ms in graph.items() if not ms or len(ms) == 1 and n not in stereogenic)
+                except StopIteration:
+                    break
+                for m in graph.pop(n):
+                    graph[m].discard(n)
+            # update chiral atoms.
+            for n in graph:
+                if n in tetrahedrons:
+                    chiral_t.add(n)
+                elif n in allenes_centers:
+                    chiral_a.add(allenes_centers[n])
+                else:
+                    chiral_c.add(cis_trans_terminals[n])
+
+        # skip already marked.
+        chiral_t.difference_update(self._atoms_stereo)
+        chiral_a.difference_update(self._allenes_stereo)
+        chiral_c.difference_update(self._cis_trans_stereo)
+        return chiral_t, chiral_c, chiral_a
+
+    def __differentiation(self: Union['MoleculeStereo', 'MoleculeContainer'], morgan,
+                          atoms_stereo, cis_trans_stereo, allenes_stereo):
+        bonds = self.int_adjacency
+
+        tetrahedrons = self._stereo_tetrahedrons
+        cis_trans = self._stereo_cis_trans
+        allenes = self._stereo_allenes
+
+        translate_tetrahedron = self._translate_tetrahedron_sign
+        translate_cis_trans = self._translate_cis_trans_sign
+        translate_allene = self._translate_allene_sign
+
+        while True:
+            morgan_update = {}
+            atoms_groups = []
+            cis_trans_groups = []
+            allenes_groups = []
+            # recalculate morgan weights with taking into account existing stereo marks.
+            if atoms_stereo:
+                grouped_stereo = defaultdict(list)
+                for n in atoms_stereo:
+                    grouped_stereo[morgan[n]].append(n)  # collect equal stereo atoms.
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo atoms give new stereo center.
+                        # process only truly stereogenic.
+                        if len(env := tetrahedrons[group[0]]) == len({morgan[x] for x in env}):
+                            s = [n for n in group if translate_tetrahedron(n, sorted(tetrahedrons[n], key=morgan.get))]
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for m in s:
+                                    morgan_update[m] = -morgan[m]
+                            for n in group:  # prevent checks repeating.
+                                atoms_stereo.discard(n)
+                        else:  # stereo group in rings. unambiguous environment order impossible.
+                            atoms_groups.append(group)
+
+            if cis_trans_stereo:
+                grouped_stereo = defaultdict(list)
+                for nm in cis_trans_stereo:
+                    n, m = nm
+                    if (mn := morgan[n]) <= (mm := morgan[m]):
+                        grouped_stereo[mn].append((n, nm))
+                    else:
+                        grouped_stereo[mm].append((m, nm))
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
+                        n1, m1, n2, m2 = cis_trans[group[0][1]]
+                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                            s = []
+                            for x, nm in group:
+                                n, m = nm
+                                n1, m1, n2, m2 = cis_trans[nm]
+                                if n2 is None:
+                                    a = n1
+                                else:
+                                    a = min(n1, n2, key=morgan.get)
+                                if m2 is None:
+                                    b = m1
+                                else:
+                                    b = min(m1, m2, key=morgan.get)
+                                if translate_cis_trans(n, m, a, b):
+                                    s.append(x)
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for n in s:
+                                    morgan_update[n] = -morgan[n]
+                                for _, nm in group:
+                                    cis_trans_stereo.discard(nm)
+                        else:
+                            cis_trans_groups.append(group)
+
+            if allenes_stereo:
+                grouped_stereo = defaultdict(list)
+                for c in allenes_stereo:
+                    grouped_stereo[morgan[c]].append(c)
+                for group in grouped_stereo.values():
+                    if not len(group) % 2:  # only even number of equal stereo bonds give new stereo center.
+                        n1, m1, n2, m2 = allenes[group[0]]
+                        if morgan[n1] != morgan.get(n2, 0) and morgan[m1] != morgan.get(m2, 0):
+                            s = []
+                            for c in group:
+                                n1, m1, n2, m2 = allenes[c]
+                                if n2 is None:
+                                    a = n1
+                                else:
+                                    a = min(n1, n2, key=morgan.get)
+                                if m2 is None:
+                                    b = m1
+                                else:
+                                    b = min(m1, m2, key=morgan.get)
+                                if translate_allene(c, a, b):
+                                    s.append(c)
+                            if 0 < len(s) < len(group):  # RS pair required.
+                                for c in s:
+                                    morgan_update[c] = -morgan[c]
+                                for c in group:
+                                    allenes_stereo.discard(c)
+                        else:
+                            allenes_groups.append(group)
+            if not morgan_update:
+                break
+            morgan = _morgan({**morgan, **morgan_update}, bonds)
+        return morgan, atoms_stereo, cis_trans_stereo, allenes_stereo, atoms_groups, cis_trans_groups, allenes_groups
+
+
+__all__ = ['MoleculeStereo']
```

### Comparing `chython-1.67/chython/algorithms/tautomers/test/__init__.py` & `chython-1.8/chython/algorithms/aromatics/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .kekule import *
+from .thiele import *
+
+
+class Aromatize(Thiele, Kekule):
+    __slots__ = ()
+
+
+__all__ = ['Aromatize']
```

### Comparing `chython-1.67/chython/containers/__init__.py` & `chython-1.8/chython/files/_mdl/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .bonds import *
-from .cgr import *
-from .molecule import *
-from .query import *
-from .reaction import *
-
-
-__all__ = [x for x in locals() if x.endswith('Container')]
-__all__.append('Bond')
-__all__.append('QueryBond')
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .emol import EMOLRead
+from .erxn import ERXNRead
+from .ewrite import EMDLWrite
+from .mol import MOLRead, common_isotopes
+from .parser import Parser, parse_error
+from .rxn import RXNRead
+from .stereo import MDLStereo
+from .read import MDLRead
+from .write import MDLWrite
```

### Comparing `chython-1.67/chython/containers/_cpack.c` & `chython-1.8/chython/algorithms/_isomorphism.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,54 +1,42 @@
-/* Generated by Cython 3.0.0 */
+/* Generated by Cython 0.29.24 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-O3"
         ],
-        "name": "chython.containers._cpack",
+        "name": "chython.algorithms._isomorphism",
         "sources": [
-            "chython/containers/_cpack.pyx"
+            "chython/algorithms/_isomorphism.pyx"
         ]
     },
-    "module_name": "chython.containers._cpack"
+    "module_name": "chython.algorithms._isomorphism"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
-#if defined(CYTHON_LIMITED_API) && 0
-  #ifndef Py_LIMITED_API
-    #if CYTHON_LIMITED_API+0 > 0x03030000
-      #define Py_LIMITED_API CYTHON_LIMITED_API
-    #else
-      #define Py_LIMITED_API 0x03030000
-    #endif
-  #endif
-#endif
-
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
-#elif PY_VERSION_HEX < 0x02070000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
-    #error Cython requires Python 2.7+ or Python 3.3+.
+#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
+    #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "3_0_0"
-#define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
-#define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030000F0
+#define CYTHON_ABI "0_29_24"
+#define CYTHON_HEX_VERSION 0x001D18F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
-#if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
+#if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
   #endif
   #ifndef __cdecl
     #define __cdecl
   #endif
   #ifndef __fastcall
@@ -59,90 +47,30 @@
   #define DL_IMPORT(t) t
 #endif
 #ifndef DL_EXPORT
   #define DL_EXPORT(t) t
 #endif
 #define __PYX_COMMA ,
 #ifndef HAVE_LONG_LONG
-  #define HAVE_LONG_LONG
+  #if PY_VERSION_HEX >= 0x02070000
+    #define HAVE_LONG_LONG
+  #endif
 #endif
 #ifndef PY_LONG_LONG
   #define PY_LONG_LONG LONG_LONG
 #endif
 #ifndef Py_HUGE_VAL
   #define Py_HUGE_VAL HUGE_VAL
 #endif
-#if defined(GRAALVM_PYTHON)
-  /* For very preliminary testing purposes. Most variables are set the same as PyPy.
-     The existence of this section does not imply that anything works or is even tested */
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 1
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 0
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 0
-  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_WRITER
-  #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #undef CYTHON_AVOID_BORROWED_REFS
-  #define CYTHON_AVOID_BORROWED_REFS 1
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PYPY_VERSION)
+#ifdef PYPY_VERSION
   #define CYTHON_COMPILING_IN_PYPY 1
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
   #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 0
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #if PY_VERSION_HEX < 0x03050000
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
@@ -159,111 +87,35 @@
   #define CYTHON_AVOID_BORROWED_REFS 1
   #undef CYTHON_ASSUME_SAFE_MACROS
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
-  #undef CYTHON_FAST_PYCALL
-  #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS (PY_MAJOR_VERSION >= 3)
-  #endif
-  #if PY_VERSION_HEX < 0x03090000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 0
-  #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
-  #undef CYTHON_USE_DICT_VERSIONS
-  #define CYTHON_USE_DICT_VERSIONS 0
-  #undef CYTHON_USE_EXC_INFO_STACK
-  #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(CYTHON_LIMITED_API)
-  #define CYTHON_COMPILING_IN_PYPY 0
-  #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 1
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
-  #undef CYTHON_CLINE_IN_TRACEBACK
-  #define CYTHON_CLINE_IN_TRACEBACK 0
-  #undef CYTHON_USE_TYPE_SLOTS
-  #define CYTHON_USE_TYPE_SLOTS 0
-  #undef CYTHON_USE_TYPE_SPECS
-  #define CYTHON_USE_TYPE_SPECS 1
-  #undef CYTHON_USE_PYTYPE_LOOKUP
-  #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #undef CYTHON_USE_ASYNC_SLOTS
-  #define CYTHON_USE_ASYNC_SLOTS 0
-  #undef CYTHON_USE_PYLIST_INTERNALS
-  #define CYTHON_USE_PYLIST_INTERNALS 0
-  #undef CYTHON_USE_UNICODE_INTERNALS
-  #define CYTHON_USE_UNICODE_INTERNALS 0
-  #ifndef CYTHON_USE_UNICODE_WRITER
-    #define CYTHON_USE_UNICODE_WRITER 0
-  #endif
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
-  #ifndef CYTHON_AVOID_BORROWED_REFS
-    #define CYTHON_AVOID_BORROWED_REFS 0
-  #endif
-  #undef CYTHON_ASSUME_SAFE_MACROS
-  #define CYTHON_ASSUME_SAFE_MACROS 0
-  #undef CYTHON_UNPACK_METHODS
-  #define CYTHON_UNPACK_METHODS 0
-  #undef CYTHON_FAST_THREAD_STATE
-  #define CYTHON_FAST_THREAD_STATE 0
-  #undef CYTHON_FAST_GIL
-  #define CYTHON_FAST_GIL 0
-  #undef CYTHON_METH_FASTCALL
-  #define CYTHON_METH_FASTCALL 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
-  #endif
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #undef CYTHON_USE_MODULE_STATE
-  #define CYTHON_USE_MODULE_STATE 1
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
-  #endif
-#elif defined(PY_NOGIL)
+#elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
-  #ifndef CYTHON_USE_ASYNC_SLOTS
-    #define CYTHON_USE_ASYNC_SLOTS 1
-  #endif
+  #undef CYTHON_USE_ASYNC_SLOTS
+  #define CYTHON_USE_ASYNC_SLOTS 0
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
@@ -278,55 +130,54 @@
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
+  #undef CYTHON_PEP489_MULTI_PHASE_INIT
+  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #undef CYTHON_USE_TP_FINALIZE
+  #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
+  #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
-  #define CYTHON_COMPILING_IN_LIMITED_API 0
-  #define CYTHON_COMPILING_IN_GRAAL 0
-  #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_TYPE_SPECS
-    #define CYTHON_USE_TYPE_SPECS 0
-  #endif
-  #ifndef CYTHON_USE_PYTYPE_LOOKUP
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYTYPE_LOOKUP
+    #define CYTHON_USE_PYTYPE_LOOKUP 0
+  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
     #define CYTHON_USE_PYTYPE_LOOKUP 1
   #endif
   #if PY_MAJOR_VERSION < 3
     #undef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 0
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
-  #ifndef CYTHON_USE_PYLONG_INTERNALS
+  #if PY_VERSION_HEX < 0x02070000
+    #undef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
     #define CYTHON_USE_PYLONG_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
-  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
+  #if PY_VERSION_HEX < 0x030300F0
     #undef CYTHON_USE_UNICODE_WRITER
     #define CYTHON_USE_UNICODE_WRITER 0
   #elif !defined(CYTHON_USE_UNICODE_WRITER)
     #define CYTHON_USE_UNICODE_WRITER 1
   #endif
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
@@ -336,68 +187,35 @@
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
-  #ifndef CYTHON_FAST_GIL
-    #define CYTHON_FAST_GIL (PY_MAJOR_VERSION < 3 || PY_VERSION_HEX >= 0x03060000 && PY_VERSION_HEX < 0x030C00A6)
-  #endif
-  #ifndef CYTHON_METH_FASTCALL
-    #define CYTHON_METH_FASTCALL (PY_VERSION_HEX >= 0x030700A1)
-  #endif
   #ifndef CYTHON_FAST_PYCALL
     #define CYTHON_FAST_PYCALL 1
   #endif
-  #ifndef CYTHON_PEP487_INIT_SUBCLASS
-    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
-  #if PY_VERSION_HEX < 0x03050000
-    #undef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
-  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
-    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
-  #endif
-  #ifndef CYTHON_USE_MODULE_STATE
-    #define CYTHON_USE_MODULE_STATE 0
-  #endif
-  #if PY_VERSION_HEX < 0x030400a1
-    #undef CYTHON_USE_TP_FINALIZE
-    #define CYTHON_USE_TP_FINALIZE 0
-  #elif !defined(CYTHON_USE_TP_FINALIZE)
-    #define CYTHON_USE_TP_FINALIZE 1
-  #endif
-  #if PY_VERSION_HEX < 0x030600B1
-    #undef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS 0
-  #elif !defined(CYTHON_USE_DICT_VERSIONS)
-    #define CYTHON_USE_DICT_VERSIONS  (PY_VERSION_HEX < 0x030C00A5)
-  #endif
-  #if PY_VERSION_HEX < 0x030700A3
-    #undef CYTHON_USE_EXC_INFO_STACK
-    #define CYTHON_USE_EXC_INFO_STACK 0
-  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
-    #define CYTHON_USE_EXC_INFO_STACK 1
+  #ifndef CYTHON_USE_TP_FINALIZE
+    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
-  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
-    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #ifndef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+  #endif
+  #ifndef CYTHON_USE_EXC_INFO_STACK
+    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
-#if !defined(CYTHON_VECTORCALL)
-#define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
-#endif
-#define CYTHON_BACKPORT_VECTORCALL (CYTHON_METH_FASTCALL && PY_VERSION_HEX < 0x030800B1)
 #if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_MAJOR_VERSION < 3
-    #include "longintrepr.h"
-  #endif
+  #include "longintrepr.h"
   #undef SHIFT
   #undef BASE
   #undef MASK
   #ifdef SIZEOF_VOID_P
     enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
   #endif
 #endif
@@ -415,128 +233,78 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_RESTRICT restrict
   #else
     #define CYTHON_RESTRICT
   #endif
 #endif
 #ifndef CYTHON_UNUSED
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(maybe_unused) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(maybe_unused)
-        #define CYTHON_UNUSED [[maybe_unused]]
-      #endif
-    #endif
-  #endif
-#endif
-#ifndef CYTHON_UNUSED
 # if defined(__GNUC__)
 #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #     define CYTHON_UNUSED __attribute__ ((__unused__))
 #   else
 #     define CYTHON_UNUSED
 #   endif
 # elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
 #   define CYTHON_UNUSED __attribute__ ((__unused__))
 # else
 #   define CYTHON_UNUSED
 # endif
 #endif
-#ifndef CYTHON_UNUSED_VAR
+#ifndef CYTHON_MAYBE_UNUSED_VAR
 #  if defined(__cplusplus)
-     template<class T> void CYTHON_UNUSED_VAR( const T& ) { }
+     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
 #  else
-#    define CYTHON_UNUSED_VAR(x) (void)(x)
+#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
 #  endif
 #endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
-  #define CYTHON_MAYBE_UNUSED_VAR(x) CYTHON_UNUSED_VAR(x)
-#endif
 #ifndef CYTHON_NCP_UNUSED
 # if CYTHON_COMPILING_IN_CPYTHON
 #  define CYTHON_NCP_UNUSED
 # else
 #  define CYTHON_NCP_UNUSED CYTHON_UNUSED
 # endif
 #endif
 #define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
 #ifdef _MSC_VER
     #ifndef _MSC_STDINT_H_
         #if _MSC_VER < 1300
-            typedef unsigned char     uint8_t;
-            typedef unsigned short    uint16_t;
-            typedef unsigned int      uint32_t;
-        #else
-            typedef unsigned __int8   uint8_t;
-            typedef unsigned __int16  uint16_t;
-            typedef unsigned __int32  uint32_t;
-        #endif
-    #endif
-    #if _MSC_VER < 1300
-        #ifdef _WIN64
-            typedef unsigned long long  __pyx_uintptr_t;
-        #else
-            typedef unsigned int        __pyx_uintptr_t;
-        #endif
-    #else
-        #ifdef _WIN64
-            typedef unsigned __int64    __pyx_uintptr_t;
+           typedef unsigned char     uint8_t;
+           typedef unsigned int      uint32_t;
         #else
-            typedef unsigned __int32    __pyx_uintptr_t;
+           typedef unsigned __int8   uint8_t;
+           typedef unsigned __int32  uint32_t;
         #endif
     #endif
 #else
-    #include <stdint.h>
-    typedef uintptr_t  __pyx_uintptr_t;
+   #include <stdint.h>
 #endif
 #ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus)
-    /* for clang __has_cpp_attribute(fallthrough) is true even before C++17
-     * but leads to warnings with -pedantic, since it is a C++17 feature */
-    #if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
-      #if __has_cpp_attribute(fallthrough)
-        #define CYTHON_FALLTHROUGH [[fallthrough]]
-      #endif
-    #endif
-    #ifndef CYTHON_FALLTHROUGH
-      #if __has_cpp_attribute(clang::fallthrough)
-        #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-      #elif __has_cpp_attribute(gnu::fallthrough)
-        #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
-      #endif
+  #if defined(__cplusplus) && __cplusplus >= 201103L
+    #if __has_cpp_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH [[fallthrough]]
+    #elif __has_cpp_attribute(clang::fallthrough)
+      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+    #elif __has_cpp_attribute(gnu::fallthrough)
+      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
     #endif
   #endif
   #ifndef CYTHON_FALLTHROUGH
     #if __has_attribute(fallthrough)
       #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
     #else
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
-  #if defined(__clang__) && defined(__apple_build_version__)
+  #if defined(__clang__ ) && defined(__apple_build_version__)
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
-#ifdef __cplusplus
-  template <typename T>
-  struct __PYX_IS_UNSIGNED_IMPL {static const bool value = T(0) < T(-1);};
-  #define __PYX_IS_UNSIGNED(type) (__PYX_IS_UNSIGNED_IMPL<type>::value)
-#else
-  #define __PYX_IS_UNSIGNED(type) (((type)-1) > 0)
-#endif
-#if CYTHON_COMPILING_IN_PYPY == 1
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x030A0000)
-#else
-  #define __PYX_NEED_TP_PRINT_SLOT  (PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000)
-#endif
-#define __PYX_REINTERPRET_FUNCION(func_pointer, other_pointer) ((func_pointer)(void(*)(void))(other_pointer))
 
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
   #elif defined(__GNUC__)
     #define CYTHON_INLINE __inline__
   #elif defined(_MSC_VER)
@@ -544,225 +312,93 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
   #else
     #define CYTHON_INLINE
   #endif
 #endif
 
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define Py_OptimizeFlag 0
+#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
-  #define __Pyx_DefaultClassType PyClass_Type
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+  #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-  #define __Pyx_DefaultClassType PyType_Type
-#if PY_VERSION_HEX >= 0x030B00A1
-    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int p, int k, int l, int s, int f,
-                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
-                                                    PyObject *fv, PyObject *cell, PyObject* fn,
-                                                    PyObject *name, int fline, PyObject *lnos) {
-        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
-        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *empty=NULL;
-        const char *fn_cstr=NULL;
-        const char *name_cstr=NULL;
-        PyCodeObject *co=NULL, *result=NULL;
-        PyObject *type, *value, *traceback;
-        PyErr_Fetch(&type, &value, &traceback);
-        if (!(kwds=PyDict_New())) goto end;
-        if (!(argcount=PyLong_FromLong(a))) goto end;
-        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
-        if (!(posonlyargcount=PyLong_FromLong(p))) goto end;
-        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
-        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
-        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
-        if (!(nlocals=PyLong_FromLong(l))) goto end;
-        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
-        if (!(stacksize=PyLong_FromLong(s))) goto end;
-        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
-        if (!(flags=PyLong_FromLong(f))) goto end;
-        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
-        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
-        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
-        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
-        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
-        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto end;
-        if (!(empty = PyTuple_New(0))) goto end;
-        result = (PyCodeObject*) PyObject_Call(replace, empty, kwds);
-    end:
-        Py_XDECREF((PyObject*) co);
-        Py_XDECREF(kwds);
-        Py_XDECREF(argcount);
-        Py_XDECREF(posonlyargcount);
-        Py_XDECREF(kwonlyargcount);
-        Py_XDECREF(nlocals);
-        Py_XDECREF(stacksize);
-        Py_XDECREF(replace);
-        Py_XDECREF(empty);
-        if (type) {
-            PyErr_Restore(type, value, traceback);
-        }
-        return result;
-    }
-#elif PY_VERSION_HEX >= 0x030800B2 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_NewWithPosOnlyArgs(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #else
-  #define __Pyx_PyCode_New(a, p, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
+  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
-#endif
-#if PY_VERSION_HEX >= 0x030900A4 || defined(Py_IS_TYPE)
-  #define __Pyx_IS_TYPE(ob, type) Py_IS_TYPE(ob, type)
-#else
-  #define __Pyx_IS_TYPE(ob, type) (((const PyObject*)ob)->ob_type == (type))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_Is)
-  #define __Pyx_Py_Is(x, y)  Py_Is(x, y)
-#else
-  #define __Pyx_Py_Is(x, y) ((x) == (y))
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsNone)
-  #define __Pyx_Py_IsNone(ob) Py_IsNone(ob)
-#else
-  #define __Pyx_Py_IsNone(ob) __Pyx_Py_Is((ob), Py_None)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsTrue)
-  #define __Pyx_Py_IsTrue(ob) Py_IsTrue(ob)
-#else
-  #define __Pyx_Py_IsTrue(ob) __Pyx_Py_Is((ob), Py_True)
-#endif
-#if PY_VERSION_HEX >= 0x030A00B1 || defined(Py_IsFalse)
-  #define __Pyx_Py_IsFalse(ob) Py_IsFalse(ob)
-#else
-  #define __Pyx_Py_IsFalse(ob) __Pyx_Py_Is((ob), Py_False)
-#endif
-#define __Pyx_NoneAsNull(obj)  (__Pyx_Py_IsNone(obj) ? NULL : (obj))
-#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
-  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
-#else
-  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
-#endif
-#ifndef CO_COROUTINE
-  #define CO_COROUTINE 0x80
-#endif
-#ifndef CO_ASYNC_GENERATOR
-  #define CO_ASYNC_GENERATOR 0x200
+  #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_FINALIZE
   #define Py_TPFLAGS_HAVE_FINALIZE 0
 #endif
-#ifndef Py_TPFLAGS_SEQUENCE
-  #define Py_TPFLAGS_SEQUENCE 0
-#endif
-#ifndef Py_TPFLAGS_MAPPING
-  #define Py_TPFLAGS_MAPPING 0
-#endif
 #ifndef METH_STACKLESS
   #define METH_STACKLESS 0
 #endif
 #if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
   #define __Pyx_PyCFunctionFast _PyCFunctionFast
   #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
 #endif
-#if CYTHON_METH_FASTCALL
-  #define __Pyx_METH_FASTCALL METH_FASTCALL
-  #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
-  #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
-#else
-  #define __Pyx_METH_FASTCALL METH_VARARGS
-  #define __Pyx_PyCFunction_FastCall PyCFunction
-  #define __Pyx_PyCFunction_FastCallWithKeywords PyCFunctionWithKeywords
-#endif
-#if CYTHON_VECTORCALL
-  #define __pyx_vectorcallfunc vectorcallfunc
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  PY_VECTORCALL_ARGUMENTS_OFFSET
-  #define __Pyx_PyVectorcall_NARGS(n)  PyVectorcall_NARGS((size_t)(n))
-#elif CYTHON_BACKPORT_VECTORCALL
-  typedef PyObject *(*__pyx_vectorcallfunc)(PyObject *callable, PyObject *const *args,
-                                            size_t nargsf, PyObject *kwnames);
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  ((size_t)1 << (8 * sizeof(size_t) - 1))
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(((size_t)(n)) & ~__Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET))
-#else
-  #define __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET  0
-  #define __Pyx_PyVectorcall_NARGS(n)  ((Py_ssize_t)(n))
-#endif
-#if PY_VERSION_HEX < 0x030900B1
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  ((void)m, PyType_FromSpecWithBases(s, b))
-  typedef PyObject *(*__Pyx_PyCMethod)(PyObject *, PyTypeObject *, PyObject *const *, size_t, PyObject *);
+#if CYTHON_FAST_PYCCALL
+#define __Pyx_PyFastCFunction_Check(func)\
+    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
 #else
-  #define __Pyx_PyType_FromModuleAndSpec(m, s, b)  PyType_FromModuleAndSpec(m, s, b)
-  #define __Pyx_PyCMethod  PyCMethod
-#endif
-#ifndef METH_METHOD
-  #define METH_METHOD 0x200
+#define __Pyx_PyFastCFunction_Check(func) 0
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
   #define PyObject_Malloc(s)   PyMem_Malloc(s)
   #define PyObject_Free(p)     PyMem_Free(p)
   #define PyObject_Realloc(p)  PyMem_Realloc(p)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
+  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
+  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
+  #define PyMem_RawFree(p)             PyMem_Free(p)
+#endif
+#if CYTHON_COMPILING_IN_PYSTON
+  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
 #else
   #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
   #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyThreadState_Current PyThreadState_Get()
-#elif !CYTHON_FAST_THREAD_STATE
+#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #elif PY_VERSION_HEX >= 0x03060000
   #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
 #elif PY_VERSION_HEX >= 0x03000000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #else
   #define __Pyx_PyThreadState_Current _PyThreadState_Current
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE void *__Pyx_PyModule_GetState(PyObject *op)
-{
-    void *result;
-    result = PyModule_GetState(op);
-    if (!result)
-        Py_FatalError("Couldn't find the module state");
-    return result;
-}
-#endif
-#define __Pyx_PyObject_GetSlot(obj, name, func_ctype)  __Pyx_PyType_GetSlot(Py_TYPE(obj), name, func_ctype)
-#if CYTHON_COMPILING_IN_LIMITED_API
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((func_ctype) PyType_GetSlot((type), Py_##name))
-#else
-  #define __Pyx_PyType_GetSlot(type, name, func_ctype)  ((type)->name)
-#endif
 #if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
 #include "pythread.h"
 #define Py_tss_NEEDS_INIT 0
 typedef int Py_tss_t;
 static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
   *key = PyThread_create_key();
   return 0;
@@ -785,166 +421,86 @@
 static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
   return PyThread_set_key_value(*key, value);
 }
 static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
   return PyThread_get_key_value(*key);
 }
 #endif
-#if PY_MAJOR_VERSION < 3
-    #if CYTHON_COMPILING_IN_PYPY
-        #if PYPY_VERSION_NUM < 0x07030600
-            #if defined(__cplusplus) && __cplusplus >= 201402L
-                [[deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")]]
-            #elif defined(__GNUC__) || defined(__clang__)
-                __attribute__ ((__deprecated__("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6")))
-            #elif defined(_MSC_VER)
-                __declspec(deprecated("`with nogil:` inside a nogil function will not release the GIL in PyPy2 < 7.3.6"))
-            #endif
-            static CYTHON_INLINE int PyGILState_Check(void) {
-                return 0;
-            }
-        #else  // PYPY_VERSION_NUM < 0x07030600
-        #endif  // PYPY_VERSION_NUM < 0x07030600
-    #else
-        static CYTHON_INLINE int PyGILState_Check(void) {
-            PyThreadState * tstate = _PyThreadState_Current;
-            return tstate && (tstate == PyGILState_GetThisThreadState());
-        }
-    #endif
-#endif
 #if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
 #define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
 #else
 #define __Pyx_PyDict_NewPresized(n)  PyDict_New()
 #endif
 #if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
 #else
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX > 0x030600B4 && CYTHON_USE_UNICODE_INTERNALS
-#define __Pyx_PyDict_GetItemStrWithError(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStr(PyObject *dict, PyObject *name) {
-    PyObject *res = __Pyx_PyDict_GetItemStrWithError(dict, name);
-    if (res == NULL) PyErr_Clear();
-    return res;
-}
-#elif PY_MAJOR_VERSION >= 3 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07020000)
-#define __Pyx_PyDict_GetItemStrWithError  PyDict_GetItemWithError
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#else
-static CYTHON_INLINE PyObject * __Pyx_PyDict_GetItemStrWithError(PyObject *dict, PyObject *name) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyDict_GetItem(dict, name);
-#else
-    PyDictEntry *ep;
-    PyDictObject *mp = (PyDictObject*) dict;
-    long hash = ((PyStringObject *) name)->ob_shash;
-    assert(hash != -1);
-    ep = (mp->ma_lookup)(mp, name, hash);
-    if (ep == NULL) {
-        return NULL;
-    }
-    return ep->me_value;
-#endif
-}
-#define __Pyx_PyDict_GetItemStr           PyDict_GetItem
-#endif
-#if CYTHON_USE_TYPE_SLOTS
-  #define __Pyx_PyType_GetFlags(tp)   (((PyTypeObject *)tp)->tp_flags)
-  #define __Pyx_PyType_HasFeature(type, feature)  ((__Pyx_PyType_GetFlags(type) & (feature)) != 0)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  (Py_TYPE(obj)->tp_iternext)
-#else
-  #define __Pyx_PyType_GetFlags(tp)   (PyType_GetFlags((PyTypeObject *)tp))
-  #define __Pyx_PyType_HasFeature(type, feature)  PyType_HasFeature(type, feature)
-  #define __Pyx_PyObject_GetIterNextFunc(obj)  PyIter_Next
-#endif
-#if CYTHON_USE_TYPE_SPECS && PY_VERSION_HEX >= 0x03080000
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  {\
-    PyTypeObject *type = Py_TYPE(obj);\
-    assert(__Pyx_PyType_HasFeature(type, Py_TPFLAGS_HEAPTYPE));\
-    PyObject_GC_Del(obj);\
-    Py_DECREF(type);\
-}
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
 #else
-#define __Pyx_PyHeapTypeObject_GC_Del(obj)  PyObject_GC_Del(obj)
+#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
 #endif
-#if CYTHON_COMPILING_IN_LIMITED_API
+#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
-  #define __Pyx_PyUnicode_READY(op)       (0)
-  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GetLength(u)
-  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_ReadChar(u, i)
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((void)u, 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((void)u, (0))
-  #define __Pyx_PyUnicode_DATA(u)         ((void*)u)
-  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)k, PyUnicode_ReadChar((PyObject*)(d), i))
-  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GetLength(u))
-#elif PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
-  #define CYTHON_PEP393_ENABLED 1
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_READY(op)       (0)
+  #if defined(PyUnicode_IS_READY)
+  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
+                                              0 : _PyUnicode_Ready((PyObject *)(op)))
   #else
-    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
-                                                0 : _PyUnicode_Ready((PyObject *)(op)))
+  #define __Pyx_PyUnicode_READY(op)       (0)
   #endif
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)PyUnicode_KIND(u))
+  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
   #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
   #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, (Py_UCS4) ch)
-  #if PY_VERSION_HEX >= 0x030C0000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
+  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
+  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
   #else
-    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
-    #else
-    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
-    #endif
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
+  #endif
+  #else
+  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
   #endif
 #else
   #define CYTHON_PEP393_ENABLED 0
   #define PyUnicode_1BYTE_KIND  1
   #define PyUnicode_2BYTE_KIND  2
   #define PyUnicode_4BYTE_KIND  4
   #define __Pyx_PyUnicode_READY(op)       (0)
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
-  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535U : 1114111U)
-  #define __Pyx_PyUnicode_KIND(u)         ((int)sizeof(Py_UNICODE))
+  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
+  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
   #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
   #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
-  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = (Py_UNICODE) ch)
+  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
   #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
 #endif
 #if CYTHON_COMPILING_IN_PYPY
   #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
 #else
   #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
   #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
       PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
 #endif
-#if CYTHON_COMPILING_IN_PYPY
-  #if !defined(PyUnicode_DecodeUnicodeEscape)
-    #define PyUnicode_DecodeUnicodeEscape(s, size, errors)  PyUnicode_Decode(s, size, "unicode_escape", errors)
-  #endif
-  #if !defined(PyUnicode_Contains) || (PY_MAJOR_VERSION == 2 && PYPY_VERSION_NUM < 0x07030500)
-    #undef PyUnicode_Contains
-    #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
-  #endif
-  #if !defined(PyByteArray_Check)
-    #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
-  #endif
-  #if !defined(PyObject_Format)
-    #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
-  #endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
+  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
+  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
+  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
 #endif
 #define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
 #define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
 #else
   #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
@@ -965,22 +521,16 @@
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
   #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
 #else
   #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
   #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
-  #define __Pyx_PySequence_ListKeepNew(obj)\
-    (likely(PyList_CheckExact(obj) && Py_REFCNT(obj) == 1) ? __Pyx_NewRef(obj) : PySequence_List(obj))
-#else
-  #define __Pyx_PySequence_ListKeepNew(obj)  PySequence_List(obj)
-#endif
 #ifndef PySet_CheckExact
-  #define PySet_CheckExact(obj)        __Pyx_IS_TYPE(obj, &PySet_Type)
+  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
 #if PY_VERSION_HEX >= 0x030900A4
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
 #else
   #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
   #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
@@ -991,46 +541,46 @@
   #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
-  #define __Pyx_Py3Int_Check(op)       PyLong_Check(op)
-  #define __Pyx_Py3Int_CheckExact(op)  PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
   #define PyInt_FromLong               PyLong_FromLong
   #define PyInt_FromSize_t             PyLong_FromSize_t
   #define PyInt_FromSsize_t            PyLong_FromSsize_t
   #define PyInt_AsLong                 PyLong_AsLong
   #define PyInt_AS_LONG                PyLong_AS_LONG
   #define PyInt_AsSsize_t              PyLong_AsSsize_t
   #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
   #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
   #define PyNumber_Int                 PyNumber_Long
-#else
-  #define __Pyx_Py3Int_Check(op)       (PyLong_Check(op) || PyInt_Check(op))
-  #define __Pyx_Py3Int_CheckExact(op)  (PyLong_CheckExact(op) || PyInt_CheckExact(op))
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyBoolObject                 PyLongObject
 #endif
 #if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
   #endif
 #endif
 #if PY_VERSION_HEX < 0x030200A4
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
+  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
+#else
+  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
 #if CYTHON_USE_ASYNC_SLOTS
   #if PY_VERSION_HEX >= 0x030500B1
     #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
     #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
   #else
     #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
@@ -1042,18 +592,16 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
-  #if !defined(_USE_MATH_DEFINES)
-    #define _USE_MATH_DEFINES
-  #endif
+#if defined(WIN32) || defined(MS_WINDOWS)
+  #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -1068,37 +616,30 @@
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
     { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
-#ifdef CYTHON_EXTERN_C
-    #undef __PYX_EXTERN_C
-    #define __PYX_EXTERN_C CYTHON_EXTERN_C
-#elif defined(__PYX_EXTERN_C)
-    #ifdef _MSC_VER
-    #pragma message ("Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.")
-    #else
-    #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
-    #endif
-#else
+#ifndef __PYX_EXTERN_C
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__chython__containers___cpack
-#define __PYX_HAVE_API__chython__containers___cpack
+#define __PYX_HAVE__chython__algorithms___isomorphism
+#define __PYX_HAVE_API__chython__algorithms___isomorphism
 /* Early includes */
-#include "pythread.h"
 #include <string.h>
+#include "pythread.h"
 #include <stdlib.h>
+#include <stdio.h>
+#include "pystate.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
@@ -1159,111 +700,54 @@
 #endif
 #define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
 #define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
-#define __Pyx_PyObject_AsWritableString(s)    ((char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
-#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*)(__pyx_uintptr_t) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
+#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
+static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
     const Py_UNICODE *u_end = u;
     while (*u_end++) ;
     return (size_t)(u_end - u - 1);
 }
-#endif
-#define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
 #define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
 #define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
 #else
 #define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
 #else
 #define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
 #endif
-#if CYTHON_USE_PYLONG_INTERNALS
-  #if PY_VERSION_HEX >= 0x030C00A7
-  #ifndef _PyLong_SIGN_MASK
-    #define _PyLong_SIGN_MASK 3
-  #endif
-  #ifndef _PyLong_NON_SIZE_BITS
-    #define _PyLong_NON_SIZE_BITS 3
-  #endif
-  #define __Pyx_PyLong_Sign(x)  (((PyLongObject*)x)->long_value.lv_tag & _PyLong_SIGN_MASK)
-  #define __Pyx_PyLong_IsNeg(x)  ((__Pyx_PyLong_Sign(x) & 2) != 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (!__Pyx_PyLong_IsNeg(x))
-  #define __Pyx_PyLong_IsZero(x)  (__Pyx_PyLong_Sign(x) & 1)
-  #define __Pyx_PyLong_IsPos(x)  (__Pyx_PyLong_Sign(x) == 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  (__Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  ((Py_ssize_t) (((PyLongObject*)x)->long_value.lv_tag >> _PyLong_NON_SIZE_BITS))
-  #define __Pyx_PyLong_SignedDigitCount(x)\
-        ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * __Pyx_PyLong_DigitCount(x))
-  #if defined(PyUnstable_Long_IsCompact) && defined(PyUnstable_Long_CompactValue)
-    #define __Pyx_PyLong_IsCompact(x)     PyUnstable_Long_IsCompact((PyLongObject*) x)
-    #define __Pyx_PyLong_CompactValue(x)  PyUnstable_Long_CompactValue((PyLongObject*) x)
-  #else
-    #define __Pyx_PyLong_IsCompact(x)     (((PyLongObject*)x)->long_value.lv_tag < (2 << _PyLong_NON_SIZE_BITS))
-    #define __Pyx_PyLong_CompactValue(x)  ((1 - (Py_ssize_t) __Pyx_PyLong_Sign(x)) * (Py_ssize_t) __Pyx_PyLong_Digits(x)[0])
-  #endif
-  typedef Py_ssize_t  __Pyx_compact_pylong;
-  typedef size_t  __Pyx_compact_upylong;
-  #else  // Py < 3.12
-  #define __Pyx_PyLong_IsNeg(x)  (Py_SIZE(x) < 0)
-  #define __Pyx_PyLong_IsNonNeg(x)  (Py_SIZE(x) >= 0)
-  #define __Pyx_PyLong_IsZero(x)  (Py_SIZE(x) == 0)
-  #define __Pyx_PyLong_IsPos(x)  (Py_SIZE(x) > 0)
-  #define __Pyx_PyLong_CompactValueUnsigned(x)  ((Py_SIZE(x) == 0) ? 0 : __Pyx_PyLong_Digits(x)[0])
-  #define __Pyx_PyLong_DigitCount(x)  __Pyx_sst_abs(Py_SIZE(x))
-  #define __Pyx_PyLong_SignedDigitCount(x)  Py_SIZE(x)
-  #define __Pyx_PyLong_IsCompact(x)  (Py_SIZE(x) == 0 || Py_SIZE(x) == 1 || Py_SIZE(x) == -1)
-  #define __Pyx_PyLong_CompactValue(x)\
-        ((Py_SIZE(x) == 0) ? (sdigit) 0 : ((Py_SIZE(x) < 0) ? -(sdigit)__Pyx_PyLong_Digits(x)[0] : (sdigit)__Pyx_PyLong_Digits(x)[0]))
-  typedef sdigit  __Pyx_compact_pylong;
-  typedef digit  __Pyx_compact_upylong;
-  #endif
-  #if PY_VERSION_HEX >= 0x030C00A5
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->long_value.ob_digit)
-  #else
-  #define __Pyx_PyLong_Digits(x)  (((PyLongObject*)x)->ob_digit)
-  #endif
-#endif
+#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
 static int __Pyx_sys_getdefaultencoding_not_ascii;
 static int __Pyx_init_sys_getdefaultencoding_params(void) {
     PyObject* sys;
     PyObject* default_encoding = NULL;
     PyObject* ascii_chars_u = NULL;
     PyObject* ascii_chars_b = NULL;
@@ -1277,15 +761,15 @@
     if (!default_encoding_c) goto bad;
     if (strcmp(default_encoding_c, "ascii") == 0) {
         __Pyx_sys_getdefaultencoding_not_ascii = 0;
     } else {
         char ascii_chars[128];
         int c;
         for (c = 0; c < 128; c++) {
-            ascii_chars[c] = (char) c;
+            ascii_chars[c] = c;
         }
         __Pyx_sys_getdefaultencoding_not_ascii = 1;
         ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
         if (!ascii_chars_u) goto bad;
         ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
         if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
             PyErr_Format(
@@ -1342,42 +826,105 @@
   #define unlikely(x) __builtin_expect(!!(x), 0)
 #else /* !__GNUC__ or GCC < 2.95 */
   #define likely(x)   (x)
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
 static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
 
-#if !CYTHON_USE_MODULE_STATE
 static PyObject *__pyx_m = NULL;
-#endif
+static PyObject *__pyx_d;
+static PyObject *__pyx_b;
+static PyObject *__pyx_cython_runtime = NULL;
+static PyObject *__pyx_empty_tuple;
+static PyObject *__pyx_empty_bytes;
+static PyObject *__pyx_empty_unicode;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
-static const char * __pyx_cfilenm = __FILE__;
+static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
 
-/* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "chython/containers/_cpack.pyx",
-  "<stringsource>",
+  "chython\\algorithms\\_isomorphism.pyx",
+  "stringsource",
 };
-/* #### Code section: utility_code_proto_before_types ### */
+/* MemviewSliceStruct.proto */
+struct __pyx_memoryview_obj;
+typedef struct {
+  struct __pyx_memoryview_obj *memview;
+  char *data;
+  Py_ssize_t shape[8];
+  Py_ssize_t strides[8];
+  Py_ssize_t suboffsets[8];
+} __Pyx_memviewslice;
+#define __Pyx_MemoryView_Len(m)  (m.shape[0])
+
+/* Atomics.proto */
+#include <pythread.h>
+#ifndef CYTHON_ATOMICS
+    #define CYTHON_ATOMICS 1
+#endif
+#define __pyx_atomic_int_type int
+#if CYTHON_ATOMICS && __GNUC__ >= 4 && (__GNUC_MINOR__ > 1 ||\
+                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL >= 2)) &&\
+                    !defined(__i386__)
+    #define __pyx_atomic_incr_aligned(value, lock) __sync_fetch_and_add(value, 1)
+    #define __pyx_atomic_decr_aligned(value, lock) __sync_fetch_and_sub(value, 1)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using GNU atomics"
+    #endif
+#elif CYTHON_ATOMICS && defined(_MSC_VER) && 0
+    #include <Windows.h>
+    #undef __pyx_atomic_int_type
+    #define __pyx_atomic_int_type LONG
+    #define __pyx_atomic_incr_aligned(value, lock) InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #pragma message ("Using MSVC atomics")
+    #endif
+#elif CYTHON_ATOMICS && (defined(__ICC) || defined(__INTEL_COMPILER)) && 0
+    #define __pyx_atomic_incr_aligned(value, lock) _InterlockedIncrement(value)
+    #define __pyx_atomic_decr_aligned(value, lock) _InterlockedDecrement(value)
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Using Intel atomics"
+    #endif
+#else
+    #undef CYTHON_ATOMICS
+    #define CYTHON_ATOMICS 0
+    #ifdef __PYX_DEBUG_ATOMICS
+        #warning "Not using atomics"
+    #endif
+#endif
+typedef volatile __pyx_atomic_int_type __pyx_atomic_int;
+#if CYTHON_ATOMICS
+    #define __pyx_add_acquisition_count(memview)\
+             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
+    #define __pyx_sub_acquisition_count(memview)\
+            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview), memview->lock)
+#else
+    #define __pyx_add_acquisition_count(memview)\
+            __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
+    #define __pyx_sub_acquisition_count(memview)\
+            __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
+#endif
+
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
 #endif
 
 /* NoFastGil.proto */
 #define __Pyx_PyGILState_Ensure PyGILState_Ensure
 #define __Pyx_PyGILState_Release PyGILState_Release
 #define __Pyx_FastGIL_Remember()
 #define __Pyx_FastGIL_Forget()
 #define __Pyx_FastGilFuncInit()
 
 /* BufferFormatStructs.proto */
+#define IS_UNSIGNED(type) (((type) -1) > 0)
 struct __Pyx_StructField_;
 #define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
 typedef struct {
   const char* name;
   struct __Pyx_StructField_* fields;
   size_t size;
   size_t arraysize[8];
@@ -1404,119 +951,83 @@
   int is_complex;
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
-/* Atomics.proto */
-#include <pythread.h>
-#ifndef CYTHON_ATOMICS
-    #define CYTHON_ATOMICS 1
-#endif
-#define __PYX_CYTHON_ATOMICS_ENABLED() CYTHON_ATOMICS
-#define __pyx_atomic_int_type int
-#define __pyx_nonatomic_int_type int
-#if CYTHON_ATOMICS && (defined(__STDC_VERSION__) &&\
-                        (__STDC_VERSION__ >= 201112L) &&\
-                        !defined(__STDC_NO_ATOMICS__))
-    #include <stdatomic.h>
-#elif CYTHON_ATOMICS && (defined(__cplusplus) && (\
-                    (__cplusplus >= 201103L) ||\
-                    (defined(_MSC_VER) && _MSC_VER >= 1700)))
-    #include <atomic>
-#endif
-#if CYTHON_ATOMICS && (defined(__STDC_VERSION__) &&\
-                        (__STDC_VERSION__ >= 201112L) &&\
-                        !defined(__STDC_NO_ATOMICS__) &&\
-                       ATOMIC_INT_LOCK_FREE == 2)
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type atomic_int
-    #define __pyx_atomic_incr_aligned(value) atomic_fetch_add_explicit(value, 1, memory_order_relaxed)
-    #define __pyx_atomic_decr_aligned(value) atomic_fetch_sub_explicit(value, 1, memory_order_acq_rel)
-    #if defined(__PYX_DEBUG_ATOMICS) && defined(_MSC_VER)
-        #pragma message ("Using standard C atomics")
-    #elif defined(__PYX_DEBUG_ATOMICS)
-        #warning "Using standard C atomics"
-    #endif
-#elif CYTHON_ATOMICS && (defined(__cplusplus) && (\
-                    (__cplusplus >= 201103L) ||\
-\
-                    (defined(_MSC_VER) && _MSC_VER >= 1700)) &&\
-                    ATOMIC_INT_LOCK_FREE == 2)
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type std::atomic_int
-    #define __pyx_atomic_incr_aligned(value) std::atomic_fetch_add_explicit(value, 1, std::memory_order_relaxed)
-    #define __pyx_atomic_decr_aligned(value) std::atomic_fetch_sub_explicit(value, 1, std::memory_order_acq_rel)
-    #if defined(__PYX_DEBUG_ATOMICS) && defined(_MSC_VER)
-        #pragma message ("Using standard C++ atomics")
-    #elif defined(__PYX_DEBUG_ATOMICS)
-        #warning "Using standard C++ atomics"
-    #endif
-#elif CYTHON_ATOMICS && (__GNUC__ >= 5 || (__GNUC__ == 4 &&\
-                    (__GNUC_MINOR__ > 1 ||\
-                    (__GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ >= 2))))
-    #define __pyx_atomic_incr_aligned(value) __sync_fetch_and_add(value, 1)
-    #define __pyx_atomic_decr_aligned(value) __sync_fetch_and_sub(value, 1)
-    #ifdef __PYX_DEBUG_ATOMICS
-        #warning "Using GNU atomics"
-    #endif
-#elif CYTHON_ATOMICS && defined(_MSC_VER)
-    #include <intrin.h>
-    #undef __pyx_atomic_int_type
-    #define __pyx_atomic_int_type long
-    #define __pyx_nonatomic_int_type long
-    #pragma intrinsic (_InterlockedExchangeAdd)
-    #define __pyx_atomic_incr_aligned(value) _InterlockedExchangeAdd(value, 1)
-    #define __pyx_atomic_decr_aligned(value) _InterlockedExchangeAdd(value, -1)
-    #ifdef __PYX_DEBUG_ATOMICS
-        #pragma message ("Using MSVC atomics")
-    #endif
-#else
-    #undef CYTHON_ATOMICS
-    #define CYTHON_ATOMICS 0
-    #ifdef __PYX_DEBUG_ATOMICS
-        #warning "Not using atomics"
-    #endif
-#endif
-#if CYTHON_ATOMICS
-    #define __pyx_add_acquisition_count(memview)\
-             __pyx_atomic_incr_aligned(__pyx_get_slice_count_pointer(memview))
-    #define __pyx_sub_acquisition_count(memview)\
-            __pyx_atomic_decr_aligned(__pyx_get_slice_count_pointer(memview))
-#else
-    #define __pyx_add_acquisition_count(memview)\
-            __pyx_add_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
-    #define __pyx_sub_acquisition_count(memview)\
-            __pyx_sub_acquisition_count_locked(__pyx_get_slice_count_pointer(memview), memview->lock)
-#endif
-
-/* MemviewSliceStruct.proto */
-struct __pyx_memoryview_obj;
-typedef struct {
-  struct __pyx_memoryview_obj *memview;
-  char *data;
-  Py_ssize_t shape[8];
-  Py_ssize_t strides[8];
-  Py_ssize_t suboffsets[8];
-} __Pyx_memviewslice;
-#define __Pyx_MemoryView_Len(m)  (m.shape[0])
-
-/* #### Code section: numeric_typedefs ### */
-/* #### Code section: complex_type_declarations ### */
-/* #### Code section: type_declarations ### */
 
 /*--- Type declarations ---*/
+struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "View.MemoryView":114
- * @cython.collection_type("sequence")
+/* "chython/algorithms/_isomorphism.pyx":30
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
+ *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+ *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+ */
+struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping {
+  PyObject_HEAD
+  unsigned int __pyx_v_back;
+  unsigned int __pyx_v_closures_counter;
+  unsigned int __pyx_v_closures_num;
+  unsigned int __pyx_v_depth;
+  unsigned int __pyx_v_front;
+  unsigned int __pyx_v_i;
+  unsigned int __pyx_v_j;
+  unsigned int __pyx_v_m;
+  PyObject *__pyx_v_mapping;
+  int *__pyx_v_matched;
+  unsigned int __pyx_v_n;
+  unsigned int __pyx_v_o;
+  __Pyx_memviewslice __pyx_v_o_bits1;
+  __Pyx_memviewslice __pyx_v_o_bits2;
+  __Pyx_memviewslice __pyx_v_o_bits3;
+  __Pyx_memviewslice __pyx_v_o_bits4;
+  unsigned PY_LONG_LONG __pyx_v_o_bond;
+  __Pyx_memviewslice __pyx_v_o_bonds;
+  unsigned PY_LONG_LONG *__pyx_v_o_closures;
+  __Pyx_memviewslice __pyx_v_o_from;
+  __Pyx_memviewslice __pyx_v_o_indices;
+  __Pyx_memviewslice __pyx_v_o_numbers;
+  unsigned int __pyx_v_o_size;
+  __Pyx_memviewslice __pyx_v_o_to;
+  int *__pyx_v_path;
+  unsigned int __pyx_v_path_size;
+  __Pyx_memviewslice __pyx_v_q_back;
+  __Pyx_memviewslice __pyx_v_q_bonds;
+  __Pyx_memviewslice __pyx_v_q_closures;
+  __Pyx_memviewslice __pyx_v_q_from;
+  __Pyx_memviewslice __pyx_v_q_indices;
+  unsigned PY_LONG_LONG __pyx_v_q_mask1;
+  unsigned PY_LONG_LONG __pyx_v_q_mask2;
+  unsigned PY_LONG_LONG __pyx_v_q_mask3;
+  unsigned PY_LONG_LONG __pyx_v_q_mask4;
+  __Pyx_memviewslice __pyx_v_q_masks1;
+  __Pyx_memviewslice __pyx_v_q_masks2;
+  __Pyx_memviewslice __pyx_v_q_masks3;
+  __Pyx_memviewslice __pyx_v_q_masks4;
+  __Pyx_memviewslice __pyx_v_q_numbers;
+  unsigned int __pyx_v_q_size;
+  unsigned int __pyx_v_q_size_dec;
+  __Pyx_memviewslice __pyx_v_q_to;
+  __Pyx_memviewslice __pyx_v_scope;
+  unsigned int __pyx_v_stack;
+  int *__pyx_v_stack_depth;
+  int *__pyx_v_stack_index;
+};
+
+
+/* "View.MemoryView":105
+ * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 struct __pyx_array_obj {
   PyObject_HEAD
@@ -1532,51 +1043,52 @@
   PyObject *_format;
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
-/* "View.MemoryView":302
+/* "View.MemoryView":279
  * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
-/* "View.MemoryView":337
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
- * cdef class memoryview:             # <<<<<<<<<<<<<<
+ * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
   PyObject_HEAD
   struct __pyx_vtabstruct_memoryview *__pyx_vtab;
   PyObject *obj;
   PyObject *_size;
   PyObject *_array_interface;
   PyThread_type_lock lock;
-  __pyx_atomic_int_type acquisition_count;
+  __pyx_atomic_int acquisition_count[2];
+  __pyx_atomic_int *acquisition_count_aligned_p;
   Py_buffer view;
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
-/* "View.MemoryView":952
- * @cython.collection_type("sequence")
+/* "View.MemoryView":965
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 struct __pyx_memoryviewslice_obj {
   struct __pyx_memoryview_obj __pyx_base;
@@ -1584,179 +1096,194 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "View.MemoryView":114
- * @cython.collection_type("sequence")
+/* "View.MemoryView":105
+ * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
-/* "View.MemoryView":337
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
- * cdef class memoryview:             # <<<<<<<<<<<<<<
+ * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 
 struct __pyx_vtabstruct_memoryview {
   char *(*get_item_pointer)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*is_slice)(struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*setitem_slice_assignment)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*setitem_slice_assign_scalar)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *);
   PyObject *(*setitem_indexed)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
-  PyObject *(*_get_base)(struct __pyx_memoryview_obj *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
-/* "View.MemoryView":952
- * @cython.collection_type("sequence")
+/* "View.MemoryView":965
+ * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 
 struct __pyx_vtabstruct__memoryviewslice {
   struct __pyx_vtabstruct_memoryview __pyx_base;
 };
 static struct __pyx_vtabstruct__memoryviewslice *__pyx_vtabptr__memoryviewslice;
-/* #### Code section: utility_code_proto ### */
 
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
-    void (*INCREF)(void*, PyObject*, Py_ssize_t);
-    void (*DECREF)(void*, PyObject*, Py_ssize_t);
-    void (*GOTREF)(void*, PyObject*, Py_ssize_t);
-    void (*GIVEREF)(void*, PyObject*, Py_ssize_t);
-    void* (*SetupContext)(const char*, Py_ssize_t, const char*);
+    void (*INCREF)(void*, PyObject*, int);
+    void (*DECREF)(void*, PyObject*, int);
+    void (*GOTREF)(void*, PyObject*, int);
+    void (*GIVEREF)(void*, PyObject*, int);
+    void* (*SetupContext)(const char*, int, const char*);
     void (*FinishContext)(void**);
   } __Pyx_RefNannyAPIStruct;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
   static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
   #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
 #ifdef WITH_THREAD
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
           if (acquire_gil) {\
               PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
               PyGILState_Release(__pyx_gilstate_save);\
           } else {\
-              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__));\
-          }
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
+              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
           }
 #else
   #define __Pyx_RefNannySetupContext(name, acquire_gil)\
-          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), (__LINE__), (__FILE__))
-  #define __Pyx_RefNannyFinishContextNogil() __Pyx_RefNannyFinishContext()
+          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
 #endif
-  #define __Pyx_RefNannyFinishContextNogil() {\
-              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
-              __Pyx_RefNannyFinishContext();\
-              PyGILState_Release(__pyx_gilstate_save);\
-          }
   #define __Pyx_RefNannyFinishContext()\
           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
-  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), (__LINE__))
-  #define __Pyx_XINCREF(r)  do { if((r) == NULL); else {__Pyx_INCREF(r); }} while(0)
-  #define __Pyx_XDECREF(r)  do { if((r) == NULL); else {__Pyx_DECREF(r); }} while(0)
-  #define __Pyx_XGOTREF(r)  do { if((r) == NULL); else {__Pyx_GOTREF(r); }} while(0)
-  #define __Pyx_XGIVEREF(r) do { if((r) == NULL); else {__Pyx_GIVEREF(r);}} while(0)
+  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
+  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
+  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
+  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
+  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
 #else
   #define __Pyx_RefNannyDeclarations
   #define __Pyx_RefNannySetupContext(name, acquire_gil)
-  #define __Pyx_RefNannyFinishContextNogil()
   #define __Pyx_RefNannyFinishContext()
   #define __Pyx_INCREF(r) Py_INCREF(r)
   #define __Pyx_DECREF(r) Py_DECREF(r)
   #define __Pyx_GOTREF(r)
   #define __Pyx_GIVEREF(r)
   #define __Pyx_XINCREF(r) Py_XINCREF(r)
   #define __Pyx_XDECREF(r) Py_XDECREF(r)
   #define __Pyx_XGOTREF(r)
   #define __Pyx_XGIVEREF(r)
 #endif
-#define __Pyx_Py_XDECREF_SET(r, v) do {\
-        PyObject *tmp = (PyObject *) r;\
-        r = v; Py_XDECREF(tmp);\
-    } while (0)
 #define __Pyx_XDECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_XDECREF(tmp);\
     } while (0)
 #define __Pyx_DECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_DECREF(tmp);\
     } while (0)
 #define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
 #define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+/* PyObjectGetAttrStr.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
 #else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
+/* GetBuiltinName.proto */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name);
+
+/* RaiseArgTupleInvalid.proto */
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+
+/* RaiseDoubleKeywords.proto */
+static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
+
+/* ParseKeywords.proto */
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
+    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
+    const char* function_name);
+
+/* MemviewSliceInit.proto */
+#define __Pyx_BUF_MAX_NDIMS %(BUF_MAX_NDIMS)d
+#define __Pyx_MEMVIEW_DIRECT   1
+#define __Pyx_MEMVIEW_PTR      2
+#define __Pyx_MEMVIEW_FULL     4
+#define __Pyx_MEMVIEW_CONTIG   8
+#define __Pyx_MEMVIEW_STRIDED  16
+#define __Pyx_MEMVIEW_FOLLOW   32
+#define __Pyx_IS_C_CONTIG 1
+#define __Pyx_IS_F_CONTIG 2
+static int __Pyx_init_memviewslice(
+                struct __pyx_memoryview_obj *memview,
+                int ndim,
+                __Pyx_memviewslice *memviewslice,
+                int memview_is_new_reference);
+static CYTHON_INLINE int __pyx_add_acquisition_count_locked(
+    __pyx_atomic_int *acquisition_count, PyThread_type_lock lock);
+static CYTHON_INLINE int __pyx_sub_acquisition_count_locked(
+    __pyx_atomic_int *acquisition_count, PyThread_type_lock lock);
+#define __pyx_get_slice_count_pointer(memview) (memview->acquisition_count_aligned_p)
+#define __pyx_get_slice_count(memview) (*__pyx_get_slice_count_pointer(memview))
+#define __PYX_INC_MEMVIEW(slice, have_gil) __Pyx_INC_MEMVIEW(slice, have_gil, __LINE__)
+#define __PYX_XDEC_MEMVIEW(slice, have_gil) __Pyx_XDEC_MEMVIEW(slice, have_gil, __LINE__)
+static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
+static CYTHON_INLINE void __Pyx_XDEC_MEMVIEW(__Pyx_memviewslice *, int, int);
+
 /* PyThreadStateGet.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
 #define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
-#if PY_VERSION_HEX >= 0x030C00A6
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->current_exception != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->current_exception ? (PyObject*) Py_TYPE(__pyx_tstate->current_exception) : (PyObject*) NULL)
-#else
-#define __Pyx_PyErr_Occurred()  (__pyx_tstate->curexc_type != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  (__pyx_tstate->curexc_type)
-#endif
+#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
 #else
 #define __Pyx_PyThreadState_declare
 #define __Pyx_PyThreadState_assign
-#define __Pyx_PyErr_Occurred()  (PyErr_Occurred() != NULL)
-#define __Pyx_PyErr_CurrentExceptionType()  PyErr_Occurred()
+#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
 #endif
 
 /* PyErrFetchRestore.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
 #define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
 #define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
 #define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
 #define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
 static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A6
+#if CYTHON_COMPILING_IN_CPYTHON
 #define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
 #else
 #define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
 #endif
 #else
 #define __Pyx_PyErr_Clear() PyErr_Clear()
 #define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
@@ -1764,194 +1291,127 @@
 #define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
 #endif
 
-/* PyObjectGetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
+/* GetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
-#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
-/* PyObjectGetAttrStrNoError.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
-
-/* GetBuiltinName.proto */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name);
-
-/* TupleAndListFromArray.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n);
-static CYTHON_INLINE PyObject* __Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n);
+/* SwapException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#else
+static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
-/* IncludeStringH.proto */
-#include <string.h>
-
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* UnicodeEquals.proto */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
-
-/* fastcall.proto */
-#define __Pyx_Arg_VARARGS(args, i) PyTuple_GET_ITEM(args, i)
-#define __Pyx_NumKwargs_VARARGS(kwds) PyDict_Size(kwds)
-#define __Pyx_KwValues_VARARGS(args, nargs) NULL
-#define __Pyx_GetKwValue_VARARGS(kw, kwvalues, s) __Pyx_PyDict_GetItemStrWithError(kw, s)
-#define __Pyx_KwargsAsDict_VARARGS(kw, kwvalues) PyDict_Copy(kw)
-#if CYTHON_METH_FASTCALL
-    #define __Pyx_Arg_FASTCALL(args, i) args[i]
-    #define __Pyx_NumKwargs_FASTCALL(kwds) PyTuple_GET_SIZE(kwds)
-    #define __Pyx_KwValues_FASTCALL(args, nargs) ((args) + (nargs))
-    static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s);
-    #define __Pyx_KwargsAsDict_FASTCALL(kw, kwvalues) _PyStack_AsDict(kwvalues, kw)
-#else
-    #define __Pyx_Arg_FASTCALL __Pyx_Arg_VARARGS
-    #define __Pyx_NumKwargs_FASTCALL __Pyx_NumKwargs_VARARGS
-    #define __Pyx_KwValues_FASTCALL __Pyx_KwValues_VARARGS
-    #define __Pyx_GetKwValue_FASTCALL __Pyx_GetKwValue_VARARGS
-    #define __Pyx_KwargsAsDict_FASTCALL __Pyx_KwargsAsDict_VARARGS
+/* GetTopmostException.proto */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_VARARGS(args, start), stop - start)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) __Pyx_PyTuple_FromArray(&__Pyx_Arg_FASTCALL(args, start), stop - start)
+
+/* SaveResetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
 #else
-#define __Pyx_ArgsSlice_VARARGS(args, start, stop) PyTuple_GetSlice(args, start, stop)
-#define __Pyx_ArgsSlice_FASTCALL(args, start, stop) PyTuple_GetSlice(args, start, stop)
+#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
+#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
 #endif
 
-/* RaiseArgTupleInvalid.proto */
-static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
-    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
-
-/* RaiseDoubleKeywords.proto */
-static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
-
-/* ParseKeywords.proto */
-static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject *const *kwvalues,
-    PyObject **argnames[],
-    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,
-    const char* function_name);
-
 /* ArgTypeTest.proto */
 #define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
-    ((likely(__Pyx_IS_TYPE(obj, type) | (none_allowed && (obj == Py_None)))) ? 1 :\
+    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
         __Pyx__ArgTypeTest(obj, type, name, exact))
 static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
 
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
 /* RaiseException.proto */
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
 
+/* PyCFunctionFastCall.proto */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+#else
+#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#endif
+
 /* PyFunctionFastCall.proto */
 #if CYTHON_FAST_PYCALL
-#if !CYTHON_VECTORCALL
 #define __Pyx_PyFunction_FastCall(func, args, nargs)\
     __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
+#if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
+#else
+#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
-#if !CYTHON_VECTORCALL
-#if PY_VERSION_HEX >= 0x03080000
-  #include "frameobject.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-  #define __Pxy_PyFrame_Initialize_Offsets()
-  #define __Pyx_PyFrame_GetLocalsplus(frame)  ((frame)->f_localsplus)
-#else
   static size_t __pyx_pyframe_localsplus_offset = 0;
   #include "frameobject.h"
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
 #endif
-#endif
-#endif
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
+/* PyObjectCall2Args.proto */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
 
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
 #endif
 
-/* PyObjectFastCall.proto */
-#define __Pyx_PyObject_FastCall(func, args, nargs)  __Pyx_PyObject_FastCallDict(func, args, (size_t)(nargs), NULL)
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs);
+/* PyObjectCallOneArg.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
 
-/* RaiseUnexpectedTypeError.proto */
-static int __Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj);
+/* IncludeStringH.proto */
+#include <string.h>
 
-/* GCCDiagnostics.proto */
-#if !defined(__INTEL_COMPILER) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
-#define __Pyx_HAS_GCC_DIAGNOSTIC
-#endif
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
 
-/* BuildPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char);
-
-/* CIntToPyUnicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_int(int value, Py_ssize_t width, char padding_char, char format_char);
-
-/* CIntToPyUnicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char);
-
-/* JoinPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char);
+/* UnicodeEquals.proto */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
 
 /* StrEquals.proto */
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
 #else
 #define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
 #endif
 
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_repr(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_repr(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#endif
+/* None.proto */
+static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
+
+/* UnaryNegOverflows.proto */
+#define UNARY_NEG_WOULD_OVERFLOW(x)\
+        (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
 /* GetAttr.proto */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
 
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
@@ -1970,33 +1430,48 @@
     (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                               int wraparound, int boundscheck);
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                      int is_list, int wraparound, int boundscheck);
 
-/* PyObjectCallOneArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
-
 /* ObjectGetItem.proto */
 #if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key);
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
 #else
 #define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
 #endif
 
-/* KeywordStringCheck.proto */
-static int __Pyx_CheckKeywordStrings(PyObject *kw, const char* function_name, int kw_allowed);
+/* decode_c_string_utf16.proto */
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 0;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = -1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+
+/* decode_c_string.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
 
-/* DivInt[Py_ssize_t].proto */
-static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
-
-/* UnaryNegOverflows.proto */
-#define __Pyx_UNARY_NEG_WOULD_OVERFLOW(x)\
-        (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
 
 /* GetAttr3.proto */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
 
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
@@ -2021,124 +1496,62 @@
 #define __PYX_GET_DICT_VERSION(dict)  (0)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
 #define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
 /* GetModuleGlobalName.proto */
 #if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
+#define __Pyx_GetModuleGlobalName(var, name)  {\
     static PY_UINT64_T __pyx_dict_version = 0;\
     static PyObject *__pyx_dict_cached_value = NULL;\
     (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
         (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
         __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
     PY_UINT64_T __pyx_dict_version;\
     PyObject *__pyx_dict_cached_value;\
     (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
+}
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
-/* AssertionsEnabled.proto */
-#define __Pyx_init_assertions_enabled()
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define __pyx_assertions_enabled() (1)
-#elif PY_VERSION_HEX < 0x03080000  ||  CYTHON_COMPILING_IN_PYPY  ||  defined(Py_LIMITED_API)
-  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
-#elif CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030900A6
-  static int __pyx_assertions_enabled_flag;
-  #define __pyx_assertions_enabled() (__pyx_assertions_enabled_flag)
-  #undef __Pyx_init_assertions_enabled
-  static void __Pyx_init_assertions_enabled(void) {
-    __pyx_assertions_enabled_flag = ! _PyInterpreterState_GetConfig(__Pyx_PyThreadState_Current->interp)->optimization_level;
-  }
-#else
-  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
-#endif
-
 /* RaiseTooManyValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
 /* RaiseNeedMoreValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
 /* RaiseNoneIterError.proto */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
 /* ExtTypeTest.proto */
 static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
 
-/* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
-static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
-#endif
-
-/* SaveResetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-#else
-#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
-#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
-#endif
-
-/* GetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
-#endif
-
-/* SwapException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#else
-static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
-#endif
-
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
-/* ImportDottedModule.proto */
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple);
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple);
-#endif
-
-/* ssize_strlen.proto */
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s);
-
 /* FastTypeChecks.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 #define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) __Pyx_IsAnySubtype2(Py_TYPE(obj), (PyTypeObject *)type1, (PyTypeObject *)type2)
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
 static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
 #else
 #define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
-#define __Pyx_TypeCheck2(obj, type1, type2) (PyObject_TypeCheck(obj, (PyTypeObject *)type1) || PyObject_TypeCheck(obj, (PyTypeObject *)type2))
 #define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
 #define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
 #endif
-#define __Pyx_PyErr_ExceptionMatches2(err1, err2)  __Pyx_PyErr_GivenExceptionMatches2(__Pyx_PyErr_CurrentExceptionType(), err1, err2)
 #define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
 
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 /* ListCompAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len)) {
         Py_INCREF(x);
@@ -2148,46 +1561,35 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* PySequenceMultiply.proto */
-#define __Pyx_PySequence_Multiply_Left(mul, seq)  __Pyx_PySequence_Multiply(seq, mul)
-static CYTHON_INLINE PyObject* __Pyx_PySequence_Multiply(PyObject *seq, Py_ssize_t mul);
-
-/* SetItemInt.proto */
-#define __Pyx_SetItemInt(o, i, v, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
-               __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
-static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
-                                               int is_list, int wraparound, int boundscheck);
-
-/* RaiseUnboundLocalError.proto */
-static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
-
-/* DivInt[long].proto */
-static CYTHON_INLINE long __Pyx_div_long(long, long);
+/* PyIntBinop.proto */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
+#else
+#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
+    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
+#endif
 
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+/* ListExtend.proto */
+static CYTHON_INLINE int __Pyx_PyList_Extend(PyObject* L, PyObject* v) {
+#if CYTHON_COMPILING_IN_CPYTHON
+    PyObject* none = _PyList_Extend((PyListObject*)L, v);
+    if (unlikely(!none))
+        return -1;
+    Py_DECREF(none);
+    return 0;
+#else
+    return PyList_SetSlice(L, PY_SSIZE_T_MAX, PY_SSIZE_T_MAX, v);
+#endif
 }
 
-/* ImportFrom.proto */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
-
-/* HasAttr.proto */
-static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
-
 /* ListAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
         Py_INCREF(x);
@@ -2197,33 +1599,25 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* DictGetItem.proto */
-#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
-static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
-#define __Pyx_PyObject_Dict_GetItem(obj, name)\
-    (likely(PyDict_CheckExact(obj)) ?\
-     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
-#else
-#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
-#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
-#endif
+/* None.proto */
+static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-/* PyObjectSetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
-#else
-#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
-#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
-#endif
+/* None.proto */
+static CYTHON_INLINE long __Pyx_div_long(long, long);
+
+/* ImportFrom.proto */
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
+
+/* HasAttr.proto */
+static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
@@ -2231,196 +1625,44 @@
 /* PyObject_GenericGetAttr.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
 #endif
 
-/* IncludeStructmemberH.proto */
-#include <structmember.h>
-
-/* FixUpExtensionType.proto */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
-#endif
-
-/* PyObjectCallNoArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
-
-/* PyObjectGetMethod.proto */
-static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
-
-/* PyObjectCallMethod0.proto */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
-
-/* ValidateBasesTuple.proto */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases);
-#endif
-
-/* PyType_Ready.proto */
-CYTHON_UNUSED static int __Pyx_PyType_Ready(PyTypeObject *t);
-
 /* SetVTable.proto */
-static int __Pyx_SetVtable(PyTypeObject* typeptr , void* vtable);
+static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
-/* GetVTable.proto */
-static void* __Pyx_GetVtable(PyTypeObject *type);
-
-/* MergeVTables.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type);
-#endif
+/* PyObjectGetAttrStrNoError.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce(PyObject* type_obj);
-#endif
-
-/* FetchSharedCythonModule.proto */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void);
-
-/* FetchCommonType.proto */
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
-#else
-static PyTypeObject* __Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases);
-#endif
-
-/* PyMethodNew.proto */
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_PyMethod_New(PyObject *func, PyObject *self, PyObject *typ) {
-    CYTHON_UNUSED_VAR(typ);
-    if (!self)
-        return __Pyx_NewRef(func);
-    return PyMethod_New(func, self);
-}
-#else
-    #define __Pyx_PyMethod_New PyMethod_New
-#endif
-
-/* PyVectorcallFastCallDict.proto */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw);
-#endif
-
-/* CythonFunctionShared.proto */
-#define __Pyx_CyFunction_USED
-#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
-#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
-#define __Pyx_CYFUNCTION_CCLASS        0x04
-#define __Pyx_CYFUNCTION_COROUTINE     0x08
-#define __Pyx_CyFunction_GetClosure(f)\
-    (((__pyx_CyFunctionObject *) (f))->func_closure)
-#if PY_VERSION_HEX < 0x030900B1
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      (((__pyx_CyFunctionObject *) (f))->func_classobj)
-#else
-  #define __Pyx_CyFunction_GetClassObj(f)\
-      ((PyObject*) ((PyCMethodObject *) (f))->mm_class)
-#endif
-#define __Pyx_CyFunction_SetClassObj(f, classobj)\
-    __Pyx__CyFunction_SetClassObj((__pyx_CyFunctionObject *) (f), (classobj))
-#define __Pyx_CyFunction_Defaults(type, f)\
-    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
-#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
-    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
-typedef struct {
-#if PY_VERSION_HEX < 0x030900B1
-    PyCFunctionObject func;
-#else
-    PyCMethodObject func;
-#endif
-#if CYTHON_BACKPORT_VECTORCALL
-    __pyx_vectorcallfunc func_vectorcall;
-#endif
-#if PY_VERSION_HEX < 0x030500A0
-    PyObject *func_weakreflist;
-#endif
-    PyObject *func_dict;
-    PyObject *func_name;
-    PyObject *func_qualname;
-    PyObject *func_doc;
-    PyObject *func_globals;
-    PyObject *func_code;
-    PyObject *func_closure;
-#if PY_VERSION_HEX < 0x030900B1
-    PyObject *func_classobj;
-#endif
-    void *defaults;
-    int defaults_pyobjects;
-    size_t defaults_size;  // used by FusedFunction for copying defaults
-    int flags;
-    PyObject *defaults_tuple;
-    PyObject *defaults_kwdict;
-    PyObject *(*defaults_getter)(PyObject *);
-    PyObject *func_annotations;
-    PyObject *func_is_coroutine;
-} __pyx_CyFunctionObject;
-#define __Pyx_CyFunction_Check(obj)  __Pyx_TypeCheck(obj, __pyx_CyFunctionType)
-#define __Pyx_IsCyOrPyCFunction(obj)  __Pyx_TypeCheck2(obj, __pyx_CyFunctionType, &PyCFunction_Type)
-#define __Pyx_CyFunction_CheckExact(obj)  __Pyx_IS_TYPE(obj, __pyx_CyFunctionType)
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj);
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
-                                                         size_t size,
-                                                         int pyobjects);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
-                                                            PyObject *tuple);
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
-                                                             PyObject *dict);
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
-                                                              PyObject *dict);
-static int __pyx_CyFunction_init(PyObject *module);
-#if CYTHON_METH_FASTCALL
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames);
-#if CYTHON_BACKPORT_VECTORCALL
-#define __Pyx_CyFunction_func_vectorcall(f) (((__pyx_CyFunctionObject*)f)->func_vectorcall)
-#else
-#define __Pyx_CyFunction_func_vectorcall(f) (((PyCFunctionObject*)f)->vectorcall)
-#endif
-#endif
-
-/* CythonFunction.proto */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
-                                      int flags, PyObject* qualname,
-                                      PyObject *closure,
-                                      PyObject *module, PyObject *globals,
-                                      PyObject* code);
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
 /* CodeObjectCache.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 typedef struct {
     PyCodeObject* code_object;
     int code_line;
 } __Pyx_CodeObjectCacheEntry;
 struct __Pyx_CodeObjectCache {
     int count;
     int max_count;
     __Pyx_CodeObjectCacheEntry* entries;
 };
 static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
 static PyCodeObject *__pyx_find_code_object(int code_line);
 static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);
-#endif
 
 /* AddTraceback.proto */
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename);
 
 #if PY_MAJOR_VERSION < 3
     static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
@@ -2449,14 +1691,17 @@
 static int __pyx_memviewslice_is_contig(const __Pyx_memviewslice mvs, char order, int ndim);
 
 /* OverlappingSlices.proto */
 static int __pyx_slices_overlap(__Pyx_memviewslice *slice1,
                                 __Pyx_memviewslice *slice2,
                                 int ndim, size_t itemsize);
 
+/* Capsule.proto */
+static CYTHON_INLINE PyObject *__pyx_capsule_create(void *p, const char *sig);
+
 /* IsLittleEndian.proto */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
 
 /* BufferFormatCheck.proto */
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
 static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
                               __Pyx_BufFmt_StackElem* stack,
@@ -2473,137 +1718,197 @@
                 int ndim,
                 __Pyx_TypeInfo *dtype,
                 __Pyx_BufFmt_StackElem stack[],
                 __Pyx_memviewslice *memviewslice,
                 PyObject *original_obj);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(PyObject *, int writable_flag);
+
+/* ObjectToMemviewSlice.proto */
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(PyObject *, int writable_flag);
+
+/* ObjectToMemviewSlice.proto */
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(PyObject *, int writable_flag);
+
+/* GCCDiagnostics.proto */
+#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define __Pyx_HAS_GCC_DIAGNOSTIC
+#endif
 
 /* MemviewDtypeToObject.proto */
-static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_char__const__(const char *itemp);
+static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_long(const char *itemp);
+static CYTHON_INLINE int __pyx_memview_set_unsigned_long(const char *itemp, PyObject *obj);
 
 /* MemviewSliceCopyTemplate.proto */
 static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object);
 
-/* MemviewSliceInit.proto */
-#define __Pyx_BUF_MAX_NDIMS %(BUF_MAX_NDIMS)d
-#define __Pyx_MEMVIEW_DIRECT   1
-#define __Pyx_MEMVIEW_PTR      2
-#define __Pyx_MEMVIEW_FULL     4
-#define __Pyx_MEMVIEW_CONTIG   8
-#define __Pyx_MEMVIEW_STRIDED  16
-#define __Pyx_MEMVIEW_FOLLOW   32
-#define __Pyx_IS_C_CONTIG 1
-#define __Pyx_IS_F_CONTIG 2
-static int __Pyx_init_memviewslice(
-                struct __pyx_memoryview_obj *memview,
-                int ndim,
-                __Pyx_memviewslice *memviewslice,
-                int memview_is_new_reference);
-static CYTHON_INLINE int __pyx_add_acquisition_count_locked(
-    __pyx_atomic_int_type *acquisition_count, PyThread_type_lock lock);
-static CYTHON_INLINE int __pyx_sub_acquisition_count_locked(
-    __pyx_atomic_int_type *acquisition_count, PyThread_type_lock lock);
-#define __pyx_get_slice_count_pointer(memview) (&memview->acquisition_count)
-#define __PYX_INC_MEMVIEW(slice, have_gil) __Pyx_INC_MEMVIEW(slice, have_gil, __LINE__)
-#define __PYX_XCLEAR_MEMVIEW(slice, have_gil) __Pyx_XCLEAR_MEMVIEW(slice, have_gil, __LINE__)
-static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
-static CYTHON_INLINE void __Pyx_XCLEAR_MEMVIEW(__Pyx_memviewslice *, int, int);
-
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value);
-
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value);
 
 /* CIntFromPy.proto */
-static CYTHON_INLINE unsigned short __Pyx_PyInt_As_unsigned_short(PyObject *);
+static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_short(unsigned short value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value);
 
 /* CIntFromPy.proto */
-static CYTHON_INLINE unsigned char __Pyx_PyInt_As_unsigned_char(PyObject *);
+static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value);
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
-/* FormatTypeName.proto */
-#if CYTHON_COMPILING_IN_LIMITED_API
-typedef PyObject *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%U"
-static __Pyx_TypeName __Pyx_PyType_GetName(PyTypeObject* tp);
-#define __Pyx_DECREF_TypeName(obj) Py_XDECREF(obj)
-#else
-typedef const char *__Pyx_TypeName;
-#define __Pyx_FMT_TYPENAME "%.200s"
-#define __Pyx_PyType_GetName(tp) ((tp)->tp_name)
-#define __Pyx_DECREF_TypeName(obj)
+/* FetchCommonType.proto */
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
+
+/* PyObjectGetMethod.proto */
+static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
+
+/* PyObjectCallMethod1.proto */
+static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);
+
+/* CoroutineBase.proto */
+typedef PyObject *(*__pyx_coroutine_body_t)(PyObject *, PyThreadState *, PyObject *);
+#if CYTHON_USE_EXC_INFO_STACK
+#define __Pyx_ExcInfoStruct  _PyErr_StackItem
+#else
+typedef struct {
+    PyObject *exc_type;
+    PyObject *exc_value;
+    PyObject *exc_traceback;
+} __Pyx_ExcInfoStruct;
+#endif
+typedef struct {
+    PyObject_HEAD
+    __pyx_coroutine_body_t body;
+    PyObject *closure;
+    __Pyx_ExcInfoStruct gi_exc_state;
+    PyObject *gi_weakreflist;
+    PyObject *classobj;
+    PyObject *yieldfrom;
+    PyObject *gi_name;
+    PyObject *gi_qualname;
+    PyObject *gi_modulename;
+    PyObject *gi_code;
+    PyObject *gi_frame;
+    int resume_label;
+    char is_running;
+} __pyx_CoroutineObject;
+static __pyx_CoroutineObject *__Pyx__Coroutine_New(
+    PyTypeObject *type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
+    PyObject *name, PyObject *qualname, PyObject *module_name);
+static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
+            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
+            PyObject *name, PyObject *qualname, PyObject *module_name);
+static CYTHON_INLINE void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *self);
+static int __Pyx_Coroutine_clear(PyObject *self);
+static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
+static PyObject *__Pyx_Coroutine_Close(PyObject *self);
+static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
+#if CYTHON_USE_EXC_INFO_STACK
+#define __Pyx_Coroutine_SwapException(self)
+#define __Pyx_Coroutine_ResetAndClearException(self)  __Pyx_Coroutine_ExceptionClear(&(self)->gi_exc_state)
+#else
+#define __Pyx_Coroutine_SwapException(self) {\
+    __Pyx_ExceptionSwap(&(self)->gi_exc_state.exc_type, &(self)->gi_exc_state.exc_value, &(self)->gi_exc_state.exc_traceback);\
+    __Pyx_Coroutine_ResetFrameBackpointer(&(self)->gi_exc_state);\
+    }
+#define __Pyx_Coroutine_ResetAndClearException(self) {\
+    __Pyx_ExceptionReset((self)->gi_exc_state.exc_type, (self)->gi_exc_state.exc_value, (self)->gi_exc_state.exc_traceback);\
+    (self)->gi_exc_state.exc_type = (self)->gi_exc_state.exc_value = (self)->gi_exc_state.exc_traceback = NULL;\
+    }
 #endif
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
+    __Pyx_PyGen__FetchStopIterationValue(__pyx_tstate, pvalue)
+#else
+#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
+    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, pvalue)
+#endif
+static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *tstate, PyObject **pvalue);
+static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state);
+
+/* PatchModuleWithCoroutine.proto */
+static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);
+
+/* PatchGeneratorABC.proto */
+static int __Pyx_patch_abc(void);
+
+/* Generator.proto */
+#define __Pyx_Generator_USED
+static PyTypeObject *__pyx_GeneratorType = 0;
+#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
+#define __Pyx_Generator_New(body, code, closure, name, qualname, module_name)\
+    __Pyx__Coroutine_New(__pyx_GeneratorType, body, code, closure, name, qualname, module_name)
+static PyObject *__Pyx_Generator_Next(PyObject *self);
+static int __pyx_Generator_init(void);
 
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
-/* #### Code section: module_declarations ### */
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *__pyx_v_self); /* proto*/
 static char *__pyx_memoryview_get_item_pointer(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index); /* proto*/
 static PyObject *__pyx_memoryview_is_slice(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj); /* proto*/
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src); /* proto*/
 static PyObject *__pyx_memoryview_setitem_slice_assign_scalar(struct __pyx_memoryview_obj *__pyx_v_self, struct __pyx_memoryview_obj *__pyx_v_dst, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_setitem_indexed(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_convert_item_to_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryview_assign_item_from_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
-static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self); /* proto*/
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
-static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto*/
 
-/* Module declarations from "cython.view" */
+/* Module declarations from 'cython.view' */
 
-/* Module declarations from "cython.dataclasses" */
+/* Module declarations from 'cython' */
 
-/* Module declarations from "cython" */
+/* Module declarations from 'cpython.mem' */
 
-/* Module declarations from "cpython.mem" */
+/* Module declarations from 'libc.string' */
 
-/* Module declarations from "chython.containers._cpack" */
-static PyObject *__pyx_collections_abc_Sequence = 0;
+/* Module declarations from 'chython.algorithms._isomorphism' */
+static PyTypeObject *__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = 0;
+static PyTypeObject *__pyx_array_type = 0;
+static PyTypeObject *__pyx_MemviewEnum_type = 0;
+static PyTypeObject *__pyx_memoryview_type = 0;
+static PyTypeObject *__pyx_memoryviewslice_type = 0;
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
-static int __pyx_array_allocate_buffer(struct __pyx_array_obj *); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
+static void *__pyx_align_pointer(void *, size_t); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
-static int assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
+static PyObject *assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
 static int __pyx_memoryview_slice_memviewslice(__Pyx_memviewslice *, Py_ssize_t, Py_ssize_t, Py_ssize_t, int, int, int *, Py_ssize_t, Py_ssize_t, Py_ssize_t, int, int, int, int); /*proto*/
 static char *__pyx_pybuffer_index(Py_buffer *, char *, Py_ssize_t, Py_ssize_t); /*proto*/
 static int __pyx_memslice_transpose(__Pyx_memviewslice *); /*proto*/
 static PyObject *__pyx_memoryview_fromslice(__Pyx_memviewslice, int, PyObject *(*)(char *), int (*)(char *, PyObject *), int); /*proto*/
 static __Pyx_memviewslice *__pyx_memoryview_get_slice_from_memoryview(struct __pyx_memoryview_obj *, __Pyx_memviewslice *); /*proto*/
 static void __pyx_memoryview_slice_copy(struct __pyx_memoryview_obj *, __Pyx_memviewslice *); /*proto*/
@@ -2613,210 +1918,319 @@
 static char __pyx_get_best_slice_order(__Pyx_memviewslice *, int); /*proto*/
 static void _copy_strided_to_strided(char *, Py_ssize_t *, char *, Py_ssize_t *, Py_ssize_t *, Py_ssize_t *, int, size_t); /*proto*/
 static void copy_strided_to_strided(__Pyx_memviewslice *, __Pyx_memviewslice *, int, size_t); /*proto*/
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *, int); /*proto*/
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *, Py_ssize_t *, Py_ssize_t, int, char); /*proto*/
 static void *__pyx_memoryview_copy_data_to_temp(__Pyx_memviewslice *, __Pyx_memviewslice *, char, int); /*proto*/
 static int __pyx_memoryview_err_extents(int, Py_ssize_t, Py_ssize_t); /*proto*/
-static int __pyx_memoryview_err_dim(PyObject *, PyObject *, int); /*proto*/
-static int __pyx_memoryview_err(PyObject *, PyObject *); /*proto*/
-static int __pyx_memoryview_err_no_memory(void); /*proto*/
+static int __pyx_memoryview_err_dim(PyObject *, char *, int); /*proto*/
+static int __pyx_memoryview_err(PyObject *, char *); /*proto*/
 static int __pyx_memoryview_copy_contents(__Pyx_memviewslice, __Pyx_memviewslice, int, int, int); /*proto*/
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *, int, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
-/* #### Code section: typeinfo ### */
-static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_char__const__ = { "const unsigned char", NULL, sizeof(unsigned char const ), { 0 }, 0, __PYX_IS_UNSIGNED(unsigned char const ) ? 'U' : 'I', __PYX_IS_UNSIGNED(unsigned char const ), 0 };
-/* #### Code section: before_global_var ### */
-#define __Pyx_MODULE_NAME "chython.containers._cpack"
-extern int __pyx_module_is_main_chython__containers___cpack;
-int __pyx_module_is_main_chython__containers___cpack = 0;
+static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_long = { "unsigned long", NULL, sizeof(unsigned long), { 0 }, 0, IS_UNSIGNED(unsigned long) ? 'U' : 'I', IS_UNSIGNED(unsigned long), 0 };
+static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_int = { "unsigned int", NULL, sizeof(unsigned int), { 0 }, 0, IS_UNSIGNED(unsigned int) ? 'U' : 'I', IS_UNSIGNED(unsigned int), 0 };
+static __Pyx_TypeInfo __Pyx_TypeInfo_unsigned_PY_LONG_LONG = { "unsigned long long", NULL, sizeof(unsigned PY_LONG_LONG), { 0 }, 0, IS_UNSIGNED(unsigned PY_LONG_LONG) ? 'U' : 'I', IS_UNSIGNED(unsigned PY_LONG_LONG), 0 };
+#define __Pyx_MODULE_NAME "chython.algorithms._isomorphism"
+extern int __pyx_module_is_main_chython__algorithms___isomorphism;
+int __pyx_module_is_main_chython__algorithms___isomorphism = 0;
 
-/* Implementation of "chython.containers._cpack" */
-/* #### Code section: global_var ### */
+/* Implementation of 'chython.algorithms._isomorphism' */
+static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_range;
-static PyObject *__pyx_builtin_object;
-static PyObject *__pyx_builtin___import__;
 static PyObject *__pyx_builtin_ValueError;
-static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_TypeError;
-static PyObject *__pyx_builtin_AssertionError;
 static PyObject *__pyx_builtin_Ellipsis;
 static PyObject *__pyx_builtin_id;
 static PyObject *__pyx_builtin_IndexError;
-/* #### Code section: string_decls ### */
-static const char __pyx_k_[] = ": ";
 static const char __pyx_k_O[] = "O";
-static const char __pyx_k_a[] = "a";
-static const char __pyx_k_b[] = "b";
 static const char __pyx_k_c[] = "c";
 static const char __pyx_k_i[] = "i";
+static const char __pyx_k_j[] = "j";
 static const char __pyx_k_m[] = "m";
 static const char __pyx_k_n[] = "n";
-static const char __pyx_k__2[] = ".";
-static const char __pyx_k__3[] = "*";
-static const char __pyx_k__6[] = "'";
-static const char __pyx_k__7[] = ")";
-static const char __pyx_k_gc[] = "gc";
+static const char __pyx_k_o[] = "o";
 static const char __pyx_k_id[] = "id";
-static const char __pyx_k__23[] = "?";
-static const char __pyx_k_abc[] = "abc";
-static const char __pyx_k_and[] = " and ";
-static const char __pyx_k_got[] = " (got ";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
-static const char __pyx_k_sys[] = "sys";
-static const char __pyx_k_Bond[] = "Bond";
+static const char __pyx_k_args[] = "args";
+static const char __pyx_k_back[] = "back";
 static const char __pyx_k_base[] = "base";
-static const char __pyx_k_bond[] = "bond";
-static const char __pyx_k_data[] = "data";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
+static const char __pyx_k_o_to[] = "o_to";
 static const char __pyx_k_pack[] = "pack";
-static const char __pyx_k_py_m[] = "py_m";
-static const char __pyx_k_py_n[] = "py_n";
-static const char __pyx_k_seen[] = "seen";
+static const char __pyx_k_path[] = "path";
+static const char __pyx_k_q_to[] = "q_to";
+static const char __pyx_k_send[] = "send";
 static const char __pyx_k_size[] = "size";
-static const char __pyx_k_spec[] = "__spec__";
 static const char __pyx_k_step[] = "step";
 static const char __pyx_k_stop[] = "stop";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_ASCII[] = "ASCII";
-static const char __pyx_k_atoms[] = "atoms";
 static const char __pyx_k_class[] = "__class__";
-static const char __pyx_k_count[] = "count";
+static const char __pyx_k_close[] = "close";
+static const char __pyx_k_depth[] = "depth";
 static const char __pyx_k_error[] = "error";
 static const char __pyx_k_flags[] = "flags";
-static const char __pyx_k_index[] = "index";
-static const char __pyx_k_py_xy[] = "py_xy";
+static const char __pyx_k_front[] = "front";
 static const char __pyx_k_range[] = "range";
+static const char __pyx_k_scope[] = "scope";
 static const char __pyx_k_shape[] = "shape";
-static const char __pyx_k_shift[] = "shift";
+static const char __pyx_k_stack[] = "stack";
 static const char __pyx_k_start[] = "start";
-static const char __pyx_k_enable[] = "enable";
+static const char __pyx_k_throw[] = "throw";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_name_2[] = "__name__";
-static const char __pyx_k_object[] = "object";
-static const char __pyx_k_orders[] = "orders";
+static const char __pyx_k_o_bond[] = "o_bond";
+static const char __pyx_k_o_from[] = "o_from";
+static const char __pyx_k_o_size[] = "o_size";
 static const char __pyx_k_pickle[] = "pickle";
-static const char __pyx_k_py_ngb[] = "py_ngb";
+static const char __pyx_k_q_back[] = "q_back";
+static const char __pyx_k_q_from[] = "q_from";
+static const char __pyx_k_q_size[] = "q_size";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
-static const char __pyx_k_Bond__m[] = "_Bond__m";
-static const char __pyx_k_Bond__n[] = "_Bond__n";
-static const char __pyx_k_charges[] = "charges";
-static const char __pyx_k_ct_sign[] = "ct_sign";
-static const char __pyx_k_disable[] = "disable";
 static const char __pyx_k_fortran[] = "fortran";
+static const char __pyx_k_mapping[] = "mapping";
+static const char __pyx_k_matched[] = "matched";
 static const char __pyx_k_memview[] = "memview";
+static const char __pyx_k_o_bits1[] = "o_bits1";
+static const char __pyx_k_o_bits2[] = "o_bits2";
+static const char __pyx_k_o_bits3[] = "o_bits3";
+static const char __pyx_k_o_bits4[] = "o_bits4";
+static const char __pyx_k_o_bonds[] = "o_bonds";
+static const char __pyx_k_q_bonds[] = "q_bonds";
+static const char __pyx_k_q_mask1[] = "q_mask1";
+static const char __pyx_k_q_mask2[] = "q_mask2";
+static const char __pyx_k_q_mask3[] = "q_mask3";
+static const char __pyx_k_q_mask4[] = "q_mask4";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
-static const char __pyx_k_Sequence[] = "Sequence";
-static const char __pyx_k_ct_count[] = "ct_count";
-static const char __pyx_k_ct_shift[] = "ct_shift";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_itemsize[] = "itemsize";
-static const char __pyx_k_py_atoms[] = "py_atoms";
-static const char __pyx_k_py_bonds[] = "py_bonds";
-static const char __pyx_k_py_plane[] = "py_plane";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
-static const char __pyx_k_radicals[] = "radicals";
-static const char __pyx_k_register[] = "register";
+static const char __pyx_k_q_masks1[] = "q_masks1";
+static const char __pyx_k_q_masks2[] = "q_masks2";
+static const char __pyx_k_q_masks3[] = "q_masks3";
+static const char __pyx_k_q_masks4[] = "q_masks4";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_TypeError[] = "TypeError";
-static const char __pyx_k_ct_stereo[] = "ct_stereo";
 static const char __pyx_k_enumerate[] = "enumerate";
-static const char __pyx_k_hydrogens[] = "hydrogens";
-static const char __pyx_k_is_chiral[] = "is_chiral";
-static const char __pyx_k_isenabled[] = "isenabled";
-static const char __pyx_k_neighbors[] = "neighbors";
+static const char __pyx_k_o_indices[] = "o_indices";
+static const char __pyx_k_o_numbers[] = "o_numbers";
+static const char __pyx_k_path_size[] = "path_size";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
+static const char __pyx_k_q_indices[] = "q_indices";
+static const char __pyx_k_q_numbers[] = "q_numbers";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_IndexError[] = "IndexError";
 static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_bond_shift[] = "bond_shift";
-static const char __pyx_k_py_charges[] = "py_charges";
-static const char __pyx_k_py_mapping[] = "py_mapping";
+static const char __pyx_k_o_closures[] = "o_closures";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
-static const char __pyx_k_Bond__order[] = "_Bond__order";
+static const char __pyx_k_q_closures[] = "q_closures";
+static const char __pyx_k_q_size_dec[] = "q_size_dec";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
-static const char __pyx_k_atoms_count[] = "atoms_count";
-static const char __pyx_k_collections[] = "collections";
-static const char __pyx_k_connections[] = "connections";
-static const char __pyx_k_py_isotopes[] = "py_isotopes";
-static const char __pyx_k_py_radicals[] = "py_radicals";
-static const char __pyx_k_stereo_sign[] = "stereo_sign";
-static const char __pyx_k_initializing[] = "_initializing";
-static const char __pyx_k_is_coroutine[] = "_is_coroutine";
-static const char __pyx_k_py_hydrogens[] = "py_hydrogens";
+static const char __pyx_k_get_mapping[] = "get_mapping";
+static const char __pyx_k_stack_depth[] = "stack_depth";
+static const char __pyx_k_stack_index[] = "stack_index";
+static const char __pyx_k_closures_num[] = "closures_num";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
-static const char __pyx_k_stringsource[] = "<stringsource>";
-static const char __pyx_k_version_info[] = "version_info";
-static const char __pyx_k_class_getitem[] = "__class_getitem__";
-static const char __pyx_k_py_bonds_flat[] = "py_bonds_flat";
+static const char __pyx_k_stringsource[] = "stringsource";
+static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
-static const char __pyx_k_AssertionError[] = "AssertionError";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
-static const char __pyx_k_collections_abc[] = "collections.abc";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
-static const char __pyx_k_py_atoms_stereo[] = "py_atoms_stereo";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
-static const char __pyx_k_py_allenes_stereo[] = "py_allenes_stereo";
+static const char __pyx_k_closures_counter[] = "closures_counter";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
-static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
-static const char __pyx_k_py_cis_trans_stereo[] = "py_cis_trans_stereo";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
-static const char __pyx_k_Invalid_shape_in_axis[] = "Invalid shape in axis ";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
-static const char __pyx_k_Cannot_index_with_type[] = "Cannot index with type '";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
-static const char __pyx_k_chython_containers_bonds[] = "chython.containers.bonds";
-static const char __pyx_k_Dimension_d_is_not_direct[] = "Dimension %d is not direct";
-static const char __pyx_k_chython_containers__cpack[] = "chython.containers._cpack";
-static const char __pyx_k_Index_out_of_bounds_axis_d[] = "Index out of bounds (axis %d)";
-static const char __pyx_k_Step_may_not_be_zero_axis_d[] = "Step may not be zero (axis %d)";
+static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
+static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
-static const char __pyx_k_chython_containers__cpack_pyx[] = "chython/containers/_cpack.pyx";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
-static const char __pyx_k_All_dimensions_preceding_dimensi[] = "All dimensions preceding dimension %d must be indexed and not sliced";
+static const char __pyx_k_chython_algorithms__isomorphism[] = "chython.algorithms._isomorphism";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
-static const char __pyx_k_Cannot_transpose_memoryview_with[] = "Cannot transpose memoryview with indirect dimensions";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))";
+static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
-static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got ";
-static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis ";
+static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
+static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
-static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension ";
+static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
-/* #### Code section: decls ### */
+static const char __pyx_k_chython_algorithms__isomorphism_2[] = "chython\\algorithms\\_isomorphism.pyx";
+static PyObject *__pyx_n_s_ASCII;
+static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
+static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
+static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
+static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
+static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
+static PyObject *__pyx_n_s_Ellipsis;
+static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
+static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
+static PyObject *__pyx_n_s_IndexError;
+static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
+static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
+static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
+static PyObject *__pyx_n_s_MemoryError;
+static PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
+static PyObject *__pyx_kp_s_MemoryView_of_r_object;
+static PyObject *__pyx_n_b_O;
+static PyObject *__pyx_kp_s_Out_of_bounds_on_buffer_access_a;
+static PyObject *__pyx_n_s_PickleError;
+static PyObject *__pyx_n_s_TypeError;
+static PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
+static PyObject *__pyx_n_s_ValueError;
+static PyObject *__pyx_n_s_View_MemoryView;
+static PyObject *__pyx_n_s_allocate_buffer;
+static PyObject *__pyx_n_s_args;
+static PyObject *__pyx_n_s_back;
+static PyObject *__pyx_n_s_base;
+static PyObject *__pyx_n_s_c;
+static PyObject *__pyx_n_u_c;
+static PyObject *__pyx_n_s_chython_algorithms__isomorphism;
+static PyObject *__pyx_kp_s_chython_algorithms__isomorphism_2;
+static PyObject *__pyx_n_s_class;
+static PyObject *__pyx_n_s_cline_in_traceback;
+static PyObject *__pyx_n_s_close;
+static PyObject *__pyx_n_s_closures_counter;
+static PyObject *__pyx_n_s_closures_num;
+static PyObject *__pyx_kp_s_contiguous_and_direct;
+static PyObject *__pyx_kp_s_contiguous_and_indirect;
+static PyObject *__pyx_n_s_depth;
+static PyObject *__pyx_n_s_dict;
+static PyObject *__pyx_n_s_dtype_is_object;
+static PyObject *__pyx_n_s_encode;
+static PyObject *__pyx_n_s_enumerate;
+static PyObject *__pyx_n_s_error;
+static PyObject *__pyx_n_s_flags;
+static PyObject *__pyx_n_s_format;
+static PyObject *__pyx_n_s_fortran;
+static PyObject *__pyx_n_u_fortran;
+static PyObject *__pyx_n_s_front;
+static PyObject *__pyx_n_s_get_mapping;
+static PyObject *__pyx_n_s_getstate;
+static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
+static PyObject *__pyx_n_s_i;
+static PyObject *__pyx_n_s_id;
+static PyObject *__pyx_n_s_import;
+static PyObject *__pyx_n_s_itemsize;
+static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
+static PyObject *__pyx_n_s_j;
+static PyObject *__pyx_n_s_m;
+static PyObject *__pyx_n_s_main;
+static PyObject *__pyx_n_s_mapping;
+static PyObject *__pyx_n_s_matched;
+static PyObject *__pyx_n_s_memview;
+static PyObject *__pyx_n_s_mode;
+static PyObject *__pyx_n_s_n;
+static PyObject *__pyx_n_s_name;
+static PyObject *__pyx_n_s_name_2;
+static PyObject *__pyx_n_s_ndim;
+static PyObject *__pyx_n_s_new;
+static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
+static PyObject *__pyx_n_s_o;
+static PyObject *__pyx_n_s_o_bits1;
+static PyObject *__pyx_n_s_o_bits2;
+static PyObject *__pyx_n_s_o_bits3;
+static PyObject *__pyx_n_s_o_bits4;
+static PyObject *__pyx_n_s_o_bond;
+static PyObject *__pyx_n_s_o_bonds;
+static PyObject *__pyx_n_s_o_closures;
+static PyObject *__pyx_n_s_o_from;
+static PyObject *__pyx_n_s_o_indices;
+static PyObject *__pyx_n_s_o_numbers;
+static PyObject *__pyx_n_s_o_size;
+static PyObject *__pyx_n_s_o_to;
+static PyObject *__pyx_n_s_obj;
+static PyObject *__pyx_n_s_pack;
+static PyObject *__pyx_n_s_path;
+static PyObject *__pyx_n_s_path_size;
+static PyObject *__pyx_n_s_pickle;
+static PyObject *__pyx_n_s_pyx_PickleError;
+static PyObject *__pyx_n_s_pyx_checksum;
+static PyObject *__pyx_n_s_pyx_getbuffer;
+static PyObject *__pyx_n_s_pyx_result;
+static PyObject *__pyx_n_s_pyx_state;
+static PyObject *__pyx_n_s_pyx_type;
+static PyObject *__pyx_n_s_pyx_unpickle_Enum;
+static PyObject *__pyx_n_s_pyx_vtable;
+static PyObject *__pyx_n_s_q_back;
+static PyObject *__pyx_n_s_q_bonds;
+static PyObject *__pyx_n_s_q_closures;
+static PyObject *__pyx_n_s_q_from;
+static PyObject *__pyx_n_s_q_indices;
+static PyObject *__pyx_n_s_q_mask1;
+static PyObject *__pyx_n_s_q_mask2;
+static PyObject *__pyx_n_s_q_mask3;
+static PyObject *__pyx_n_s_q_mask4;
+static PyObject *__pyx_n_s_q_masks1;
+static PyObject *__pyx_n_s_q_masks2;
+static PyObject *__pyx_n_s_q_masks3;
+static PyObject *__pyx_n_s_q_masks4;
+static PyObject *__pyx_n_s_q_numbers;
+static PyObject *__pyx_n_s_q_size;
+static PyObject *__pyx_n_s_q_size_dec;
+static PyObject *__pyx_n_s_q_to;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_reduce;
+static PyObject *__pyx_n_s_reduce_cython;
+static PyObject *__pyx_n_s_reduce_ex;
+static PyObject *__pyx_n_s_scope;
+static PyObject *__pyx_n_s_send;
+static PyObject *__pyx_n_s_setstate;
+static PyObject *__pyx_n_s_setstate_cython;
+static PyObject *__pyx_n_s_shape;
+static PyObject *__pyx_n_s_size;
+static PyObject *__pyx_n_s_stack;
+static PyObject *__pyx_n_s_stack_depth;
+static PyObject *__pyx_n_s_stack_index;
+static PyObject *__pyx_n_s_start;
+static PyObject *__pyx_n_s_step;
+static PyObject *__pyx_n_s_stop;
+static PyObject *__pyx_kp_s_strided_and_direct;
+static PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
+static PyObject *__pyx_kp_s_strided_and_indirect;
+static PyObject *__pyx_kp_s_stringsource;
+static PyObject *__pyx_n_s_struct;
+static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_n_s_throw;
+static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
+static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
+static PyObject *__pyx_n_s_unpack;
+static PyObject *__pyx_n_s_update;
+static PyObject *__pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_q_numbers, __Pyx_memviewslice __pyx_v_q_back, __Pyx_memviewslice __pyx_v_q_masks1, __Pyx_memviewslice __pyx_v_q_masks2, __Pyx_memviewslice __pyx_v_q_masks3, __Pyx_memviewslice __pyx_v_q_masks4, __Pyx_memviewslice __pyx_v_q_closures, __Pyx_memviewslice __pyx_v_q_from, __Pyx_memviewslice __pyx_v_q_to, __Pyx_memviewslice __pyx_v_q_indices, __Pyx_memviewslice __pyx_v_q_bonds, __Pyx_memviewslice __pyx_v_o_numbers, __Pyx_memviewslice __pyx_v_o_bits1, __Pyx_memviewslice __pyx_v_o_bits2, __Pyx_memviewslice __pyx_v_o_bits3, __Pyx_memviewslice __pyx_v_o_bits4, __Pyx_memviewslice __pyx_v_o_bonds, __Pyx_memviewslice __pyx_v_o_from, __Pyx_memviewslice __pyx_v_o_to, __Pyx_memviewslice __pyx_v_o_indices, __Pyx_memviewslice __pyx_v_scope); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item); /* proto */
@@ -2847,954 +2261,1779 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_16is_c_contig(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_18is_f_contig(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_20copy(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
-static PyObject *__pyx_pf_7chython_10containers_6_cpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data); /* proto */
+static PyObject *__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-/* #### Code section: late_includes ### */
-/* #### Code section: module_state ### */
-typedef struct {
-  PyObject *__pyx_d;
-  PyObject *__pyx_b;
-  PyObject *__pyx_cython_runtime;
-  PyObject *__pyx_empty_tuple;
-  PyObject *__pyx_empty_bytes;
-  PyObject *__pyx_empty_unicode;
-  #ifdef __Pyx_CyFunction_USED
-  PyTypeObject *__pyx_CyFunctionType;
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  PyTypeObject *__pyx_FusedFunctionType;
-  #endif
-  #ifdef __Pyx_Generator_USED
-  PyTypeObject *__pyx_GeneratorType;
-  #endif
-  #ifdef __Pyx_IterableCoroutine_USED
-  PyTypeObject *__pyx_IterableCoroutineType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineAwaitType;
-  #endif
-  #ifdef __Pyx_Coroutine_USED
-  PyTypeObject *__pyx_CoroutineType;
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  #endif
-  #if CYTHON_USE_MODULE_STATE
-  PyObject *__pyx_type___pyx_array;
-  PyObject *__pyx_type___pyx_MemviewEnum;
-  PyObject *__pyx_type___pyx_memoryview;
-  PyObject *__pyx_type___pyx_memoryviewslice;
-  #endif
-  PyTypeObject *__pyx_array_type;
-  PyTypeObject *__pyx_MemviewEnum_type;
-  PyTypeObject *__pyx_memoryview_type;
-  PyTypeObject *__pyx_memoryviewslice_type;
-  PyObject *__pyx_kp_u_;
-  PyObject *__pyx_n_s_ASCII;
-  PyObject *__pyx_kp_s_All_dimensions_preceding_dimensi;
-  PyObject *__pyx_n_s_AssertionError;
-  PyObject *__pyx_n_s_Bond;
-  PyObject *__pyx_n_s_Bond__m;
-  PyObject *__pyx_n_s_Bond__n;
-  PyObject *__pyx_n_s_Bond__order;
-  PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
-  PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
-  PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
-  PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
-  PyObject *__pyx_kp_u_Cannot_index_with_type;
-  PyObject *__pyx_kp_s_Cannot_transpose_memoryview_with;
-  PyObject *__pyx_kp_s_Dimension_d_is_not_direct;
-  PyObject *__pyx_n_s_Ellipsis;
-  PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
-  PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
-  PyObject *__pyx_n_s_IndexError;
-  PyObject *__pyx_kp_s_Index_out_of_bounds_axis_d;
-  PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
-  PyObject *__pyx_kp_u_Invalid_mode_expected_c_or_fortr;
-  PyObject *__pyx_kp_u_Invalid_shape_in_axis;
-  PyObject *__pyx_n_s_MemoryError;
-  PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
-  PyObject *__pyx_kp_s_MemoryView_of_r_object;
-  PyObject *__pyx_n_b_O;
-  PyObject *__pyx_kp_u_Out_of_bounds_on_buffer_access_a;
-  PyObject *__pyx_n_s_PickleError;
-  PyObject *__pyx_n_s_Sequence;
-  PyObject *__pyx_kp_s_Step_may_not_be_zero_axis_d;
-  PyObject *__pyx_n_s_TypeError;
-  PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
-  PyObject *__pyx_n_s_ValueError;
-  PyObject *__pyx_n_s_View_MemoryView;
-  PyObject *__pyx_kp_u__2;
-  PyObject *__pyx_n_s__23;
-  PyObject *__pyx_n_s__3;
-  PyObject *__pyx_kp_u__6;
-  PyObject *__pyx_kp_u__7;
-  PyObject *__pyx_n_s_a;
-  PyObject *__pyx_n_s_abc;
-  PyObject *__pyx_n_s_allocate_buffer;
-  PyObject *__pyx_kp_u_and;
-  PyObject *__pyx_n_s_asyncio_coroutines;
-  PyObject *__pyx_n_s_atoms;
-  PyObject *__pyx_n_s_atoms_count;
-  PyObject *__pyx_n_s_b;
-  PyObject *__pyx_n_s_base;
-  PyObject *__pyx_n_s_bond;
-  PyObject *__pyx_n_s_bond_shift;
-  PyObject *__pyx_n_s_c;
-  PyObject *__pyx_n_u_c;
-  PyObject *__pyx_n_s_charges;
-  PyObject *__pyx_n_s_chython_containers__cpack;
-  PyObject *__pyx_kp_s_chython_containers__cpack_pyx;
-  PyObject *__pyx_n_s_chython_containers_bonds;
-  PyObject *__pyx_n_s_class;
-  PyObject *__pyx_n_s_class_getitem;
-  PyObject *__pyx_n_s_cline_in_traceback;
-  PyObject *__pyx_n_s_collections;
-  PyObject *__pyx_kp_s_collections_abc;
-  PyObject *__pyx_n_s_connections;
-  PyObject *__pyx_kp_s_contiguous_and_direct;
-  PyObject *__pyx_kp_s_contiguous_and_indirect;
-  PyObject *__pyx_n_s_count;
-  PyObject *__pyx_n_s_ct_count;
-  PyObject *__pyx_n_s_ct_shift;
-  PyObject *__pyx_n_s_ct_sign;
-  PyObject *__pyx_n_s_ct_stereo;
-  PyObject *__pyx_n_s_data;
-  PyObject *__pyx_n_s_dict;
-  PyObject *__pyx_kp_u_disable;
-  PyObject *__pyx_n_s_dtype_is_object;
-  PyObject *__pyx_kp_u_enable;
-  PyObject *__pyx_n_s_encode;
-  PyObject *__pyx_n_s_enumerate;
-  PyObject *__pyx_n_s_error;
-  PyObject *__pyx_n_s_flags;
-  PyObject *__pyx_n_s_format;
-  PyObject *__pyx_n_s_fortran;
-  PyObject *__pyx_n_u_fortran;
-  PyObject *__pyx_kp_u_gc;
-  PyObject *__pyx_n_s_getstate;
-  PyObject *__pyx_kp_u_got;
-  PyObject *__pyx_kp_u_got_differing_extents_in_dimensi;
-  PyObject *__pyx_n_s_hydrogens;
-  PyObject *__pyx_n_s_i;
-  PyObject *__pyx_n_s_id;
-  PyObject *__pyx_n_s_import;
-  PyObject *__pyx_n_s_index;
-  PyObject *__pyx_n_s_initializing;
-  PyObject *__pyx_n_s_is_chiral;
-  PyObject *__pyx_n_s_is_coroutine;
-  PyObject *__pyx_kp_u_isenabled;
-  PyObject *__pyx_n_s_itemsize;
-  PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
-  PyObject *__pyx_n_s_m;
-  PyObject *__pyx_n_s_main;
-  PyObject *__pyx_n_s_memview;
-  PyObject *__pyx_n_s_mode;
-  PyObject *__pyx_n_s_n;
-  PyObject *__pyx_n_s_name;
-  PyObject *__pyx_n_s_name_2;
-  PyObject *__pyx_n_s_ndim;
-  PyObject *__pyx_n_s_neighbors;
-  PyObject *__pyx_n_s_new;
-  PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
-  PyObject *__pyx_n_s_obj;
-  PyObject *__pyx_n_s_object;
-  PyObject *__pyx_n_s_orders;
-  PyObject *__pyx_n_s_pack;
-  PyObject *__pyx_n_s_pickle;
-  PyObject *__pyx_n_s_py_allenes_stereo;
-  PyObject *__pyx_n_s_py_atoms;
-  PyObject *__pyx_n_s_py_atoms_stereo;
-  PyObject *__pyx_n_s_py_bonds;
-  PyObject *__pyx_n_s_py_bonds_flat;
-  PyObject *__pyx_n_s_py_charges;
-  PyObject *__pyx_n_s_py_cis_trans_stereo;
-  PyObject *__pyx_n_s_py_hydrogens;
-  PyObject *__pyx_n_s_py_isotopes;
-  PyObject *__pyx_n_s_py_m;
-  PyObject *__pyx_n_s_py_mapping;
-  PyObject *__pyx_n_s_py_n;
-  PyObject *__pyx_n_s_py_ngb;
-  PyObject *__pyx_n_s_py_plane;
-  PyObject *__pyx_n_s_py_radicals;
-  PyObject *__pyx_n_s_py_xy;
-  PyObject *__pyx_n_s_pyx_PickleError;
-  PyObject *__pyx_n_s_pyx_checksum;
-  PyObject *__pyx_n_s_pyx_result;
-  PyObject *__pyx_n_s_pyx_state;
-  PyObject *__pyx_n_s_pyx_type;
-  PyObject *__pyx_n_s_pyx_unpickle_Enum;
-  PyObject *__pyx_n_s_pyx_vtable;
-  PyObject *__pyx_n_s_radicals;
-  PyObject *__pyx_n_s_range;
-  PyObject *__pyx_n_s_reduce;
-  PyObject *__pyx_n_s_reduce_cython;
-  PyObject *__pyx_n_s_reduce_ex;
-  PyObject *__pyx_n_s_register;
-  PyObject *__pyx_n_s_seen;
-  PyObject *__pyx_n_s_setstate;
-  PyObject *__pyx_n_s_setstate_cython;
-  PyObject *__pyx_n_s_shape;
-  PyObject *__pyx_n_s_shift;
-  PyObject *__pyx_n_s_size;
-  PyObject *__pyx_n_s_spec;
-  PyObject *__pyx_n_s_start;
-  PyObject *__pyx_n_s_step;
-  PyObject *__pyx_n_s_stereo_sign;
-  PyObject *__pyx_n_s_stop;
-  PyObject *__pyx_kp_s_strided_and_direct;
-  PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
-  PyObject *__pyx_kp_s_strided_and_indirect;
-  PyObject *__pyx_kp_s_stringsource;
-  PyObject *__pyx_n_s_struct;
-  PyObject *__pyx_n_s_sys;
-  PyObject *__pyx_n_s_test;
-  PyObject *__pyx_kp_s_unable_to_allocate_array_data;
-  PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
-  PyObject *__pyx_n_s_unpack;
-  PyObject *__pyx_n_s_update;
-  PyObject *__pyx_n_s_version_info;
-  PyObject *__pyx_float_0_;
-  PyObject *__pyx_int_0;
-  PyObject *__pyx_int_1;
-  PyObject *__pyx_int_3;
-  PyObject *__pyx_int_112105877;
-  PyObject *__pyx_int_136983863;
-  PyObject *__pyx_int_184977713;
-  PyObject *__pyx_int_neg_1;
-  PyObject *__pyx_slice__5;
-  PyObject *__pyx_tuple__4;
-  PyObject *__pyx_tuple__8;
-  PyObject *__pyx_tuple__9;
-  PyObject *__pyx_tuple__10;
-  PyObject *__pyx_tuple__11;
-  PyObject *__pyx_tuple__12;
-  PyObject *__pyx_tuple__13;
-  PyObject *__pyx_tuple__14;
-  PyObject *__pyx_tuple__15;
-  PyObject *__pyx_tuple__16;
-  PyObject *__pyx_tuple__17;
-  PyObject *__pyx_tuple__18;
-  PyObject *__pyx_tuple__19;
-  PyObject *__pyx_tuple__21;
-  PyObject *__pyx_codeobj__20;
-  PyObject *__pyx_codeobj__22;
-} __pyx_mstate;
+static PyObject *__pyx_int_0;
+static PyObject *__pyx_int_1;
+static PyObject *__pyx_int_184977713;
+static PyObject *__pyx_int_neg_1;
+static PyObject *__pyx_codeobj_;
+static PyObject *__pyx_tuple__2;
+static PyObject *__pyx_tuple__3;
+static PyObject *__pyx_tuple__4;
+static PyObject *__pyx_tuple__5;
+static PyObject *__pyx_tuple__6;
+static PyObject *__pyx_tuple__7;
+static PyObject *__pyx_tuple__8;
+static PyObject *__pyx_tuple__9;
+static PyObject *__pyx_slice__16;
+static PyObject *__pyx_tuple__10;
+static PyObject *__pyx_tuple__11;
+static PyObject *__pyx_tuple__12;
+static PyObject *__pyx_tuple__13;
+static PyObject *__pyx_tuple__14;
+static PyObject *__pyx_tuple__15;
+static PyObject *__pyx_tuple__17;
+static PyObject *__pyx_tuple__18;
+static PyObject *__pyx_tuple__19;
+static PyObject *__pyx_tuple__20;
+static PyObject *__pyx_tuple__21;
+static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
+static PyObject *__pyx_tuple__24;
+static PyObject *__pyx_tuple__25;
+static PyObject *__pyx_tuple__26;
+static PyObject *__pyx_codeobj__27;
+/* Late includes */
+static PyObject *__pyx_gb_7chython_10algorithms_12_isomorphism_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-#if CYTHON_USE_MODULE_STATE
-#ifdef __cplusplus
-namespace {
-  extern struct PyModuleDef __pyx_moduledef;
-} /* anonymous namespace */
-#else
-static struct PyModuleDef __pyx_moduledef;
-#endif
+/* "chython/algorithms/_isomorphism.pyx":30
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
+ *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+ *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+ */
 
-#define __pyx_mstate(o) ((__pyx_mstate *)__Pyx_PyModule_GetState(o))
+/* Python wrapper */
+static PyObject *__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_7chython_10algorithms_12_isomorphism_1get_mapping = {"get_mapping", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_7chython_10algorithms_12_isomorphism_1get_mapping(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  __Pyx_memviewslice __pyx_v_q_numbers = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_back = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_masks1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_masks2 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_masks3 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_masks4 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_closures = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_from = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_to = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_q_bonds = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_numbers = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_bits1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_bits2 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_bits3 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_bits4 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_bonds = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_from = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_to = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_o_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_scope = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_mapping (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_q_numbers,&__pyx_n_s_q_back,&__pyx_n_s_q_masks1,&__pyx_n_s_q_masks2,&__pyx_n_s_q_masks3,&__pyx_n_s_q_masks4,&__pyx_n_s_q_closures,&__pyx_n_s_q_from,&__pyx_n_s_q_to,&__pyx_n_s_q_indices,&__pyx_n_s_q_bonds,&__pyx_n_s_o_numbers,&__pyx_n_s_o_bits1,&__pyx_n_s_o_bits2,&__pyx_n_s_o_bits3,&__pyx_n_s_o_bits4,&__pyx_n_s_o_bonds,&__pyx_n_s_o_from,&__pyx_n_s_o_to,&__pyx_n_s_o_indices,&__pyx_n_s_scope,0};
+    PyObject* values[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case 21: values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
+        CYTHON_FALLTHROUGH;
+        case 20: values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
+        CYTHON_FALLTHROUGH;
+        case 19: values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
+        CYTHON_FALLTHROUGH;
+        case 18: values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
+        CYTHON_FALLTHROUGH;
+        case 17: values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
+        CYTHON_FALLTHROUGH;
+        case 16: values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
+        CYTHON_FALLTHROUGH;
+        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
+        CYTHON_FALLTHROUGH;
+        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
+        CYTHON_FALLTHROUGH;
+        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
+        CYTHON_FALLTHROUGH;
+        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
+        CYTHON_FALLTHROUGH;
+        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
+        CYTHON_FALLTHROUGH;
+        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
+        CYTHON_FALLTHROUGH;
+        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
+        CYTHON_FALLTHROUGH;
+        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
+        CYTHON_FALLTHROUGH;
+        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
+        CYTHON_FALLTHROUGH;
+        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
+        CYTHON_FALLTHROUGH;
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        CYTHON_FALLTHROUGH;
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        CYTHON_FALLTHROUGH;
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_numbers)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_back)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 1); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_masks1)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 2); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  3:
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_masks2)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 3); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  4:
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_masks3)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 4); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  5:
+        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_masks4)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 5); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  6:
+        if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_closures)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 6); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  7:
+        if (likely((values[7] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_from)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 7); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  8:
+        if (likely((values[8] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_to)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 8); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  9:
+        if (likely((values[9] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_indices)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 9); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 10:
+        if (likely((values[10] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q_bonds)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 10); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 11:
+        if (likely((values[11] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_numbers)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 11); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 12:
+        if (likely((values[12] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_bits1)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 12); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 13:
+        if (likely((values[13] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_bits2)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 13); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 14:
+        if (likely((values[14] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_bits3)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 14); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 15:
+        if (likely((values[15] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_bits4)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 15); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 16:
+        if (likely((values[16] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_bonds)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 16); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 17:
+        if (likely((values[17] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_from)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 17); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 18:
+        if (likely((values[18] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_to)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 18); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 19:
+        if (likely((values[19] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o_indices)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 19); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case 20:
+        if (likely((values[20] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scope)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, 20); __PYX_ERR(0, 30, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_mapping") < 0)) __PYX_ERR(0, 30, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 21) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+      values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
+      values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
+      values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
+      values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
+      values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
+      values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
+      values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
+      values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
+      values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
+      values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
+      values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
+      values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
+      values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
+      values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
+      values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
+      values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
+    }
+    __pyx_v_q_numbers = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_numbers.memview)) __PYX_ERR(0, 30, __pyx_L3_error)
+    __pyx_v_q_back = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_back.memview)) __PYX_ERR(0, 30, __pyx_L3_error)
+    __pyx_v_q_masks1 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks1.memview)) __PYX_ERR(0, 31, __pyx_L3_error)
+    __pyx_v_q_masks2 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[3], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks2.memview)) __PYX_ERR(0, 31, __pyx_L3_error)
+    __pyx_v_q_masks3 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[4], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks3.memview)) __PYX_ERR(0, 32, __pyx_L3_error)
+    __pyx_v_q_masks4 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[5], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_masks4.memview)) __PYX_ERR(0, 32, __pyx_L3_error)
+    __pyx_v_q_closures = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[6], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_closures.memview)) __PYX_ERR(0, 33, __pyx_L3_error)
+    __pyx_v_q_from = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[7], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_from.memview)) __PYX_ERR(0, 33, __pyx_L3_error)
+    __pyx_v_q_to = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[8], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_to.memview)) __PYX_ERR(0, 34, __pyx_L3_error)
+    __pyx_v_q_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[9], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_indices.memview)) __PYX_ERR(0, 34, __pyx_L3_error)
+    __pyx_v_q_bonds = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[10], PyBUF_WRITABLE); if (unlikely(!__pyx_v_q_bonds.memview)) __PYX_ERR(0, 35, __pyx_L3_error)
+    __pyx_v_o_numbers = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(values[11], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_numbers.memview)) __PYX_ERR(0, 35, __pyx_L3_error)
+    __pyx_v_o_bits1 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[12], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits1.memview)) __PYX_ERR(0, 36, __pyx_L3_error)
+    __pyx_v_o_bits2 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[13], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits2.memview)) __PYX_ERR(0, 36, __pyx_L3_error)
+    __pyx_v_o_bits3 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[14], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits3.memview)) __PYX_ERR(0, 37, __pyx_L3_error)
+    __pyx_v_o_bits4 = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[15], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bits4.memview)) __PYX_ERR(0, 37, __pyx_L3_error)
+    __pyx_v_o_bonds = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(values[16], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_bonds.memview)) __PYX_ERR(0, 38, __pyx_L3_error)
+    __pyx_v_o_from = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[17], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_from.memview)) __PYX_ERR(0, 38, __pyx_L3_error)
+    __pyx_v_o_to = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[18], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_to.memview)) __PYX_ERR(0, 39, __pyx_L3_error)
+    __pyx_v_o_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[19], PyBUF_WRITABLE); if (unlikely(!__pyx_v_o_indices.memview)) __PYX_ERR(0, 39, __pyx_L3_error)
+    __pyx_v_scope = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(values[20], PyBUF_WRITABLE); if (unlikely(!__pyx_v_scope.memview)) __PYX_ERR(0, 40, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("get_mapping", 1, 21, 21, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 30, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("chython.algorithms._isomorphism.get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(((PyObject *)__pyx_v_q_numbers.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_numbers"); __PYX_ERR(0, 30, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_back.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_back"); __PYX_ERR(0, 30, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_masks1.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks1"); __PYX_ERR(0, 31, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_masks2.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks2"); __PYX_ERR(0, 31, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_masks3.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks3"); __PYX_ERR(0, 32, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_masks4.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_masks4"); __PYX_ERR(0, 32, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_closures.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_closures"); __PYX_ERR(0, 33, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_from.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_from"); __PYX_ERR(0, 33, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_to.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_to"); __PYX_ERR(0, 34, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_indices.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_indices"); __PYX_ERR(0, 34, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_q_bonds.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "q_bonds"); __PYX_ERR(0, 35, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_numbers.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_numbers"); __PYX_ERR(0, 35, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_bits1.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits1"); __PYX_ERR(0, 36, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_bits2.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits2"); __PYX_ERR(0, 36, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_bits3.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits3"); __PYX_ERR(0, 37, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_bits4.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bits4"); __PYX_ERR(0, 37, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_bonds.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_bonds"); __PYX_ERR(0, 38, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_from.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_from"); __PYX_ERR(0, 38, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_to.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_to"); __PYX_ERR(0, 39, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_o_indices.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "o_indices"); __PYX_ERR(0, 39, __pyx_L1_error)
+  }
+  if (unlikely(((PyObject *)__pyx_v_scope.memview) == Py_None)) {
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "scope"); __PYX_ERR(0, 40, __pyx_L1_error)
+  }
+  __pyx_r = __pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(__pyx_self, __pyx_v_q_numbers, __pyx_v_q_back, __pyx_v_q_masks1, __pyx_v_q_masks2, __pyx_v_q_masks3, __pyx_v_q_masks4, __pyx_v_q_closures, __pyx_v_q_from, __pyx_v_q_to, __pyx_v_q_indices, __pyx_v_q_bonds, __pyx_v_o_numbers, __pyx_v_o_bits1, __pyx_v_o_bits2, __pyx_v_o_bits3, __pyx_v_o_bits4, __pyx_v_o_bonds, __pyx_v_o_from, __pyx_v_o_to, __pyx_v_o_indices, __pyx_v_scope);
 
-#define __pyx_mstate_global (__pyx_mstate(PyState_FindModule(&__pyx_moduledef)))
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-#define __pyx_m (PyState_FindModule(&__pyx_moduledef))
-#else
-static __pyx_mstate __pyx_mstate_global_static =
-#ifdef __cplusplus
-    {};
-#else
-    {0};
-#endif
-static __pyx_mstate *__pyx_mstate_global = &__pyx_mstate_global_static;
-#endif
-/* #### Code section: module_state_clear ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_clear(PyObject *m) {
-  __pyx_mstate *clear_module_state = __pyx_mstate(m);
-  if (!clear_module_state) return 0;
-  Py_CLEAR(clear_module_state->__pyx_d);
-  Py_CLEAR(clear_module_state->__pyx_b);
-  Py_CLEAR(clear_module_state->__pyx_cython_runtime);
-  Py_CLEAR(clear_module_state->__pyx_empty_tuple);
-  Py_CLEAR(clear_module_state->__pyx_empty_bytes);
-  Py_CLEAR(clear_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_CLEAR(clear_module_state->__pyx_FusedFunctionType);
-  #endif
-  Py_CLEAR(clear_module_state->__pyx_array_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_array);
-  Py_CLEAR(clear_module_state->__pyx_MemviewEnum_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_MemviewEnum);
-  Py_CLEAR(clear_module_state->__pyx_memoryview_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryview);
-  Py_CLEAR(clear_module_state->__pyx_memoryviewslice_type);
-  Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryviewslice);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ASCII);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_AssertionError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Bond);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Bond__m);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Bond__n);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Bond__order);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Cannot_index_with_type);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Ellipsis);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
-  Py_CLEAR(clear_module_state->__pyx_n_s_IndexError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_shape_in_axis);
-  Py_CLEAR(clear_module_state->__pyx_n_s_MemoryError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_CLEAR(clear_module_state->__pyx_n_b_O);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-  Py_CLEAR(clear_module_state->__pyx_n_s_PickleError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Sequence);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_CLEAR(clear_module_state->__pyx_n_s_TypeError);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ValueError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_View_MemoryView);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__2);
-  Py_CLEAR(clear_module_state->__pyx_n_s__23);
-  Py_CLEAR(clear_module_state->__pyx_n_s__3);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__6);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__7);
-  Py_CLEAR(clear_module_state->__pyx_n_s_a);
-  Py_CLEAR(clear_module_state->__pyx_n_s_abc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_allocate_buffer);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_and);
-  Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_CLEAR(clear_module_state->__pyx_n_s_atoms);
-  Py_CLEAR(clear_module_state->__pyx_n_s_atoms_count);
-  Py_CLEAR(clear_module_state->__pyx_n_s_b);
-  Py_CLEAR(clear_module_state->__pyx_n_s_base);
-  Py_CLEAR(clear_module_state->__pyx_n_s_bond);
-  Py_CLEAR(clear_module_state->__pyx_n_s_bond_shift);
-  Py_CLEAR(clear_module_state->__pyx_n_s_c);
-  Py_CLEAR(clear_module_state->__pyx_n_u_c);
-  Py_CLEAR(clear_module_state->__pyx_n_s_charges);
-  Py_CLEAR(clear_module_state->__pyx_n_s_chython_containers__cpack);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_chython_containers__cpack_pyx);
-  Py_CLEAR(clear_module_state->__pyx_n_s_chython_containers_bonds);
-  Py_CLEAR(clear_module_state->__pyx_n_s_class);
-  Py_CLEAR(clear_module_state->__pyx_n_s_class_getitem);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
-  Py_CLEAR(clear_module_state->__pyx_n_s_collections);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_collections_abc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_connections);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_direct);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_indirect);
-  Py_CLEAR(clear_module_state->__pyx_n_s_count);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ct_count);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ct_shift);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ct_sign);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ct_stereo);
-  Py_CLEAR(clear_module_state->__pyx_n_s_data);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dict);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_dtype_is_object);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_encode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_enumerate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_error);
-  Py_CLEAR(clear_module_state->__pyx_n_s_flags);
-  Py_CLEAR(clear_module_state->__pyx_n_s_format);
-  Py_CLEAR(clear_module_state->__pyx_n_s_fortran);
-  Py_CLEAR(clear_module_state->__pyx_n_u_fortran);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_gc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_getstate);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_got);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_hydrogens);
-  Py_CLEAR(clear_module_state->__pyx_n_s_i);
-  Py_CLEAR(clear_module_state->__pyx_n_s_id);
-  Py_CLEAR(clear_module_state->__pyx_n_s_import);
-  Py_CLEAR(clear_module_state->__pyx_n_s_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_initializing);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_chiral);
-  Py_CLEAR(clear_module_state->__pyx_n_s_is_coroutine);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_isenabled);
-  Py_CLEAR(clear_module_state->__pyx_n_s_itemsize);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
-  Py_CLEAR(clear_module_state->__pyx_n_s_m);
-  Py_CLEAR(clear_module_state->__pyx_n_s_main);
-  Py_CLEAR(clear_module_state->__pyx_n_s_memview);
-  Py_CLEAR(clear_module_state->__pyx_n_s_mode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n);
-  Py_CLEAR(clear_module_state->__pyx_n_s_name);
-  Py_CLEAR(clear_module_state->__pyx_n_s_name_2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ndim);
-  Py_CLEAR(clear_module_state->__pyx_n_s_neighbors);
-  Py_CLEAR(clear_module_state->__pyx_n_s_new);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_CLEAR(clear_module_state->__pyx_n_s_obj);
-  Py_CLEAR(clear_module_state->__pyx_n_s_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_orders);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pickle);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_allenes_stereo);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_atoms);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_atoms_stereo);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_bonds);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_bonds_flat);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_charges);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_cis_trans_stereo);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_hydrogens);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_isotopes);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_m);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_mapping);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_n);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_ngb);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_plane);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_radicals);
-  Py_CLEAR(clear_module_state->__pyx_n_s_py_xy);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_PickleError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_checksum);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_result);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_state);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_type);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_unpickle_Enum);
-  Py_CLEAR(clear_module_state->__pyx_n_s_pyx_vtable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_radicals);
-  Py_CLEAR(clear_module_state->__pyx_n_s_range);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reduce_ex);
-  Py_CLEAR(clear_module_state->__pyx_n_s_register);
-  Py_CLEAR(clear_module_state->__pyx_n_s_seen);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_setstate_cython);
-  Py_CLEAR(clear_module_state->__pyx_n_s_shape);
-  Py_CLEAR(clear_module_state->__pyx_n_s_shift);
-  Py_CLEAR(clear_module_state->__pyx_n_s_size);
-  Py_CLEAR(clear_module_state->__pyx_n_s_spec);
-  Py_CLEAR(clear_module_state->__pyx_n_s_start);
-  Py_CLEAR(clear_module_state->__pyx_n_s_step);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stereo_sign);
-  Py_CLEAR(clear_module_state->__pyx_n_s_stop);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_indirect);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_stringsource);
-  Py_CLEAR(clear_module_state->__pyx_n_s_struct);
-  Py_CLEAR(clear_module_state->__pyx_n_s_sys);
-  Py_CLEAR(clear_module_state->__pyx_n_s_test);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_array_data);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
-  Py_CLEAR(clear_module_state->__pyx_n_s_unpack);
-  Py_CLEAR(clear_module_state->__pyx_n_s_update);
-  Py_CLEAR(clear_module_state->__pyx_n_s_version_info);
-  Py_CLEAR(clear_module_state->__pyx_float_0_);
-  Py_CLEAR(clear_module_state->__pyx_int_0);
-  Py_CLEAR(clear_module_state->__pyx_int_1);
-  Py_CLEAR(clear_module_state->__pyx_int_3);
-  Py_CLEAR(clear_module_state->__pyx_int_112105877);
-  Py_CLEAR(clear_module_state->__pyx_int_136983863);
-  Py_CLEAR(clear_module_state->__pyx_int_184977713);
-  Py_CLEAR(clear_module_state->__pyx_int_neg_1);
-  Py_CLEAR(clear_module_state->__pyx_slice__5);
-  Py_CLEAR(clear_module_state->__pyx_tuple__4);
-  Py_CLEAR(clear_module_state->__pyx_tuple__8);
-  Py_CLEAR(clear_module_state->__pyx_tuple__9);
-  Py_CLEAR(clear_module_state->__pyx_tuple__10);
-  Py_CLEAR(clear_module_state->__pyx_tuple__11);
-  Py_CLEAR(clear_module_state->__pyx_tuple__12);
-  Py_CLEAR(clear_module_state->__pyx_tuple__13);
-  Py_CLEAR(clear_module_state->__pyx_tuple__14);
-  Py_CLEAR(clear_module_state->__pyx_tuple__15);
-  Py_CLEAR(clear_module_state->__pyx_tuple__16);
-  Py_CLEAR(clear_module_state->__pyx_tuple__17);
-  Py_CLEAR(clear_module_state->__pyx_tuple__18);
-  Py_CLEAR(clear_module_state->__pyx_tuple__19);
-  Py_CLEAR(clear_module_state->__pyx_tuple__21);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__20);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__22);
-  return 0;
+static PyObject *__pyx_pf_7chython_10algorithms_12_isomorphism_get_mapping(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_q_numbers, __Pyx_memviewslice __pyx_v_q_back, __Pyx_memviewslice __pyx_v_q_masks1, __Pyx_memviewslice __pyx_v_q_masks2, __Pyx_memviewslice __pyx_v_q_masks3, __Pyx_memviewslice __pyx_v_q_masks4, __Pyx_memviewslice __pyx_v_q_closures, __Pyx_memviewslice __pyx_v_q_from, __Pyx_memviewslice __pyx_v_q_to, __Pyx_memviewslice __pyx_v_q_indices, __Pyx_memviewslice __pyx_v_q_bonds, __Pyx_memviewslice __pyx_v_o_numbers, __Pyx_memviewslice __pyx_v_o_bits1, __Pyx_memviewslice __pyx_v_o_bits2, __Pyx_memviewslice __pyx_v_o_bits3, __Pyx_memviewslice __pyx_v_o_bits4, __Pyx_memviewslice __pyx_v_o_bonds, __Pyx_memviewslice __pyx_v_o_from, __Pyx_memviewslice __pyx_v_o_to, __Pyx_memviewslice __pyx_v_o_indices, __Pyx_memviewslice __pyx_v_scope) {
+  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_cur_scope;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_mapping", 0);
+  __pyx_cur_scope = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(__pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, __pyx_empty_tuple, NULL);
+  if (unlikely(!__pyx_cur_scope)) {
+    __pyx_cur_scope = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)Py_None);
+    __Pyx_INCREF(Py_None);
+    __PYX_ERR(0, 30, __pyx_L1_error)
+  } else {
+    __Pyx_GOTREF(__pyx_cur_scope);
+  }
+  __pyx_cur_scope->__pyx_v_q_numbers = __pyx_v_q_numbers;
+  __pyx_cur_scope->__pyx_v_q_back = __pyx_v_q_back;
+  __pyx_cur_scope->__pyx_v_q_masks1 = __pyx_v_q_masks1;
+  __pyx_cur_scope->__pyx_v_q_masks2 = __pyx_v_q_masks2;
+  __pyx_cur_scope->__pyx_v_q_masks3 = __pyx_v_q_masks3;
+  __pyx_cur_scope->__pyx_v_q_masks4 = __pyx_v_q_masks4;
+  __pyx_cur_scope->__pyx_v_q_closures = __pyx_v_q_closures;
+  __pyx_cur_scope->__pyx_v_q_from = __pyx_v_q_from;
+  __pyx_cur_scope->__pyx_v_q_to = __pyx_v_q_to;
+  __pyx_cur_scope->__pyx_v_q_indices = __pyx_v_q_indices;
+  __pyx_cur_scope->__pyx_v_q_bonds = __pyx_v_q_bonds;
+  __pyx_cur_scope->__pyx_v_o_numbers = __pyx_v_o_numbers;
+  __pyx_cur_scope->__pyx_v_o_bits1 = __pyx_v_o_bits1;
+  __pyx_cur_scope->__pyx_v_o_bits2 = __pyx_v_o_bits2;
+  __pyx_cur_scope->__pyx_v_o_bits3 = __pyx_v_o_bits3;
+  __pyx_cur_scope->__pyx_v_o_bits4 = __pyx_v_o_bits4;
+  __pyx_cur_scope->__pyx_v_o_bonds = __pyx_v_o_bonds;
+  __pyx_cur_scope->__pyx_v_o_from = __pyx_v_o_from;
+  __pyx_cur_scope->__pyx_v_o_to = __pyx_v_o_to;
+  __pyx_cur_scope->__pyx_v_o_indices = __pyx_v_o_indices;
+  __pyx_cur_scope->__pyx_v_scope = __pyx_v_scope;
+  {
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_7chython_10algorithms_12_isomorphism_2generator, __pyx_codeobj_, (PyObject *) __pyx_cur_scope, __pyx_n_s_get_mapping, __pyx_n_s_get_mapping, __pyx_n_s_chython_algorithms__isomorphism); if (unlikely(!gen)) __PYX_ERR(0, 30, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_cur_scope);
+    __Pyx_RefNannyFinishContext();
+    return (PyObject *) gen;
+  }
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("chython.algorithms._isomorphism.get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_numbers, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_back, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks1, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks2, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks3, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_masks4, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_closures, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_from, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_to, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_q_bonds, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_numbers, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits1, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits2, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits3, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bits4, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_bonds, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_from, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_to, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_o_indices, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_cur_scope->__pyx_v_scope, 1);
+  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
 }
-#endif
-/* #### Code section: module_state_traverse ### */
-#if CYTHON_USE_MODULE_STATE
-static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
-  __pyx_mstate *traverse_module_state = __pyx_mstate(m);
-  if (!traverse_module_state) return 0;
-  Py_VISIT(traverse_module_state->__pyx_d);
-  Py_VISIT(traverse_module_state->__pyx_b);
-  Py_VISIT(traverse_module_state->__pyx_cython_runtime);
-  Py_VISIT(traverse_module_state->__pyx_empty_tuple);
-  Py_VISIT(traverse_module_state->__pyx_empty_bytes);
-  Py_VISIT(traverse_module_state->__pyx_empty_unicode);
-  #ifdef __Pyx_CyFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_CyFunctionType);
-  #endif
-  #ifdef __Pyx_FusedFunction_USED
-  Py_VISIT(traverse_module_state->__pyx_FusedFunctionType);
+
+static PyObject *__pyx_gb_7chython_10algorithms_12_isomorphism_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
+{
+  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_cur_scope = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)__pyx_generator->closure);
+  PyObject *__pyx_r = NULL;
+  size_t __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  unsigned int __pyx_t_5;
+  unsigned int __pyx_t_6;
+  unsigned int __pyx_t_7;
+  size_t __pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  size_t __pyx_t_11;
+  unsigned int __pyx_t_12;
+  unsigned int __pyx_t_13;
+  unsigned int __pyx_t_14;
+  size_t __pyx_t_15;
+  int __pyx_t_16;
+  int __pyx_t_17;
+  char const *__pyx_t_18;
+  PyObject *__pyx_t_19 = NULL;
+  PyObject *__pyx_t_20 = NULL;
+  PyObject *__pyx_t_21 = NULL;
+  PyObject *__pyx_t_22 = NULL;
+  PyObject *__pyx_t_23 = NULL;
+  PyObject *__pyx_t_24 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_mapping", 0);
+  switch (__pyx_generator->resume_label) {
+    case 0: goto __pyx_L3_first_run;
+    case 1: goto __pyx_L26_resume_from_yield;
+    default: /* CPython raises the right error here */
+    __Pyx_RefNannyFinishContext();
+    return NULL;
+  }
+  __pyx_L3_first_run:;
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 30, __pyx_L1_error)
+
+  /* "chython/algorithms/_isomorphism.pyx":42
+ *                 unsigned int[::1] scope not None):
+ *     # expected less than 2^16 atoms in structure.
+ *     cdef unsigned int stack = 0, path_size = 0, q_size, q_size_dec, o_size, depth, front, back, closures_num             # <<<<<<<<<<<<<<
+ *     cdef unsigned int n, m, o, i, j, closures_counter
+ *     cdef unsigned long long q_mask1, q_mask2, q_mask3, q_mask4, o_bond
+ */
+  __pyx_cur_scope->__pyx_v_stack = 0;
+  __pyx_cur_scope->__pyx_v_path_size = 0;
+
+  /* "chython/algorithms/_isomorphism.pyx":47
+ *     cdef dict mapping
+ * 
+ *     q_size = len(q_numbers)             # <<<<<<<<<<<<<<
+ *     q_size_dec = q_size - 1
+ *     o_size = len(o_numbers)
+ */
+  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_cur_scope->__pyx_v_q_numbers); 
+  __pyx_cur_scope->__pyx_v_q_size = __pyx_t_1;
+
+  /* "chython/algorithms/_isomorphism.pyx":48
+ * 
+ *     q_size = len(q_numbers)
+ *     q_size_dec = q_size - 1             # <<<<<<<<<<<<<<
+ *     o_size = len(o_numbers)
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ */
+  __pyx_cur_scope->__pyx_v_q_size_dec = (__pyx_cur_scope->__pyx_v_q_size - 1);
+
+  /* "chython/algorithms/_isomorphism.pyx":49
+ *     q_size = len(q_numbers)
+ *     q_size_dec = q_size - 1
+ *     o_size = len(o_numbers)             # <<<<<<<<<<<<<<
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ */
+  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_cur_scope->__pyx_v_o_numbers); 
+  __pyx_cur_scope->__pyx_v_o_size = __pyx_t_1;
+
+  /* "chython/algorithms/_isomorphism.pyx":50
+ *     q_size_dec = q_size - 1
+ *     o_size = len(o_numbers)
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))             # <<<<<<<<<<<<<<
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ */
+  __pyx_cur_scope->__pyx_v_path = ((int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_q_size_dec * (sizeof(int)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":51
+ *     o_size = len(o_numbers)
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))             # <<<<<<<<<<<<<<
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
+ */
+  __pyx_cur_scope->__pyx_v_stack_index = ((int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(int)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":52
+ *     cdef int *path = <int *> PyMem_Malloc(q_size_dec * sizeof(int))
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))             # <<<<<<<<<<<<<<
+ *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
+ *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+ */
+  __pyx_cur_scope->__pyx_v_stack_depth = ((int *)PyMem_Malloc(((2 * __pyx_cur_scope->__pyx_v_o_size) * (sizeof(int)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":53
+ *     cdef int *stack_index = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))             # <<<<<<<<<<<<<<
+ *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+ * 
+ */
+  __pyx_cur_scope->__pyx_v_matched = ((int *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(int)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":54
+ *     cdef int *stack_depth = <int *> PyMem_Malloc(2 * o_size * sizeof(int))
+ *     cdef bint *matched = <bint *> PyMem_Malloc(o_size * sizeof(bint))
+ *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))             # <<<<<<<<<<<<<<
+ * 
+ *     if not path or not stack_index or not stack_depth or not matched or not o_closures:
+ */
+  __pyx_cur_scope->__pyx_v_o_closures = ((unsigned PY_LONG_LONG *)PyMem_Malloc((__pyx_cur_scope->__pyx_v_o_size * (sizeof(unsigned PY_LONG_LONG)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":56
+ *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+ * 
+ *     if not path or not stack_index or not stack_depth or not matched or not o_closures:             # <<<<<<<<<<<<<<
+ *         raise MemoryError()
+ * 
+ */
+  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_path != 0)) != 0);
+  if (!__pyx_t_3) {
+  } else {
+    __pyx_t_2 = __pyx_t_3;
+    goto __pyx_L5_bool_binop_done;
+  }
+  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_stack_index != 0)) != 0);
+  if (!__pyx_t_3) {
+  } else {
+    __pyx_t_2 = __pyx_t_3;
+    goto __pyx_L5_bool_binop_done;
+  }
+  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_stack_depth != 0)) != 0);
+  if (!__pyx_t_3) {
+  } else {
+    __pyx_t_2 = __pyx_t_3;
+    goto __pyx_L5_bool_binop_done;
+  }
+  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_matched != 0)) != 0);
+  if (!__pyx_t_3) {
+  } else {
+    __pyx_t_2 = __pyx_t_3;
+    goto __pyx_L5_bool_binop_done;
+  }
+  __pyx_t_3 = ((!(__pyx_cur_scope->__pyx_v_o_closures != 0)) != 0);
+  __pyx_t_2 = __pyx_t_3;
+  __pyx_L5_bool_binop_done:;
+  if (unlikely(__pyx_t_2)) {
+
+    /* "chython/algorithms/_isomorphism.pyx":57
+ * 
+ *     if not path or not stack_index or not stack_depth or not matched or not o_closures:
+ *         raise MemoryError()             # <<<<<<<<<<<<<<
+ * 
+ *     memset(matched, 0, o_size * sizeof(bint))
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 57, __pyx_L1_error)
+
+    /* "chython/algorithms/_isomorphism.pyx":56
+ *     cdef unsigned long long *o_closures = <unsigned long long *> PyMem_Malloc(o_size * sizeof(unsigned long long))
+ * 
+ *     if not path or not stack_index or not stack_depth or not matched or not o_closures:             # <<<<<<<<<<<<<<
+ *         raise MemoryError()
+ * 
+ */
+  }
+
+  /* "chython/algorithms/_isomorphism.pyx":59
+ *         raise MemoryError()
+ * 
+ *     memset(matched, 0, o_size * sizeof(bint))             # <<<<<<<<<<<<<<
+ *     memset(o_closures, 0, o_size * sizeof(unsigned long long))
+ * 
+ */
+  (void)(memset(__pyx_cur_scope->__pyx_v_matched, 0, (__pyx_cur_scope->__pyx_v_o_size * (sizeof(int)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":60
+ * 
+ *     memset(matched, 0, o_size * sizeof(bint))
+ *     memset(o_closures, 0, o_size * sizeof(unsigned long long))             # <<<<<<<<<<<<<<
+ * 
+ *     # find entry-points.
+ */
+  (void)(memset(__pyx_cur_scope->__pyx_v_o_closures, 0, (__pyx_cur_scope->__pyx_v_o_size * (sizeof(unsigned PY_LONG_LONG)))));
+
+  /* "chython/algorithms/_isomorphism.pyx":63
+ * 
+ *     # find entry-points.
+ *     q_mask1 = q_masks1[0]             # <<<<<<<<<<<<<<
+ *     q_mask2 = q_masks2[0]
+ *     q_mask3 = q_masks3[0]
+ */
+  __pyx_t_4 = 0;
+  __pyx_cur_scope->__pyx_v_q_mask1 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks1.data) + __pyx_t_4)) )));
+
+  /* "chython/algorithms/_isomorphism.pyx":64
+ *     # find entry-points.
+ *     q_mask1 = q_masks1[0]
+ *     q_mask2 = q_masks2[0]             # <<<<<<<<<<<<<<
+ *     q_mask3 = q_masks3[0]
+ *     q_mask4 = q_masks4[0]
+ */
+  __pyx_t_4 = 0;
+  __pyx_cur_scope->__pyx_v_q_mask2 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks2.data) + __pyx_t_4)) )));
+
+  /* "chython/algorithms/_isomorphism.pyx":65
+ *     q_mask1 = q_masks1[0]
+ *     q_mask2 = q_masks2[0]
+ *     q_mask3 = q_masks3[0]             # <<<<<<<<<<<<<<
+ *     q_mask4 = q_masks4[0]
+ *     for n in range(o_size):
+ */
+  __pyx_t_4 = 0;
+  __pyx_cur_scope->__pyx_v_q_mask3 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks3.data) + __pyx_t_4)) )));
+
+  /* "chython/algorithms/_isomorphism.pyx":66
+ *     q_mask2 = q_masks2[0]
+ *     q_mask3 = q_masks3[0]
+ *     q_mask4 = q_masks4[0]             # <<<<<<<<<<<<<<
+ *     for n in range(o_size):
+ *         if (scope[n] and
+ */
+  __pyx_t_4 = 0;
+  __pyx_cur_scope->__pyx_v_q_mask4 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks4.data) + __pyx_t_4)) )));
+
+  /* "chython/algorithms/_isomorphism.pyx":67
+ *     q_mask3 = q_masks3[0]
+ *     q_mask4 = q_masks4[0]
+ *     for n in range(o_size):             # <<<<<<<<<<<<<<
+ *         if (scope[n] and
+ *             q_mask1 & o_bits1[n] and
+ */
+  __pyx_t_5 = __pyx_cur_scope->__pyx_v_o_size;
+  __pyx_t_6 = __pyx_t_5;
+  for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+    __pyx_cur_scope->__pyx_v_n = __pyx_t_7;
+
+    /* "chython/algorithms/_isomorphism.pyx":68
+ *     q_mask4 = q_masks4[0]
+ *     for n in range(o_size):
+ *         if (scope[n] and             # <<<<<<<<<<<<<<
+ *             q_mask1 & o_bits1[n] and
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ */
+    __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_1)) ))) != 0);
+    if (__pyx_t_3) {
+    } else {
+      __pyx_t_2 = __pyx_t_3;
+      goto __pyx_L13_bool_binop_done;
+    }
+
+    /* "chython/algorithms/_isomorphism.pyx":69
+ *     for n in range(o_size):
+ *         if (scope[n] and
+ *             q_mask1 & o_bits1[n] and             # <<<<<<<<<<<<<<
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ *             q_mask3 & o_bits3[n] == o_bits3[n] and
+ */
+    __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask1 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits1.data) + __pyx_t_1)) )))) != 0);
+    if (__pyx_t_3) {
+    } else {
+      __pyx_t_2 = __pyx_t_3;
+      goto __pyx_L13_bool_binop_done;
+    }
+
+    /* "chython/algorithms/_isomorphism.pyx":70
+ *         if (scope[n] and
+ *             q_mask1 & o_bits1[n] and
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and             # <<<<<<<<<<<<<<
+ *             q_mask3 & o_bits3[n] == o_bits3[n] and
+ *             q_mask4 & o_bits4[n]):
+ */
+    __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_1)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_8)) )))) != 0);
+    if (__pyx_t_3) {
+    } else {
+      __pyx_t_2 = __pyx_t_3;
+      goto __pyx_L13_bool_binop_done;
+    }
+
+    /* "chython/algorithms/_isomorphism.pyx":71
+ *             q_mask1 & o_bits1[n] and
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ *             q_mask3 & o_bits3[n] == o_bits3[n] and             # <<<<<<<<<<<<<<
+ *             q_mask4 & o_bits4[n]):
+ * 
+ */
+    __pyx_t_8 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask3 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_8)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_1)) )))) != 0);
+    if (__pyx_t_3) {
+    } else {
+      __pyx_t_2 = __pyx_t_3;
+      goto __pyx_L13_bool_binop_done;
+    }
+
+    /* "chython/algorithms/_isomorphism.pyx":72
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ *             q_mask3 & o_bits3[n] == o_bits3[n] and
+ *             q_mask4 & o_bits4[n]):             # <<<<<<<<<<<<<<
+ * 
+ *             stack_index[stack] = n
+ */
+    __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+    __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask4 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits4.data) + __pyx_t_1)) )))) != 0);
+    __pyx_t_2 = __pyx_t_3;
+    __pyx_L13_bool_binop_done:;
+
+    /* "chython/algorithms/_isomorphism.pyx":68
+ *     q_mask4 = q_masks4[0]
+ *     for n in range(o_size):
+ *         if (scope[n] and             # <<<<<<<<<<<<<<
+ *             q_mask1 & o_bits1[n] and
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ */
+    if (__pyx_t_2) {
+
+      /* "chython/algorithms/_isomorphism.pyx":74
+ *             q_mask4 & o_bits4[n]):
+ * 
+ *             stack_index[stack] = n             # <<<<<<<<<<<<<<
+ *             stack_depth[stack] = 0
+ *             stack += 1
+ */
+      (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_n;
+
+      /* "chython/algorithms/_isomorphism.pyx":75
+ * 
+ *             stack_index[stack] = n
+ *             stack_depth[stack] = 0             # <<<<<<<<<<<<<<
+ *             stack += 1
+ * 
+ */
+      (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = 0;
+
+      /* "chython/algorithms/_isomorphism.pyx":76
+ *             stack_index[stack] = n
+ *             stack_depth[stack] = 0
+ *             stack += 1             # <<<<<<<<<<<<<<
+ * 
+ *     try:
+ */
+      __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
+
+      /* "chython/algorithms/_isomorphism.pyx":68
+ *     q_mask4 = q_masks4[0]
+ *     for n in range(o_size):
+ *         if (scope[n] and             # <<<<<<<<<<<<<<
+ *             q_mask1 & o_bits1[n] and
+ *             q_mask2 & o_bits2[n] == o_bits2[n] and
+ */
+    }
+  }
+
+  /* "chython/algorithms/_isomorphism.pyx":78
+ *             stack += 1
+ * 
+ *     try:             # <<<<<<<<<<<<<<
+ *         while stack:
+ *             stack -= 1
+ */
+  /*try:*/ {
+
+    /* "chython/algorithms/_isomorphism.pyx":79
+ * 
+ *     try:
+ *         while stack:             # <<<<<<<<<<<<<<
+ *             stack -= 1
+ *             depth = stack_depth[stack]
+ */
+    while (1) {
+      __pyx_t_2 = (__pyx_cur_scope->__pyx_v_stack != 0);
+      if (!__pyx_t_2) break;
+
+      /* "chython/algorithms/_isomorphism.pyx":80
+ *     try:
+ *         while stack:
+ *             stack -= 1             # <<<<<<<<<<<<<<
+ *             depth = stack_depth[stack]
+ *             n = stack_index[stack]
+ */
+      __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack - 1);
+
+      /* "chython/algorithms/_isomorphism.pyx":81
+ *         while stack:
+ *             stack -= 1
+ *             depth = stack_depth[stack]             # <<<<<<<<<<<<<<
+ *             n = stack_index[stack]
+ * 
+ */
+      __pyx_cur_scope->__pyx_v_depth = (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]);
+
+      /* "chython/algorithms/_isomorphism.pyx":82
+ *             stack -= 1
+ *             depth = stack_depth[stack]
+ *             n = stack_index[stack]             # <<<<<<<<<<<<<<
+ * 
+ *             if depth == q_size_dec:
+ */
+      __pyx_cur_scope->__pyx_v_n = (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]);
+
+      /* "chython/algorithms/_isomorphism.pyx":84
+ *             n = stack_index[stack]
+ * 
+ *             if depth == q_size_dec:             # <<<<<<<<<<<<<<
+ *                 mapping = _PyDict_NewPresized(q_size)
+ *                 for i in range(depth):
+ */
+      __pyx_t_2 = ((__pyx_cur_scope->__pyx_v_depth == __pyx_cur_scope->__pyx_v_q_size_dec) != 0);
+      if (__pyx_t_2) {
+
+        /* "chython/algorithms/_isomorphism.pyx":85
+ * 
+ *             if depth == q_size_dec:
+ *                 mapping = _PyDict_NewPresized(q_size)             # <<<<<<<<<<<<<<
+ *                 for i in range(depth):
+ *                     mapping[q_numbers[i]] = o_numbers[path[i]]
+ */
+        __pyx_t_9 = _PyDict_NewPresized(__pyx_cur_scope->__pyx_v_q_size); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 85, __pyx_L19_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_mapping);
+        __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_mapping, ((PyObject*)__pyx_t_9));
+        __Pyx_GIVEREF(__pyx_t_9);
+        __pyx_t_9 = 0;
+
+        /* "chython/algorithms/_isomorphism.pyx":86
+ *             if depth == q_size_dec:
+ *                 mapping = _PyDict_NewPresized(q_size)
+ *                 for i in range(depth):             # <<<<<<<<<<<<<<
+ *                     mapping[q_numbers[i]] = o_numbers[path[i]]
+ *                 mapping[q_numbers[depth]] = o_numbers[n]
+ */
+        __pyx_t_5 = __pyx_cur_scope->__pyx_v_depth;
+        __pyx_t_6 = __pyx_t_5;
+        for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+          __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
+
+          /* "chython/algorithms/_isomorphism.pyx":87
+ *                 mapping = _PyDict_NewPresized(q_size)
+ *                 for i in range(depth):
+ *                     mapping[q_numbers[i]] = o_numbers[path[i]]             # <<<<<<<<<<<<<<
+ *                 mapping[q_numbers[depth]] = o_numbers[n]
+ *                 yield mapping
+ */
+          __pyx_t_4 = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i]);
+          __pyx_t_9 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_4)) )))); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 87, __pyx_L19_error)
+          __Pyx_GOTREF(__pyx_t_9);
+          if (unlikely(__pyx_cur_scope->__pyx_v_mapping == Py_None)) {
+            PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+            __PYX_ERR(0, 87, __pyx_L19_error)
+          }
+          __pyx_t_1 = __pyx_cur_scope->__pyx_v_i;
+          __pyx_t_10 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_q_numbers.data) + __pyx_t_1)) )))); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 87, __pyx_L19_error)
+          __Pyx_GOTREF(__pyx_t_10);
+          if (unlikely(PyDict_SetItem(__pyx_cur_scope->__pyx_v_mapping, __pyx_t_10, __pyx_t_9) < 0)) __PYX_ERR(0, 87, __pyx_L19_error)
+          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+        }
+
+        /* "chython/algorithms/_isomorphism.pyx":88
+ *                 for i in range(depth):
+ *                     mapping[q_numbers[i]] = o_numbers[path[i]]
+ *                 mapping[q_numbers[depth]] = o_numbers[n]             # <<<<<<<<<<<<<<
+ *                 yield mapping
+ *             else:
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+        __pyx_t_9 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_o_numbers.data) + __pyx_t_1)) )))); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 88, __pyx_L19_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        if (unlikely(__pyx_cur_scope->__pyx_v_mapping == Py_None)) {
+          PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+          __PYX_ERR(0, 88, __pyx_L19_error)
+        }
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_depth;
+        __pyx_t_10 = __Pyx_PyInt_From_unsigned_long((*((unsigned long *) ( /* dim=0 */ ((char *) (((unsigned long *) __pyx_cur_scope->__pyx_v_q_numbers.data) + __pyx_t_1)) )))); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 88, __pyx_L19_error)
+        __Pyx_GOTREF(__pyx_t_10);
+        if (unlikely(PyDict_SetItem(__pyx_cur_scope->__pyx_v_mapping, __pyx_t_10, __pyx_t_9) < 0)) __PYX_ERR(0, 88, __pyx_L19_error)
+        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+
+        /* "chython/algorithms/_isomorphism.pyx":89
+ *                     mapping[q_numbers[i]] = o_numbers[path[i]]
+ *                 mapping[q_numbers[depth]] = o_numbers[n]
+ *                 yield mapping             # <<<<<<<<<<<<<<
+ *             else:
+ *                 if path_size != depth:  # dead end reached
+ */
+        __Pyx_INCREF(__pyx_cur_scope->__pyx_v_mapping);
+        __pyx_r = __pyx_cur_scope->__pyx_v_mapping;
+        __Pyx_XGIVEREF(__pyx_r);
+        __Pyx_RefNannyFinishContext();
+        __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
+        /* return from generator, yielding value */
+        __pyx_generator->resume_label = 1;
+        return __pyx_r;
+        __pyx_L26_resume_from_yield:;
+        if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 89, __pyx_L19_error)
+
+        /* "chython/algorithms/_isomorphism.pyx":84
+ *             n = stack_index[stack]
+ * 
+ *             if depth == q_size_dec:             # <<<<<<<<<<<<<<
+ *                 mapping = _PyDict_NewPresized(q_size)
+ *                 for i in range(depth):
+ */
+        goto __pyx_L23;
+      }
+
+      /* "chython/algorithms/_isomorphism.pyx":91
+ *                 yield mapping
+ *             else:
+ *                 if path_size != depth:  # dead end reached             # <<<<<<<<<<<<<<
+ *                     for i in range(depth, path_size):
+ *                         matched[path[i]] = False  # mark unmatched
+ */
+      /*else*/ {
+        __pyx_t_2 = ((__pyx_cur_scope->__pyx_v_path_size != __pyx_cur_scope->__pyx_v_depth) != 0);
+        if (__pyx_t_2) {
+
+          /* "chython/algorithms/_isomorphism.pyx":92
+ *             else:
+ *                 if path_size != depth:  # dead end reached
+ *                     for i in range(depth, path_size):             # <<<<<<<<<<<<<<
+ *                         matched[path[i]] = False  # mark unmatched
+ *                     path_size = depth
+ */
+          __pyx_t_5 = __pyx_cur_scope->__pyx_v_path_size;
+          __pyx_t_6 = __pyx_t_5;
+          for (__pyx_t_7 = __pyx_cur_scope->__pyx_v_depth; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+            __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
+
+            /* "chython/algorithms/_isomorphism.pyx":93
+ *                 if path_size != depth:  # dead end reached
+ *                     for i in range(depth, path_size):
+ *                         matched[path[i]] = False  # mark unmatched             # <<<<<<<<<<<<<<
+ *                     path_size = depth
+ * 
+ */
+            (__pyx_cur_scope->__pyx_v_matched[(__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_i])]) = 0;
+          }
+
+          /* "chython/algorithms/_isomorphism.pyx":94
+ *                     for i in range(depth, path_size):
+ *                         matched[path[i]] = False  # mark unmatched
+ *                     path_size = depth             # <<<<<<<<<<<<<<
+ * 
+ *                 matched[n] = True
+ */
+          __pyx_cur_scope->__pyx_v_path_size = __pyx_cur_scope->__pyx_v_depth;
+
+          /* "chython/algorithms/_isomorphism.pyx":91
+ *                 yield mapping
+ *             else:
+ *                 if path_size != depth:  # dead end reached             # <<<<<<<<<<<<<<
+ *                     for i in range(depth, path_size):
+ *                         matched[path[i]] = False  # mark unmatched
+ */
+        }
+
+        /* "chython/algorithms/_isomorphism.pyx":96
+ *                     path_size = depth
+ * 
+ *                 matched[n] = True             # <<<<<<<<<<<<<<
+ *                 path[path_size] = n
+ *                 path_size += 1
+ */
+        (__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_n]) = 1;
+
+        /* "chython/algorithms/_isomorphism.pyx":97
+ * 
+ *                 matched[n] = True
+ *                 path[path_size] = n             # <<<<<<<<<<<<<<
+ *                 path_size += 1
+ * 
+ */
+        (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_path_size]) = __pyx_cur_scope->__pyx_v_n;
+
+        /* "chython/algorithms/_isomorphism.pyx":98
+ *                 matched[n] = True
+ *                 path[path_size] = n
+ *                 path_size += 1             # <<<<<<<<<<<<<<
+ * 
+ *                 front = depth + 1
+ */
+        __pyx_cur_scope->__pyx_v_path_size = (__pyx_cur_scope->__pyx_v_path_size + 1);
+
+        /* "chython/algorithms/_isomorphism.pyx":100
+ *                 path_size += 1
+ * 
+ *                 front = depth + 1             # <<<<<<<<<<<<<<
+ *                 back = q_back[front]
+ *                 if back != depth:  # branch
+ */
+        __pyx_cur_scope->__pyx_v_front = (__pyx_cur_scope->__pyx_v_depth + 1);
+
+        /* "chython/algorithms/_isomorphism.pyx":101
+ * 
+ *                 front = depth + 1
+ *                 back = q_back[front]             # <<<<<<<<<<<<<<
+ *                 if back != depth:  # branch
+ *                     n = path[back]
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_back = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_back.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":102
+ *                 front = depth + 1
+ *                 back = q_back[front]
+ *                 if back != depth:  # branch             # <<<<<<<<<<<<<<
+ *                     n = path[back]
+ * 
+ */
+        __pyx_t_2 = ((__pyx_cur_scope->__pyx_v_back != __pyx_cur_scope->__pyx_v_depth) != 0);
+        if (__pyx_t_2) {
+
+          /* "chython/algorithms/_isomorphism.pyx":103
+ *                 back = q_back[front]
+ *                 if back != depth:  # branch
+ *                     n = path[back]             # <<<<<<<<<<<<<<
+ * 
+ *                 # load next query atom
+ */
+          __pyx_cur_scope->__pyx_v_n = (__pyx_cur_scope->__pyx_v_path[__pyx_cur_scope->__pyx_v_back]);
+
+          /* "chython/algorithms/_isomorphism.pyx":102
+ *                 front = depth + 1
+ *                 back = q_back[front]
+ *                 if back != depth:  # branch             # <<<<<<<<<<<<<<
+ *                     n = path[back]
+ * 
+ */
+        }
+
+        /* "chython/algorithms/_isomorphism.pyx":106
+ * 
+ *                 # load next query atom
+ *                 q_mask1 = q_masks1[front]             # <<<<<<<<<<<<<<
+ *                 q_mask2 = q_masks2[front]
+ *                 q_mask3 = q_masks3[front]
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_q_mask1 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks1.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":107
+ *                 # load next query atom
+ *                 q_mask1 = q_masks1[front]
+ *                 q_mask2 = q_masks2[front]             # <<<<<<<<<<<<<<
+ *                 q_mask3 = q_masks3[front]
+ *                 q_mask4 = q_masks4[front]
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_q_mask2 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks2.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":108
+ *                 q_mask1 = q_masks1[front]
+ *                 q_mask2 = q_masks2[front]
+ *                 q_mask3 = q_masks3[front]             # <<<<<<<<<<<<<<
+ *                 q_mask4 = q_masks4[front]
+ *                 closures_num = q_closures[front]
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_q_mask3 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks3.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":109
+ *                 q_mask2 = q_masks2[front]
+ *                 q_mask3 = q_masks3[front]
+ *                 q_mask4 = q_masks4[front]             # <<<<<<<<<<<<<<
+ *                 closures_num = q_closures[front]
+ * 
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_q_mask4 = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_masks4.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":110
+ *                 q_mask3 = q_masks3[front]
+ *                 q_mask4 = q_masks4[front]
+ *                 closures_num = q_closures[front]             # <<<<<<<<<<<<<<
+ * 
+ *                 for i in range(o_from[n], o_to[n]):
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_front;
+        __pyx_cur_scope->__pyx_v_closures_num = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_closures.data) + __pyx_t_1)) )));
+
+        /* "chython/algorithms/_isomorphism.pyx":112
+ *                 closures_num = q_closures[front]
+ * 
+ *                 for i in range(o_from[n], o_to[n]):             # <<<<<<<<<<<<<<
+ *                     o_bond = o_bonds[i]
+ *                     m = o_indices[i]
+ */
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+        __pyx_t_5 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_1)) )));
+        __pyx_t_1 = __pyx_cur_scope->__pyx_v_n;
+        __pyx_t_6 = __pyx_t_5;
+        for (__pyx_t_7 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_1)) ))); __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+          __pyx_cur_scope->__pyx_v_i = __pyx_t_7;
+
+          /* "chython/algorithms/_isomorphism.pyx":113
+ * 
+ *                 for i in range(o_from[n], o_to[n]):
+ *                     o_bond = o_bonds[i]             # <<<<<<<<<<<<<<
+ *                     m = o_indices[i]
+ *                     if (scope[m] and not matched[m] and
+ */
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_i;
+          __pyx_cur_scope->__pyx_v_o_bond = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bonds.data) + __pyx_t_8)) )));
+
+          /* "chython/algorithms/_isomorphism.pyx":114
+ *                 for i in range(o_from[n], o_to[n]):
+ *                     o_bond = o_bonds[i]
+ *                     m = o_indices[i]             # <<<<<<<<<<<<<<
+ *                     if (scope[m] and not matched[m] and
+ *                         q_mask1 & o_bond == o_bond and
+ */
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_i;
+          __pyx_cur_scope->__pyx_v_m = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_8)) )));
+
+          /* "chython/algorithms/_isomorphism.pyx":115
+ *                     o_bond = o_bonds[i]
+ *                     m = o_indices[i]
+ *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
+ *                         q_mask1 & o_bond == o_bond and
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ */
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_3 = ((*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_scope.data) + __pyx_t_8)) ))) != 0);
+          if (__pyx_t_3) {
+          } else {
+            __pyx_t_2 = __pyx_t_3;
+            goto __pyx_L34_bool_binop_done;
+          }
+          __pyx_t_3 = ((!((__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_m]) != 0)) != 0);
+          if (__pyx_t_3) {
+          } else {
+            __pyx_t_2 = __pyx_t_3;
+            goto __pyx_L34_bool_binop_done;
+          }
+
+          /* "chython/algorithms/_isomorphism.pyx":116
+ *                     m = o_indices[i]
+ *                     if (scope[m] and not matched[m] and
+ *                         q_mask1 & o_bond == o_bond and             # <<<<<<<<<<<<<<
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ *                         q_mask3 & o_bits3[m] == o_bits3[m] and
+ */
+          __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask1 & __pyx_cur_scope->__pyx_v_o_bond) == __pyx_cur_scope->__pyx_v_o_bond) != 0);
+          if (__pyx_t_3) {
+          } else {
+            __pyx_t_2 = __pyx_t_3;
+            goto __pyx_L34_bool_binop_done;
+          }
+
+          /* "chython/algorithms/_isomorphism.pyx":117
+ *                     if (scope[m] and not matched[m] and
+ *                         q_mask1 & o_bond == o_bond and
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and             # <<<<<<<<<<<<<<
+ *                         q_mask3 & o_bits3[m] == o_bits3[m] and
+ *                         q_mask4 & o_bits4[m]):
+ */
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_11 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask2 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_8)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits2.data) + __pyx_t_11)) )))) != 0);
+          if (__pyx_t_3) {
+          } else {
+            __pyx_t_2 = __pyx_t_3;
+            goto __pyx_L34_bool_binop_done;
+          }
+
+          /* "chython/algorithms/_isomorphism.pyx":118
+ *                         q_mask1 & o_bond == o_bond and
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ *                         q_mask3 & o_bits3[m] == o_bits3[m] and             # <<<<<<<<<<<<<<
+ *                         q_mask4 & o_bits4[m]):
+ * 
+ */
+          __pyx_t_11 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_3 = (((__pyx_cur_scope->__pyx_v_q_mask3 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_11)) )))) == (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits3.data) + __pyx_t_8)) )))) != 0);
+          if (__pyx_t_3) {
+          } else {
+            __pyx_t_2 = __pyx_t_3;
+            goto __pyx_L34_bool_binop_done;
+          }
+
+          /* "chython/algorithms/_isomorphism.pyx":119
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ *                         q_mask3 & o_bits3[m] == o_bits3[m] and
+ *                         q_mask4 & o_bits4[m]):             # <<<<<<<<<<<<<<
+ * 
+ *                         if closures_num:  # candidate atom should have same closures.
+ */
+          __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+          __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_q_mask4 & (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bits4.data) + __pyx_t_8)) )))) != 0);
+          __pyx_t_2 = __pyx_t_3;
+          __pyx_L34_bool_binop_done:;
+
+          /* "chython/algorithms/_isomorphism.pyx":115
+ *                     o_bond = o_bonds[i]
+ *                     m = o_indices[i]
+ *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
+ *                         q_mask1 & o_bond == o_bond and
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ */
+          if (__pyx_t_2) {
+
+            /* "chython/algorithms/_isomorphism.pyx":121
+ *                         q_mask4 & o_bits4[m]):
+ * 
+ *                         if closures_num:  # candidate atom should have same closures.             # <<<<<<<<<<<<<<
+ *                             closures_counter = 0
+ *                             # make a map of closures for o_n atom
+ */
+            __pyx_t_2 = (__pyx_cur_scope->__pyx_v_closures_num != 0);
+            if (__pyx_t_2) {
+
+              /* "chython/algorithms/_isomorphism.pyx":122
+ * 
+ *                         if closures_num:  # candidate atom should have same closures.
+ *                             closures_counter = 0             # <<<<<<<<<<<<<<
+ *                             # make a map of closures for o_n atom
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
+ */
+              __pyx_cur_scope->__pyx_v_closures_counter = 0;
+
+              /* "chython/algorithms/_isomorphism.pyx":125
+ *                             # make a map of closures for o_n atom
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
+ *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
+ *                                 o = o_indices[j]
+ *                                 if o != n and matched[o]:
+ */
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_13 = __pyx_t_12;
+              for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
+                __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
+
+                /* "chython/algorithms/_isomorphism.pyx":126
+ *                             # an index is an neighbor atom and an value is an bond between o_n and the neighbor
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                 o = o_indices[j]             # <<<<<<<<<<<<<<
+ *                                 if o != n and matched[o]:
+ *                                     o_closures[o] = o_bonds[j]
+ */
+                __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
+                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_11)) )));
+
+                /* "chython/algorithms/_isomorphism.pyx":127
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                 o = o_indices[j]
+ *                                 if o != n and matched[o]:             # <<<<<<<<<<<<<<
+ *                                     o_closures[o] = o_bonds[j]
+ *                                     closures_counter += 1
+ */
+                __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_o != __pyx_cur_scope->__pyx_v_n) != 0);
+                if (__pyx_t_3) {
+                } else {
+                  __pyx_t_2 = __pyx_t_3;
+                  goto __pyx_L44_bool_binop_done;
+                }
+                __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_o]) != 0);
+                __pyx_t_2 = __pyx_t_3;
+                __pyx_L44_bool_binop_done:;
+                if (__pyx_t_2) {
+
+                  /* "chython/algorithms/_isomorphism.pyx":128
+ *                                 o = o_indices[j]
+ *                                 if o != n and matched[o]:
+ *                                     o_closures[o] = o_bonds[j]             # <<<<<<<<<<<<<<
+ *                                     closures_counter += 1
+ * 
+ */
+                  __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
+                  (__pyx_cur_scope->__pyx_v_o_closures[__pyx_cur_scope->__pyx_v_o]) = (*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_o_bonds.data) + __pyx_t_11)) )));
+
+                  /* "chython/algorithms/_isomorphism.pyx":129
+ *                                 if o != n and matched[o]:
+ *                                     o_closures[o] = o_bonds[j]
+ *                                     closures_counter += 1             # <<<<<<<<<<<<<<
+ * 
+ *                             if closures_counter == closures_num:
+ */
+                  __pyx_cur_scope->__pyx_v_closures_counter = (__pyx_cur_scope->__pyx_v_closures_counter + 1);
+
+                  /* "chython/algorithms/_isomorphism.pyx":127
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                 o = o_indices[j]
+ *                                 if o != n and matched[o]:             # <<<<<<<<<<<<<<
+ *                                     o_closures[o] = o_bonds[j]
+ *                                     closures_counter += 1
+ */
+                }
+              }
+
+              /* "chython/algorithms/_isomorphism.pyx":131
+ *                                     closures_counter += 1
+ * 
+ *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+ */
+              __pyx_t_2 = ((__pyx_cur_scope->__pyx_v_closures_counter == __pyx_cur_scope->__pyx_v_closures_num) != 0);
+              if (__pyx_t_2) {
+
+                /* "chython/algorithms/_isomorphism.pyx":132
+ * 
+ *                             if closures_counter == closures_num:
+ *                                 for j in range(q_from[front], q_to[front]):             # <<<<<<<<<<<<<<
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+ *                                         break
+ */
+                __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
+                __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_to.data) + __pyx_t_8)) )));
+                __pyx_t_8 = __pyx_cur_scope->__pyx_v_front;
+                __pyx_t_13 = __pyx_t_12;
+                for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
+                  __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
+
+                  /* "chython/algorithms/_isomorphism.pyx":133
+ *                             if closures_counter == closures_num:
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough             # <<<<<<<<<<<<<<
+ *                                         break
+ *                                 else:
+ */
+                  __pyx_t_11 = __pyx_cur_scope->__pyx_v_j;
+                  __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                  __pyx_t_2 = ((!(((*((unsigned PY_LONG_LONG *) ( /* dim=0 */ ((char *) (((unsigned PY_LONG_LONG *) __pyx_cur_scope->__pyx_v_q_bonds.data) + __pyx_t_11)) ))) & (__pyx_cur_scope->__pyx_v_o_closures[(__pyx_cur_scope->__pyx_v_path[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_q_indices.data) + __pyx_t_15)) )))])])) != 0)) != 0);
+                  if (__pyx_t_2) {
+
+                    /* "chython/algorithms/_isomorphism.pyx":134
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+ *                                         break             # <<<<<<<<<<<<<<
+ *                                 else:
+ *                                     stack_index[stack] = m
+ */
+                    goto __pyx_L48_break;
+
+                    /* "chython/algorithms/_isomorphism.pyx":133
+ *                             if closures_counter == closures_num:
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough             # <<<<<<<<<<<<<<
+ *                                         break
+ *                                 else:
+ */
+                  }
+                }
+                /*else*/ {
+
+                  /* "chython/algorithms/_isomorphism.pyx":136
+ *                                         break
+ *                                 else:
+ *                                     stack_index[stack] = m             # <<<<<<<<<<<<<<
+ *                                     stack_depth[stack] = front
+ *                                     stack += 1
+ */
+                  (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
+
+                  /* "chython/algorithms/_isomorphism.pyx":137
+ *                                 else:
+ *                                     stack_index[stack] = m
+ *                                     stack_depth[stack] = front             # <<<<<<<<<<<<<<
+ *                                     stack += 1
+ * 
+ */
+                  (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
+
+                  /* "chython/algorithms/_isomorphism.pyx":138
+ *                                     stack_index[stack] = m
+ *                                     stack_depth[stack] = front
+ *                                     stack += 1             # <<<<<<<<<<<<<<
+ * 
+ *                             # fill an array with nulls
+ */
+                  __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
+                }
+                __pyx_L48_break:;
+
+                /* "chython/algorithms/_isomorphism.pyx":131
+ *                                     closures_counter += 1
+ * 
+ *                             if closures_counter == closures_num:             # <<<<<<<<<<<<<<
+ *                                 for j in range(q_from[front], q_to[front]):
+ *                                     if not q_bonds[j] & o_closures[path[q_indices[j]]]:  # if true then enough
+ */
+              }
+
+              /* "chython/algorithms/_isomorphism.pyx":141
+ * 
+ *                             # fill an array with nulls
+ *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
+ *                                 o_closures[o_indices[j]] = 0
+ *                         else:  # candidate atom should not have closures.
+ */
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_13 = __pyx_t_12;
+              for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
+                __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
+
+                /* "chython/algorithms/_isomorphism.pyx":142
+ *                             # fill an array with nulls
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                 o_closures[o_indices[j]] = 0             # <<<<<<<<<<<<<<
+ *                         else:  # candidate atom should not have closures.
+ *                             for j in range(o_from[m], o_to[m]):
+ */
+                __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                (__pyx_cur_scope->__pyx_v_o_closures[(*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_15)) )))]) = 0;
+              }
+
+              /* "chython/algorithms/_isomorphism.pyx":121
+ *                         q_mask4 & o_bits4[m]):
+ * 
+ *                         if closures_num:  # candidate atom should have same closures.             # <<<<<<<<<<<<<<
+ *                             closures_counter = 0
+ *                             # make a map of closures for o_n atom
+ */
+              goto __pyx_L40;
+            }
+
+            /* "chython/algorithms/_isomorphism.pyx":144
+ *                                 o_closures[o_indices[j]] = 0
+ *                         else:  # candidate atom should not have closures.
+ *                             for j in range(o_from[m], o_to[m]):             # <<<<<<<<<<<<<<
+ *                                o = o_indices[j]
+ *                                if o != n and matched[o]:
+ */
+            /*else*/ {
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_12 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_to.data) + __pyx_t_8)) )));
+              __pyx_t_8 = __pyx_cur_scope->__pyx_v_m;
+              __pyx_t_13 = __pyx_t_12;
+              for (__pyx_t_14 = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_from.data) + __pyx_t_8)) ))); __pyx_t_14 < __pyx_t_13; __pyx_t_14+=1) {
+                __pyx_cur_scope->__pyx_v_j = __pyx_t_14;
+
+                /* "chython/algorithms/_isomorphism.pyx":145
+ *                         else:  # candidate atom should not have closures.
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                o = o_indices[j]             # <<<<<<<<<<<<<<
+ *                                if o != n and matched[o]:
+ *                                    break  # found closure
+ */
+                __pyx_t_15 = __pyx_cur_scope->__pyx_v_j;
+                __pyx_cur_scope->__pyx_v_o = (*((unsigned int *) ( /* dim=0 */ ((char *) (((unsigned int *) __pyx_cur_scope->__pyx_v_o_indices.data) + __pyx_t_15)) )));
+
+                /* "chython/algorithms/_isomorphism.pyx":146
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                o = o_indices[j]
+ *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
+ *                                    break  # found closure
+ *                             else:
+ */
+                __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_o != __pyx_cur_scope->__pyx_v_n) != 0);
+                if (__pyx_t_3) {
+                } else {
+                  __pyx_t_2 = __pyx_t_3;
+                  goto __pyx_L55_bool_binop_done;
+                }
+                __pyx_t_3 = ((__pyx_cur_scope->__pyx_v_matched[__pyx_cur_scope->__pyx_v_o]) != 0);
+                __pyx_t_2 = __pyx_t_3;
+                __pyx_L55_bool_binop_done:;
+                if (__pyx_t_2) {
+
+                  /* "chython/algorithms/_isomorphism.pyx":147
+ *                                o = o_indices[j]
+ *                                if o != n and matched[o]:
+ *                                    break  # found closure             # <<<<<<<<<<<<<<
+ *                             else:
+ *                                 stack_index[stack] = m
+ */
+                  goto __pyx_L53_break;
+
+                  /* "chython/algorithms/_isomorphism.pyx":146
+ *                             for j in range(o_from[m], o_to[m]):
+ *                                o = o_indices[j]
+ *                                if o != n and matched[o]:             # <<<<<<<<<<<<<<
+ *                                    break  # found closure
+ *                             else:
+ */
+                }
+              }
+              /*else*/ {
+
+                /* "chython/algorithms/_isomorphism.pyx":149
+ *                                    break  # found closure
+ *                             else:
+ *                                 stack_index[stack] = m             # <<<<<<<<<<<<<<
+ *                                 stack_depth[stack] = front
+ *                                 stack += 1
+ */
+                (__pyx_cur_scope->__pyx_v_stack_index[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_m;
+
+                /* "chython/algorithms/_isomorphism.pyx":150
+ *                             else:
+ *                                 stack_index[stack] = m
+ *                                 stack_depth[stack] = front             # <<<<<<<<<<<<<<
+ *                                 stack += 1
+ *     finally:
+ */
+                (__pyx_cur_scope->__pyx_v_stack_depth[__pyx_cur_scope->__pyx_v_stack]) = __pyx_cur_scope->__pyx_v_front;
+
+                /* "chython/algorithms/_isomorphism.pyx":151
+ *                                 stack_index[stack] = m
+ *                                 stack_depth[stack] = front
+ *                                 stack += 1             # <<<<<<<<<<<<<<
+ *     finally:
+ *         PyMem_Free(path)
+ */
+                __pyx_cur_scope->__pyx_v_stack = (__pyx_cur_scope->__pyx_v_stack + 1);
+              }
+              __pyx_L53_break:;
+            }
+            __pyx_L40:;
+
+            /* "chython/algorithms/_isomorphism.pyx":115
+ *                     o_bond = o_bonds[i]
+ *                     m = o_indices[i]
+ *                     if (scope[m] and not matched[m] and             # <<<<<<<<<<<<<<
+ *                         q_mask1 & o_bond == o_bond and
+ *                         q_mask2 & o_bits2[m] == o_bits2[m] and
+ */
+          }
+        }
+      }
+      __pyx_L23:;
+    }
+  }
+
+  /* "chython/algorithms/_isomorphism.pyx":153
+ *                                 stack += 1
+ *     finally:
+ *         PyMem_Free(path)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      PyMem_Free(__pyx_cur_scope->__pyx_v_path);
+
+      /* "chython/algorithms/_isomorphism.pyx":154
+ *     finally:
+ *         PyMem_Free(path)
+ *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)
+ */
+      PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
+
+      /* "chython/algorithms/_isomorphism.pyx":155
+ *         PyMem_Free(path)
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(stack_depth)
+ *         PyMem_Free(o_closures)
+ */
+      PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
+
+      /* "chython/algorithms/_isomorphism.pyx":156
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(o_closures)
+ */
+      PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
+
+      /* "chython/algorithms/_isomorphism.pyx":157
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)
+ *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
+ */
+      PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
+      goto __pyx_L20;
+    }
+    __pyx_L19_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_assign
+      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
+      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_22, &__pyx_t_23, &__pyx_t_24);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21) < 0)) __Pyx_ErrFetch(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
+      __Pyx_XGOTREF(__pyx_t_19);
+      __Pyx_XGOTREF(__pyx_t_20);
+      __Pyx_XGOTREF(__pyx_t_21);
+      __Pyx_XGOTREF(__pyx_t_22);
+      __Pyx_XGOTREF(__pyx_t_23);
+      __Pyx_XGOTREF(__pyx_t_24);
+      __pyx_t_16 = __pyx_lineno; __pyx_t_17 = __pyx_clineno; __pyx_t_18 = __pyx_filename;
+      {
+
+        /* "chython/algorithms/_isomorphism.pyx":153
+ *                                 stack += 1
+ *     finally:
+ *         PyMem_Free(path)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)
+ */
+        PyMem_Free(__pyx_cur_scope->__pyx_v_path);
+
+        /* "chython/algorithms/_isomorphism.pyx":154
+ *     finally:
+ *         PyMem_Free(path)
+ *         PyMem_Free(matched)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)
+ */
+        PyMem_Free(__pyx_cur_scope->__pyx_v_matched);
+
+        /* "chython/algorithms/_isomorphism.pyx":155
+ *         PyMem_Free(path)
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(stack_depth)
+ *         PyMem_Free(o_closures)
+ */
+        PyMem_Free(__pyx_cur_scope->__pyx_v_stack_index);
+
+        /* "chython/algorithms/_isomorphism.pyx":156
+ *         PyMem_Free(matched)
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(o_closures)
+ */
+        PyMem_Free(__pyx_cur_scope->__pyx_v_stack_depth);
+
+        /* "chython/algorithms/_isomorphism.pyx":157
+ *         PyMem_Free(stack_index)
+ *         PyMem_Free(stack_depth)
+ *         PyMem_Free(o_closures)             # <<<<<<<<<<<<<<
+ */
+        PyMem_Free(__pyx_cur_scope->__pyx_v_o_closures);
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_22);
+        __Pyx_XGIVEREF(__pyx_t_23);
+        __Pyx_XGIVEREF(__pyx_t_24);
+        __Pyx_ExceptionReset(__pyx_t_22, __pyx_t_23, __pyx_t_24);
+      }
+      __Pyx_XGIVEREF(__pyx_t_19);
+      __Pyx_XGIVEREF(__pyx_t_20);
+      __Pyx_XGIVEREF(__pyx_t_21);
+      __Pyx_ErrRestore(__pyx_t_19, __pyx_t_20, __pyx_t_21);
+      __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0;
+      __pyx_lineno = __pyx_t_16; __pyx_clineno = __pyx_t_17; __pyx_filename = __pyx_t_18;
+      goto __pyx_L1_error;
+    }
+    __pyx_L20:;
+  }
+  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
+
+  /* "chython/algorithms/_isomorphism.pyx":30
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
+ *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+ *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+ */
+
+  /* function exit code */
+  PyErr_SetNone(PyExc_StopIteration);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_AddTraceback("get_mapping", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
+  #if !CYTHON_USE_EXC_INFO_STACK
+  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
   #endif
-  Py_VISIT(traverse_module_state->__pyx_array_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_array);
-  Py_VISIT(traverse_module_state->__pyx_MemviewEnum_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_MemviewEnum);
-  Py_VISIT(traverse_module_state->__pyx_memoryview_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryview);
-  Py_VISIT(traverse_module_state->__pyx_memoryviewslice_type);
-  Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryviewslice);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ASCII);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_AssertionError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Bond);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Bond__m);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Bond__n);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Bond__order);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Cannot_index_with_type);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Ellipsis);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
-  Py_VISIT(traverse_module_state->__pyx_n_s_IndexError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_shape_in_axis);
-  Py_VISIT(traverse_module_state->__pyx_n_s_MemoryError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_VISIT(traverse_module_state->__pyx_n_b_O);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-  Py_VISIT(traverse_module_state->__pyx_n_s_PickleError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Sequence);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_VISIT(traverse_module_state->__pyx_n_s_TypeError);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ValueError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_View_MemoryView);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__2);
-  Py_VISIT(traverse_module_state->__pyx_n_s__23);
-  Py_VISIT(traverse_module_state->__pyx_n_s__3);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__6);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__7);
-  Py_VISIT(traverse_module_state->__pyx_n_s_a);
-  Py_VISIT(traverse_module_state->__pyx_n_s_abc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_allocate_buffer);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_and);
-  Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
-  Py_VISIT(traverse_module_state->__pyx_n_s_atoms);
-  Py_VISIT(traverse_module_state->__pyx_n_s_atoms_count);
-  Py_VISIT(traverse_module_state->__pyx_n_s_b);
-  Py_VISIT(traverse_module_state->__pyx_n_s_base);
-  Py_VISIT(traverse_module_state->__pyx_n_s_bond);
-  Py_VISIT(traverse_module_state->__pyx_n_s_bond_shift);
-  Py_VISIT(traverse_module_state->__pyx_n_s_c);
-  Py_VISIT(traverse_module_state->__pyx_n_u_c);
-  Py_VISIT(traverse_module_state->__pyx_n_s_charges);
-  Py_VISIT(traverse_module_state->__pyx_n_s_chython_containers__cpack);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_chython_containers__cpack_pyx);
-  Py_VISIT(traverse_module_state->__pyx_n_s_chython_containers_bonds);
-  Py_VISIT(traverse_module_state->__pyx_n_s_class);
-  Py_VISIT(traverse_module_state->__pyx_n_s_class_getitem);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
-  Py_VISIT(traverse_module_state->__pyx_n_s_collections);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_collections_abc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_connections);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_direct);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_indirect);
-  Py_VISIT(traverse_module_state->__pyx_n_s_count);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ct_count);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ct_shift);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ct_sign);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ct_stereo);
-  Py_VISIT(traverse_module_state->__pyx_n_s_data);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dict);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_dtype_is_object);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_encode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_enumerate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_error);
-  Py_VISIT(traverse_module_state->__pyx_n_s_flags);
-  Py_VISIT(traverse_module_state->__pyx_n_s_format);
-  Py_VISIT(traverse_module_state->__pyx_n_s_fortran);
-  Py_VISIT(traverse_module_state->__pyx_n_u_fortran);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_gc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_getstate);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_got);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_hydrogens);
-  Py_VISIT(traverse_module_state->__pyx_n_s_i);
-  Py_VISIT(traverse_module_state->__pyx_n_s_id);
-  Py_VISIT(traverse_module_state->__pyx_n_s_import);
-  Py_VISIT(traverse_module_state->__pyx_n_s_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_initializing);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_chiral);
-  Py_VISIT(traverse_module_state->__pyx_n_s_is_coroutine);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_isenabled);
-  Py_VISIT(traverse_module_state->__pyx_n_s_itemsize);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
-  Py_VISIT(traverse_module_state->__pyx_n_s_m);
-  Py_VISIT(traverse_module_state->__pyx_n_s_main);
-  Py_VISIT(traverse_module_state->__pyx_n_s_memview);
-  Py_VISIT(traverse_module_state->__pyx_n_s_mode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n);
-  Py_VISIT(traverse_module_state->__pyx_n_s_name);
-  Py_VISIT(traverse_module_state->__pyx_n_s_name_2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ndim);
-  Py_VISIT(traverse_module_state->__pyx_n_s_neighbors);
-  Py_VISIT(traverse_module_state->__pyx_n_s_new);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_VISIT(traverse_module_state->__pyx_n_s_obj);
-  Py_VISIT(traverse_module_state->__pyx_n_s_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_orders);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pickle);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_allenes_stereo);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_atoms);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_atoms_stereo);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_bonds);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_bonds_flat);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_charges);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_cis_trans_stereo);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_hydrogens);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_isotopes);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_m);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_mapping);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_n);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_ngb);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_plane);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_radicals);
-  Py_VISIT(traverse_module_state->__pyx_n_s_py_xy);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_PickleError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_checksum);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_result);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_state);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_type);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_unpickle_Enum);
-  Py_VISIT(traverse_module_state->__pyx_n_s_pyx_vtable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_radicals);
-  Py_VISIT(traverse_module_state->__pyx_n_s_range);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reduce_ex);
-  Py_VISIT(traverse_module_state->__pyx_n_s_register);
-  Py_VISIT(traverse_module_state->__pyx_n_s_seen);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_setstate_cython);
-  Py_VISIT(traverse_module_state->__pyx_n_s_shape);
-  Py_VISIT(traverse_module_state->__pyx_n_s_shift);
-  Py_VISIT(traverse_module_state->__pyx_n_s_size);
-  Py_VISIT(traverse_module_state->__pyx_n_s_spec);
-  Py_VISIT(traverse_module_state->__pyx_n_s_start);
-  Py_VISIT(traverse_module_state->__pyx_n_s_step);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stereo_sign);
-  Py_VISIT(traverse_module_state->__pyx_n_s_stop);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_indirect);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_stringsource);
-  Py_VISIT(traverse_module_state->__pyx_n_s_struct);
-  Py_VISIT(traverse_module_state->__pyx_n_s_sys);
-  Py_VISIT(traverse_module_state->__pyx_n_s_test);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_array_data);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
-  Py_VISIT(traverse_module_state->__pyx_n_s_unpack);
-  Py_VISIT(traverse_module_state->__pyx_n_s_update);
-  Py_VISIT(traverse_module_state->__pyx_n_s_version_info);
-  Py_VISIT(traverse_module_state->__pyx_float_0_);
-  Py_VISIT(traverse_module_state->__pyx_int_0);
-  Py_VISIT(traverse_module_state->__pyx_int_1);
-  Py_VISIT(traverse_module_state->__pyx_int_3);
-  Py_VISIT(traverse_module_state->__pyx_int_112105877);
-  Py_VISIT(traverse_module_state->__pyx_int_136983863);
-  Py_VISIT(traverse_module_state->__pyx_int_184977713);
-  Py_VISIT(traverse_module_state->__pyx_int_neg_1);
-  Py_VISIT(traverse_module_state->__pyx_slice__5);
-  Py_VISIT(traverse_module_state->__pyx_tuple__4);
-  Py_VISIT(traverse_module_state->__pyx_tuple__8);
-  Py_VISIT(traverse_module_state->__pyx_tuple__9);
-  Py_VISIT(traverse_module_state->__pyx_tuple__10);
-  Py_VISIT(traverse_module_state->__pyx_tuple__11);
-  Py_VISIT(traverse_module_state->__pyx_tuple__12);
-  Py_VISIT(traverse_module_state->__pyx_tuple__13);
-  Py_VISIT(traverse_module_state->__pyx_tuple__14);
-  Py_VISIT(traverse_module_state->__pyx_tuple__15);
-  Py_VISIT(traverse_module_state->__pyx_tuple__16);
-  Py_VISIT(traverse_module_state->__pyx_tuple__17);
-  Py_VISIT(traverse_module_state->__pyx_tuple__18);
-  Py_VISIT(traverse_module_state->__pyx_tuple__19);
-  Py_VISIT(traverse_module_state->__pyx_tuple__21);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__20);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__22);
-  return 0;
+  __pyx_generator->resume_label = -1;
+  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
 }
-#endif
-/* #### Code section: module_state_defines ### */
-#define __pyx_d __pyx_mstate_global->__pyx_d
-#define __pyx_b __pyx_mstate_global->__pyx_b
-#define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
-#define __pyx_empty_tuple __pyx_mstate_global->__pyx_empty_tuple
-#define __pyx_empty_bytes __pyx_mstate_global->__pyx_empty_bytes
-#define __pyx_empty_unicode __pyx_mstate_global->__pyx_empty_unicode
-#ifdef __Pyx_CyFunction_USED
-#define __pyx_CyFunctionType __pyx_mstate_global->__pyx_CyFunctionType
-#endif
-#ifdef __Pyx_FusedFunction_USED
-#define __pyx_FusedFunctionType __pyx_mstate_global->__pyx_FusedFunctionType
-#endif
-#ifdef __Pyx_Generator_USED
-#define __pyx_GeneratorType __pyx_mstate_global->__pyx_GeneratorType
-#endif
-#ifdef __Pyx_IterableCoroutine_USED
-#define __pyx_IterableCoroutineType __pyx_mstate_global->__pyx_IterableCoroutineType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineAwaitType __pyx_mstate_global->__pyx_CoroutineAwaitType
-#endif
-#ifdef __Pyx_Coroutine_USED
-#define __pyx_CoroutineType __pyx_mstate_global->__pyx_CoroutineType
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#endif
-#if CYTHON_USE_MODULE_STATE
-#define __pyx_type___pyx_array __pyx_mstate_global->__pyx_type___pyx_array
-#define __pyx_type___pyx_MemviewEnum __pyx_mstate_global->__pyx_type___pyx_MemviewEnum
-#define __pyx_type___pyx_memoryview __pyx_mstate_global->__pyx_type___pyx_memoryview
-#define __pyx_type___pyx_memoryviewslice __pyx_mstate_global->__pyx_type___pyx_memoryviewslice
-#endif
-#define __pyx_array_type __pyx_mstate_global->__pyx_array_type
-#define __pyx_MemviewEnum_type __pyx_mstate_global->__pyx_MemviewEnum_type
-#define __pyx_memoryview_type __pyx_mstate_global->__pyx_memoryview_type
-#define __pyx_memoryviewslice_type __pyx_mstate_global->__pyx_memoryviewslice_type
-#define __pyx_kp_u_ __pyx_mstate_global->__pyx_kp_u_
-#define __pyx_n_s_ASCII __pyx_mstate_global->__pyx_n_s_ASCII
-#define __pyx_kp_s_All_dimensions_preceding_dimensi __pyx_mstate_global->__pyx_kp_s_All_dimensions_preceding_dimensi
-#define __pyx_n_s_AssertionError __pyx_mstate_global->__pyx_n_s_AssertionError
-#define __pyx_n_s_Bond __pyx_mstate_global->__pyx_n_s_Bond
-#define __pyx_n_s_Bond__m __pyx_mstate_global->__pyx_n_s_Bond__m
-#define __pyx_n_s_Bond__n __pyx_mstate_global->__pyx_n_s_Bond__n
-#define __pyx_n_s_Bond__order __pyx_mstate_global->__pyx_n_s_Bond__order
-#define __pyx_kp_s_Buffer_view_does_not_expose_stri __pyx_mstate_global->__pyx_kp_s_Buffer_view_does_not_expose_stri
-#define __pyx_kp_s_Can_only_create_a_buffer_that_is __pyx_mstate_global->__pyx_kp_s_Can_only_create_a_buffer_that_is
-#define __pyx_kp_s_Cannot_assign_to_read_only_memor __pyx_mstate_global->__pyx_kp_s_Cannot_assign_to_read_only_memor
-#define __pyx_kp_s_Cannot_create_writable_memory_vi __pyx_mstate_global->__pyx_kp_s_Cannot_create_writable_memory_vi
-#define __pyx_kp_u_Cannot_index_with_type __pyx_mstate_global->__pyx_kp_u_Cannot_index_with_type
-#define __pyx_kp_s_Cannot_transpose_memoryview_with __pyx_mstate_global->__pyx_kp_s_Cannot_transpose_memoryview_with
-#define __pyx_kp_s_Dimension_d_is_not_direct __pyx_mstate_global->__pyx_kp_s_Dimension_d_is_not_direct
-#define __pyx_n_s_Ellipsis __pyx_mstate_global->__pyx_n_s_Ellipsis
-#define __pyx_kp_s_Empty_shape_tuple_for_cython_arr __pyx_mstate_global->__pyx_kp_s_Empty_shape_tuple_for_cython_arr
-#define __pyx_kp_s_Incompatible_checksums_0x_x_vs_0 __pyx_mstate_global->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0
-#define __pyx_n_s_IndexError __pyx_mstate_global->__pyx_n_s_IndexError
-#define __pyx_kp_s_Index_out_of_bounds_axis_d __pyx_mstate_global->__pyx_kp_s_Index_out_of_bounds_axis_d
-#define __pyx_kp_s_Indirect_dimensions_not_supporte __pyx_mstate_global->__pyx_kp_s_Indirect_dimensions_not_supporte
-#define __pyx_kp_u_Invalid_mode_expected_c_or_fortr __pyx_mstate_global->__pyx_kp_u_Invalid_mode_expected_c_or_fortr
-#define __pyx_kp_u_Invalid_shape_in_axis __pyx_mstate_global->__pyx_kp_u_Invalid_shape_in_axis
-#define __pyx_n_s_MemoryError __pyx_mstate_global->__pyx_n_s_MemoryError
-#define __pyx_kp_s_MemoryView_of_r_at_0x_x __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_at_0x_x
-#define __pyx_kp_s_MemoryView_of_r_object __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_object
-#define __pyx_n_b_O __pyx_mstate_global->__pyx_n_b_O
-#define __pyx_kp_u_Out_of_bounds_on_buffer_access_a __pyx_mstate_global->__pyx_kp_u_Out_of_bounds_on_buffer_access_a
-#define __pyx_n_s_PickleError __pyx_mstate_global->__pyx_n_s_PickleError
-#define __pyx_n_s_Sequence __pyx_mstate_global->__pyx_n_s_Sequence
-#define __pyx_kp_s_Step_may_not_be_zero_axis_d __pyx_mstate_global->__pyx_kp_s_Step_may_not_be_zero_axis_d
-#define __pyx_n_s_TypeError __pyx_mstate_global->__pyx_n_s_TypeError
-#define __pyx_kp_s_Unable_to_convert_item_to_object __pyx_mstate_global->__pyx_kp_s_Unable_to_convert_item_to_object
-#define __pyx_n_s_ValueError __pyx_mstate_global->__pyx_n_s_ValueError
-#define __pyx_n_s_View_MemoryView __pyx_mstate_global->__pyx_n_s_View_MemoryView
-#define __pyx_kp_u__2 __pyx_mstate_global->__pyx_kp_u__2
-#define __pyx_n_s__23 __pyx_mstate_global->__pyx_n_s__23
-#define __pyx_n_s__3 __pyx_mstate_global->__pyx_n_s__3
-#define __pyx_kp_u__6 __pyx_mstate_global->__pyx_kp_u__6
-#define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
-#define __pyx_n_s_a __pyx_mstate_global->__pyx_n_s_a
-#define __pyx_n_s_abc __pyx_mstate_global->__pyx_n_s_abc
-#define __pyx_n_s_allocate_buffer __pyx_mstate_global->__pyx_n_s_allocate_buffer
-#define __pyx_kp_u_and __pyx_mstate_global->__pyx_kp_u_and
-#define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
-#define __pyx_n_s_atoms __pyx_mstate_global->__pyx_n_s_atoms
-#define __pyx_n_s_atoms_count __pyx_mstate_global->__pyx_n_s_atoms_count
-#define __pyx_n_s_b __pyx_mstate_global->__pyx_n_s_b
-#define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
-#define __pyx_n_s_bond __pyx_mstate_global->__pyx_n_s_bond
-#define __pyx_n_s_bond_shift __pyx_mstate_global->__pyx_n_s_bond_shift
-#define __pyx_n_s_c __pyx_mstate_global->__pyx_n_s_c
-#define __pyx_n_u_c __pyx_mstate_global->__pyx_n_u_c
-#define __pyx_n_s_charges __pyx_mstate_global->__pyx_n_s_charges
-#define __pyx_n_s_chython_containers__cpack __pyx_mstate_global->__pyx_n_s_chython_containers__cpack
-#define __pyx_kp_s_chython_containers__cpack_pyx __pyx_mstate_global->__pyx_kp_s_chython_containers__cpack_pyx
-#define __pyx_n_s_chython_containers_bonds __pyx_mstate_global->__pyx_n_s_chython_containers_bonds
-#define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
-#define __pyx_n_s_class_getitem __pyx_mstate_global->__pyx_n_s_class_getitem
-#define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
-#define __pyx_n_s_collections __pyx_mstate_global->__pyx_n_s_collections
-#define __pyx_kp_s_collections_abc __pyx_mstate_global->__pyx_kp_s_collections_abc
-#define __pyx_n_s_connections __pyx_mstate_global->__pyx_n_s_connections
-#define __pyx_kp_s_contiguous_and_direct __pyx_mstate_global->__pyx_kp_s_contiguous_and_direct
-#define __pyx_kp_s_contiguous_and_indirect __pyx_mstate_global->__pyx_kp_s_contiguous_and_indirect
-#define __pyx_n_s_count __pyx_mstate_global->__pyx_n_s_count
-#define __pyx_n_s_ct_count __pyx_mstate_global->__pyx_n_s_ct_count
-#define __pyx_n_s_ct_shift __pyx_mstate_global->__pyx_n_s_ct_shift
-#define __pyx_n_s_ct_sign __pyx_mstate_global->__pyx_n_s_ct_sign
-#define __pyx_n_s_ct_stereo __pyx_mstate_global->__pyx_n_s_ct_stereo
-#define __pyx_n_s_data __pyx_mstate_global->__pyx_n_s_data
-#define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
-#define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
-#define __pyx_n_s_dtype_is_object __pyx_mstate_global->__pyx_n_s_dtype_is_object
-#define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
-#define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
-#define __pyx_n_s_enumerate __pyx_mstate_global->__pyx_n_s_enumerate
-#define __pyx_n_s_error __pyx_mstate_global->__pyx_n_s_error
-#define __pyx_n_s_flags __pyx_mstate_global->__pyx_n_s_flags
-#define __pyx_n_s_format __pyx_mstate_global->__pyx_n_s_format
-#define __pyx_n_s_fortran __pyx_mstate_global->__pyx_n_s_fortran
-#define __pyx_n_u_fortran __pyx_mstate_global->__pyx_n_u_fortran
-#define __pyx_kp_u_gc __pyx_mstate_global->__pyx_kp_u_gc
-#define __pyx_n_s_getstate __pyx_mstate_global->__pyx_n_s_getstate
-#define __pyx_kp_u_got __pyx_mstate_global->__pyx_kp_u_got
-#define __pyx_kp_u_got_differing_extents_in_dimensi __pyx_mstate_global->__pyx_kp_u_got_differing_extents_in_dimensi
-#define __pyx_n_s_hydrogens __pyx_mstate_global->__pyx_n_s_hydrogens
-#define __pyx_n_s_i __pyx_mstate_global->__pyx_n_s_i
-#define __pyx_n_s_id __pyx_mstate_global->__pyx_n_s_id
-#define __pyx_n_s_import __pyx_mstate_global->__pyx_n_s_import
-#define __pyx_n_s_index __pyx_mstate_global->__pyx_n_s_index
-#define __pyx_n_s_initializing __pyx_mstate_global->__pyx_n_s_initializing
-#define __pyx_n_s_is_chiral __pyx_mstate_global->__pyx_n_s_is_chiral
-#define __pyx_n_s_is_coroutine __pyx_mstate_global->__pyx_n_s_is_coroutine
-#define __pyx_kp_u_isenabled __pyx_mstate_global->__pyx_kp_u_isenabled
-#define __pyx_n_s_itemsize __pyx_mstate_global->__pyx_n_s_itemsize
-#define __pyx_kp_s_itemsize_0_for_cython_array __pyx_mstate_global->__pyx_kp_s_itemsize_0_for_cython_array
-#define __pyx_n_s_m __pyx_mstate_global->__pyx_n_s_m
-#define __pyx_n_s_main __pyx_mstate_global->__pyx_n_s_main
-#define __pyx_n_s_memview __pyx_mstate_global->__pyx_n_s_memview
-#define __pyx_n_s_mode __pyx_mstate_global->__pyx_n_s_mode
-#define __pyx_n_s_n __pyx_mstate_global->__pyx_n_s_n
-#define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
-#define __pyx_n_s_name_2 __pyx_mstate_global->__pyx_n_s_name_2
-#define __pyx_n_s_ndim __pyx_mstate_global->__pyx_n_s_ndim
-#define __pyx_n_s_neighbors __pyx_mstate_global->__pyx_n_s_neighbors
-#define __pyx_n_s_new __pyx_mstate_global->__pyx_n_s_new
-#define __pyx_kp_s_no_default___reduce___due_to_non __pyx_mstate_global->__pyx_kp_s_no_default___reduce___due_to_non
-#define __pyx_n_s_obj __pyx_mstate_global->__pyx_n_s_obj
-#define __pyx_n_s_object __pyx_mstate_global->__pyx_n_s_object
-#define __pyx_n_s_orders __pyx_mstate_global->__pyx_n_s_orders
-#define __pyx_n_s_pack __pyx_mstate_global->__pyx_n_s_pack
-#define __pyx_n_s_pickle __pyx_mstate_global->__pyx_n_s_pickle
-#define __pyx_n_s_py_allenes_stereo __pyx_mstate_global->__pyx_n_s_py_allenes_stereo
-#define __pyx_n_s_py_atoms __pyx_mstate_global->__pyx_n_s_py_atoms
-#define __pyx_n_s_py_atoms_stereo __pyx_mstate_global->__pyx_n_s_py_atoms_stereo
-#define __pyx_n_s_py_bonds __pyx_mstate_global->__pyx_n_s_py_bonds
-#define __pyx_n_s_py_bonds_flat __pyx_mstate_global->__pyx_n_s_py_bonds_flat
-#define __pyx_n_s_py_charges __pyx_mstate_global->__pyx_n_s_py_charges
-#define __pyx_n_s_py_cis_trans_stereo __pyx_mstate_global->__pyx_n_s_py_cis_trans_stereo
-#define __pyx_n_s_py_hydrogens __pyx_mstate_global->__pyx_n_s_py_hydrogens
-#define __pyx_n_s_py_isotopes __pyx_mstate_global->__pyx_n_s_py_isotopes
-#define __pyx_n_s_py_m __pyx_mstate_global->__pyx_n_s_py_m
-#define __pyx_n_s_py_mapping __pyx_mstate_global->__pyx_n_s_py_mapping
-#define __pyx_n_s_py_n __pyx_mstate_global->__pyx_n_s_py_n
-#define __pyx_n_s_py_ngb __pyx_mstate_global->__pyx_n_s_py_ngb
-#define __pyx_n_s_py_plane __pyx_mstate_global->__pyx_n_s_py_plane
-#define __pyx_n_s_py_radicals __pyx_mstate_global->__pyx_n_s_py_radicals
-#define __pyx_n_s_py_xy __pyx_mstate_global->__pyx_n_s_py_xy
-#define __pyx_n_s_pyx_PickleError __pyx_mstate_global->__pyx_n_s_pyx_PickleError
-#define __pyx_n_s_pyx_checksum __pyx_mstate_global->__pyx_n_s_pyx_checksum
-#define __pyx_n_s_pyx_result __pyx_mstate_global->__pyx_n_s_pyx_result
-#define __pyx_n_s_pyx_state __pyx_mstate_global->__pyx_n_s_pyx_state
-#define __pyx_n_s_pyx_type __pyx_mstate_global->__pyx_n_s_pyx_type
-#define __pyx_n_s_pyx_unpickle_Enum __pyx_mstate_global->__pyx_n_s_pyx_unpickle_Enum
-#define __pyx_n_s_pyx_vtable __pyx_mstate_global->__pyx_n_s_pyx_vtable
-#define __pyx_n_s_radicals __pyx_mstate_global->__pyx_n_s_radicals
-#define __pyx_n_s_range __pyx_mstate_global->__pyx_n_s_range
-#define __pyx_n_s_reduce __pyx_mstate_global->__pyx_n_s_reduce
-#define __pyx_n_s_reduce_cython __pyx_mstate_global->__pyx_n_s_reduce_cython
-#define __pyx_n_s_reduce_ex __pyx_mstate_global->__pyx_n_s_reduce_ex
-#define __pyx_n_s_register __pyx_mstate_global->__pyx_n_s_register
-#define __pyx_n_s_seen __pyx_mstate_global->__pyx_n_s_seen
-#define __pyx_n_s_setstate __pyx_mstate_global->__pyx_n_s_setstate
-#define __pyx_n_s_setstate_cython __pyx_mstate_global->__pyx_n_s_setstate_cython
-#define __pyx_n_s_shape __pyx_mstate_global->__pyx_n_s_shape
-#define __pyx_n_s_shift __pyx_mstate_global->__pyx_n_s_shift
-#define __pyx_n_s_size __pyx_mstate_global->__pyx_n_s_size
-#define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
-#define __pyx_n_s_start __pyx_mstate_global->__pyx_n_s_start
-#define __pyx_n_s_step __pyx_mstate_global->__pyx_n_s_step
-#define __pyx_n_s_stereo_sign __pyx_mstate_global->__pyx_n_s_stereo_sign
-#define __pyx_n_s_stop __pyx_mstate_global->__pyx_n_s_stop
-#define __pyx_kp_s_strided_and_direct __pyx_mstate_global->__pyx_kp_s_strided_and_direct
-#define __pyx_kp_s_strided_and_direct_or_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_direct_or_indirect
-#define __pyx_kp_s_strided_and_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_indirect
-#define __pyx_kp_s_stringsource __pyx_mstate_global->__pyx_kp_s_stringsource
-#define __pyx_n_s_struct __pyx_mstate_global->__pyx_n_s_struct
-#define __pyx_n_s_sys __pyx_mstate_global->__pyx_n_s_sys
-#define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
-#define __pyx_kp_s_unable_to_allocate_array_data __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_array_data
-#define __pyx_kp_s_unable_to_allocate_shape_and_str __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_shape_and_str
-#define __pyx_n_s_unpack __pyx_mstate_global->__pyx_n_s_unpack
-#define __pyx_n_s_update __pyx_mstate_global->__pyx_n_s_update
-#define __pyx_n_s_version_info __pyx_mstate_global->__pyx_n_s_version_info
-#define __pyx_float_0_ __pyx_mstate_global->__pyx_float_0_
-#define __pyx_int_0 __pyx_mstate_global->__pyx_int_0
-#define __pyx_int_1 __pyx_mstate_global->__pyx_int_1
-#define __pyx_int_3 __pyx_mstate_global->__pyx_int_3
-#define __pyx_int_112105877 __pyx_mstate_global->__pyx_int_112105877
-#define __pyx_int_136983863 __pyx_mstate_global->__pyx_int_136983863
-#define __pyx_int_184977713 __pyx_mstate_global->__pyx_int_184977713
-#define __pyx_int_neg_1 __pyx_mstate_global->__pyx_int_neg_1
-#define __pyx_slice__5 __pyx_mstate_global->__pyx_slice__5
-#define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
-#define __pyx_tuple__8 __pyx_mstate_global->__pyx_tuple__8
-#define __pyx_tuple__9 __pyx_mstate_global->__pyx_tuple__9
-#define __pyx_tuple__10 __pyx_mstate_global->__pyx_tuple__10
-#define __pyx_tuple__11 __pyx_mstate_global->__pyx_tuple__11
-#define __pyx_tuple__12 __pyx_mstate_global->__pyx_tuple__12
-#define __pyx_tuple__13 __pyx_mstate_global->__pyx_tuple__13
-#define __pyx_tuple__14 __pyx_mstate_global->__pyx_tuple__14
-#define __pyx_tuple__15 __pyx_mstate_global->__pyx_tuple__15
-#define __pyx_tuple__16 __pyx_mstate_global->__pyx_tuple__16
-#define __pyx_tuple__17 __pyx_mstate_global->__pyx_tuple__17
-#define __pyx_tuple__18 __pyx_mstate_global->__pyx_tuple__18
-#define __pyx_tuple__19 __pyx_mstate_global->__pyx_tuple__19
-#define __pyx_tuple__21 __pyx_mstate_global->__pyx_tuple__21
-#define __pyx_codeobj__20 __pyx_mstate_global->__pyx_codeobj__20
-#define __pyx_codeobj__22 __pyx_mstate_global->__pyx_codeobj__22
-/* #### Code section: module_code ### */
 
-/* "View.MemoryView":131
+/* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -3802,127 +4041,120 @@
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_array___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_shape = 0;
   Py_ssize_t __pyx_v_itemsize;
   PyObject *__pyx_v_format = 0;
   PyObject *__pyx_v_mode = 0;
   int __pyx_v_allocate_buffer;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_shape,&__pyx_n_s_itemsize,&__pyx_n_s_format,&__pyx_n_s_mode,&__pyx_n_s_allocate_buffer,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_shape,&__pyx_n_s_itemsize,&__pyx_n_s_format,&__pyx_n_s_mode,&__pyx_n_s_allocate_buffer,0};
     PyObject* values[5] = {0,0,0,0,0};
     values[3] = ((PyObject *)__pyx_n_s_c);
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  5: values[4] = __Pyx_Arg_VARARGS(__pyx_args, 4);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_VARARGS(__pyx_args, 3);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_shape)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_itemsize)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 131, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_format)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 131, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_mode);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_allocate_buffer);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 131, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 122, __pyx_L3_error)
       }
     } else {
-      switch (__pyx_nargs) {
-        case  5: values[4] = __Pyx_Arg_VARARGS(__pyx_args, 4);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_VARARGS(__pyx_args, 3);
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
-        values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-        values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 131, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 132, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
     } else {
 
-      /* "View.MemoryView":132
+      /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, __pyx_nargs); __PYX_ERR(1, 131, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 131, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 131, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -3933,542 +4165,636 @@
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer) {
   int __pyx_v_idx;
+  Py_ssize_t __pyx_v_i;
   Py_ssize_t __pyx_v_dim;
+  PyObject **__pyx_v_p;
   char __pyx_v_order;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  char *__pyx_t_8;
+  char *__pyx_t_7;
+  int __pyx_t_8;
   Py_ssize_t __pyx_t_9;
-  Py_UCS4 __pyx_t_10;
+  PyObject *__pyx_t_10 = NULL;
+  Py_ssize_t __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
-  /* "View.MemoryView":137
- *         cdef Py_ssize_t dim
+  /* "View.MemoryView":129
+ *         cdef PyObject **p
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 137, __pyx_L1_error)
+    __PYX_ERR(1, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 137, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
-  /* "View.MemoryView":138
+  /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
-  /* "View.MemoryView":140
+  /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Empty shape tuple for cython.array"
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
-  __pyx_t_2 = (!(__pyx_v_self->ndim != 0));
+  __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":141
+    /* "View.MemoryView":133
  * 
  *         if not self.ndim:
- *             raise ValueError, "Empty shape tuple for cython.array"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Empty_shape_tuple_for_cython_arr, 0, 0);
-    __PYX_ERR(1, 141, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 133, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 133, __pyx_L1_error)
 
-    /* "View.MemoryView":140
+    /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Empty shape tuple for cython.array"
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":143
- *             raise ValueError, "Empty shape tuple for cython.array"
+  /* "View.MemoryView":135
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "itemsize <= 0 for cython.array"
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
-  __pyx_t_2 = (__pyx_v_itemsize <= 0);
+  __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":144
+    /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
- *             raise ValueError, "itemsize <= 0 for cython.array"             # <<<<<<<<<<<<<<
+ *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_itemsize_0_for_cython_array, 0, 0);
-    __PYX_ERR(1, 144, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 136, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 136, __pyx_L1_error)
 
-    /* "View.MemoryView":143
- *             raise ValueError, "Empty shape tuple for cython.array"
+    /* "View.MemoryView":135
+ *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "itemsize <= 0 for cython.array"
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":146
- *             raise ValueError, "itemsize <= 0 for cython.array"
+  /* "View.MemoryView":138
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
-  __pyx_t_3 = (!__pyx_t_2);
-  if (__pyx_t_3) {
+  __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":147
+    /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 147, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
-    __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_7 = 1;
       }
     }
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_n_s_ASCII};
-      __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
-      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 147, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_4);
-    __pyx_t_4 = 0;
+    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 139, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "View.MemoryView":146
- *             raise ValueError, "itemsize <= 0 for cython.array"
+    /* "View.MemoryView":138
+ *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
-  /* "View.MemoryView":148
+  /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_v_format))) __PYX_ERR(1, 148, __pyx_L1_error)
-  __pyx_t_4 = __pyx_v_format;
-  __Pyx_INCREF(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 140, __pyx_L1_error)
+  __pyx_t_3 = __pyx_v_format;
+  __Pyx_INCREF(__pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
-  __pyx_v_self->_format = ((PyObject*)__pyx_t_4);
-  __pyx_t_4 = 0;
+  __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
-  /* "View.MemoryView":149
+  /* "View.MemoryView":141
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(1, 149, __pyx_L1_error)
+    __PYX_ERR(1, 141, __pyx_L1_error)
   }
-  __pyx_t_8 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(1, 149, __pyx_L1_error)
-  __pyx_v_self->format = __pyx_t_8;
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 141, __pyx_L1_error)
+  __pyx_v_self->format = __pyx_t_7;
 
-  /* "View.MemoryView":152
+  /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
  * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
-  /* "View.MemoryView":153
+  /* "View.MemoryView":145
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
  * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
-  /* "View.MemoryView":155
+  /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
- *             raise MemoryError, "unable to allocate shape and strides."
+ *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
-  __pyx_t_3 = (!(__pyx_v_self->_shape != 0));
-  if (unlikely(__pyx_t_3)) {
+  __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
+  if (unlikely(__pyx_t_4)) {
 
-    /* "View.MemoryView":156
+    /* "View.MemoryView":148
  * 
  *         if not self._shape:
- *             raise MemoryError, "unable to allocate shape and strides."             # <<<<<<<<<<<<<<
+ *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_Raise(__pyx_builtin_MemoryError, __pyx_kp_s_unable_to_allocate_shape_and_str, 0, 0);
-    __PYX_ERR(1, 156, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 148, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 148, __pyx_L1_error)
 
-    /* "View.MemoryView":155
+    /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
- *             raise MemoryError, "unable to allocate shape and strides."
+ *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   }
 
-  /* "View.MemoryView":159
+  /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
-  __pyx_t_7 = 0;
-  __pyx_t_4 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_4); __pyx_t_1 = 0;
+  __pyx_t_8 = 0;
+  __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
-    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely((0 < 0))) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 151, __pyx_L1_error)
     #else
-    __pyx_t_5 = PySequence_ITEM(__pyx_t_4, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 159, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
-    __pyx_v_idx = __pyx_t_7;
-    __pyx_t_7 = (__pyx_t_7 + 1);
+    __pyx_v_idx = __pyx_t_8;
+    __pyx_t_8 = (__pyx_t_8 + 1);
 
-    /* "View.MemoryView":160
+    /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
-    __pyx_t_3 = (__pyx_v_dim <= 0);
-    if (unlikely(__pyx_t_3)) {
+    __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
+    if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":161
+      /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."             # <<<<<<<<<<<<<<
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_9 = 0;
-      __pyx_t_10 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Invalid_shape_in_axis);
-      __pyx_t_9 += 22;
-      __Pyx_GIVEREF(__pyx_kp_u_Invalid_shape_in_axis);
-      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Invalid_shape_in_axis);
-      __pyx_t_6 = __Pyx_PyUnicode_From_int(__pyx_v_idx, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
-      __Pyx_GIVEREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_6);
-      __pyx_t_6 = 0;
-      __Pyx_INCREF(__pyx_kp_u_);
-      __pyx_t_9 += 2;
-      __Pyx_GIVEREF(__pyx_kp_u_);
-      PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_);
-      __pyx_t_6 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_GIVEREF(__pyx_t_5);
+      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
       __Pyx_GIVEREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
+      __pyx_t_5 = 0;
       __pyx_t_6 = 0;
-      __Pyx_INCREF(__pyx_kp_u__2);
-      __pyx_t_9 += 1;
-      __Pyx_GIVEREF(__pyx_kp_u__2);
-      PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_kp_u__2);
-      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_5, 5, __pyx_t_9, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 161, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_6, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 161, __pyx_L1_error)
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __PYX_ERR(1, 153, __pyx_L1_error)
 
-      /* "View.MemoryView":160
+      /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
-    /* "View.MemoryView":162
+    /* "View.MemoryView":154
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
  * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
-    /* "View.MemoryView":159
+    /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
- *                 raise ValueError, f"Invalid shape in axis {idx}: {dim}."
+ *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":165
+  /* "View.MemoryView":157
  * 
  *         cdef char order
- *         if mode == 'c':             # <<<<<<<<<<<<<<
- *             order = b'C'
- *             self.mode = u'c'
+ *         if mode == 'fortran':             # <<<<<<<<<<<<<<
+ *             order = b'F'
+ *             self.mode = u'fortran'
  */
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(1, 165, __pyx_L1_error)
-  if (__pyx_t_3) {
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 157, __pyx_L1_error)
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":166
+    /* "View.MemoryView":158
  *         cdef char order
- *         if mode == 'c':
- *             order = b'C'             # <<<<<<<<<<<<<<
- *             self.mode = u'c'
- *         elif mode == 'fortran':
+ *         if mode == 'fortran':
+ *             order = b'F'             # <<<<<<<<<<<<<<
+ *             self.mode = u'fortran'
+ *         elif mode == 'c':
  */
-    __pyx_v_order = 'C';
+    __pyx_v_order = 'F';
 
-    /* "View.MemoryView":167
- *         if mode == 'c':
- *             order = b'C'
- *             self.mode = u'c'             # <<<<<<<<<<<<<<
- *         elif mode == 'fortran':
+    /* "View.MemoryView":159
+ *         if mode == 'fortran':
  *             order = b'F'
+ *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
+ *         elif mode == 'c':
+ *             order = b'C'
  */
-    __Pyx_INCREF(__pyx_n_u_c);
-    __Pyx_GIVEREF(__pyx_n_u_c);
+    __Pyx_INCREF(__pyx_n_u_fortran);
+    __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
-    __pyx_v_self->mode = __pyx_n_u_c;
+    __pyx_v_self->mode = __pyx_n_u_fortran;
 
-    /* "View.MemoryView":165
+    /* "View.MemoryView":157
  * 
  *         cdef char order
- *         if mode == 'c':             # <<<<<<<<<<<<<<
- *             order = b'C'
- *             self.mode = u'c'
+ *         if mode == 'fortran':             # <<<<<<<<<<<<<<
+ *             order = b'F'
+ *             self.mode = u'fortran'
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":168
- *             order = b'C'
- *             self.mode = u'c'
- *         elif mode == 'fortran':             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
+ *         elif mode == 'c':             # <<<<<<<<<<<<<<
+ *             order = b'C'
+ *             self.mode = u'c'
  */
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(1, 168, __pyx_L1_error)
-  if (likely(__pyx_t_3)) {
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 160, __pyx_L1_error)
+  if (likely(__pyx_t_4)) {
 
-    /* "View.MemoryView":169
- *             self.mode = u'c'
- *         elif mode == 'fortran':
- *             order = b'F'             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":161
  *             self.mode = u'fortran'
+ *         elif mode == 'c':
+ *             order = b'C'             # <<<<<<<<<<<<<<
+ *             self.mode = u'c'
  *         else:
  */
-    __pyx_v_order = 'F';
+    __pyx_v_order = 'C';
 
-    /* "View.MemoryView":170
- *         elif mode == 'fortran':
- *             order = b'F'
- *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":162
+ *         elif mode == 'c':
+ *             order = b'C'
+ *             self.mode = u'c'             # <<<<<<<<<<<<<<
  *         else:
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  */
-    __Pyx_INCREF(__pyx_n_u_fortran);
-    __Pyx_GIVEREF(__pyx_n_u_fortran);
+    __Pyx_INCREF(__pyx_n_u_c);
+    __Pyx_GIVEREF(__pyx_n_u_c);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
-    __pyx_v_self->mode = __pyx_n_u_fortran;
+    __pyx_v_self->mode = __pyx_n_u_c;
 
-    /* "View.MemoryView":168
- *             order = b'C'
- *             self.mode = u'c'
- *         elif mode == 'fortran':             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
+ *         elif mode == 'c':             # <<<<<<<<<<<<<<
+ *             order = b'C'
+ *             self.mode = u'c'
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":172
- *             self.mode = u'fortran'
+  /* "View.MemoryView":164
+ *             self.mode = u'c'
  *         else:
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)
+ *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_mode, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_6, 0, 0);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __PYX_ERR(1, 172, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __PYX_ERR(1, 164, __pyx_L1_error)
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":174
- *             raise ValueError, f"Invalid mode, expected 'c' or 'fortran', got {mode}"
+  /* "View.MemoryView":166
+ *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)             # <<<<<<<<<<<<<<
+ *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
+ *                                              itemsize, self.ndim, order)
  * 
- *         self.free_data = allocate_buffer
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
-  /* "View.MemoryView":176
- *         self.len = fill_contig_strides_array(self._shape, self._strides, itemsize, self.ndim, order)
+  /* "View.MemoryView":169
+ *                                              itemsize, self.ndim, order)
  * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
- * 
+ *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
-  /* "View.MemoryView":177
+  /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
- * 
  *         if allocate_buffer:
+ * 
  */
-  __pyx_t_6 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 177, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 177, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_v_self->dtype_is_object = __pyx_t_3;
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+  __pyx_v_self->dtype_is_object = __pyx_t_4;
 
-  /* "View.MemoryView":179
+  /* "View.MemoryView":171
+ *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
- * 
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *             _allocate_buffer(self)
+ * 
  * 
  */
-  if (__pyx_v_allocate_buffer) {
+  __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
+  if (__pyx_t_4) {
 
-    /* "View.MemoryView":180
+    /* "View.MemoryView":174
  * 
- *         if allocate_buffer:
- *             _allocate_buffer(self)             # <<<<<<<<<<<<<<
+ * 
+ *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")
+ */
+    __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
+
+    /* "View.MemoryView":175
+ * 
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ */
+    __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
+    if (unlikely(__pyx_t_4)) {
+
+      /* "View.MemoryView":176
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
+ * 
+ *             if self.dtype_is_object:
+ */
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 176, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __PYX_ERR(1, 176, __pyx_L1_error)
+
+      /* "View.MemoryView":175
+ * 
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ */
+    }
+
+    /* "View.MemoryView":178
+ *                 raise MemoryError("unable to allocate array data.")
+ * 
+ *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ */
+    __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_4) {
+
+      /* "View.MemoryView":179
+ * 
+ *             if self.dtype_is_object:
+ *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None
+ */
+      __pyx_v_p = ((PyObject **)__pyx_v_self->data);
+
+      /* "View.MemoryView":180
+ *             if self.dtype_is_object:
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
+ *                     p[i] = Py_None
+ *                     Py_INCREF(Py_None)
+ */
+      if (unlikely(__pyx_v_itemsize == 0)) {
+        PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
+        __PYX_ERR(1, 180, __pyx_L1_error)
+      }
+      else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
+        PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
+        __PYX_ERR(1, 180, __pyx_L1_error)
+      }
+      __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
+      __pyx_t_9 = __pyx_t_1;
+      for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
+        __pyx_v_i = __pyx_t_11;
+
+        /* "View.MemoryView":181
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None             # <<<<<<<<<<<<<<
+ *                     Py_INCREF(Py_None)
+ * 
+ */
+        (__pyx_v_p[__pyx_v_i]) = Py_None;
+
+        /* "View.MemoryView":182
+ *                 for i in range(self.len / itemsize):
+ *                     p[i] = Py_None
+ *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
-    __pyx_t_7 = __pyx_array_allocate_buffer(__pyx_v_self); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(1, 180, __pyx_L1_error)
+        Py_INCREF(Py_None);
+      }
 
-    /* "View.MemoryView":179
- *         self.dtype_is_object = format == b'O'
+      /* "View.MemoryView":178
+ *                 raise MemoryError("unable to allocate array data.")
  * 
+ *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
+ *                 p = <PyObject **> self.data
+ *                 for i in range(self.len / itemsize):
+ */
+    }
+
+    /* "View.MemoryView":171
+ *         self.free_data = allocate_buffer
+ *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
- *             _allocate_buffer(self)
+ * 
  * 
  */
   }
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_10);
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":182
- *             _allocate_buffer(self)
+/* "View.MemoryView":185
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
+ *         if self.mode == u"c":
  */
 
 /* Python wrapper */
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-CYTHON_UNUSED static int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(((struct __pyx_array_obj *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -4476,316 +4802,278 @@
 }
 
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_v_bufmode;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  char *__pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  int __pyx_t_4;
-  Py_ssize_t *__pyx_t_5;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  char *__pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  Py_ssize_t *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  if (unlikely(__pyx_v_info == NULL)) {
+  if (__pyx_v_info == NULL) {
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":184
+  /* "View.MemoryView":186
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1             # <<<<<<<<<<<<<<
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
   __pyx_v_bufmode = -1;
 
-  /* "View.MemoryView":185
+  /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):             # <<<<<<<<<<<<<<
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if self.mode == u"c":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = ((__pyx_v_flags & ((PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS) | PyBUF_ANY_CONTIGUOUS)) != 0);
-  if (__pyx_t_1) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 187, __pyx_L1_error)
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":186
+    /* "View.MemoryView":188
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
-    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 186, __pyx_L1_error)
-    if (__pyx_t_1) {
-
-      /* "View.MemoryView":187
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- */
-      __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
+    __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-      /* "View.MemoryView":186
+    /* "View.MemoryView":187
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):
- *             if self.mode == u"c":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
+ *         if self.mode == u"c":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
  */
-      goto __pyx_L4;
-    }
+    goto __pyx_L3;
+  }
 
-    /* "View.MemoryView":188
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
+  /* "View.MemoryView":189
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
  */
-    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 188, __pyx_L1_error)
-    if (__pyx_t_1) {
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 189, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_2 != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":189
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
- */
-      __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
-
-      /* "View.MemoryView":188
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
+    /* "View.MemoryView":190
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
+ */
+    __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
+
+    /* "View.MemoryView":189
+ *         if self.mode == u"c":
+ *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
  */
-    }
-    __pyx_L4:;
+  }
+  __pyx_L3:;
 
-    /* "View.MemoryView":190
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):             # <<<<<<<<<<<<<<
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":191
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
-    __pyx_t_1 = (!((__pyx_v_flags & __pyx_v_bufmode) != 0));
-    if (unlikely(__pyx_t_1)) {
+  __pyx_t_1 = ((!((__pyx_v_flags & __pyx_v_bufmode) != 0)) != 0);
+  if (unlikely(__pyx_t_1)) {
 
-      /* "View.MemoryView":191
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":192
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Can_only_create_a_buffer_that_is, 0, 0);
-      __PYX_ERR(1, 191, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 192, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 192, __pyx_L1_error)
 
-      /* "View.MemoryView":190
- *             elif self.mode == u"fortran":
- *                 bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- *             if not (flags & bufmode):             # <<<<<<<<<<<<<<
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+    /* "View.MemoryView":191
+ *         elif self.mode == u"fortran":
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
-    }
-
-    /* "View.MemoryView":185
- *     def __getbuffer__(self, Py_buffer *info, int flags):
- *         cdef int bufmode = -1
- *         if flags & (PyBUF_C_CONTIGUOUS | PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS):             # <<<<<<<<<<<<<<
- *             if self.mode == u"c":
- *                 bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
- */
   }
 
-  /* "View.MemoryView":192
- *             if not (flags & bufmode):
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":193
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data             # <<<<<<<<<<<<<<
  *         info.len = self.len
- * 
+ *         info.ndim = self.ndim
  */
-  __pyx_t_2 = __pyx_v_self->data;
-  __pyx_v_info->buf = __pyx_t_2;
+  __pyx_t_4 = __pyx_v_self->data;
+  __pyx_v_info->buf = __pyx_t_4;
 
-  /* "View.MemoryView":193
- *                 raise ValueError, "Can only create a buffer that is contiguous in memory."
+  /* "View.MemoryView":194
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  *         info.len = self.len             # <<<<<<<<<<<<<<
- * 
- *         if flags & PyBUF_STRIDES:
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape
  */
-  __pyx_t_3 = __pyx_v_self->len;
-  __pyx_v_info->len = __pyx_t_3;
+  __pyx_t_5 = __pyx_v_self->len;
+  __pyx_v_info->len = __pyx_t_5;
 
   /* "View.MemoryView":195
+ *         info.buf = self.data
  *         info.len = self.len
- * 
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
- *             info.ndim = self.ndim
- *             info.shape = self._shape
+ *         info.ndim = self.ndim             # <<<<<<<<<<<<<<
+ *         info.shape = self._shape
+ *         info.strides = self._strides
  */
-  __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
-  if (__pyx_t_1) {
-
-    /* "View.MemoryView":196
- * 
- *         if flags & PyBUF_STRIDES:
- *             info.ndim = self.ndim             # <<<<<<<<<<<<<<
- *             info.shape = self._shape
- *             info.strides = self._strides
- */
-    __pyx_t_4 = __pyx_v_self->ndim;
-    __pyx_v_info->ndim = __pyx_t_4;
-
-    /* "View.MemoryView":197
- *         if flags & PyBUF_STRIDES:
- *             info.ndim = self.ndim
- *             info.shape = self._shape             # <<<<<<<<<<<<<<
- *             info.strides = self._strides
- *         else:
- */
-    __pyx_t_5 = __pyx_v_self->_shape;
-    __pyx_v_info->shape = __pyx_t_5;
-
-    /* "View.MemoryView":198
- *             info.ndim = self.ndim
- *             info.shape = self._shape
- *             info.strides = self._strides             # <<<<<<<<<<<<<<
- *         else:
- *             info.ndim = 1
- */
-    __pyx_t_5 = __pyx_v_self->_strides;
-    __pyx_v_info->strides = __pyx_t_5;
+  __pyx_t_6 = __pyx_v_self->ndim;
+  __pyx_v_info->ndim = __pyx_t_6;
 
-    /* "View.MemoryView":195
+  /* "View.MemoryView":196
  *         info.len = self.len
- * 
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
- *             info.ndim = self.ndim
- *             info.shape = self._shape
- */
-    goto __pyx_L6;
-  }
-
-  /* "View.MemoryView":200
- *             info.strides = self._strides
- *         else:
- *             info.ndim = 1             # <<<<<<<<<<<<<<
- *             info.shape = &self.len if flags & PyBUF_ND else NULL
- *             info.strides = NULL
- */
-  /*else*/ {
-    __pyx_v_info->ndim = 1;
-
-    /* "View.MemoryView":201
- *         else:
- *             info.ndim = 1
- *             info.shape = &self.len if flags & PyBUF_ND else NULL             # <<<<<<<<<<<<<<
- *             info.strides = NULL
- * 
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape             # <<<<<<<<<<<<<<
+ *         info.strides = self._strides
+ *         info.suboffsets = NULL
  */
-    if (((__pyx_v_flags & PyBUF_ND) != 0)) {
-      __pyx_t_5 = (&__pyx_v_self->len);
-    } else {
-      __pyx_t_5 = NULL;
-    }
-    __pyx_v_info->shape = __pyx_t_5;
+  __pyx_t_7 = __pyx_v_self->_shape;
+  __pyx_v_info->shape = __pyx_t_7;
 
-    /* "View.MemoryView":202
- *             info.ndim = 1
- *             info.shape = &self.len if flags & PyBUF_ND else NULL
- *             info.strides = NULL             # <<<<<<<<<<<<<<
- * 
+  /* "View.MemoryView":197
+ *         info.ndim = self.ndim
+ *         info.shape = self._shape
+ *         info.strides = self._strides             # <<<<<<<<<<<<<<
  *         info.suboffsets = NULL
+ *         info.itemsize = self.itemsize
  */
-    __pyx_v_info->strides = NULL;
-  }
-  __pyx_L6:;
+  __pyx_t_7 = __pyx_v_self->_strides;
+  __pyx_v_info->strides = __pyx_t_7;
 
-  /* "View.MemoryView":204
- *             info.strides = NULL
- * 
+  /* "View.MemoryView":198
+ *         info.shape = self._shape
+ *         info.strides = self._strides
  *         info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *         info.itemsize = self.itemsize
  *         info.readonly = 0
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "View.MemoryView":205
- * 
+  /* "View.MemoryView":199
+ *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
+ * 
  */
-  __pyx_t_3 = __pyx_v_self->itemsize;
-  __pyx_v_info->itemsize = __pyx_t_3;
+  __pyx_t_5 = __pyx_v_self->itemsize;
+  __pyx_v_info->itemsize = __pyx_t_5;
 
-  /* "View.MemoryView":206
+  /* "View.MemoryView":200
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
- *         info.obj = self
+ * 
+ *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
-  /* "View.MemoryView":207
- *         info.itemsize = self.itemsize
+  /* "View.MemoryView":202
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL             # <<<<<<<<<<<<<<
- *         info.obj = self
  * 
+ *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
+ *             info.format = self.format
+ *         else:
  */
-  if (((__pyx_v_flags & PyBUF_FORMAT) != 0)) {
-    __pyx_t_2 = __pyx_v_self->format;
-  } else {
-    __pyx_t_2 = NULL;
-  }
-  __pyx_v_info->format = __pyx_t_2;
+  __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":203
+ * 
+ *         if flags & PyBUF_FORMAT:
+ *             info.format = self.format             # <<<<<<<<<<<<<<
+ *         else:
+ *             info.format = NULL
+ */
+    __pyx_t_4 = __pyx_v_self->format;
+    __pyx_v_info->format = __pyx_t_4;
 
-  /* "View.MemoryView":208
+    /* "View.MemoryView":202
  *         info.readonly = 0
- *         info.format = self.format if flags & PyBUF_FORMAT else NULL
+ * 
+ *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
+ *             info.format = self.format
+ *         else:
+ */
+    goto __pyx_L5;
+  }
+
+  /* "View.MemoryView":205
+ *             info.format = self.format
+ *         else:
+ *             info.format = NULL             # <<<<<<<<<<<<<<
+ * 
+ *         info.obj = self
+ */
+  /*else*/ {
+    __pyx_v_info->format = NULL;
+  }
+  __pyx_L5:;
+
+  /* "View.MemoryView":207
+ *             info.format = NULL
+ * 
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
- *     def __dealloc__(array self):
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":182
- *             _allocate_buffer(self)
+  /* "View.MemoryView":185
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
+ *         if self.mode == u"c":
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
@@ -4795,165 +5083,156 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":210
- *         info.obj = self
+/* "View.MemoryView":211
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
 /* Python wrapper */
 static void __pyx_array___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_array___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  int __pyx_t_2;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":211
+  /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  */
-  __pyx_t_1 = (__pyx_v_self->callback_free_data != NULL);
+  __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":212
+    /* "View.MemoryView":213
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
-    /* "View.MemoryView":211
+    /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":213
+  /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:             # <<<<<<<<<<<<<<
+ *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+ *                 refcount_objects_in_slice(self.data, self._shape,
  */
-  if (__pyx_v_self->free_data) {
-  } else {
-    __pyx_t_1 = __pyx_v_self->free_data;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_2 = (__pyx_v_self->data != NULL);
-  __pyx_t_1 = __pyx_t_2;
-  __pyx_L4_bool_binop_done:;
+  __pyx_t_1 = (__pyx_v_self->free_data != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":214
+    /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
- *             free(self.data)
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  */
-    if (__pyx_v_self->dtype_is_object) {
+    __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":215
- *         elif self.free_data and self.data is not NULL:
+      /* "View.MemoryView":216
+ *         elif self.free_data:
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)             # <<<<<<<<<<<<<<
+ *                 refcount_objects_in_slice(self.data, self._shape,             # <<<<<<<<<<<<<<
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)
- *         PyObject_Free(self._shape)
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_self->data, __pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_self->ndim, 0);
 
-      /* "View.MemoryView":214
+      /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:
+ *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
- *             free(self.data)
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  */
     }
 
-    /* "View.MemoryView":216
- *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+    /* "View.MemoryView":218
+ *                 refcount_objects_in_slice(self.data, self._shape,
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
  * 
  */
     free(__pyx_v_self->data);
 
-    /* "View.MemoryView":213
+    /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
- *         elif self.free_data and self.data is not NULL:             # <<<<<<<<<<<<<<
+ *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+ *                 refcount_objects_in_slice(self.data, self._shape,
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":217
- *                 refcount_objects_in_slice(self.data, self._shape, self._strides, self.ndim, inc=False)
+  /* "View.MemoryView":219
+ *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
-  /* "View.MemoryView":210
- *         info.obj = self
+  /* "View.MemoryView":211
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":219
- *         PyObject_Free(self._shape)
+/* "View.MemoryView":222
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def memview(self):
+ *     @property
+ *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_5array_7memview___get__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -4965,48 +5244,48 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":221
+  /* "View.MemoryView":223
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 221, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":219
- *         PyObject_Free(self._shape)
+  /* "View.MemoryView":222
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def memview(self):
+ *     @property
+ *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.memview.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":224
+/* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5018,54 +5297,54 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_memview", 0);
 
-  /* "View.MemoryView":225
+  /* "View.MemoryView":227
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
-  /* "View.MemoryView":226
+  /* "View.MemoryView":228
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":224
+  /* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -5078,26 +5357,25 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":228
+/* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self); /*proto*/
 static Py_ssize_t __pyx_array___len__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5105,50 +5383,49 @@
 }
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":229
+  /* "View.MemoryView":231
  * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
-  /* "View.MemoryView":228
+  /* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":231
+/* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr); /*proto*/
 static PyObject *__pyx_array___getattr__(PyObject *__pyx_v_self, PyObject *__pyx_v_attr) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getattr__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_attr));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5161,32 +5438,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
-  /* "View.MemoryView":232
+  /* "View.MemoryView":234
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 232, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 232, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":231
+  /* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -5198,26 +5475,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":234
+/* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item); /*proto*/
 static PyObject *__pyx_array___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_item));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5230,32 +5506,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":235
+  /* "View.MemoryView":237
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":234
+  /* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -5267,26 +5543,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":237
+/* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
 /* Python wrapper */
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_array___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array_12__setitem__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v_item), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5298,27 +5573,27 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
-  /* "View.MemoryView":238
+  /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely((PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0))) __PYX_ERR(1, 238, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":237
+  /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -5332,577 +5607,349 @@
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_array___reduce_cython__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_array___reduce_cython__(CYTHON_UNUSED struct __pyx_array_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_array_2__setstate_cython__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_array_2__setstate_cython__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_array_2__setstate_cython__(CYTHON_UNUSED struct __pyx_array_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":248
- * 
- * @cname("__pyx_array_allocate_buffer")
- * cdef int _allocate_buffer(array self) except -1:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-
-static int __pyx_array_allocate_buffer(struct __pyx_array_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_v_i;
-  PyObject **__pyx_v_p;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  Py_ssize_t __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_allocate_buffer", 0);
-
-  /* "View.MemoryView":254
- *     cdef PyObject **p
- * 
- *     self.free_data = True             # <<<<<<<<<<<<<<
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:
- */
-  __pyx_v_self->free_data = 1;
-
-  /* "View.MemoryView":255
- * 
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
- *     if not self.data:
- *         raise MemoryError, "unable to allocate array data."
- */
-  __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
-
-  /* "View.MemoryView":256
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:             # <<<<<<<<<<<<<<
- *         raise MemoryError, "unable to allocate array data."
- * 
- */
-  __pyx_t_1 = (!(__pyx_v_self->data != 0));
-  if (unlikely(__pyx_t_1)) {
-
-    /* "View.MemoryView":257
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:
- *         raise MemoryError, "unable to allocate array data."             # <<<<<<<<<<<<<<
- * 
- *     if self.dtype_is_object:
- */
-    __Pyx_Raise(__pyx_builtin_MemoryError, __pyx_kp_s_unable_to_allocate_array_data, 0, 0);
-    __PYX_ERR(1, 257, __pyx_L1_error)
-
-    /* "View.MemoryView":256
- *     self.free_data = True
- *     self.data = <char *>malloc(self.len)
- *     if not self.data:             # <<<<<<<<<<<<<<
- *         raise MemoryError, "unable to allocate array data."
- * 
- */
-  }
-
-  /* "View.MemoryView":259
- *         raise MemoryError, "unable to allocate array data."
- * 
- *     if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- */
-  if (__pyx_v_self->dtype_is_object) {
-
-    /* "View.MemoryView":260
- * 
- *     if self.dtype_is_object:
- *         p = <PyObject **> self.data             # <<<<<<<<<<<<<<
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None
- */
-    __pyx_v_p = ((PyObject **)__pyx_v_self->data);
-
-    /* "View.MemoryView":261
- *     if self.dtype_is_object:
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):             # <<<<<<<<<<<<<<
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)
- */
-    if (unlikely(__pyx_v_self->itemsize == 0)) {
-      PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 261, __pyx_L1_error)
-    }
-    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_self->itemsize == (Py_ssize_t)-1)  && unlikely(__Pyx_UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
-      PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 261, __pyx_L1_error)
-    }
-    __pyx_t_2 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_self->itemsize);
-    __pyx_t_3 = __pyx_t_2;
-    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-      __pyx_v_i = __pyx_t_4;
-
-      /* "View.MemoryView":262
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None             # <<<<<<<<<<<<<<
- *             Py_INCREF(Py_None)
- *     return 0
- */
-      (__pyx_v_p[__pyx_v_i]) = Py_None;
-
-      /* "View.MemoryView":263
- *         for i in range(self.len // self.itemsize):
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
- *     return 0
- * 
- */
-      Py_INCREF(Py_None);
-    }
-
-    /* "View.MemoryView":259
- *         raise MemoryError, "unable to allocate array data."
- * 
- *     if self.dtype_is_object:             # <<<<<<<<<<<<<<
- *         p = <PyObject **> self.data
- *         for i in range(self.len // self.itemsize):
- */
-  }
-
-  /* "View.MemoryView":264
- *             p[i] = Py_None
- *             Py_INCREF(Py_None)
- *     return 0             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = 0;
-  goto __pyx_L0;
-
-  /* "View.MemoryView":248
- * 
- * @cname("__pyx_array_allocate_buffer")
- * cdef int _allocate_buffer(array self) except -1:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._allocate_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "View.MemoryView":268
+/* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):             # <<<<<<<<<<<<<<
+ * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
+ *                           char *mode, char *buf):
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
  */
 
-static struct __pyx_array_obj *__pyx_array_new(PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, char *__pyx_v_format, char *__pyx_v_c_mode, char *__pyx_v_buf) {
+static struct __pyx_array_obj *__pyx_array_new(PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, char *__pyx_v_format, char *__pyx_v_mode, char *__pyx_v_buf) {
   struct __pyx_array_obj *__pyx_v_result = 0;
-  PyObject *__pyx_v_mode = 0;
   struct __pyx_array_obj *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
-  /* "View.MemoryView":270
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):
+  /* "View.MemoryView":248
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.             # <<<<<<<<<<<<<<
- * 
- *     if buf is NULL:
- */
-  if (((__pyx_v_c_mode[0]) == 'f')) {
-    __Pyx_INCREF(__pyx_n_s_fortran);
-    __pyx_t_1 = __pyx_n_s_fortran;
-  } else {
-    __Pyx_INCREF(__pyx_n_s_c);
-    __pyx_t_1 = __pyx_n_s_c;
-  }
-  __pyx_v_mode = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "View.MemoryView":272
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
  * 
- *     if buf is NULL:             # <<<<<<<<<<<<<<
- *         result = array.__new__(array, shape, itemsize, format, mode)
+ *     if buf == NULL:             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
-  __pyx_t_2 = (__pyx_v_buf == NULL);
-  if (__pyx_t_2) {
+  __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":273
+    /* "View.MemoryView":249
  * 
- *     if buf is NULL:
- *         result = array.__new__(array, shape, itemsize, format, mode)             # <<<<<<<<<<<<<<
+ *     if buf == NULL:
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 273, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 273, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 273, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_shape);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
+    __Pyx_GIVEREF(__pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
-    __Pyx_INCREF(__pyx_v_mode);
-    __Pyx_GIVEREF(__pyx_v_mode);
-    PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_v_mode);
-    __pyx_t_1 = 0;
-    __pyx_t_3 = 0;
-    __pyx_t_3 = ((PyObject *)__pyx_tp_new_array(((PyTypeObject *)__pyx_array_type), __pyx_t_4, NULL)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 273, __pyx_L1_error)
-    __Pyx_GOTREF((PyObject *)__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
+    __pyx_t_2 = 0;
     __pyx_t_3 = 0;
+    __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
+    __pyx_t_4 = 0;
 
-    /* "View.MemoryView":272
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
+    /* "View.MemoryView":248
+ *     cdef array result
  * 
- *     if buf is NULL:             # <<<<<<<<<<<<<<
- *         result = array.__new__(array, shape, itemsize, format, mode)
+ *     if buf == NULL:             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":275
- *         result = array.__new__(array, shape, itemsize, format, mode)
+  /* "View.MemoryView":251
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)             # <<<<<<<<<<<<<<
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
+ *                        allocate_buffer=False)
  *         result.data = buf
- * 
  */
   /*else*/ {
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 275, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_shape);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_4);
-    __Pyx_INCREF(__pyx_v_mode);
-    __Pyx_GIVEREF(__pyx_v_mode);
-    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_v_mode);
-    __pyx_t_3 = 0;
+    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_3);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 275, __pyx_L1_error)
-    __pyx_t_3 = ((PyObject *)__pyx_tp_new_array(((PyTypeObject *)__pyx_array_type), __pyx_t_1, __pyx_t_4)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 275, __pyx_L1_error)
-    __Pyx_GOTREF((PyObject *)__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_3);
+    __pyx_t_5 = 0;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":276
+    /* "View.MemoryView":252
+ *     else:
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
+ *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
+ *         result.data = buf
+ * 
+ */
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 252, __pyx_L1_error)
+
+    /* "View.MemoryView":251
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
- *         result = array.__new__(array, shape, itemsize, format, mode, allocate_buffer=False)
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
+ *                        allocate_buffer=False)
+ *         result.data = buf
+ */
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
+    __pyx_t_5 = 0;
+
+    /* "View.MemoryView":253
+ *         result = array(shape, itemsize, format, mode.decode('ASCII'),
+ *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":278
+  /* "View.MemoryView":255
  *         result.data = buf
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_XDECREF((PyObject *)__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":268
+  /* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
- * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format, char *c_mode, char *buf):             # <<<<<<<<<<<<<<
+ * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
+ *                           char *mode, char *buf):
  *     cdef array result
- *     cdef str mode = "fortran" if c_mode[0] == b'f' else "c"  # this often comes from a constant C string.
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.array_cwrapper", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
-  __Pyx_XDECREF(__pyx_v_mode);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":304
+/* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
 /* Python wrapper */
 static int __pyx_MemviewEnum___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_MemviewEnum___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_name = 0;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_name,0};
     PyObject* values[1] = {0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_name)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 304, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 304, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 281, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 1)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 304, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -5912,53 +5959,52 @@
 }
 
 static int __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v_name) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "View.MemoryView":305
+  /* "View.MemoryView":282
  *     cdef object name
  *     def __init__(self, name):
  *         self.name = name             # <<<<<<<<<<<<<<
  *     def __repr__(self):
  *         return self.name
  */
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   __Pyx_GOTREF(__pyx_v_self->name);
   __Pyx_DECREF(__pyx_v_self->name);
   __pyx_v_self->name = __pyx_v_name;
 
-  /* "View.MemoryView":304
+  /* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":306
+/* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_MemviewEnum___repr__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -5966,27 +6012,27 @@
 }
 
 static PyObject *__pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":307
+  /* "View.MemoryView":284
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
-  /* "View.MemoryView":306
+  /* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -6000,38 +6046,19 @@
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_MemviewEnum___reduce_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -6039,16 +6066,17 @@
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":5
  *     cdef object _dict
@@ -6081,33 +6109,34 @@
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
   __pyx_t_2 = (__pyx_v__dict != Py_None);
-  if (__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
     __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v__dict);
-    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_3));
-    __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_4));
+    __pyx_t_4 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
  *         use_setstate = self.name is not None
@@ -6125,203 +6154,147 @@
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
  *         use_setstate = self.name is not None             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  */
   /*else*/ {
-    __pyx_t_2 = (__pyx_v_self->name != Py_None);
-    __pyx_v_use_setstate = __pyx_t_2;
+    __pyx_t_3 = (__pyx_v_self->name != Py_None);
+    __pyx_v_use_setstate = __pyx_t_3;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
-  if (__pyx_v_use_setstate) {
+  __pyx_t_3 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":13
  *         use_setstate = self.name is not None
  *     if use_setstate:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_136983863);
-    __Pyx_GIVEREF(__pyx_int_136983863);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_136983863);
+    __Pyx_INCREF(__pyx_int_184977713);
+    __Pyx_GIVEREF(__pyx_int_184977713);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_1, 2, Py_None);
-    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_state);
-    __pyx_t_3 = 0;
-    __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_4;
+    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
     __pyx_t_4 = 0;
+    __pyx_t_1 = 0;
+    __pyx_r = __pyx_t_5;
+    __pyx_t_5 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, None), state
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_136983863);
-    __Pyx_GIVEREF(__pyx_int_136983863);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_136983863);
+    __Pyx_INCREF(__pyx_int_184977713);
+    __Pyx_GIVEREF(__pyx_int_184977713);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
     PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
-    __pyx_t_4 = 0;
+    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
+    __pyx_t_5 = 0;
     __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_4;
+    __pyx_t_4 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.Enum.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 16, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 16, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 16, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.Enum.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_MemviewEnum_2__setstate_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_MemviewEnum_2__setstate_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_MemviewEnum_2__setstate_cython__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
@@ -6330,26 +6303,26 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None) || __Pyx_RaiseUnexpectedTypeError("tuple", __pyx_v___pyx_state))) __PYX_ERR(1, 17, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Enum, (type(self), 0x82a3537, state)
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
@@ -6359,97 +6332,175 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":349
+/* "View.MemoryView":298
+ * 
+ * @cname('__pyx_align_pointer')
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
+ */
+
+static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
+  Py_intptr_t __pyx_v_aligned_p;
+  size_t __pyx_v_offset;
+  void *__pyx_r;
+  int __pyx_t_1;
+
+  /* "View.MemoryView":300
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
+ *     cdef size_t offset
+ * 
+ */
+  __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
+
+  /* "View.MemoryView":304
+ * 
+ *     with cython.cdivision(True):
+ *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
+ * 
+ *     if offset > 0:
+ */
+  __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
+
+  /* "View.MemoryView":306
+ *         offset = aligned_p % alignment
+ * 
+ *     if offset > 0:             # <<<<<<<<<<<<<<
+ *         aligned_p += alignment - offset
+ * 
+ */
+  __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":307
+ * 
+ *     if offset > 0:
+ *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
+ * 
+ *     return <void *> aligned_p
+ */
+    __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
+
+    /* "View.MemoryView":306
+ *         offset = aligned_p % alignment
+ * 
+ *     if offset > 0:             # <<<<<<<<<<<<<<
+ *         aligned_p += alignment - offset
+ * 
+ */
+  }
+
+  /* "View.MemoryView":309
+ *         aligned_p += alignment - offset
+ * 
+ *     return <void *> aligned_p             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = ((void *)__pyx_v_aligned_p);
+  goto __pyx_L0;
+
+  /* "View.MemoryView":298
+ * 
+ * @cname('__pyx_align_pointer')
+ * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
+ *     "Align pointer memory on a given boundary"
+ *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_memoryview___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_obj = 0;
   int __pyx_v_flags;
   int __pyx_v_dtype_is_object;
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_flags,&__pyx_n_s_dtype_is_object,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_flags,&__pyx_n_s_dtype_is_object,0};
     PyObject* values[3] = {0,0,0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_obj)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flags)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 349, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dtype_is_object);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 349, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 345, __pyx_L3_error)
       }
     } else {
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-        values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 349, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, __pyx_nargs); __PYX_ERR(1, 349, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -6460,313 +6511,279 @@
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj, int __pyx_v_flags, int __pyx_v_dtype_is_object) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  Py_intptr_t __pyx_t_4;
-  size_t __pyx_t_5;
+  int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "View.MemoryView":350
+  /* "View.MemoryView":346
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
   __Pyx_GOTREF(__pyx_v_self->obj);
   __Pyx_DECREF(__pyx_v_self->obj);
   __pyx_v_self->obj = __pyx_v_obj;
 
-  /* "View.MemoryView":351
+  /* "View.MemoryView":347
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj
  *         self.flags = flags             # <<<<<<<<<<<<<<
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  */
   __pyx_v_self->flags = __pyx_v_flags;
 
-  /* "View.MemoryView":352
+  /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   __pyx_t_2 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)__pyx_memoryview_type));
-  if (!__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (!__pyx_t_3) {
   } else {
-    __pyx_t_1 = __pyx_t_2;
+    __pyx_t_1 = __pyx_t_3;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_2 = (__pyx_v_obj != Py_None);
+  __pyx_t_3 = (__pyx_v_obj != Py_None);
+  __pyx_t_2 = (__pyx_t_3 != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":353
+    /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_3 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 353, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 349, __pyx_L1_error)
 
-    /* "View.MemoryView":354
+    /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
-    __pyx_t_1 = (((PyObject *)__pyx_v_self->view.obj) == NULL);
+    __pyx_t_1 = ((((PyObject *)__pyx_v_self->view.obj) == NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":355
+      /* "View.MemoryView":351
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
  * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
-      /* "View.MemoryView":356
+      /* "View.MemoryView":352
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
+ *         global __pyx_memoryview_thread_locks_used
  */
       Py_INCREF(Py_None);
 
-      /* "View.MemoryView":354
+      /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     }
 
-    /* "View.MemoryView":352
+    /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
-  /* "View.MemoryView":358
- *                 Py_INCREF(Py_None)
+  /* "View.MemoryView":355
  * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-  __pyx_t_1 = (!__PYX_CYTHON_ATOMICS_ENABLED());
+  __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":360
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
- */
-    __pyx_t_1 = (__pyx_memoryview_thread_locks_used < 8);
-    if (__pyx_t_1) {
-
-      /* "View.MemoryView":361
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:
- */
-      __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
-
-      /* "View.MemoryView":362
- *             if __pyx_memoryview_thread_locks_used < 8:
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
- *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- */
-      __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
-
-      /* "View.MemoryView":360
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:             # <<<<<<<<<<<<<<
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+    /* "View.MemoryView":356
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ */
+    __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+
+    /* "View.MemoryView":357
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  */
-    }
+    __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
 
-    /* "View.MemoryView":363
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
- *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+    /* "View.MemoryView":355
+ * 
+ *         global __pyx_memoryview_thread_locks_used
+ *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
  */
-    __pyx_t_1 = (__pyx_v_self->lock == NULL);
-    if (__pyx_t_1) {
+  }
 
-      /* "View.MemoryView":364
- *                 __pyx_memoryview_thread_locks_used += 1
+  /* "View.MemoryView":358
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
- *                 if self.lock is NULL:
- *                     raise MemoryError
  */
-      __pyx_v_self->lock = PyThread_allocate_lock();
+  __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+  if (__pyx_t_1) {
 
-      /* "View.MemoryView":365
+    /* "View.MemoryView":359
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
- * 
+ *                 raise MemoryError
  */
-      __pyx_t_1 = (__pyx_v_self->lock == NULL);
-      if (unlikely(__pyx_t_1)) {
+    __pyx_v_self->lock = PyThread_allocate_lock();
 
-        /* "View.MemoryView":366
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
- *                     raise MemoryError             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":360
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *                 raise MemoryError
  * 
- *         if flags & PyBUF_FORMAT:
  */
-        PyErr_NoMemory(); __PYX_ERR(1, 366, __pyx_L1_error)
+    __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
+    if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":365
+      /* "View.MemoryView":361
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                     raise MemoryError
+ *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
+ *         if flags & PyBUF_FORMAT:
  */
-      }
+      PyErr_NoMemory(); __PYX_ERR(1, 361, __pyx_L1_error)
 
-      /* "View.MemoryView":363
- *                 self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
- *                 __pyx_memoryview_thread_locks_used += 1
+      /* "View.MemoryView":360
+ *         if self.lock is NULL:
+ *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
- *                 self.lock = PyThread_allocate_lock()
- *                 if self.lock is NULL:
+ *                 raise MemoryError
+ * 
  */
     }
 
     /* "View.MemoryView":358
- *                 Py_INCREF(Py_None)
- * 
- *         if not __PYX_CYTHON_ATOMICS_ENABLED():             # <<<<<<<<<<<<<<
- *             global __pyx_memoryview_thread_locks_used
- *             if __pyx_memoryview_thread_locks_used < 8:
+ *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
+ *             __pyx_memoryview_thread_locks_used += 1
+ *         if self.lock is NULL:             # <<<<<<<<<<<<<<
+ *             self.lock = PyThread_allocate_lock()
+ *             if self.lock is NULL:
  */
   }
 
-  /* "View.MemoryView":368
- *                     raise MemoryError
+  /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":369
+    /* "View.MemoryView":364
  * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
-    __pyx_t_2 = ((__pyx_v_self->view.format[0]) == 'O');
+    __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L12_bool_binop_done;
+      goto __pyx_L11_bool_binop_done;
     }
-    __pyx_t_2 = ((__pyx_v_self->view.format[1]) == '\x00');
+    __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
-    __pyx_L12_bool_binop_done:;
+    __pyx_L11_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
-    /* "View.MemoryView":368
- *                     raise MemoryError
+    /* "View.MemoryView":363
+ *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
-    goto __pyx_L11;
+    goto __pyx_L10;
   }
 
-  /* "View.MemoryView":371
+  /* "View.MemoryView":366
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
  * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
-  __pyx_L11:;
+  __pyx_L10:;
 
-  /* "View.MemoryView":373
+  /* "View.MemoryView":368
  *             self.dtype_is_object = dtype_is_object
  * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0             # <<<<<<<<<<<<<<
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
+ *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
- * 
  */
-  #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_4 = ((Py_intptr_t)((void *)(&__pyx_v_self->acquisition_count)));
-    __pyx_t_5 = (sizeof(__pyx_atomic_int_type));
-    if (unlikely(__pyx_t_5 == 0)) {
-      PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 373, __pyx_L1_error)
-    }
-    __pyx_t_1 = ((__pyx_t_4 % __pyx_t_5) == 0);
-    if (unlikely(!__pyx_t_1)) {
-      __Pyx_Raise(__pyx_builtin_AssertionError, 0, 0, 0);
-      __PYX_ERR(1, 373, __pyx_L1_error)
-    }
-  }
-  #else
-  if ((1)); else __PYX_ERR(1, 373, __pyx_L1_error)
-  #endif
+  __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
-  /* "View.MemoryView":374
- * 
- *         assert <Py_intptr_t><void*>(&self.acquisition_count) % sizeof(__pyx_atomic_int_type) == 0
+  /* "View.MemoryView":370
+ *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
+ *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
-  /* "View.MemoryView":349
+  /* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -6777,26 +6794,25 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":376
+/* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
 /* Python wrapper */
 static void __pyx_memoryview___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_memoryview___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_2__dealloc__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
@@ -6804,218 +6820,220 @@
 static void __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_2__dealloc__(struct __pyx_memoryview_obj *__pyx_v_self) {
   int __pyx_v_i;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
-  PyThread_type_lock __pyx_t_5;
+  int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
+  PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":377
+  /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":378
+    /* "View.MemoryView":374
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
-    /* "View.MemoryView":377
+    /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":379
+  /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
-  __pyx_t_1 = (((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = ((((Py_buffer *)(&__pyx_v_self->view))->obj == Py_None) != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":381
+    /* "View.MemoryView":377
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL             # <<<<<<<<<<<<<<
  *             Py_DECREF(Py_None)
  * 
  */
     ((Py_buffer *)(&__pyx_v_self->view))->obj = NULL;
 
-    /* "View.MemoryView":382
+    /* "View.MemoryView":378
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  *             Py_DECREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *         cdef int i
  */
     Py_DECREF(Py_None);
 
-    /* "View.MemoryView":379
+    /* "View.MemoryView":375
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  *         elif (<__pyx_buffer *> &self.view).obj == Py_None:             # <<<<<<<<<<<<<<
  * 
  *             (<__pyx_buffer *> &self.view).obj = NULL
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":386
+  /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
-  __pyx_t_1 = (__pyx_v_self->lock != NULL);
-  if (__pyx_t_1) {
+  __pyx_t_2 = ((__pyx_v_self->lock != NULL) != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":387
+    /* "View.MemoryView":383
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):             # <<<<<<<<<<<<<<
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  */
-    __pyx_t_2 = __pyx_memoryview_thread_locks_used;
-    __pyx_t_3 = __pyx_t_2;
-    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-      __pyx_v_i = __pyx_t_4;
+    __pyx_t_3 = __pyx_memoryview_thread_locks_used;
+    __pyx_t_4 = __pyx_t_3;
+    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
+      __pyx_v_i = __pyx_t_5;
 
-      /* "View.MemoryView":388
+      /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
-      __pyx_t_1 = ((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock);
-      if (__pyx_t_1) {
+      __pyx_t_2 = (((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock) != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":389
+        /* "View.MemoryView":385
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1             # <<<<<<<<<<<<<<
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  */
         __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used - 1);
 
-        /* "View.MemoryView":390
+        /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
-        __pyx_t_1 = (__pyx_v_i != __pyx_memoryview_thread_locks_used);
-        if (__pyx_t_1) {
+        __pyx_t_2 = ((__pyx_v_i != __pyx_memoryview_thread_locks_used) != 0);
+        if (__pyx_t_2) {
 
-          /* "View.MemoryView":392
+          /* "View.MemoryView":388
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])             # <<<<<<<<<<<<<<
  *                     break
  *             else:
  */
-          __pyx_t_5 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
-          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
+          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+          __pyx_t_7 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
 
-          /* "View.MemoryView":391
+          /* "View.MemoryView":387
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (             # <<<<<<<<<<<<<<
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break
  */
-          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_5;
-          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_7;
 
-          /* "View.MemoryView":390
+          /* "View.MemoryView":386
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         }
 
-        /* "View.MemoryView":393
+        /* "View.MemoryView":389
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break             # <<<<<<<<<<<<<<
  *             else:
  *                 PyThread_free_lock(self.lock)
  */
         goto __pyx_L6_break;
 
-        /* "View.MemoryView":388
+        /* "View.MemoryView":384
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       }
     }
     /*else*/ {
 
-      /* "View.MemoryView":395
+      /* "View.MemoryView":391
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
-    /* "View.MemoryView":386
+    /* "View.MemoryView":382
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
-  /* "View.MemoryView":376
+  /* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":397
+/* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7033,107 +7051,107 @@
   Py_ssize_t __pyx_t_6;
   char *__pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
-  /* "View.MemoryView":399
+  /* "View.MemoryView":395
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
  * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
-  /* "View.MemoryView":401
+  /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 401, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 397, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 401, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 397, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely((0 < 0))) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely((0 < 0))) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 401, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 401, __pyx_L1_error)
+          else __PYX_ERR(1, 397, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
-    /* "View.MemoryView":402
+    /* "View.MemoryView":398
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 402, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 402, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 398, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 398, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
-    /* "View.MemoryView":401
+    /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":404
+  /* "View.MemoryView":400
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  *         return itemp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":397
+  /* "View.MemoryView":393
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -7145,26 +7163,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":407
+/* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index); /*proto*/
 static PyObject *__pyx_memoryview___getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_4__getitem__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v_index));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -7174,185 +7191,186 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_4__getitem__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index) {
   PyObject *__pyx_v_have_slices = NULL;
   PyObject *__pyx_v_indices = NULL;
   char *__pyx_v_itemp;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  char *__pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
+  char *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":408
+  /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":409
+    /* "View.MemoryView":405
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF((PyObject *)__pyx_v_self);
+    __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
-    /* "View.MemoryView":408
+    /* "View.MemoryView":404
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   }
 
-  /* "View.MemoryView":411
+  /* "View.MemoryView":407
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 411, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (likely(__pyx_t_2 != Py_None)) {
-    PyObject* sequence = __pyx_t_2;
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 407, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (likely(__pyx_t_3 != Py_None)) {
+    PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 411, __pyx_L1_error)
+      __PYX_ERR(1, 407, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
-    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
-    __Pyx_INCREF(__pyx_t_3);
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
+    __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 411, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 407, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 411, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 407, __pyx_L1_error)
   }
-  __pyx_v_have_slices = __pyx_t_3;
-  __pyx_t_3 = 0;
-  __pyx_v_indices = __pyx_t_4;
+  __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
+  __pyx_v_indices = __pyx_t_5;
+  __pyx_t_5 = 0;
 
-  /* "View.MemoryView":414
+  /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 414, __pyx_L1_error)
-  if (__pyx_t_1) {
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 410, __pyx_L1_error)
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":415
+    /* "View.MemoryView":411
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 415, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":414
+    /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
-  /* "View.MemoryView":417
+  /* "View.MemoryView":413
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_5 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_5 == ((char *)NULL))) __PYX_ERR(1, 417, __pyx_L1_error)
-    __pyx_v_itemp = __pyx_t_5;
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 413, __pyx_L1_error)
+    __pyx_v_itemp = __pyx_t_6;
 
-    /* "View.MemoryView":418
+    /* "View.MemoryView":414
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 414, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":407
+  /* "View.MemoryView":403
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_indices);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":420
+/* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_6__setitem__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v_index), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -7360,213 +7378,217 @@
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_6__setitem__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
   PyObject *__pyx_v_have_slices = NULL;
   PyObject *__pyx_v_obj = NULL;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
-  /* "View.MemoryView":421
+  /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
-  if (unlikely(__pyx_v_self->view.readonly)) {
+  __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
+  if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":422
+    /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"             # <<<<<<<<<<<<<<
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_Cannot_assign_to_read_only_memor, 0, 0);
-    __PYX_ERR(1, 422, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 418, __pyx_L1_error)
 
-    /* "View.MemoryView":421
+    /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":424
- *             raise TypeError, "Cannot assign to read-only memoryview"
+  /* "View.MemoryView":420
+ *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_1 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 424, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (likely(__pyx_t_1 != Py_None)) {
-    PyObject* sequence = __pyx_t_1;
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (likely(__pyx_t_2 != Py_None)) {
+    PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 424, __pyx_L1_error)
+      __PYX_ERR(1, 420, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    __Pyx_INCREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 424, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 424, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     #endif
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 424, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 420, __pyx_L1_error)
   }
-  __pyx_v_have_slices = __pyx_t_2;
-  __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_3);
+  __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
+  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "View.MemoryView":426
+  /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely((__pyx_t_4 < 0))) __PYX_ERR(1, 426, __pyx_L1_error)
-  if (__pyx_t_4) {
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 422, __pyx_L1_error)
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":427
+    /* "View.MemoryView":423
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 427, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_v_obj = __pyx_t_1;
-    __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 423, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_obj = __pyx_t_2;
+    __pyx_t_2 = 0;
 
-    /* "View.MemoryView":428
+    /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely((__pyx_t_4 < 0))) __PYX_ERR(1, 428, __pyx_L1_error)
-    if (__pyx_t_4) {
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":429
+      /* "View.MemoryView":425
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 429, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_1, __pyx_v_obj); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 429, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "View.MemoryView":428
+      /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":431
+    /* "View.MemoryView":427
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_3 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 431, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 431, __pyx_L1_error)
-      __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_3), __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 431, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":426
+    /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
     goto __pyx_L4;
   }
 
-  /* "View.MemoryView":433
+  /* "View.MemoryView":429
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 433, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
-  /* "View.MemoryView":420
+  /* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
  *         if self.view.readonly:
- *             raise TypeError, "Cannot assign to read-only memoryview"
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":435
+/* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7584,26 +7606,26 @@
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
-  /* "View.MemoryView":436
+  /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
-  __pyx_t_2 = (!__pyx_t_1);
+  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":437
+    /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
     {
@@ -7611,59 +7633,59 @@
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_3);
       __Pyx_XGOTREF(__pyx_t_4);
       __Pyx_XGOTREF(__pyx_t_5);
       /*try:*/ {
 
-        /* "View.MemoryView":438
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":439
+        /* "View.MemoryView":435
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 439, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 435, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
-        /* "View.MemoryView":438
+        /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 438, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
-        /* "View.MemoryView":437
+        /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       }
@@ -7672,89 +7694,89 @@
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       goto __pyx_L9_try_end;
       __pyx_L4_error:;
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-      /* "View.MemoryView":440
+      /* "View.MemoryView":436
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 440, __pyx_L6_except_error)
-        __Pyx_XGOTREF(__pyx_t_7);
-        __Pyx_XGOTREF(__pyx_t_8);
-        __Pyx_XGOTREF(__pyx_t_6);
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 436, __pyx_L6_except_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __Pyx_GOTREF(__pyx_t_8);
+        __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":441
+        /* "View.MemoryView":437
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
  * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_r = Py_None; __Pyx_INCREF(Py_None);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         goto __pyx_L7_except_return;
       }
       goto __pyx_L6_except_error;
+      __pyx_L6_except_error:;
 
-      /* "View.MemoryView":437
+      /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
-      __pyx_L6_except_error:;
       __Pyx_XGIVEREF(__pyx_t_3);
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L1_error;
       __pyx_L7_except_return:;
       __Pyx_XGIVEREF(__pyx_t_3);
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
-    /* "View.MemoryView":436
+    /* "View.MemoryView":432
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
-  /* "View.MemoryView":443
+  /* "View.MemoryView":439
  *                 return None
  * 
  *         return obj             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":435
+  /* "View.MemoryView":431
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -7768,101 +7790,106 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":445
+/* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src) {
   __Pyx_memviewslice __pyx_v_dst_slice;
   __Pyx_memviewslice __pyx_v_src_slice;
-  __Pyx_memviewslice __pyx_v_msrc;
-  __Pyx_memviewslice __pyx_v_mdst;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_memviewslice *__pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_t_3;
+  __Pyx_memviewslice *__pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
-  /* "View.MemoryView":448
- *         cdef __Pyx_memviewslice dst_slice
+  /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
- *         cdef __Pyx_memviewslice msrc = get_slice_from_memview(src, &src_slice)[0]             # <<<<<<<<<<<<<<
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]
  * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_v_msrc = (__pyx_t_1[0]);
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 445, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 445, __pyx_L1_error)
 
-  /* "View.MemoryView":449
- *         cdef __Pyx_memviewslice src_slice
- *         cdef __Pyx_memviewslice msrc = get_slice_from_memview(src, &src_slice)[0]
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":446
+ * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 449, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 449, __pyx_L1_error)
-  __pyx_v_mdst = (__pyx_t_1[0]);
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 446, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 446, __pyx_L1_error)
 
-  /* "View.MemoryView":451
- *         cdef __Pyx_memviewslice mdst = get_slice_from_memview(dst, &dst_slice)[0]
- * 
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":447
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 451, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_5 = __pyx_memoryview_copy_contents(__pyx_v_msrc, __pyx_v_mdst, __pyx_t_3, __pyx_t_4, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 451, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":445
+ *         cdef __Pyx_memviewslice src_slice
+ * 
+ *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
+ *                                  get_slice_from_memview(dst, &dst_slice)[0],
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
+ */
+  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 445, __pyx_L1_error)
+
+  /* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.setitem_slice_assignment", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":453
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
+/* "View.MemoryView":449
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
 static PyObject *__pyx_memoryview_setitem_slice_assign_scalar(struct __pyx_memoryview_obj *__pyx_v_self, struct __pyx_memoryview_obj *__pyx_v_dst, PyObject *__pyx_v_value) {
@@ -7886,201 +7913,204 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
-  /* "View.MemoryView":455
+  /* "View.MemoryView":451
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
  * 
  */
   __pyx_v_tmp = NULL;
 
-  /* "View.MemoryView":460
+  /* "View.MemoryView":456
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 460, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 456, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
-  /* "View.MemoryView":462
+  /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
-  __pyx_t_2 = (((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array)));
+  __pyx_t_2 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":463
+    /* "View.MemoryView":459
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
-    /* "View.MemoryView":464
+    /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
-    __pyx_t_2 = (__pyx_v_tmp == NULL);
+    __pyx_t_2 = ((__pyx_v_tmp == NULL) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":465
+      /* "View.MemoryView":461
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 465, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(1, 461, __pyx_L1_error)
 
-      /* "View.MemoryView":464
+      /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     }
 
-    /* "View.MemoryView":466
+    /* "View.MemoryView":462
  *             if tmp == NULL:
  *                 raise MemoryError
  *             item = tmp             # <<<<<<<<<<<<<<
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
-    /* "View.MemoryView":462
+    /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":468
+  /* "View.MemoryView":464
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
  * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":470
+  /* "View.MemoryView":466
  *             item = <void *> array
  * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
-    /* "View.MemoryView":471
+    /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
-    if (__pyx_v_self->dtype_is_object) {
+    __pyx_t_2 = (__pyx_v_self->dtype_is_object != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":472
+      /* "View.MemoryView":468
  *         try:
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
-      /* "View.MemoryView":471
+      /* "View.MemoryView":467
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
-    /* "View.MemoryView":474
+    /* "View.MemoryView":470
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 474, __pyx_L6_error)
+      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 470, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
-    /* "View.MemoryView":478
+    /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
-    __pyx_t_2 = (__pyx_v_self->view.suboffsets != NULL);
+    __pyx_t_2 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":479
+      /* "View.MemoryView":475
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_4 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 479, __pyx_L6_error)
+      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 475, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "View.MemoryView":478
+      /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
-    /* "View.MemoryView":480
+    /* "View.MemoryView":476
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,             # <<<<<<<<<<<<<<
  *                                 item, self.dtype_is_object)
  *         finally:
  */
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
-  /* "View.MemoryView":483
+  /* "View.MemoryView":479
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
@@ -8119,16 +8149,16 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "View.MemoryView":453
- *         memoryview_copy_contents(msrc, mdst, src.ndim, dst.ndim, self.dtype_is_object)
+  /* "View.MemoryView":449
+ *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
   /* function exit code */
@@ -8140,15 +8170,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":485
+/* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8159,36 +8189,36 @@
   char *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
-  /* "View.MemoryView":486
+  /* "View.MemoryView":482
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 486, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 482, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
-  /* "View.MemoryView":487
+  /* "View.MemoryView":483
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 487, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 483, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":485
+  /* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -8201,15 +8231,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":489
+/* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8223,46 +8253,47 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   int __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  int __pyx_t_10;
+  PyObject *__pyx_t_9 = NULL;
+  size_t __pyx_t_10;
+  int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":492
+  /* "View.MemoryView":488
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_ImportDottedModule(__pyx_n_s_struct, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 492, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 488, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":495
+  /* "View.MemoryView":491
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 495, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 491, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":496
+  /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
@@ -8270,94 +8301,120 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "View.MemoryView":497
+      /* "View.MemoryView":493
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
- *             raise ValueError, "Unable to convert item to object"
+ *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 497, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 497, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_7);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
-      {
-        PyObject *__pyx_callargs[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_8, 2+__pyx_t_8);
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_5)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 497, __pyx_L3_error)
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      } else
+      #endif
+      {
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        if (__pyx_t_7) {
+          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
+        }
+        __Pyx_GIVEREF(__pyx_t_6);
+        PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
+        __Pyx_INCREF(__pyx_v_bytesitem);
+        __Pyx_GIVEREF(__pyx_v_bytesitem);
+        PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
+        __pyx_t_6 = 0;
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "View.MemoryView":496
+      /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
-    /* "View.MemoryView":501
- *             raise ValueError, "Unable to convert item to object"
+    /* "View.MemoryView":497
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
-      __pyx_t_9 = __Pyx_ssize_strlen(__pyx_v_self->view.format); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(1, 501, __pyx_L5_except_error)
-      __pyx_t_10 = (__pyx_t_9 == 1);
-      if (__pyx_t_10) {
+      __pyx_t_10 = strlen(__pyx_v_self->view.format); 
+      __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
+      if (__pyx_t_11) {
 
-        /* "View.MemoryView":502
+        /* "View.MemoryView":498
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 502, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 498, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
-        /* "View.MemoryView":501
- *             raise ValueError, "Unable to convert item to object"
+        /* "View.MemoryView":497
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
       }
 
-      /* "View.MemoryView":503
+      /* "View.MemoryView":499
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -8366,95 +8423,100 @@
       goto __pyx_L6_except_return;
     }
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-    /* "View.MemoryView":498
+    /* "View.MemoryView":494
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Unable to convert item to object"
+ *             raise ValueError("Unable to convert item to object")
  *         else:
  */
-    __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 498, __pyx_L5_except_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_7);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_6);
-    __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_6 = 0;
+    __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 494, __pyx_L5_except_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
+    __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 498, __pyx_L5_except_error)
-      __Pyx_XGOTREF(__pyx_t_6);
-      __Pyx_XGOTREF(__pyx_t_5);
-      __Pyx_XGOTREF(__pyx_t_1);
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 494, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_1);
 
-      /* "View.MemoryView":499
+      /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
- *             raise ValueError, "Unable to convert item to object"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Unable_to_convert_item_to_object, 0, 0);
-      __PYX_ERR(1, 499, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __PYX_ERR(1, 495, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
+    __pyx_L5_except_error:;
 
-    /* "View.MemoryView":496
+    /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
-    __pyx_L5_except_error:;
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L1_error;
     __pyx_L6_except_return:;
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":489
+  /* "View.MemoryView":485
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesitem);
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":505
+/* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -8463,218 +8525,247 @@
   char __pyx_v_c;
   PyObject *__pyx_v_bytesvalue = 0;
   Py_ssize_t __pyx_v_i;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
-  char *__pyx_t_9;
-  char *__pyx_t_10;
+  Py_ssize_t __pyx_t_9;
+  PyObject *__pyx_t_10 = NULL;
   char *__pyx_t_11;
   char *__pyx_t_12;
+  char *__pyx_t_13;
+  char *__pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":508
+  /* "View.MemoryView":504
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_ImportDottedModule(__pyx_n_s_struct, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 508, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 504, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":513
+  /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
   __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
-  if (__pyx_t_2) {
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
-    /* "View.MemoryView":514
+    /* "View.MemoryView":510
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 514, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
+    __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 514, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_3))) __PYX_ERR(1, 514, __pyx_L1_error)
-    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_3);
-    __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
+    __pyx_t_4 = 0;
 
-    /* "View.MemoryView":513
+    /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":516
+  /* "View.MemoryView":512
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 516, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 516, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = NULL;
-    __pyx_t_6 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_4)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_4);
+    __pyx_t_5 = NULL;
+    __pyx_t_7 = 0;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_6 = 1;
+        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __pyx_t_7 = 1;
       }
     }
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_4, __pyx_t_1, __pyx_v_value};
-      __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 516, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (__pyx_t_5) {
+        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
+      }
+      __Pyx_GIVEREF(__pyx_t_1);
+      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
+      __Pyx_INCREF(__pyx_v_value);
+      __Pyx_GIVEREF(__pyx_v_value);
+      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
+      __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
-    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_3))) __PYX_ERR(1, 516, __pyx_L1_error)
-    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_3);
-    __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
+    __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":518
+  /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
-  __pyx_t_7 = 0;
+  __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(1, 518, __pyx_L1_error)
+    __PYX_ERR(1, 514, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
-  __pyx_t_8 = __pyx_v_bytesvalue;
-  __pyx_t_10 = PyBytes_AS_STRING(__pyx_t_8);
-  __pyx_t_11 = (__pyx_t_10 + PyBytes_GET_SIZE(__pyx_t_8));
-  for (__pyx_t_12 = __pyx_t_10; __pyx_t_12 < __pyx_t_11; __pyx_t_12++) {
-    __pyx_t_9 = __pyx_t_12;
-    __pyx_v_c = (__pyx_t_9[0]);
+  __pyx_t_10 = __pyx_v_bytesvalue;
+  __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
+  __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
+  for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
+    __pyx_t_11 = __pyx_t_14;
+    __pyx_v_c = (__pyx_t_11[0]);
 
-    /* "View.MemoryView":519
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
-    __pyx_v_i = __pyx_t_7;
+    __pyx_v_i = __pyx_t_9;
 
-    /* "View.MemoryView":518
+    /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
-    __pyx_t_7 = (__pyx_t_7 + 1);
+    __pyx_t_9 = (__pyx_t_9 + 1);
 
-    /* "View.MemoryView":519
+    /* "View.MemoryView":515
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "View.MemoryView":505
+  /* "View.MemoryView":501
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_10);
   __Pyx_AddTraceback("View.MemoryView.memoryview.assign_item_from_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":521
- *             itemp[i] = c
+/* "View.MemoryView":518
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
 /* Python wrapper */
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
-CYTHON_UNUSED static int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_8__getbuffer__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -8682,309 +8773,315 @@
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_8__getbuffer__(struct __pyx_memoryview_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
-  Py_ssize_t *__pyx_t_3;
-  char *__pyx_t_4;
-  void *__pyx_t_5;
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t *__pyx_t_4;
+  char *__pyx_t_5;
+  void *__pyx_t_6;
+  int __pyx_t_7;
+  Py_ssize_t __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  if (unlikely(__pyx_v_info == NULL)) {
+  if (__pyx_v_info == NULL) {
     PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
     return -1;
   }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
   __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":523
+  /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
   if (__pyx_t_2) {
   } else {
     __pyx_t_1 = __pyx_t_2;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = __pyx_v_self->view.readonly;
+  __pyx_t_2 = (__pyx_v_self->view.readonly != 0);
+  __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":524
+    /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Cannot_create_writable_memory_vi, 0, 0);
-    __PYX_ERR(1, 524, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 520, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(1, 520, __pyx_L1_error)
 
-    /* "View.MemoryView":523
+    /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  */
   }
 
-  /* "View.MemoryView":526
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+  /* "View.MemoryView":522
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":527
+    /* "View.MemoryView":523
  * 
  *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.shape;
-    __pyx_v_info->shape = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.shape;
+    __pyx_v_info->shape = __pyx_t_4;
 
-    /* "View.MemoryView":526
- *             raise ValueError, "Cannot create writable memory view from read-only memoryview"
+    /* "View.MemoryView":522
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
  *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
     goto __pyx_L6;
   }
 
-  /* "View.MemoryView":529
+  /* "View.MemoryView":525
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
   __pyx_L6:;
 
-  /* "View.MemoryView":531
+  /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":532
+    /* "View.MemoryView":528
  * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.strides;
-    __pyx_v_info->strides = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.strides;
+    __pyx_v_info->strides = __pyx_t_4;
 
-    /* "View.MemoryView":531
+    /* "View.MemoryView":527
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
     goto __pyx_L7;
   }
 
-  /* "View.MemoryView":534
+  /* "View.MemoryView":530
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
   __pyx_L7:;
 
-  /* "View.MemoryView":536
+  /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":537
+    /* "View.MemoryView":533
  * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.suboffsets;
-    __pyx_v_info->suboffsets = __pyx_t_3;
+    __pyx_t_4 = __pyx_v_self->view.suboffsets;
+    __pyx_v_info->suboffsets = __pyx_t_4;
 
-    /* "View.MemoryView":536
+    /* "View.MemoryView":532
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
     goto __pyx_L8;
   }
 
-  /* "View.MemoryView":539
+  /* "View.MemoryView":535
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
   __pyx_L8:;
 
-  /* "View.MemoryView":541
+  /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":542
+    /* "View.MemoryView":538
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
-    __pyx_t_4 = __pyx_v_self->view.format;
-    __pyx_v_info->format = __pyx_t_4;
+    __pyx_t_5 = __pyx_v_self->view.format;
+    __pyx_v_info->format = __pyx_t_5;
 
-    /* "View.MemoryView":541
+    /* "View.MemoryView":537
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":544
+  /* "View.MemoryView":540
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":546
+  /* "View.MemoryView":542
  *             info.format = NULL
  * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
-  __pyx_t_5 = __pyx_v_self->view.buf;
-  __pyx_v_info->buf = __pyx_t_5;
+  __pyx_t_6 = __pyx_v_self->view.buf;
+  __pyx_v_info->buf = __pyx_t_6;
 
-  /* "View.MemoryView":547
+  /* "View.MemoryView":543
  * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
-  __pyx_t_6 = __pyx_v_self->view.ndim;
-  __pyx_v_info->ndim = __pyx_t_6;
+  __pyx_t_7 = __pyx_v_self->view.ndim;
+  __pyx_v_info->ndim = __pyx_t_7;
 
-  /* "View.MemoryView":548
+  /* "View.MemoryView":544
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize             # <<<<<<<<<<<<<<
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  */
-  __pyx_t_7 = __pyx_v_self->view.itemsize;
-  __pyx_v_info->itemsize = __pyx_t_7;
+  __pyx_t_8 = __pyx_v_self->view.itemsize;
+  __pyx_v_info->itemsize = __pyx_t_8;
 
-  /* "View.MemoryView":549
+  /* "View.MemoryView":545
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len             # <<<<<<<<<<<<<<
  *         info.readonly = self.view.readonly
  *         info.obj = self
  */
-  __pyx_t_7 = __pyx_v_self->view.len;
-  __pyx_v_info->len = __pyx_t_7;
+  __pyx_t_8 = __pyx_v_self->view.len;
+  __pyx_v_info->len = __pyx_t_8;
 
-  /* "View.MemoryView":550
+  /* "View.MemoryView":546
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
  * 
  */
   __pyx_t_1 = __pyx_v_self->view.readonly;
   __pyx_v_info->readonly = __pyx_t_1;
 
-  /* "View.MemoryView":551
+  /* "View.MemoryView":547
  *         info.len = self.view.len
  *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
- * 
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
-  __Pyx_INCREF((PyObject *)__pyx_v_self);
-  __Pyx_GIVEREF((PyObject *)__pyx_v_self);
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":521
- *             itemp[i] = c
+  /* "View.MemoryView":518
  * 
- *     @cname('getbuffer')             # <<<<<<<<<<<<<<
- *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
@@ -8994,26 +9091,25 @@
     __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":554
- * 
+/* "View.MemoryView":553
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def T(self):
+ *     @property
+ *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
+ *         transpose_memslice(&result.from_slice)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_1T___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9027,500 +9123,445 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":556
+  /* "View.MemoryView":554
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 556, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 554, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 556, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 554, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":557
+  /* "View.MemoryView":555
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(1, 557, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 555, __pyx_L1_error)
 
-  /* "View.MemoryView":558
+  /* "View.MemoryView":556
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":554
+  /* "View.MemoryView":553
  * 
- * 
- *     @property             # <<<<<<<<<<<<<<
- *     def T(self):
+ *     @property
+ *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
+ *         transpose_memslice(&result.from_slice)
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.T.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":560
- *         return result
+/* "View.MemoryView":559
+ * 
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
+ *         return self.obj
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def base(self):
- *         return self._get_base()
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4base_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":562
- *     @property
- *     def base(self):
- *         return self._get_base()             # <<<<<<<<<<<<<<
- * 
- *     cdef _get_base(self):
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->_get_base(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 562, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_r = __pyx_t_1;
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
   /* "View.MemoryView":560
- *         return result
- * 
- *     @property             # <<<<<<<<<<<<<<
+ *     @property
  *     def base(self):
- *         return self._get_base()
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("View.MemoryView.memoryview.base.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "View.MemoryView":564
- *         return self._get_base()
- * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
- *         return self.obj
- * 
- */
-
-static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_get_base", 0);
-
-  /* "View.MemoryView":565
- * 
- *     cdef _get_base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":564
- *         return self._get_base()
+  /* "View.MemoryView":559
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":567
- *         return self.obj
+/* "View.MemoryView":563
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def shape(self):
+ *     @property
+ *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_5shape_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_5shape___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_5shape___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_7genexpr__pyx_v_length;
+  Py_ssize_t __pyx_v_length;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":569
+  /* "View.MemoryView":564
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 569, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
-    for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
-      __pyx_t_2 = __pyx_t_4;
-      __pyx_7genexpr__pyx_v_length = (__pyx_t_2[0]);
-      __pyx_t_5 = PyInt_FromSsize_t(__pyx_7genexpr__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 569, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 569, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 569, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 564, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
+  for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
+    __pyx_t_2 = __pyx_t_4;
+    __pyx_v_length = (__pyx_t_2[0]);
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 564, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":567
- *         return self.obj
+  /* "View.MemoryView":563
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def shape(self):
+ *     @property
+ *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview.shape.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":571
- *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+/* "View.MemoryView":567
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def strides(self):
+ *     @property
+ *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_7strides_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_7strides___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_7strides___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_8genexpr1__pyx_v_stride;
+  Py_ssize_t __pyx_v_stride;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":573
+  /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
- *             raise ValueError, "Buffer view does not expose strides"
+ *             raise ValueError("Buffer view does not expose strides")
  */
-  __pyx_t_1 = (__pyx_v_self->view.strides == NULL);
+  __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":575
+    /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
- *             raise ValueError, "Buffer view does not expose strides"             # <<<<<<<<<<<<<<
+ *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Buffer_view_does_not_expose_stri, 0, 0);
-    __PYX_ERR(1, 575, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 570, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 570, __pyx_L1_error)
 
-    /* "View.MemoryView":573
+    /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
- *             raise ValueError, "Buffer view does not expose strides"
+ *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
-  /* "View.MemoryView":577
- *             raise ValueError, "Buffer view does not expose strides"
+  /* "View.MemoryView":572
+ *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
-    for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
-      __pyx_t_3 = __pyx_t_5;
-      __pyx_8genexpr1__pyx_v_stride = (__pyx_t_3[0]);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_8genexpr1__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 577, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 577, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 577, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
+  for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
+    __pyx_t_3 = __pyx_t_5;
+    __pyx_v_stride = (__pyx_t_3[0]);
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 572, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  }
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":571
- *         return tuple([length for length in self.view.shape[:self.view.ndim]])
+  /* "View.MemoryView":567
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def strides(self):
+ *     @property
+ *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.memoryview.strides.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":579
- *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
+/* "View.MemoryView":575
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def suboffsets(self):
+ *     @property
+ *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_10suboffsets_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_10suboffsets_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_10suboffsets___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_10suboffsets___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
-  Py_ssize_t __pyx_8genexpr2__pyx_v_suboffset;
+  Py_ssize_t __pyx_v_suboffset;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t *__pyx_t_3;
+  PyObject *__pyx_t_3 = NULL;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
+  Py_ssize_t *__pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":581
+  /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->view.suboffsets == NULL);
+  __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":582
+    /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PySequence_Multiply(__pyx_tuple__4, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 582, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__13, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 577, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":581
+    /* "View.MemoryView":576
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   }
 
-  /* "View.MemoryView":584
+  /* "View.MemoryView":579
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  { /* enter inner scope */
-    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 584, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
+  for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
+    __pyx_t_4 = __pyx_t_6;
+    __pyx_v_suboffset = (__pyx_t_4[0]);
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
-    for (__pyx_t_5 = __pyx_v_self->view.suboffsets; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
-      __pyx_t_3 = __pyx_t_5;
-      __pyx_8genexpr2__pyx_v_suboffset = (__pyx_t_3[0]);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_8genexpr2__pyx_v_suboffset); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 584, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 584, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
-  } /* exit inner scope */
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 584, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_r = __pyx_t_6;
-  __pyx_t_6 = 0;
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 579, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  }
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":579
- *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
+  /* "View.MemoryView":575
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def suboffsets(self):
+ *     @property
+ *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.memoryview.suboffsets.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":586
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+/* "View.MemoryView":582
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def ndim(self):
+ *     @property
+ *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4ndim_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4ndim___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9532,59 +9573,58 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":588
+  /* "View.MemoryView":583
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 588, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":586
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+  /* "View.MemoryView":582
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def ndim(self):
+ *     @property
+ *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.ndim.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":590
- *         return self.view.ndim
+/* "View.MemoryView":586
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def itemsize(self):
+ *     @property
+ *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_8itemsize_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_8itemsize___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9596,59 +9636,58 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":592
+  /* "View.MemoryView":587
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 592, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":590
- *         return self.view.ndim
+  /* "View.MemoryView":586
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def itemsize(self):
+ *     @property
+ *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.itemsize.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":594
- *         return self.view.itemsize
+/* "View.MemoryView":590
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def nbytes(self):
+ *     @property
+ *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_6nbytes___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9662,40 +9701,40 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":596
+  /* "View.MemoryView":591
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 596, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":594
- *         return self.view.itemsize
+  /* "View.MemoryView":590
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def nbytes(self):
+ *     @property
+ *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -9703,26 +9742,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":598
- *         return self.size * self.view.itemsize
+/* "View.MemoryView":594
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def size(self):
+ *     @property
+ *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
+ *             result = 1
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
   __pyx_r = __pyx_pf_15View_dot_MemoryView_10memoryview_4size___get__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9731,138 +9769,139 @@
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4size___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_v_result = NULL;
   PyObject *__pyx_v_length = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  Py_ssize_t *__pyx_t_2;
+  int __pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  Py_ssize_t *__pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":600
+  /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":601
+    /* "View.MemoryView":596
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
-    /* "View.MemoryView":603
+    /* "View.MemoryView":598
  *             result = 1
  * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
-    __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
-    for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
-      __pyx_t_2 = __pyx_t_4;
-      __pyx_t_5 = PyInt_FromSsize_t((__pyx_t_2[0])); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 603, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_5);
-      __pyx_t_5 = 0;
+    __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
+    for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
+      __pyx_t_3 = __pyx_t_5;
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 598, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
+      __pyx_t_6 = 0;
 
-      /* "View.MemoryView":604
+      /* "View.MemoryView":599
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_5 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 604, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_5);
-      __pyx_t_5 = 0;
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 599, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
+      __pyx_t_6 = 0;
     }
 
-    /* "View.MemoryView":606
+    /* "View.MemoryView":601
  *                 result *= length
  * 
  *             self._size = result             # <<<<<<<<<<<<<<
  * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
-    /* "View.MemoryView":600
+    /* "View.MemoryView":595
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   }
 
-  /* "View.MemoryView":608
+  /* "View.MemoryView":603
  *             self._size = result
  * 
  *         return self._size             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":598
- *         return self.size * self.view.itemsize
+  /* "View.MemoryView":594
  * 
- *     @property             # <<<<<<<<<<<<<<
- *     def size(self):
+ *     @property
+ *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
+ *             result = 1
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.memoryview.size.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":610
+/* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
 /* Python wrapper */
 static Py_ssize_t __pyx_memoryview___len__(PyObject *__pyx_v_self); /*proto*/
 static Py_ssize_t __pyx_memoryview___len__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9871,79 +9910,78 @@
 
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":611
+  /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
-  __pyx_t_1 = (__pyx_v_self->view.ndim >= 1);
+  __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":612
+    /* "View.MemoryView":607
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
  * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
-    /* "View.MemoryView":611
+    /* "View.MemoryView":606
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   }
 
-  /* "View.MemoryView":614
+  /* "View.MemoryView":609
  *             return self.view.shape[0]
  * 
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":610
+  /* "View.MemoryView":605
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":616
+/* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___repr__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_memoryview___repr__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_12__repr__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -9957,64 +9995,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":618
+  /* "View.MemoryView":613
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 618, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 613, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 617, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":616
+  /* "View.MemoryView":611
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -10027,26 +10065,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":620
+/* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_memoryview___str__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_14__str__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
@@ -10059,43 +10096,43 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__str__", 0);
 
-  /* "View.MemoryView":621
+  /* "View.MemoryView":616
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":620
+  /* "View.MemoryView":615
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -10107,47 +10144,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":624
+/* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_c_contig (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("is_c_contig", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "is_c_contig", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_16is_c_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10159,39 +10177,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
-  /* "View.MemoryView":627
+  /* "View.MemoryView":622
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 627, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 622, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":628
+  /* "View.MemoryView":623
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 628, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":624
+  /* "View.MemoryView":619
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10202,47 +10220,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":630
+/* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_f_contig (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("is_f_contig", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "is_f_contig", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_18is_f_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10254,39 +10253,39 @@
   __Pyx_memviewslice *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
-  /* "View.MemoryView":633
+  /* "View.MemoryView":628
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 633, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 628, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":634
+  /* "View.MemoryView":629
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 634, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 629, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":630
+  /* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -10297,47 +10296,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":636
+/* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("copy", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "copy", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_20copy(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10349,57 +10329,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy", 0);
 
-  /* "View.MemoryView":638
+  /* "View.MemoryView":633
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
-  /* "View.MemoryView":640
+  /* "View.MemoryView":635
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
-  /* "View.MemoryView":641
+  /* "View.MemoryView":636
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 641, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 636, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":646
+  /* "View.MemoryView":641
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 646, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":636
+  /* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -10410,47 +10390,28 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":648
+/* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
 /* Python wrapper */
-static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy_fortran (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("copy_fortran", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "copy_fortran", 0))) return NULL;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -10463,57 +10424,57 @@
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
-  /* "View.MemoryView":650
+  /* "View.MemoryView":645
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
-  /* "View.MemoryView":652
+  /* "View.MemoryView":647
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
-  /* "View.MemoryView":653
+  /* "View.MemoryView":648
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 653, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 648, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
-  /* "View.MemoryView":658
+  /* "View.MemoryView":653
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":648
+  /* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -10526,192 +10487,126 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_memoryview___reduce_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_memoryview_2__setstate_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_memoryview_2__setstate_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":662
+/* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10723,64 +10618,64 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_cwrapper", 0);
 
-  /* "View.MemoryView":663
+  /* "View.MemoryView":658
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 663, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":664
+  /* "View.MemoryView":659
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
  * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
-  /* "View.MemoryView":665
+  /* "View.MemoryView":660
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":662
+  /* "View.MemoryView":657
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -10794,518 +10689,599 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":668
+/* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:             # <<<<<<<<<<<<<<
+ * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
-  /* "View.MemoryView":669
+  /* "View.MemoryView":664
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:
+ * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
  * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":668
+  /* "View.MemoryView":663
  * 
  * @cname('__pyx_memoryview_check')
- * cdef inline bint memoryview_check(object o) noexcept:             # <<<<<<<<<<<<<<
+ * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":671
+/* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
 static PyObject *_unellipsify(PyObject *__pyx_v_index, int __pyx_v_ndim) {
-  Py_ssize_t __pyx_v_idx;
   PyObject *__pyx_v_tup = NULL;
   PyObject *__pyx_v_result = NULL;
   int __pyx_v_have_slices;
   int __pyx_v_seen_ellipsis;
+  CYTHON_UNUSED PyObject *__pyx_v_idx = NULL;
   PyObject *__pyx_v_item = NULL;
   Py_ssize_t __pyx_v_nslices;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  Py_ssize_t __pyx_t_4;
+  PyObject *__pyx_t_4 = NULL;
   Py_ssize_t __pyx_t_5;
-  Py_UCS4 __pyx_t_6;
+  PyObject *(*__pyx_t_6)(PyObject *);
   PyObject *__pyx_t_7 = NULL;
+  Py_ssize_t __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_unellipsify", 0);
 
-  /* "View.MemoryView":677
+  /* "View.MemoryView":671
+ *     full slices.
  *     """
- *     cdef Py_ssize_t idx
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)             # <<<<<<<<<<<<<<
- * 
- *     result = [slice(None)] * ndim
+ *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
+ *         tup = (index,)
+ *     else:
  */
-  __pyx_t_2 = PyTuple_Check(__pyx_v_index); 
+  __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
+  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
-    __Pyx_INCREF(((PyObject*)__pyx_v_index));
-    __pyx_t_1 = __pyx_v_index;
-  } else {
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 677, __pyx_L1_error)
+
+    /* "View.MemoryView":672
+ *     """
+ *     if not isinstance(index, tuple):
+ *         tup = (index,)             # <<<<<<<<<<<<<<
+ *     else:
+ *         tup = index
+ */
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
-    __pyx_t_1 = __pyx_t_3;
+    __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
+
+    /* "View.MemoryView":671
+ *     full slices.
+ *     """
+ *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
+ *         tup = (index,)
+ *     else:
+ */
+    goto __pyx_L3;
   }
-  __pyx_v_tup = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":679
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)
+  /* "View.MemoryView":674
+ *         tup = (index,)
+ *     else:
+ *         tup = index             # <<<<<<<<<<<<<<
+ * 
+ *     result = []
+ */
+  /*else*/ {
+    __Pyx_INCREF(__pyx_v_index);
+    __pyx_v_tup = __pyx_v_index;
+  }
+  __pyx_L3:;
+
+  /* "View.MemoryView":676
+ *         tup = index
  * 
- *     result = [slice(None)] * ndim             # <<<<<<<<<<<<<<
+ *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_1 = PyList_New(1 * ((__pyx_v_ndim<0) ? 0:__pyx_v_ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 679, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  { Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < __pyx_v_ndim; __pyx_temp++) {
-      __Pyx_INCREF(__pyx_slice__5);
-      __Pyx_GIVEREF(__pyx_slice__5);
-      PyList_SET_ITEM(__pyx_t_1, __pyx_temp, __pyx_slice__5);
-    }
-  }
-  __pyx_v_result = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 676, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_v_result = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
-  /* "View.MemoryView":680
+  /* "View.MemoryView":677
  * 
- *     result = [slice(None)] * ndim
+ *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
- *     idx = 0
+ *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
-  /* "View.MemoryView":681
- *     result = [slice(None)] * ndim
+  /* "View.MemoryView":678
+ *     result = []
  *     have_slices = False
  *     seen_ellipsis = False             # <<<<<<<<<<<<<<
- *     idx = 0
- *     for item in tup:
+ *     for idx, item in enumerate(tup):
+ *         if item is Ellipsis:
  */
   __pyx_v_seen_ellipsis = 0;
 
-  /* "View.MemoryView":682
+  /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
- *     idx = 0             # <<<<<<<<<<<<<<
- *     for item in tup:
- *         if item is Ellipsis:
- */
-  __pyx_v_idx = 0;
-
-  /* "View.MemoryView":683
- *     seen_ellipsis = False
- *     idx = 0
- *     for item in tup:             # <<<<<<<<<<<<<<
+ *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
-  if (unlikely(__pyx_v_tup == Py_None)) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(1, 683, __pyx_L1_error)
+  __Pyx_INCREF(__pyx_int_0);
+  __pyx_t_3 = __pyx_int_0;
+  if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
+    __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
+    __pyx_t_6 = NULL;
+  } else {
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 679, __pyx_L1_error)
   }
-  __pyx_t_1 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   for (;;) {
-    if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely((0 < 0))) __PYX_ERR(1, 683, __pyx_L1_error)
-    #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 683, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_3);
-    __pyx_t_3 = 0;
+    if (likely(!__pyx_t_6)) {
+      if (likely(PyList_CheckExact(__pyx_t_4))) {
+        if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      } else {
+        if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        #else
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        #endif
+      }
+    } else {
+      __pyx_t_7 = __pyx_t_6(__pyx_t_4);
+      if (unlikely(!__pyx_t_7)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(1, 679, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_7);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
+    __pyx_t_7 = 0;
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_3);
+    __pyx_t_3 = __pyx_t_7;
+    __pyx_t_7 = 0;
 
-    /* "View.MemoryView":684
- *     idx = 0
- *     for item in tup:
+    /* "View.MemoryView":680
+ *     seen_ellipsis = False
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
     __pyx_t_2 = (__pyx_v_item == __pyx_builtin_Ellipsis);
-    if (__pyx_t_2) {
+    __pyx_t_1 = (__pyx_t_2 != 0);
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":685
- *     for item in tup:
+      /* "View.MemoryView":681
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
-      __pyx_t_2 = (!__pyx_v_seen_ellipsis);
-      if (__pyx_t_2) {
+      __pyx_t_1 = ((!(__pyx_v_seen_ellipsis != 0)) != 0);
+      if (__pyx_t_1) {
 
-        /* "View.MemoryView":686
+        /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)             # <<<<<<<<<<<<<<
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
- *             have_slices = True
+ *             else:
  */
-        if (unlikely(__pyx_v_tup == Py_None)) {
-          PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-          __PYX_ERR(1, 686, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 682, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        { Py_ssize_t __pyx_temp;
+          for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
+            __Pyx_INCREF(__pyx_slice__16);
+            __Pyx_GIVEREF(__pyx_slice__16);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__16);
+          }
         }
-        __pyx_t_5 = PyTuple_GET_SIZE(__pyx_v_tup); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 686, __pyx_L1_error)
-        __pyx_v_idx = (__pyx_v_idx + (__pyx_v_ndim - __pyx_t_5));
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-        /* "View.MemoryView":687
+        /* "View.MemoryView":683
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
- *             have_slices = True
- *         else:
+ *             else:
+ *                 result.append(slice(None))
  */
         __pyx_v_seen_ellipsis = 1;
 
-        /* "View.MemoryView":685
- *     for item in tup:
+        /* "View.MemoryView":681
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
+        goto __pyx_L7;
       }
 
-      /* "View.MemoryView":688
- *                 idx += ndim - len(tup)
+      /* "View.MemoryView":685
  *                 seen_ellipsis = True
+ *             else:
+ *                 result.append(slice(None))             # <<<<<<<<<<<<<<
+ *             have_slices = True
+ *         else:
+ */
+      /*else*/ {
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__16); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 685, __pyx_L1_error)
+      }
+      __pyx_L7:;
+
+      /* "View.MemoryView":686
+ *             else:
+ *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
  *         else:
- *             if isinstance(item, slice):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):
  */
       __pyx_v_have_slices = 1;
 
-      /* "View.MemoryView":684
- *     idx = 0
- *     for item in tup:
+      /* "View.MemoryView":680
+ *     seen_ellipsis = False
+ *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
- *                 idx += ndim - len(tup)
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
-      goto __pyx_L5;
+      goto __pyx_L6;
     }
 
-    /* "View.MemoryView":690
+    /* "View.MemoryView":688
  *             have_slices = True
  *         else:
- *             if isinstance(item, slice):             # <<<<<<<<<<<<<<
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
  */
     /*else*/ {
       __pyx_t_2 = PySlice_Check(__pyx_v_item); 
-      if (__pyx_t_2) {
+      __pyx_t_10 = ((!(__pyx_t_2 != 0)) != 0);
+      if (__pyx_t_10) {
+      } else {
+        __pyx_t_1 = __pyx_t_10;
+        goto __pyx_L9_bool_binop_done;
+      }
+      __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
+      __pyx_t_1 = __pyx_t_10;
+      __pyx_L9_bool_binop_done:;
+      if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":691
+        /* "View.MemoryView":689
  *         else:
- *             if isinstance(item, slice):
- *                 have_slices = True             # <<<<<<<<<<<<<<
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
+ * 
+ *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_v_have_slices = 1;
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_11);
+        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_Raise(__pyx_t_11, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __PYX_ERR(1, 689, __pyx_L1_error)
 
-        /* "View.MemoryView":690
+        /* "View.MemoryView":688
  *             have_slices = True
  *         else:
- *             if isinstance(item, slice):             # <<<<<<<<<<<<<<
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
+ *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
  */
-        goto __pyx_L7;
       }
 
-      /* "View.MemoryView":692
- *             if isinstance(item, slice):
- *                 have_slices = True
- *             elif not PyIndex_Check(item):             # <<<<<<<<<<<<<<
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
- */
-      __pyx_t_2 = (!(PyIndex_Check(__pyx_v_item) != 0));
-      if (unlikely(__pyx_t_2)) {
-
-        /* "View.MemoryView":693
- *                 have_slices = True
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"             # <<<<<<<<<<<<<<
- *             result[idx] = item
- *         idx += 1
- */
-        __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_5 = 0;
-        __pyx_t_6 = 127;
-        __Pyx_INCREF(__pyx_kp_u_Cannot_index_with_type);
-        __pyx_t_5 += 24;
-        __Pyx_GIVEREF(__pyx_kp_u_Cannot_index_with_type);
-        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Cannot_index_with_type);
-        __pyx_t_7 = __Pyx_PyObject_FormatSimple(((PyObject *)Py_TYPE(__pyx_v_item)), __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
-        __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
-        __Pyx_GIVEREF(__pyx_t_7);
-        PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_7);
-        __pyx_t_7 = 0;
-        __Pyx_INCREF(__pyx_kp_u__6);
-        __pyx_t_5 += 1;
-        __Pyx_GIVEREF(__pyx_kp_u__6);
-        PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u__6);
-        __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 693, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_Raise(__pyx_builtin_TypeError, __pyx_t_7, 0, 0);
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __PYX_ERR(1, 693, __pyx_L1_error)
-
-        /* "View.MemoryView":692
- *             if isinstance(item, slice):
- *                 have_slices = True
- *             elif not PyIndex_Check(item):             # <<<<<<<<<<<<<<
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
+      /* "View.MemoryView":691
+ *                 raise TypeError("Cannot index with type '%s'" % type(item))
+ * 
+ *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
+ *             result.append(item)
+ * 
  */
+      __pyx_t_10 = (__pyx_v_have_slices != 0);
+      if (!__pyx_t_10) {
+      } else {
+        __pyx_t_1 = __pyx_t_10;
+        goto __pyx_L11_bool_binop_done;
       }
-      __pyx_L7:;
+      __pyx_t_10 = PySlice_Check(__pyx_v_item); 
+      __pyx_t_2 = (__pyx_t_10 != 0);
+      __pyx_t_1 = __pyx_t_2;
+      __pyx_L11_bool_binop_done:;
+      __pyx_v_have_slices = __pyx_t_1;
 
-      /* "View.MemoryView":694
- *             elif not PyIndex_Check(item):
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item             # <<<<<<<<<<<<<<
- *         idx += 1
+      /* "View.MemoryView":692
  * 
- */
-      if (unlikely((__Pyx_SetItemInt(__pyx_v_result, __pyx_v_idx, __pyx_v_item, Py_ssize_t, 1, PyInt_FromSsize_t, 1, 1, 1) < 0))) __PYX_ERR(1, 694, __pyx_L1_error)
-    }
-    __pyx_L5:;
-
-    /* "View.MemoryView":695
- *                 raise TypeError, f"Cannot index with type '{type(item)}'"
- *             result[idx] = item
- *         idx += 1             # <<<<<<<<<<<<<<
+ *             have_slices = have_slices or isinstance(item, slice)
+ *             result.append(item)             # <<<<<<<<<<<<<<
  * 
- *     nslices = ndim - idx
+ *     nslices = ndim - len(result)
  */
-    __pyx_v_idx = (__pyx_v_idx + 1);
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 692, __pyx_L1_error)
+    }
+    __pyx_L6:;
 
-    /* "View.MemoryView":683
+    /* "View.MemoryView":679
+ *     have_slices = False
  *     seen_ellipsis = False
- *     idx = 0
- *     for item in tup:             # <<<<<<<<<<<<<<
+ *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "View.MemoryView":694
+ *             result.append(item)
+ * 
+ *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
+ *     if nslices:
+ *         result.extend([slice(None)] * nslices)
+ */
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
+  __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
+
+  /* "View.MemoryView":695
+ * 
+ *     nslices = ndim - len(result)
+ *     if nslices:             # <<<<<<<<<<<<<<
+ *         result.extend([slice(None)] * nslices)
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_nslices != 0);
+  if (__pyx_t_1) {
 
-  /* "View.MemoryView":697
- *         idx += 1
+    /* "View.MemoryView":696
+ *     nslices = ndim - len(result)
+ *     if nslices:
+ *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
- *     nslices = ndim - idx             # <<<<<<<<<<<<<<
  *     return have_slices or nslices, tuple(result)
+ */
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 696, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    { Py_ssize_t __pyx_temp;
+      for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
+        __Pyx_INCREF(__pyx_slice__16);
+        __Pyx_GIVEREF(__pyx_slice__16);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__16);
+      }
+    }
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+    /* "View.MemoryView":695
+ * 
+ *     nslices = ndim - len(result)
+ *     if nslices:             # <<<<<<<<<<<<<<
+ *         result.extend([slice(None)] * nslices)
  * 
  */
-  __pyx_v_nslices = (__pyx_v_ndim - __pyx_v_idx);
+  }
 
   /* "View.MemoryView":698
+ *         result.extend([slice(None)] * nslices)
  * 
- *     nslices = ndim - idx
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_1 = __pyx_t_7;
-    __pyx_t_7 = 0;
-    goto __pyx_L9_bool_binop_done;
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_3 = __pyx_t_4;
+    __pyx_t_4 = 0;
+    goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_7 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __pyx_t_7;
-  __pyx_t_7 = 0;
-  __pyx_L9_bool_binop_done:;
-  __pyx_t_7 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 698, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_7);
-  __pyx_t_1 = 0;
-  __pyx_t_7 = 0;
-  __pyx_r = ((PyObject*)__pyx_t_3);
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __pyx_t_4;
+  __pyx_t_4 = 0;
+  __pyx_L14_bool_binop_done:;
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
+  __pyx_t_4 = 0;
+  __pyx_r = ((PyObject*)__pyx_t_11);
+  __pyx_t_11 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":671
+  /* "View.MemoryView":666
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_11);
   __Pyx_AddTraceback("View.MemoryView._unellipsify", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_tup);
   __Pyx_XDECREF(__pyx_v_result);
+  __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:             # <<<<<<<<<<<<<<
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
-static int assert_direct_dimensions(Py_ssize_t *__pyx_v_suboffsets, int __pyx_v_ndim) {
+static PyObject *assert_direct_dimensions(Py_ssize_t *__pyx_v_suboffsets, int __pyx_v_ndim) {
   Py_ssize_t __pyx_v_suboffset;
-  int __pyx_r;
+  PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   Py_ssize_t *__pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
   /* "View.MemoryView":701
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"
+ *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
     __pyx_t_1 = __pyx_t_3;
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
     /* "View.MemoryView":702
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")
+ * 
  */
-    __pyx_t_4 = (__pyx_v_suboffset >= 0);
+    __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
     if (unlikely(__pyx_t_4)) {
 
       /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"             # <<<<<<<<<<<<<<
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
+ * 
  * 
  */
-      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_kp_s_Indirect_dimensions_not_supporte, 0, 0);
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 703, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __PYX_ERR(1, 703, __pyx_L1_error)
 
       /* "View.MemoryView":702
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag
+ *             raise ValueError("Indirect dimensions not supported")
+ * 
  */
     }
   }
 
-  /* "View.MemoryView":704
- *         if suboffset >= 0:
- *             raise ValueError, "Indirect dimensions not supported"
- *     return 0  # return type just used as an error flag             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = 0;
-  goto __pyx_L0;
-
   /* "View.MemoryView":700
  *     return have_slices or nslices, tuple(result)
  * 
- * cdef int assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim) except -1:             # <<<<<<<<<<<<<<
+ * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
   /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.assert_direct_dimensions", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
+  __pyx_r = 0;
   __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":711
+/* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -11318,575 +11294,574 @@
   __Pyx_memviewslice *__pyx_v_p_src;
   struct __pyx_memoryviewslice_obj *__pyx_v_memviewsliceobj = 0;
   __Pyx_memviewslice *__pyx_v_p_dst;
   int *__pyx_v_p_suboffset_dim;
   Py_ssize_t __pyx_v_start;
   Py_ssize_t __pyx_v_stop;
   Py_ssize_t __pyx_v_step;
-  Py_ssize_t __pyx_v_cindex;
   int __pyx_v_have_start;
   int __pyx_v_have_stop;
   int __pyx_v_have_step;
   PyObject *__pyx_v_index = NULL;
   struct __pyx_memoryview_obj *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  struct __pyx_memoryview_obj *__pyx_t_3;
-  char *__pyx_t_4;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  PyObject *(*__pyx_t_7)(PyObject *);
-  PyObject *__pyx_t_8 = NULL;
-  Py_ssize_t __pyx_t_9;
-  int __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  struct __pyx_memoryview_obj *__pyx_t_4;
+  char *__pyx_t_5;
+  int __pyx_t_6;
+  Py_ssize_t __pyx_t_7;
+  PyObject *(*__pyx_t_8)(PyObject *);
+  PyObject *__pyx_t_9 = NULL;
+  Py_ssize_t __pyx_t_10;
+  int __pyx_t_11;
+  Py_ssize_t __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memview_slice", 0);
 
-  /* "View.MemoryView":712
+  /* "View.MemoryView":711
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim             # <<<<<<<<<<<<<<
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
-  /* "View.MemoryView":719
+  /* "View.MemoryView":718
  * 
  * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
  * 
  *     cdef _memoryviewslice memviewsliceobj
  */
   (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
-  /* "View.MemoryView":723
+  /* "View.MemoryView":722
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_1 = (__pyx_v_memview->view.ndim > 0);
-    if (unlikely(!__pyx_t_1)) {
-      __Pyx_Raise(__pyx_builtin_AssertionError, 0, 0, 0);
-      __PYX_ERR(1, 723, __pyx_L1_error)
+  if (unlikely(!Py_OptimizeFlag)) {
+    if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
+      PyErr_SetNone(PyExc_AssertionError);
+      __PYX_ERR(1, 722, __pyx_L1_error)
     }
   }
-  #else
-  if ((1)); else __PYX_ERR(1, 723, __pyx_L1_error)
   #endif
 
-  /* "View.MemoryView":725
+  /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":726
+    /* "View.MemoryView":725
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 726, __pyx_L1_error)
-    __pyx_t_2 = ((PyObject *)__pyx_v_memview);
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 725, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_v_memview);
+    __Pyx_INCREF(__pyx_t_3);
+    __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "View.MemoryView":727
+    /* "View.MemoryView":726
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
-    /* "View.MemoryView":725
+    /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":729
+  /* "View.MemoryView":728
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
-    /* "View.MemoryView":730
+    /* "View.MemoryView":729
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":736
+  /* "View.MemoryView":735
  * 
  * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
  * 
  */
-  __pyx_t_3 = __pyx_v_p_src->memview;
-  __pyx_v_dst.memview = __pyx_t_3;
+  __pyx_t_4 = __pyx_v_p_src->memview;
+  __pyx_v_dst.memview = __pyx_t_4;
 
-  /* "View.MemoryView":737
+  /* "View.MemoryView":736
  * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __pyx_v_p_src->data;
-  __pyx_v_dst.data = __pyx_t_4;
+  __pyx_t_5 = __pyx_v_p_src->data;
+  __pyx_v_dst.data = __pyx_t_5;
 
-  /* "View.MemoryView":742
+  /* "View.MemoryView":741
  * 
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
- *     cdef Py_ssize_t start, stop, step, cindex
+ *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
-  /* "View.MemoryView":743
+  /* "View.MemoryView":742
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t start, stop, step, cindex
+ *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
-  /* "View.MemoryView":747
+  /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
- *             cindex = index
+ *             slice_memviewslice(
  */
-  __pyx_t_5 = 0;
+  __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
-    __pyx_t_2 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_2); __pyx_t_6 = 0;
-    __pyx_t_7 = NULL;
+    __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
+    __pyx_t_8 = NULL;
   } else {
-    __pyx_t_6 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 747, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 747, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 746, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 746, __pyx_L1_error)
   }
   for (;;) {
-    if (likely(!__pyx_t_7)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_2)) break;
+    if (likely(!__pyx_t_8)) {
+      if (likely(PyList_CheckExact(__pyx_t_3))) {
+        if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_8 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely((0 < 0))) __PYX_ERR(1, 747, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 747, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_8);
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
-        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
+        if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely((0 < 0))) __PYX_ERR(1, 747, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
         #else
-        __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 747, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_8);
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
-      __pyx_t_8 = __pyx_t_7(__pyx_t_2);
-      if (unlikely(!__pyx_t_8)) {
+      __pyx_t_9 = __pyx_t_8(__pyx_t_3);
+      if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 747, __pyx_L1_error)
+          else __PYX_ERR(1, 746, __pyx_L1_error)
         }
         break;
       }
-      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GOTREF(__pyx_t_9);
     }
-    __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_8);
-    __pyx_t_8 = 0;
-    __pyx_v_dim = __pyx_t_5;
-    __pyx_t_5 = (__pyx_t_5 + 1);
+    __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
+    __pyx_t_9 = 0;
+    __pyx_v_dim = __pyx_t_6;
+    __pyx_t_6 = (__pyx_t_6 + 1);
 
-    /* "View.MemoryView":748
+    /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
- *             cindex = index
  *             slice_memviewslice(
+ *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
-    __pyx_t_1 = (PyIndex_Check(__pyx_v_index) != 0);
-    if (__pyx_t_1) {
+    __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":749
- *     for dim, index in enumerate(indices):
- *         if PyIndex_Check(index):
- *             cindex = index             # <<<<<<<<<<<<<<
- *             slice_memviewslice(
+      /* "View.MemoryView":751
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
+ *                 dim, new_ndim, p_suboffset_dim,
+ *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
+ *                 0, 0, 0, # have_{start,stop,step}
+ *                 False)
  */
-      __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 749, __pyx_L1_error)
-      __pyx_v_cindex = __pyx_t_9;
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 751, __pyx_L1_error)
 
-      /* "View.MemoryView":750
+      /* "View.MemoryView":748
+ *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
- *             cindex = index
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_10 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_cindex, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(1, 750, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 748, __pyx_L1_error)
 
-      /* "View.MemoryView":748
+      /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
- *             cindex = index
  *             slice_memviewslice(
+ *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":756
+    /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
-    __pyx_t_1 = (__pyx_v_index == Py_None);
+    __pyx_t_2 = (__pyx_v_index == Py_None);
+    __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":757
+      /* "View.MemoryView":755
  *                 False)
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1             # <<<<<<<<<<<<<<
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  */
       (__pyx_v_p_dst->shape[__pyx_v_new_ndim]) = 1;
 
-      /* "View.MemoryView":758
+      /* "View.MemoryView":756
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0             # <<<<<<<<<<<<<<
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1
  */
       (__pyx_v_p_dst->strides[__pyx_v_new_ndim]) = 0;
 
-      /* "View.MemoryView":759
+      /* "View.MemoryView":757
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1             # <<<<<<<<<<<<<<
  *             new_ndim += 1
  *         else:
  */
       (__pyx_v_p_dst->suboffsets[__pyx_v_new_ndim]) = -1L;
 
-      /* "View.MemoryView":760
+      /* "View.MemoryView":758
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  *         else:
  *             start = index.start or 0
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
 
-      /* "View.MemoryView":756
+      /* "View.MemoryView":754
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":762
+    /* "View.MemoryView":760
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 762, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 760, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 760, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 760, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
-      __pyx_v_start = __pyx_t_9;
+      __pyx_v_start = __pyx_t_10;
 
-      /* "View.MemoryView":763
+      /* "View.MemoryView":761
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 763, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 763, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 761, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 761, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 763, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 761, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
-      __pyx_v_stop = __pyx_t_9;
+      __pyx_v_stop = __pyx_t_10;
 
-      /* "View.MemoryView":764
+      /* "View.MemoryView":762
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 764, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
       if (!__pyx_t_1) {
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_8); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 764, __pyx_L1_error)
-        __pyx_t_9 = __pyx_t_11;
-        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
+        __pyx_t_10 = __pyx_t_12;
+        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
-      __pyx_t_9 = 0;
+      __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
-      __pyx_v_step = __pyx_t_9;
+      __pyx_v_step = __pyx_t_10;
 
-      /* "View.MemoryView":766
+      /* "View.MemoryView":764
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 766, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
-      /* "View.MemoryView":767
+      /* "View.MemoryView":765
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 767, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 765, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
-      /* "View.MemoryView":768
+      /* "View.MemoryView":766
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 768, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_1 = (__pyx_t_8 != Py_None);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_1 = (__pyx_t_9 != Py_None);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
-      /* "View.MemoryView":770
+      /* "View.MemoryView":768
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_10 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(1, 770, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 768, __pyx_L1_error)
 
-      /* "View.MemoryView":776
+      /* "View.MemoryView":774
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":747
+    /* "View.MemoryView":746
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
- *             cindex = index
+ *             slice_memviewslice(
  */
   }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":778
+  /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __Pyx_XDECREF((PyObject *)__pyx_r);
+    __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":780
+    /* "View.MemoryView":778
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 780, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 778, __pyx_L1_error) }
 
-    /* "View.MemoryView":781
+    /* "View.MemoryView":779
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 781, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 779, __pyx_L1_error) }
 
-    /* "View.MemoryView":779
+    /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 779, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_memoryview_type))))) __PYX_ERR(1, 779, __pyx_L1_error)
-    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 777, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 777, __pyx_L1_error)
+    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":778
+    /* "View.MemoryView":776
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
-  /* "View.MemoryView":784
+  /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
   /*else*/ {
-    __Pyx_XDECREF((PyObject *)__pyx_r);
+    __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":785
+    /* "View.MemoryView":783
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 784, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 782, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
 
-    /* "View.MemoryView":784
+    /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_memoryview_type))))) __PYX_ERR(1, 784, __pyx_L1_error)
-    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 782, __pyx_L1_error)
+    __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":711
+  /* "View.MemoryView":710
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("View.MemoryView.memview_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_memviewsliceobj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":793
+/* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -11896,775 +11871,781 @@
   int __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":813
+  /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
-  __pyx_t_1 = (!__pyx_v_is_slice);
+  __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":815
+    /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
-    __pyx_t_1 = (__pyx_v_start < 0);
+    __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":816
+      /* "View.MemoryView":830
  * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-      /* "View.MemoryView":815
+      /* "View.MemoryView":829
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
-    /* "View.MemoryView":817
+    /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     __pyx_t_1 = (0 <= __pyx_v_start);
     if (__pyx_t_1) {
       __pyx_t_1 = (__pyx_v_start < __pyx_v_shape);
     }
-    __pyx_t_2 = (!__pyx_t_1);
+    __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":818
+      /* "View.MemoryView":832
  *             start += shape
  *         if not 0 <= start < shape:
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_IndexError, __pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 818, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 832, __pyx_L1_error)
 
-      /* "View.MemoryView":817
+      /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_IndexError, "Index out of bounds (axis %d)", dim)
+ *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
-    /* "View.MemoryView":813
+    /* "View.MemoryView":827
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":821
+  /* "View.MemoryView":835
  *     else:
  * 
- *         if have_step:             # <<<<<<<<<<<<<<
- *             negative_step = step < 0
- *             if step == 0:
+ *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
+ * 
+ *         if have_step and step == 0:
  */
   /*else*/ {
-    __pyx_t_2 = (__pyx_v_have_step != 0);
-    if (__pyx_t_2) {
+    __pyx_t_1 = ((__pyx_v_have_step != 0) != 0);
+    if (__pyx_t_1) {
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+      goto __pyx_L6_bool_binop_done;
+    }
+    __pyx_t_1 = ((__pyx_v_step < 0) != 0);
+    __pyx_t_2 = __pyx_t_1;
+    __pyx_L6_bool_binop_done:;
+    __pyx_v_negative_step = __pyx_t_2;
 
-      /* "View.MemoryView":822
+    /* "View.MemoryView":837
+ *         negative_step = have_step != 0 and step < 0
  * 
- *         if have_step:
- *             negative_step = step < 0             # <<<<<<<<<<<<<<
- *             if step == 0:
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- */
-      __pyx_v_negative_step = (__pyx_v_step < 0);
-
-      /* "View.MemoryView":823
- *         if have_step:
- *             negative_step = step < 0
- *             if step == 0:             # <<<<<<<<<<<<<<
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- */
-      __pyx_t_2 = (__pyx_v_step == 0);
-      if (__pyx_t_2) {
-
-        /* "View.MemoryView":824
- *             negative_step = step < 0
- *             if step == 0:
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
- *         else:
- *             negative_step = False
- */
-        __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_ValueError, __pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 824, __pyx_L1_error)
-
-        /* "View.MemoryView":823
- *         if have_step:
- *             negative_step = step < 0
- *             if step == 0:             # <<<<<<<<<<<<<<
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- */
-      }
-
-      /* "View.MemoryView":821
- *     else:
+ *         if have_step and step == 0:             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
- *         if have_step:             # <<<<<<<<<<<<<<
- *             negative_step = step < 0
- *             if step == 0:
  */
-      goto __pyx_L6;
+    __pyx_t_1 = (__pyx_v_have_step != 0);
+    if (__pyx_t_1) {
+    } else {
+      __pyx_t_2 = __pyx_t_1;
+      goto __pyx_L9_bool_binop_done;
     }
+    __pyx_t_1 = ((__pyx_v_step == 0) != 0);
+    __pyx_t_2 = __pyx_t_1;
+    __pyx_L9_bool_binop_done:;
+    if (__pyx_t_2) {
 
-    /* "View.MemoryView":826
- *                 _err_dim(PyExc_ValueError, "Step may not be zero (axis %d)", dim)
- *         else:
- *             negative_step = False             # <<<<<<<<<<<<<<
- *             step = 1
+      /* "View.MemoryView":838
+ * 
+ *         if have_step and step == 0:
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
+ * 
  * 
  */
-    /*else*/ {
-      __pyx_v_negative_step = 0;
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 838, __pyx_L1_error)
 
-      /* "View.MemoryView":827
- *         else:
- *             negative_step = False
- *             step = 1             # <<<<<<<<<<<<<<
+      /* "View.MemoryView":837
+ *         negative_step = have_step != 0 and step < 0
  * 
+ *         if have_step and step == 0:             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
-      __pyx_v_step = 1;
     }
-    __pyx_L6:;
 
-    /* "View.MemoryView":830
+    /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":831
+      /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
-      __pyx_t_2 = (__pyx_v_start < 0);
+      __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":832
+        /* "View.MemoryView":843
  *         if have_start:
  *             if start < 0:
  *                 start += shape             # <<<<<<<<<<<<<<
  *                 if start < 0:
  *                     start = 0
  */
         __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-        /* "View.MemoryView":833
+        /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
-        __pyx_t_2 = (__pyx_v_start < 0);
+        __pyx_t_2 = ((__pyx_v_start < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":834
+          /* "View.MemoryView":845
  *                 start += shape
  *                 if start < 0:
  *                     start = 0             # <<<<<<<<<<<<<<
  *             elif start >= shape:
  *                 if negative_step:
  */
           __pyx_v_start = 0;
 
-          /* "View.MemoryView":833
+          /* "View.MemoryView":844
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
-        /* "View.MemoryView":831
+        /* "View.MemoryView":842
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
-        goto __pyx_L9;
+        goto __pyx_L12;
       }
 
-      /* "View.MemoryView":835
+      /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
-      __pyx_t_2 = (__pyx_v_start >= __pyx_v_shape);
+      __pyx_t_2 = ((__pyx_v_start >= __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":836
+        /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
-        if (__pyx_v_negative_step) {
+        __pyx_t_2 = (__pyx_v_negative_step != 0);
+        if (__pyx_t_2) {
 
-          /* "View.MemoryView":837
+          /* "View.MemoryView":848
  *             elif start >= shape:
  *                 if negative_step:
  *                     start = shape - 1             # <<<<<<<<<<<<<<
  *                 else:
  *                     start = shape
  */
           __pyx_v_start = (__pyx_v_shape - 1);
 
-          /* "View.MemoryView":836
+          /* "View.MemoryView":847
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
-          goto __pyx_L11;
+          goto __pyx_L14;
         }
 
-        /* "View.MemoryView":839
+        /* "View.MemoryView":850
  *                     start = shape - 1
  *                 else:
  *                     start = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         /*else*/ {
           __pyx_v_start = __pyx_v_shape;
         }
-        __pyx_L11:;
+        __pyx_L14:;
 
-        /* "View.MemoryView":835
+        /* "View.MemoryView":846
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
-      __pyx_L9:;
+      __pyx_L12:;
 
-      /* "View.MemoryView":830
+      /* "View.MemoryView":841
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
-      goto __pyx_L8;
+      goto __pyx_L11;
     }
 
-    /* "View.MemoryView":841
+    /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
     /*else*/ {
-      if (__pyx_v_negative_step) {
+      __pyx_t_2 = (__pyx_v_negative_step != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":842
+        /* "View.MemoryView":853
  *         else:
  *             if negative_step:
  *                 start = shape - 1             # <<<<<<<<<<<<<<
  *             else:
  *                 start = 0
  */
         __pyx_v_start = (__pyx_v_shape - 1);
 
-        /* "View.MemoryView":841
+        /* "View.MemoryView":852
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
-        goto __pyx_L12;
+        goto __pyx_L15;
       }
 
-      /* "View.MemoryView":844
+      /* "View.MemoryView":855
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
  * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
-      __pyx_L12:;
+      __pyx_L15:;
     }
-    __pyx_L8:;
+    __pyx_L11:;
 
-    /* "View.MemoryView":846
+    /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":847
+      /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
-      __pyx_t_2 = (__pyx_v_stop < 0);
+      __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":848
+        /* "View.MemoryView":859
  *         if have_stop:
  *             if stop < 0:
  *                 stop += shape             # <<<<<<<<<<<<<<
  *                 if stop < 0:
  *                     stop = 0
  */
         __pyx_v_stop = (__pyx_v_stop + __pyx_v_shape);
 
-        /* "View.MemoryView":849
+        /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
-        __pyx_t_2 = (__pyx_v_stop < 0);
+        __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":850
+          /* "View.MemoryView":861
  *                 stop += shape
  *                 if stop < 0:
  *                     stop = 0             # <<<<<<<<<<<<<<
  *             elif stop > shape:
  *                 stop = shape
  */
           __pyx_v_stop = 0;
 
-          /* "View.MemoryView":849
+          /* "View.MemoryView":860
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
-        /* "View.MemoryView":847
+        /* "View.MemoryView":858
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
-        goto __pyx_L14;
+        goto __pyx_L17;
       }
 
-      /* "View.MemoryView":851
+      /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
-      __pyx_t_2 = (__pyx_v_stop > __pyx_v_shape);
+      __pyx_t_2 = ((__pyx_v_stop > __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":852
+        /* "View.MemoryView":863
  *                     stop = 0
  *             elif stop > shape:
  *                 stop = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         __pyx_v_stop = __pyx_v_shape;
 
-        /* "View.MemoryView":851
+        /* "View.MemoryView":862
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       }
-      __pyx_L14:;
+      __pyx_L17:;
 
-      /* "View.MemoryView":846
+      /* "View.MemoryView":857
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
-      goto __pyx_L13;
+      goto __pyx_L16;
     }
 
-    /* "View.MemoryView":854
+    /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
     /*else*/ {
-      if (__pyx_v_negative_step) {
+      __pyx_t_2 = (__pyx_v_negative_step != 0);
+      if (__pyx_t_2) {
 
-        /* "View.MemoryView":855
+        /* "View.MemoryView":866
  *         else:
  *             if negative_step:
  *                 stop = -1             # <<<<<<<<<<<<<<
  *             else:
  *                 stop = shape
  */
         __pyx_v_stop = -1L;
 
-        /* "View.MemoryView":854
+        /* "View.MemoryView":865
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
-        goto __pyx_L16;
+        goto __pyx_L19;
       }
 
-      /* "View.MemoryView":857
+      /* "View.MemoryView":868
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
  * 
- * 
+ *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
-      __pyx_L16:;
+      __pyx_L19:;
     }
-    __pyx_L13:;
+    __pyx_L16:;
+
+    /* "View.MemoryView":870
+ *                 stop = shape
+ * 
+ *         if not have_step:             # <<<<<<<<<<<<<<
+ *             step = 1
+ * 
+ */
+    __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
+    if (__pyx_t_2) {
 
-    /* "View.MemoryView":861
+      /* "View.MemoryView":871
+ * 
+ *         if not have_step:
+ *             step = 1             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+      __pyx_v_step = 1;
+
+      /* "View.MemoryView":870
+ *                 stop = shape
+ * 
+ *         if not have_step:             # <<<<<<<<<<<<<<
+ *             step = 1
+ * 
+ */
+    }
+
+    /* "View.MemoryView":875
  * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
  * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
-    /* "View.MemoryView":863
+    /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":864
+      /* "View.MemoryView":878
  * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
  * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
-      /* "View.MemoryView":863
+      /* "View.MemoryView":877
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     }
 
-    /* "View.MemoryView":866
+    /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
-    __pyx_t_2 = (__pyx_v_new_shape < 0);
+    __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":867
+      /* "View.MemoryView":881
  * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_new_shape = 0;
 
-      /* "View.MemoryView":866
+      /* "View.MemoryView":880
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     }
 
-    /* "View.MemoryView":870
+    /* "View.MemoryView":884
  * 
  * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
-    /* "View.MemoryView":871
+    /* "View.MemoryView":885
  * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
  * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
-    /* "View.MemoryView":872
+    /* "View.MemoryView":886
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":875
+  /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
-  __pyx_t_2 = ((__pyx_v_suboffset_dim[0]) < 0);
+  __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":876
+    /* "View.MemoryView":890
  * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
-    /* "View.MemoryView":875
+    /* "View.MemoryView":889
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
-    goto __pyx_L19;
+    goto __pyx_L23;
   }
 
-  /* "View.MemoryView":878
+  /* "View.MemoryView":892
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
  * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
-  __pyx_L19:;
+  __pyx_L23:;
 
-  /* "View.MemoryView":880
+  /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
-  __pyx_t_2 = (__pyx_v_suboffset >= 0);
+  __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":881
+    /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
-    __pyx_t_2 = (!__pyx_v_is_slice);
+    __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":882
+      /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
-      __pyx_t_2 = (__pyx_v_new_ndim == 0);
+      __pyx_t_2 = ((__pyx_v_new_ndim == 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":883
+        /* "View.MemoryView":897
  *         if not is_slice:
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset             # <<<<<<<<<<<<<<
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  */
         __pyx_v_dst->data = ((((char **)__pyx_v_dst->data)[0]) + __pyx_v_suboffset);
 
-        /* "View.MemoryView":882
+        /* "View.MemoryView":896
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
-        goto __pyx_L22;
+        goto __pyx_L26;
       }
 
-      /* "View.MemoryView":885
+      /* "View.MemoryView":899
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
  *                                      "must be indexed and not sliced", dim)
  *         else:
  */
       /*else*/ {
 
-        /* "View.MemoryView":886
+        /* "View.MemoryView":900
  *             else:
- *                 _err_dim(PyExc_IndexError, "All dimensions preceding dimension %d "
+ *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(PyExc_IndexError, __pyx_kp_s_All_dimensions_preceding_dimensi, __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 885, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 899, __pyx_L1_error)
       }
-      __pyx_L22:;
+      __pyx_L26:;
 
-      /* "View.MemoryView":881
+      /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
-      goto __pyx_L21;
+      goto __pyx_L25;
     }
 
-    /* "View.MemoryView":888
+    /* "View.MemoryView":902
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
  * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
-    __pyx_L21:;
+    __pyx_L25:;
 
-    /* "View.MemoryView":880
+    /* "View.MemoryView":894
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
-  /* "View.MemoryView":890
+  /* "View.MemoryView":904
  *             suboffset_dim[0] = new_ndim
  * 
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":793
+  /* "View.MemoryView":807
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.slice_memviewslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.slice_memviewslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":896
+/* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -12675,335 +12656,308 @@
   Py_ssize_t __pyx_v_itemsize;
   char *__pyx_v_resultp;
   char *__pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  Py_UCS4 __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("pybuffer_index", 0);
 
-  /* "View.MemoryView":898
+  /* "View.MemoryView":912
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t itemsize = view.itemsize
  *     cdef char *resultp
  */
   __pyx_v_suboffset = -1L;
 
-  /* "View.MemoryView":899
+  /* "View.MemoryView":913
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
  * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":902
+  /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize
  */
-  __pyx_t_2 = (__pyx_v_view->ndim == 0);
+  __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":903
+    /* "View.MemoryView":917
  * 
  *     if view.ndim == 0:
- *         shape = view.len // itemsize             # <<<<<<<<<<<<<<
+ *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 903, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
-    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(__Pyx_UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
+    else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 903, __pyx_L1_error)
+      __PYX_ERR(1, 917, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
-    /* "View.MemoryView":904
+    /* "View.MemoryView":918
  *     if view.ndim == 0:
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
-    /* "View.MemoryView":902
+    /* "View.MemoryView":916
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
- *         shape = view.len // itemsize
+ *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":906
+  /* "View.MemoryView":920
  *         stride = itemsize
  *     else:
  *         shape = view.shape[dim]             # <<<<<<<<<<<<<<
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  */
   /*else*/ {
     __pyx_v_shape = (__pyx_v_view->shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":907
+    /* "View.MemoryView":921
  *     else:
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]             # <<<<<<<<<<<<<<
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]
  */
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":908
+    /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
-    __pyx_t_2 = (__pyx_v_view->suboffsets != NULL);
+    __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":909
+      /* "View.MemoryView":923
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
  * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
-      /* "View.MemoryView":908
+      /* "View.MemoryView":922
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":911
+  /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
-  __pyx_t_2 = (__pyx_v_index < 0);
+  __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":912
+    /* "View.MemoryView":926
  * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
-    /* "View.MemoryView":913
+    /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
-    __pyx_t_2 = (__pyx_v_index < 0);
+    __pyx_t_2 = ((__pyx_v_index < 0) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":914
+      /* "View.MemoryView":928
  *         index += view.shape[dim]
  *         if index < 0:
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"             # <<<<<<<<<<<<<<
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 914, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_1 = 0;
-      __pyx_t_4 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      __pyx_t_1 += 37;
-      __Pyx_GIVEREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-      __pyx_t_5 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 914, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_1 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_5);
-      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_5);
-      __pyx_t_5 = 0;
-      __Pyx_INCREF(__pyx_kp_u__7);
-      __pyx_t_1 += 1;
-      __Pyx_GIVEREF(__pyx_kp_u__7);
-      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u__7);
-      __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 914, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_Raise(__pyx_builtin_IndexError, __pyx_t_5, 0, 0);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(1, 914, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __PYX_ERR(1, 928, __pyx_L1_error)
 
-      /* "View.MemoryView":913
+      /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     }
 
-    /* "View.MemoryView":911
+    /* "View.MemoryView":925
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
-  /* "View.MemoryView":916
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+  /* "View.MemoryView":930
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
-  __pyx_t_2 = (__pyx_v_index >= __pyx_v_shape);
+  __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":917
+    /* "View.MemoryView":931
  * 
  *     if index >= shape:
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"             # <<<<<<<<<<<<<<
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 917, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = 0;
-    __pyx_t_4 = 127;
-    __Pyx_INCREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    __pyx_t_1 += 37;
-    __Pyx_GIVEREF(__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Out_of_bounds_on_buffer_access_a);
-    __pyx_t_3 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_dim, 0, ' ', 'd'); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 917, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __Pyx_INCREF(__pyx_kp_u__7);
-    __pyx_t_1 += 1;
-    __Pyx_GIVEREF(__pyx_kp_u__7);
-    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u__7);
-    __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_5, 3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 917, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 931, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_Raise(__pyx_builtin_IndexError, __pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 917, __pyx_L1_error)
+    __PYX_ERR(1, 931, __pyx_L1_error)
 
-    /* "View.MemoryView":916
- *             raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+    /* "View.MemoryView":930
+ *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   }
 
-  /* "View.MemoryView":919
- *         raise IndexError, f"Out of bounds on buffer access (axis {dim})"
+  /* "View.MemoryView":933
+ *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
-  /* "View.MemoryView":920
+  /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
-  __pyx_t_2 = (__pyx_v_suboffset >= 0);
+  __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":921
+    /* "View.MemoryView":935
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
  * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
-    /* "View.MemoryView":920
+    /* "View.MemoryView":934
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   }
 
-  /* "View.MemoryView":923
+  /* "View.MemoryView":937
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  *     return resultp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":896
+  /* "View.MemoryView":910
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView.pybuffer_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":929
+/* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:             # <<<<<<<<<<<<<<
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
 static int __pyx_memslice_transpose(__Pyx_memviewslice *__pyx_v_memslice) {
   int __pyx_v_ndim;
   Py_ssize_t *__pyx_v_shape;
@@ -13019,209 +12973,207 @@
   Py_ssize_t __pyx_t_6;
   int __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":930
+  /* "View.MemoryView":944
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
-  /* "View.MemoryView":932
+  /* "View.MemoryView":946
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
-  /* "View.MemoryView":933
+  /* "View.MemoryView":947
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
-  /* "View.MemoryView":937
+  /* "View.MemoryView":951
  * 
  *     cdef int i, j
- *     for i in range(ndim // 2):             # <<<<<<<<<<<<<<
+ *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = __Pyx_div_long(__pyx_v_ndim, 2);
   __pyx_t_4 = __pyx_t_3;
   for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_4; __pyx_t_1+=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":938
+    /* "View.MemoryView":952
  *     cdef int i, j
- *     for i in range(ndim // 2):
+ *     for i in range(ndim / 2):
  *         j = ndim - 1 - i             # <<<<<<<<<<<<<<
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]
  */
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
-    /* "View.MemoryView":939
- *     for i in range(ndim // 2):
+    /* "View.MemoryView":953
+ *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  */
     __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
     __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
     (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
     (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
-    /* "View.MemoryView":940
+    /* "View.MemoryView":954
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
     __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
     __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
     (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
     (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
-    /* "View.MemoryView":942
+    /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
-    __pyx_t_8 = ((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0);
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
     if (!__pyx_t_8) {
     } else {
       __pyx_t_7 = __pyx_t_8;
       goto __pyx_L6_bool_binop_done;
     }
-    __pyx_t_8 = ((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0);
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
     __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
     if (__pyx_t_7) {
 
-      /* "View.MemoryView":943
+      /* "View.MemoryView":957
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
- *     return 0
+ *     return 1
  */
-      __pyx_t_9 = __pyx_memoryview_err(PyExc_ValueError, __pyx_kp_s_Cannot_transpose_memoryview_with); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 943, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 957, __pyx_L1_error)
 
-      /* "View.MemoryView":942
+      /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":945
- *             _err(PyExc_ValueError, "Cannot transpose memoryview with indirect dimensions")
+  /* "View.MemoryView":959
+ *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
- *     return 0             # <<<<<<<<<<<<<<
+ *     return 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_r = 0;
+  __pyx_r = 1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":929
+  /* "View.MemoryView":943
  * 
  * @cname('__pyx_memslice_transpose')
- * cdef int transpose_memslice(__Pyx_memviewslice *memslice) except -1 nogil:             # <<<<<<<<<<<<<<
+ * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.transpose_memslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.transpose_memslice", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
+  __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":963
+/* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
 /* Python wrapper */
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_memoryviewslice___dealloc__(PyObject *__pyx_v_self) {
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
   __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":964
+  /* "View.MemoryView":977
  * 
  *     def __dealloc__(self):
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __PYX_XCLEAR_MEMVIEW((&__pyx_v_self->from_slice), 1);
+  __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
-  /* "View.MemoryView":963
+  /* "View.MemoryView":976
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":966
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+/* "View.MemoryView":979
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp) {
@@ -13230,65 +13182,65 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":967
+  /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
-  __pyx_t_1 = (__pyx_v_self->to_object_func != NULL);
+  __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":968
+    /* "View.MemoryView":981
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 968, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 981, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":967
+    /* "View.MemoryView":980
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
-  /* "View.MemoryView":970
+  /* "View.MemoryView":983
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 970, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":966
- *         __PYX_XCLEAR_MEMVIEW(&self.from_slice, 1)
+  /* "View.MemoryView":979
+ *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
   /* function exit code */
@@ -13298,15 +13250,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":972
+/* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13317,58 +13269,58 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":973
+  /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
-  __pyx_t_1 = (__pyx_v_self->to_dtype_func != NULL);
+  __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":974
+    /* "View.MemoryView":987
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 974, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 987, __pyx_L1_error)
 
-    /* "View.MemoryView":973
+    /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":976
+  /* "View.MemoryView":989
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
- *     cdef _get_base(self):
+ *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 976, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 989, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":972
+  /* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -13381,226 +13333,173 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":978
- *             memoryview.assign_item_from_object(self, itemp, value)
+/* "View.MemoryView":992
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
-static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
+/* Python wrapper */
+static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_get_base", 0);
+  __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":979
- * 
- *     cdef _get_base(self):
+  /* "View.MemoryView":993
+ *     @property
+ *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
  * 
- * 
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
-  /* "View.MemoryView":978
- *             memoryview.assign_item_from_object(self, itemp, value)
+  /* "View.MemoryView":992
  * 
- *     cdef _get_base(self):             # <<<<<<<<<<<<<<
+ *     @property
+ *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  if (unlikely(__pyx_nargs > 0)) {
-    __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
-  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
   __pyx_r = __pyx_pf___pyx_memoryviewslice___reduce_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
+static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_state,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 3, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__setstate_cython__") < 0)) __PYX_ERR(1, 3, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v___pyx_state = values[0];
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__setstate_cython__", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 3, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf___pyx_memoryviewslice_2__setstate_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf___pyx_memoryviewslice_2__setstate_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_kp_s_no_default___reduce___due_to_non, 0, 0);
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(1, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
- *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -13635,15 +13534,15 @@
   /* "View.MemoryView":1007
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
-  __pyx_t_1 = (((PyObject *)__pyx_v_memviewslice.memview) == Py_None);
+  __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":1008
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
  * 
@@ -13661,15 +13560,15 @@
  * 
  */
   }
 
   /* "View.MemoryView":1013
  * 
  * 
- *     result = _memoryviewslice.__new__(_memoryviewslice, None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
+ *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
   __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
@@ -13678,56 +13577,56 @@
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = ((PyObject *)__pyx_tp_new__memoryviewslice(((PyTypeObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
-  __Pyx_GOTREF((PyObject *)__pyx_t_2);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1015
- *     result = _memoryviewslice.__new__(_memoryviewslice, None, 0, dtype_is_object)
+ *     result = _memoryviewslice(None, 0, dtype_is_object)
  * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
   /* "View.MemoryView":1016
  * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()
+ *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
   /* "View.MemoryView":1018
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()             # <<<<<<<<<<<<<<
+ *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->__pyx_vtab)->_get_base(((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1019
  * 
- *     result.from_object = (<memoryview> memviewslice.memview)._get_base()
+ *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
  * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
@@ -13860,15 +13759,15 @@
     /* "View.MemoryView":1038
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
-    __pyx_t_1 = (__pyx_v_suboffset >= 0);
+    __pyx_t_1 = ((__pyx_v_suboffset >= 0) != 0);
     if (__pyx_t_1) {
 
       /* "View.MemoryView":1039
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
@@ -13960,15 +13859,15 @@
  *     result.to_dtype_func = to_dtype_func
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF((PyObject *)__pyx_v_result);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
   /* "View.MemoryView":999
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
@@ -13999,42 +13898,44 @@
  */
 
 static __Pyx_memviewslice *__pyx_memoryview_get_slice_from_memoryview(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_mslice) {
   struct __pyx_memoryviewslice_obj *__pyx_v_obj = 0;
   __Pyx_memviewslice *__pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_slice_from_memview", 0);
 
   /* "View.MemoryView":1055
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "View.MemoryView":1056
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
     if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1056, __pyx_L1_error)
-    __pyx_t_2 = ((PyObject *)__pyx_v_memview);
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
-    __pyx_t_2 = 0;
+    __pyx_t_3 = ((PyObject *)__pyx_v_memview);
+    __Pyx_INCREF(__pyx_t_3);
+    __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
+    __pyx_t_3 = 0;
 
     /* "View.MemoryView":1057
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview
  *         return &obj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, mslice)
@@ -14078,27 +13979,27 @@
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice) except NULL:
  *     cdef _memoryviewslice obj
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.get_slice_from_memview", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
- * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst) noexcept:             # <<<<<<<<<<<<<<
+ * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
 static void __pyx_memoryview_slice_copy(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_dst) {
   int __pyx_v_dim;
   Py_ssize_t *__pyx_v_shape;
@@ -14204,15 +14105,15 @@
     }
     (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
   /* "View.MemoryView":1063
  * 
  * @cname('__pyx_memoryview_slice_copy')
- * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst) noexcept:             # <<<<<<<<<<<<<<
+ * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
@@ -14287,51 +14188,53 @@
 
 static PyObject *__pyx_memoryview_copy_object_from_slice(struct __pyx_memoryview_obj *__pyx_v_memview, __Pyx_memviewslice *__pyx_v_memviewslice) {
   PyObject *(*__pyx_v_to_object_func)(char *);
   int (*__pyx_v_to_dtype_func)(char *, PyObject *);
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  PyObject *(*__pyx_t_2)(char *);
-  int (*__pyx_t_3)(char *, PyObject *);
-  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_2;
+  PyObject *(*__pyx_t_3)(char *);
+  int (*__pyx_t_4)(char *, PyObject *);
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
   /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
-  if (__pyx_t_1) {
+  __pyx_t_2 = (__pyx_t_1 != 0);
+  if (__pyx_t_2) {
 
     /* "View.MemoryView":1095
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
-    __pyx_t_2 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
-    __pyx_v_to_object_func = __pyx_t_2;
+    __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
+    __pyx_v_to_object_func = __pyx_t_3;
 
     /* "View.MemoryView":1096
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func             # <<<<<<<<<<<<<<
  *     else:
  *         to_object_func = NULL
  */
-    __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
-    __pyx_v_to_dtype_func = __pyx_t_3;
+    __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
+    __pyx_v_to_dtype_func = __pyx_t_4;
 
     /* "View.MemoryView":1094
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
@@ -14372,270 +14275,296 @@
   /* "View.MemoryView":1103
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1087
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.memoryview_copy_from_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "View.MemoryView":1109
  * 
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:             # <<<<<<<<<<<<<<
- *     return -arg if arg < 0 else arg
- * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
+ *     if arg < 0:
+ *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
-  Py_ssize_t __pyx_t_1;
+  int __pyx_t_1;
 
   /* "View.MemoryView":1110
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:
- *     return -arg if arg < 0 else arg             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:             # <<<<<<<<<<<<<<
+ *         return -arg
+ *     else:
+ */
+  __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":1111
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:
+ *         return -arg             # <<<<<<<<<<<<<<
+ *     else:
+ *         return arg
+ */
+    __pyx_r = (-__pyx_v_arg);
+    goto __pyx_L0;
+
+    /* "View.MemoryView":1110
+ * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
+ *     if arg < 0:             # <<<<<<<<<<<<<<
+ *         return -arg
+ *     else:
+ */
+  }
+
+  /* "View.MemoryView":1113
+ *         return -arg
+ *     else:
+ *         return arg             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_get_best_slice_order')
  */
-  if ((__pyx_v_arg < 0)) {
-    __pyx_t_1 = (-__pyx_v_arg);
-  } else {
-    __pyx_t_1 = __pyx_v_arg;
+  /*else*/ {
+    __pyx_r = __pyx_v_arg;
+    goto __pyx_L0;
   }
-  __pyx_r = __pyx_t_1;
-  goto __pyx_L0;
 
   /* "View.MemoryView":1109
  * 
  * 
- * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) noexcept nogil:             # <<<<<<<<<<<<<<
- *     return -arg if arg < 0 else arg
- * 
+ * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
+ *     if arg < 0:
+ *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1113
+/* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
- * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
 static char __pyx_get_best_slice_order(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim) {
   int __pyx_v_i;
   Py_ssize_t __pyx_v_c_stride;
   Py_ssize_t __pyx_v_f_stride;
   char __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1118
+  /* "View.MemoryView":1121
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
  * 
  */
   __pyx_v_c_stride = 0;
 
-  /* "View.MemoryView":1119
+  /* "View.MemoryView":1122
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
-  /* "View.MemoryView":1121
+  /* "View.MemoryView":1124
  *     cdef Py_ssize_t f_stride = 0
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1122
+    /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
-    __pyx_t_2 = ((__pyx_v_mslice->shape[__pyx_v_i]) > 1);
+    __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1123
+      /* "View.MemoryView":1126
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1124
+      /* "View.MemoryView":1127
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
-      /* "View.MemoryView":1122
+      /* "View.MemoryView":1125
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
-  /* "View.MemoryView":1126
+  /* "View.MemoryView":1129
  *             break
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_1;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1127
+    /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
-    __pyx_t_2 = ((__pyx_v_mslice->shape[__pyx_v_i]) > 1);
+    __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1128
+      /* "View.MemoryView":1131
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1129
+      /* "View.MemoryView":1132
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
-      /* "View.MemoryView":1127
+      /* "View.MemoryView":1130
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
-  /* "View.MemoryView":1131
+  /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
-  __pyx_t_2 = (abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride));
+  __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1132
+    /* "View.MemoryView":1135
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
-    /* "View.MemoryView":1131
+    /* "View.MemoryView":1134
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
-  /* "View.MemoryView":1134
+  /* "View.MemoryView":1137
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
  * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1113
+  /* "View.MemoryView":1116
  * 
  * @cname('__pyx_get_best_slice_order')
- * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1137
+/* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
@@ -14643,458 +14572,460 @@
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   CYTHON_UNUSED Py_ssize_t __pyx_v_src_extent;
   Py_ssize_t __pyx_v_dst_extent;
   Py_ssize_t __pyx_v_src_stride;
   Py_ssize_t __pyx_v_dst_stride;
   int __pyx_t_1;
   int __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
+  int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
+  Py_ssize_t __pyx_t_6;
 
-  /* "View.MemoryView":1144
+  /* "View.MemoryView":1147
  * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
-  /* "View.MemoryView":1145
+  /* "View.MemoryView":1148
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  */
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
-  /* "View.MemoryView":1146
+  /* "View.MemoryView":1149
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
-  /* "View.MemoryView":1147
+  /* "View.MemoryView":1150
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
-  /* "View.MemoryView":1149
+  /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
-  __pyx_t_1 = (__pyx_v_ndim == 1);
+  __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1150
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
-    __pyx_t_2 = (__pyx_v_src_stride > 0);
+    __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
-    __pyx_t_2 = (__pyx_v_dst_stride > 0);
+    __pyx_t_2 = ((__pyx_v_dst_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
 
-    /* "View.MemoryView":1151
+    /* "View.MemoryView":1154
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
- *         else:
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        else:
  */
     __pyx_t_2 = (((size_t)__pyx_v_src_stride) == __pyx_v_itemsize);
     if (__pyx_t_2) {
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
-    __pyx_t_1 = __pyx_t_2;
+    __pyx_t_3 = (__pyx_t_2 != 0);
+    __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
-    /* "View.MemoryView":1150
+    /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1152
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
- *         else:
- *             for i in range(dst_extent):
+      /* "View.MemoryView":1155
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
+ *        else:
+ *            for i in range(dst_extent):
  */
       (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
-      /* "View.MemoryView":1150
+      /* "View.MemoryView":1153
  * 
  *     if ndim == 1:
- *         if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
 
-    /* "View.MemoryView":1154
- *             memcpy(dst_data, src_data, itemsize * dst_extent)
- *         else:
- *             for i in range(dst_extent):             # <<<<<<<<<<<<<<
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride
+    /* "View.MemoryView":1157
+ *            memcpy(dst_data, src_data, itemsize * dst_extent)
+ *        else:
+ *            for i in range(dst_extent):             # <<<<<<<<<<<<<<
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride
  */
     /*else*/ {
-      __pyx_t_3 = __pyx_v_dst_extent;
-      __pyx_t_4 = __pyx_t_3;
-      for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-        __pyx_v_i = __pyx_t_5;
-
-        /* "View.MemoryView":1155
- *         else:
- *             for i in range(dst_extent):
- *                 memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
- *                 src_data += src_stride
- *                 dst_data += dst_stride
+      __pyx_t_4 = __pyx_v_dst_extent;
+      __pyx_t_5 = __pyx_t_4;
+      for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+        __pyx_v_i = __pyx_t_6;
+
+        /* "View.MemoryView":1158
+ *        else:
+ *            for i in range(dst_extent):
+ *                memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
+ *                src_data += src_stride
+ *                dst_data += dst_stride
  */
         (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize));
 
-        /* "View.MemoryView":1156
- *             for i in range(dst_extent):
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride             # <<<<<<<<<<<<<<
- *                 dst_data += dst_stride
+        /* "View.MemoryView":1159
+ *            for i in range(dst_extent):
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride             # <<<<<<<<<<<<<<
+ *                dst_data += dst_stride
  *     else:
  */
         __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-        /* "View.MemoryView":1157
- *                 memcpy(dst_data, src_data, itemsize)
- *                 src_data += src_stride
- *                 dst_data += dst_stride             # <<<<<<<<<<<<<<
+        /* "View.MemoryView":1160
+ *                memcpy(dst_data, src_data, itemsize)
+ *                src_data += src_stride
+ *                dst_data += dst_stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(dst_extent):
  */
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
-    /* "View.MemoryView":1149
+    /* "View.MemoryView":1152
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
- *         if (src_stride > 0 and dst_stride > 0 and
- *             <size_t> src_stride == itemsize == <size_t> dst_stride):
+ *        if (src_stride > 0 and dst_stride > 0 and
+ *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1159
- *                 dst_data += dst_stride
+  /* "View.MemoryView":1162
+ *                dst_data += dst_stride
  *     else:
  *         for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *             _copy_strided_to_strided(src_data, src_strides + 1,
  *                                      dst_data, dst_strides + 1,
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_v_dst_extent;
-    __pyx_t_4 = __pyx_t_3;
-    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-      __pyx_v_i = __pyx_t_5;
+    __pyx_t_4 = __pyx_v_dst_extent;
+    __pyx_t_5 = __pyx_t_4;
+    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+      __pyx_v_i = __pyx_t_6;
 
-      /* "View.MemoryView":1160
+      /* "View.MemoryView":1163
  *     else:
  *         for i in range(dst_extent):
  *             _copy_strided_to_strided(src_data, src_strides + 1,             # <<<<<<<<<<<<<<
  *                                      dst_data, dst_strides + 1,
  *                                      src_shape + 1, dst_shape + 1,
  */
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
-      /* "View.MemoryView":1164
+      /* "View.MemoryView":1167
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
  * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-      /* "View.MemoryView":1165
+      /* "View.MemoryView":1168
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1137
+  /* "View.MemoryView":1140
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1167
+/* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
-  /* "View.MemoryView":1170
+  /* "View.MemoryView":1173
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
  * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1167
+  /* "View.MemoryView":1170
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
- *                                   int ndim, size_t itemsize) noexcept nogil:
+ *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1174
+/* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *__pyx_v_src, int __pyx_v_ndim) {
   Py_ssize_t __pyx_v_shape;
   Py_ssize_t __pyx_v_size;
   Py_ssize_t __pyx_r;
   Py_ssize_t __pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
 
-  /* "View.MemoryView":1176
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:
+  /* "View.MemoryView":1179
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     for shape in src.shape[:ndim]:
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
-  /* "View.MemoryView":1178
+  /* "View.MemoryView":1181
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  * 
  *     for shape in src.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         size *= shape
  * 
  */
   __pyx_t_3 = (__pyx_v_src->shape + __pyx_v_ndim);
   for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_shape = (__pyx_t_2[0]);
 
-    /* "View.MemoryView":1179
+    /* "View.MemoryView":1182
  * 
  *     for shape in src.shape[:ndim]:
  *         size *= shape             # <<<<<<<<<<<<<<
  * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * __pyx_v_shape);
   }
 
-  /* "View.MemoryView":1181
+  /* "View.MemoryView":1184
  *         size *= shape
  * 
  *     return size             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1174
+  /* "View.MemoryView":1177
  * 
  * @cname('__pyx_memoryview_slice_get_size')
- * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef Py_ssize_t shape, size = src.memview.view.itemsize
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1184
+/* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
- *                 int ndim, char order) noexcept nogil:
+ *                 int ndim, char order) nogil:
  */
 
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, Py_ssize_t __pyx_v_stride, int __pyx_v_ndim, char __pyx_v_order) {
   int __pyx_v_idx;
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
 
-  /* "View.MemoryView":1193
+  /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
-  __pyx_t_1 = (__pyx_v_order == 'F');
+  __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1194
+    /* "View.MemoryView":1197
  * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_idx = __pyx_t_4;
 
-      /* "View.MemoryView":1195
+      /* "View.MemoryView":1198
  *     if order == 'F':
  *         for idx in range(ndim):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  *     else:
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1196
+      /* "View.MemoryView":1199
  *         for idx in range(ndim):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
-    /* "View.MemoryView":1193
+    /* "View.MemoryView":1196
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1198
+  /* "View.MemoryView":1201
  *             stride *= shape[idx]
  *     else:
  *         for idx in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride *= shape[idx]
  */
   /*else*/ {
     for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1; __pyx_t_2-=1) {
       __pyx_v_idx = __pyx_t_2;
 
-      /* "View.MemoryView":1199
+      /* "View.MemoryView":1202
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride *= shape[idx]
  * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1200
+      /* "View.MemoryView":1203
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride *= shape[idx]             # <<<<<<<<<<<<<<
  * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1202
+  /* "View.MemoryView":1205
  *             stride *= shape[idx]
  * 
  *     return stride             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1184
+  /* "View.MemoryView":1187
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
- *                 int ndim, char order) noexcept nogil:
+ *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1205
+/* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -15109,501 +15040,529 @@
   int __pyx_t_3;
   struct __pyx_memoryview_obj *__pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":1216
+  /* "View.MemoryView":1219
  *     cdef void *result
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1217
+  /* "View.MemoryView":1220
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
  * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
-  /* "View.MemoryView":1219
+  /* "View.MemoryView":1222
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
-  /* "View.MemoryView":1220
+  /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  * 
  */
-  __pyx_t_2 = (!(__pyx_v_result != 0));
+  __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1221
+    /* "View.MemoryView":1224
  *     result = malloc(size)
  *     if not result:
- *         _err_no_memory()             # <<<<<<<<<<<<<<
+ *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err_no_memory(); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1221, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1224, __pyx_L1_error)
 
-    /* "View.MemoryView":1220
+    /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
- *         _err_no_memory()
+ *         _err(MemoryError, NULL)
  * 
  */
   }
 
-  /* "View.MemoryView":1224
+  /* "View.MemoryView":1227
  * 
  * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
-  /* "View.MemoryView":1225
+  /* "View.MemoryView":1228
  * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
 
-  /* "View.MemoryView":1226
+  /* "View.MemoryView":1229
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1227
+    /* "View.MemoryView":1230
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1228
+    /* "View.MemoryView":1231
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
- *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize, ndim, order)
+ *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1230
+  /* "View.MemoryView":1233
  *         tmpslice.suboffsets[i] = -1
  * 
- *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize, ndim, order)             # <<<<<<<<<<<<<<
- * 
+ *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
+ *                               ndim, order)
  * 
  */
   (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
-  /* "View.MemoryView":1233
+  /* "View.MemoryView":1237
  * 
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
   __pyx_t_5 = __pyx_t_3;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1234
+    /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
-    __pyx_t_2 = ((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1);
+    __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1235
+      /* "View.MemoryView":1239
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
  * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
-      /* "View.MemoryView":1234
+      /* "View.MemoryView":1238
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1237
+  /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
-  __pyx_t_2 = __pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim);
+  __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1238
+    /* "View.MemoryView":1242
  * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
     (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
-    /* "View.MemoryView":1237
+    /* "View.MemoryView":1241
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":1240
+  /* "View.MemoryView":1244
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":1242
+  /* "View.MemoryView":1246
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1205
+  /* "View.MemoryView":1208
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.copy_data_to_temp", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.copy_data_to_temp", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = NULL;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1247
+/* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
 static int __pyx_memoryview_err_extents(int __pyx_v_i, Py_ssize_t __pyx_v_extent1, Py_ssize_t __pyx_v_extent2) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  Py_UCS4 __pyx_t_3;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
-  /* "View.MemoryView":1249
- * cdef int _err_extents(int i, Py_ssize_t extent1,
+  /* "View.MemoryView":1254
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"             # <<<<<<<<<<<<<<
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
+ *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = 0;
-  __pyx_t_3 = 127;
-  __Pyx_INCREF(__pyx_kp_u_got_differing_extents_in_dimensi);
-  __pyx_t_2 += 35;
-  __Pyx_GIVEREF(__pyx_kp_u_got_differing_extents_in_dimensi);
-  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_got_differing_extents_in_dimensi);
-  __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_i, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u_got);
-  __pyx_t_2 += 6;
-  __Pyx_GIVEREF(__pyx_kp_u_got);
-  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_got);
-  __pyx_t_4 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_extent1, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u_and);
-  __pyx_t_2 += 5;
-  __Pyx_GIVEREF(__pyx_kp_u_and);
-  PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u_and);
-  __pyx_t_4 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_v_extent2, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_t_4);
-  __pyx_t_4 = 0;
-  __Pyx_INCREF(__pyx_kp_u__7);
-  __pyx_t_2 += 1;
-  __Pyx_GIVEREF(__pyx_kp_u__7);
-  PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_kp_u__7);
-  __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1249, __pyx_L1_error)
+  __Pyx_GIVEREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
+  __pyx_t_1 = 0;
+  __pyx_t_2 = 0;
+  __pyx_t_3 = 0;
+
+  /* "View.MemoryView":1253
+ * cdef int _err_extents(int i, Py_ssize_t extent1,
+ *                              Py_ssize_t extent2) except -1 with gil:
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
+ *                                                         (i, extent1, extent2))
+ * 
+ */
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_Raise(__pyx_builtin_ValueError, __pyx_t_4, 0, 0);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_ERR(1, 1249, __pyx_L1_error)
+  __PYX_ERR(1, 1253, __pyx_L1_error)
 
-  /* "View.MemoryView":1247
+  /* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
- *     raise ValueError, f"got differing extents in dimension {i} (got {extent1} and {extent2})"
+ *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView._err_extents", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1252
+/* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg % dim
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
-static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, PyObject *__pyx_v_msg, int __pyx_v_dim) {
+static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, char *__pyx_v_msg, int __pyx_v_dim) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_dim", 0);
-  __Pyx_INCREF(__pyx_v_msg);
+  __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1253
+  /* "View.MemoryView":1258
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:
- *     raise <object>error, msg % dim             # <<<<<<<<<<<<<<
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
+ *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1253, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyString_FormatSafe(__pyx_v_msg, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_Raise(((PyObject *)__pyx_v_error), __pyx_t_2, 0, 0);
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __PYX_ERR(1, 1253, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_INCREF(__pyx_v_error);
+  __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(1, 1258, __pyx_L1_error)
 
-  /* "View.MemoryView":1252
+  /* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
- * cdef int _err_dim(PyObject *error, str msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg % dim
+ * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView._err_dim", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
-  __Pyx_XDECREF(__pyx_v_msg);
+  __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1256
+/* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg
- * 
+ * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))
  */
 
-static int __pyx_memoryview_err(PyObject *__pyx_v_error, PyObject *__pyx_v_msg) {
+static int __pyx_memoryview_err(PyObject *__pyx_v_error, char *__pyx_v_msg) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err", 0);
-  __Pyx_INCREF(__pyx_v_msg);
+  __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1257
+  /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:
- *     raise <object>error, msg             # <<<<<<<<<<<<<<
- * 
- * @cname('__pyx_memoryview_err_no_memory')
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:             # <<<<<<<<<<<<<<
+ *         raise error(msg.decode('ascii'))
+ *     else:
  */
-  __Pyx_Raise(((PyObject *)__pyx_v_error), __pyx_v_msg, 0, 0);
-  __PYX_ERR(1, 1257, __pyx_L1_error)
+  __pyx_t_1 = ((__pyx_v_msg != NULL) != 0);
+  if (unlikely(__pyx_t_1)) {
 
-  /* "View.MemoryView":1256
- * 
- * @cname('__pyx_memoryview_err')
- * cdef int _err(PyObject *error, str msg) except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise <object>error, msg
- * 
+    /* "View.MemoryView":1263
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
+ *     else:
+ *         raise error
  */
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_v_error);
+    __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(1, 1263, __pyx_L1_error)
 
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._err", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __Pyx_XDECREF(__pyx_v_msg);
-  __Pyx_RefNannyFinishContext();
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
-  return __pyx_r;
-}
-
-/* "View.MemoryView":1260
- * 
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise MemoryError
- * 
+    /* "View.MemoryView":1262
+ * @cname('__pyx_memoryview_err')
+ * cdef int _err(object error, char *msg) except -1 with gil:
+ *     if msg != NULL:             # <<<<<<<<<<<<<<
+ *         raise error(msg.decode('ascii'))
+ *     else:
  */
+  }
 
-static int __pyx_memoryview_err_no_memory(void) {
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_RefNannySetupContext("_err_no_memory", 0);
-
-  /* "View.MemoryView":1261
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:
- *     raise MemoryError             # <<<<<<<<<<<<<<
- * 
+  /* "View.MemoryView":1265
+ *         raise error(msg.decode('ascii'))
+ *     else:
+ *         raise error             # <<<<<<<<<<<<<<
  * 
+ * @cname('__pyx_memoryview_copy_contents')
  */
-  PyErr_NoMemory(); __PYX_ERR(1, 1261, __pyx_L1_error)
+  /*else*/ {
+    __Pyx_Raise(__pyx_v_error, 0, 0, 0);
+    __PYX_ERR(1, 1265, __pyx_L1_error)
+  }
 
-  /* "View.MemoryView":1260
- * 
- * @cname('__pyx_memoryview_err_no_memory')
- * cdef int _err_no_memory() except -1 with gil:             # <<<<<<<<<<<<<<
- *     raise MemoryError
+  /* "View.MemoryView":1261
  * 
+ * @cname('__pyx_memoryview_err')
+ * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
+ *     if msg != NULL:
+ *         raise error(msg.decode('ascii'))
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_AddTraceback("View.MemoryView._err_no_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("View.MemoryView._err", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
+  __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1265
+/* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -15620,1167 +15579,1151 @@
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   void *__pyx_t_7;
+  int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  #ifdef WITH_THREAD
-  PyGILState_STATE __pyx_gilstate_save;
-  #endif
 
-  /* "View.MemoryView":1273
+  /* "View.MemoryView":1276
  *     Check for overlapping memory and verify the shapes.
  *     """
  *     cdef void *tmpdata = NULL             # <<<<<<<<<<<<<<
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  */
   __pyx_v_tmpdata = NULL;
 
-  /* "View.MemoryView":1274
+  /* "View.MemoryView":1277
  *     """
  *     cdef void *tmpdata = NULL
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  */
   __pyx_t_1 = __pyx_v_src.memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1276
+  /* "View.MemoryView":1279
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)             # <<<<<<<<<<<<<<
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False
  */
   __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_src), __pyx_v_src_ndim);
 
-  /* "View.MemoryView":1277
+  /* "View.MemoryView":1280
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False             # <<<<<<<<<<<<<<
  *     cdef bint direct_copy = False
  *     cdef __Pyx_memviewslice tmp
  */
   __pyx_v_broadcasting = 0;
 
-  /* "View.MemoryView":1278
+  /* "View.MemoryView":1281
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
  * 
  */
   __pyx_v_direct_copy = 0;
 
-  /* "View.MemoryView":1281
+  /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
-  __pyx_t_2 = (__pyx_v_src_ndim < __pyx_v_dst_ndim);
+  __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1282
+    /* "View.MemoryView":1285
  * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
-    /* "View.MemoryView":1281
+    /* "View.MemoryView":1284
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1283
+  /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
-  __pyx_t_2 = (__pyx_v_dst_ndim < __pyx_v_src_ndim);
+  __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1284
+    /* "View.MemoryView":1287
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
-    /* "View.MemoryView":1283
+    /* "View.MemoryView":1286
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1286
+  /* "View.MemoryView":1289
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
   __pyx_t_4 = __pyx_v_src_ndim;
-  if ((__pyx_t_3 > __pyx_t_4)) {
+  if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
-  /* "View.MemoryView":1288
+  /* "View.MemoryView":1291
  *     cdef int ndim = max(src_ndim, dst_ndim)
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
   __pyx_t_3 = __pyx_t_5;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1289
+    /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
-    __pyx_t_2 = ((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i]));
+    __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1290
+      /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
-      __pyx_t_2 = ((__pyx_v_src.shape[__pyx_v_i]) == 1);
+      __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) == 1) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":1291
+        /* "View.MemoryView":1294
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  *                 broadcasting = True             # <<<<<<<<<<<<<<
  *                 src.strides[i] = 0
  *             else:
  */
         __pyx_v_broadcasting = 1;
 
-        /* "View.MemoryView":1292
+        /* "View.MemoryView":1295
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  *                 src.strides[i] = 0             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  */
         (__pyx_v_src.strides[__pyx_v_i]) = 0;
 
-        /* "View.MemoryView":1290
+        /* "View.MemoryView":1293
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":1294
+      /* "View.MemoryView":1297
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1294, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":1289
+      /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
-    /* "View.MemoryView":1296
+    /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
-    __pyx_t_2 = ((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0);
+    __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1297
+      /* "View.MemoryView":1300
  * 
  *         if src.suboffsets[i] >= 0:
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_6 = __pyx_memoryview_err_dim(PyExc_ValueError, __pyx_kp_s_Dimension_d_is_not_direct, __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1300, __pyx_L1_error)
 
-      /* "View.MemoryView":1296
+      /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1299
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+  /* "View.MemoryView":1302
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
-  __pyx_t_2 = __pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
+  __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1301
+    /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
-    __pyx_t_2 = (!__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim));
+    __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1302
+      /* "View.MemoryView":1305
  * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
-      /* "View.MemoryView":1301
+      /* "View.MemoryView":1304
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     }
 
-    /* "View.MemoryView":1304
+    /* "View.MemoryView":1307
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1304, __pyx_L1_error)
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1307, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
-    /* "View.MemoryView":1305
+    /* "View.MemoryView":1308
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
-    /* "View.MemoryView":1299
- *             _err_dim(PyExc_ValueError, "Dimension %d is not direct", i)
+    /* "View.MemoryView":1302
+ *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
-  /* "View.MemoryView":1307
+  /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = (!__pyx_v_broadcasting);
+  __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1310
+    /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
-    __pyx_t_2 = __pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim);
+    __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1311
+      /* "View.MemoryView":1314
  * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
-      /* "View.MemoryView":1310
+      /* "View.MemoryView":1313
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
-    /* "View.MemoryView":1312
+    /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
-    __pyx_t_2 = __pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim);
+    __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1313
+      /* "View.MemoryView":1316
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
  * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
-      /* "View.MemoryView":1312
+      /* "View.MemoryView":1315
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     }
     __pyx_L12:;
 
-    /* "View.MemoryView":1315
+    /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    if (__pyx_v_direct_copy) {
+    __pyx_t_2 = (__pyx_v_direct_copy != 0);
+    if (__pyx_t_2) {
 
-      /* "View.MemoryView":1317
+      /* "View.MemoryView":1320
  *         if direct_copy:
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-      /* "View.MemoryView":1318
+      /* "View.MemoryView":1321
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
       (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
-      /* "View.MemoryView":1319
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+      /* "View.MemoryView":1322
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  *             free(tmpdata)
  *             return 0
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-      /* "View.MemoryView":1320
+      /* "View.MemoryView":1323
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
  * 
  */
       free(__pyx_v_tmpdata);
 
-      /* "View.MemoryView":1321
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+      /* "View.MemoryView":1324
+ *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
-      /* "View.MemoryView":1315
+      /* "View.MemoryView":1318
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
- *             refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
-    /* "View.MemoryView":1307
+    /* "View.MemoryView":1310
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1323
+  /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
-  if (__pyx_t_2) {
+  __pyx_t_8 = (__pyx_t_2 != 0);
+  if (__pyx_t_8) {
 
-    /* "View.MemoryView":1326
+    /* "View.MemoryView":1329
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 1326, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1329, __pyx_L1_error)
 
-    /* "View.MemoryView":1327
+    /* "View.MemoryView":1330
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 1327, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1330, __pyx_L1_error)
 
-    /* "View.MemoryView":1323
+    /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1329
+  /* "View.MemoryView":1332
  *         transpose_memslice(&dst)
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1330
+  /* "View.MemoryView":1333
  * 
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1331
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=False)
+  /* "View.MemoryView":1334
+ *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1333
- *     refcount_copying(&dst, dtype_is_object, ndim, inc=True)
+  /* "View.MemoryView":1336
+ *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   free(__pyx_v_tmpdata);
 
-  /* "View.MemoryView":1334
+  /* "View.MemoryView":1337
  * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1265
+  /* "View.MemoryView":1268
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  #ifdef WITH_THREAD
-  __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
-  #endif
-  __Pyx_AddTraceback("View.MemoryView.memoryview_copy_contents", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  {
+    #ifdef WITH_THREAD
+    PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
+    #endif
+    __Pyx_AddTraceback("View.MemoryView.memoryview_copy_contents", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    #ifdef WITH_THREAD
+    __Pyx_PyGILState_Release(__pyx_gilstate_save);
+    #endif
+  }
   __pyx_r = -1;
-  #ifdef WITH_THREAD
-  __Pyx_PyGILState_Release(__pyx_gilstate_save);
-  #endif
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1337
+/* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
- *                             int ndim_other) noexcept nogil:
+ *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
   int __pyx_v_i;
   int __pyx_v_offset;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
 
-  /* "View.MemoryView":1341
- *                             int ndim_other) noexcept nogil:
+  /* "View.MemoryView":1344
+ *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
-  /* "View.MemoryView":1343
+  /* "View.MemoryView":1346
  *     cdef int offset = ndim_other - ndim
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
   for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1344
+    /* "View.MemoryView":1347
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1345
+    /* "View.MemoryView":1348
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-    /* "View.MemoryView":1346
+    /* "View.MemoryView":1349
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
  * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
-  /* "View.MemoryView":1348
+  /* "View.MemoryView":1351
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1349
+    /* "View.MemoryView":1352
  * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
-    /* "View.MemoryView":1350
+    /* "View.MemoryView":1353
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
-    /* "View.MemoryView":1351
+    /* "View.MemoryView":1354
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1337
+  /* "View.MemoryView":1340
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
- *                             int ndim_other) noexcept nogil:
+ *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1359
+/* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
+ *                            int ndim, bint inc) nogil:
  * 
- *     if dtype_is_object:
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
+  int __pyx_t_1;
 
-  /* "View.MemoryView":1361
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:
+  /* "View.MemoryView":1366
  * 
- *     if dtype_is_object:             # <<<<<<<<<<<<<<
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)
  * 
+ *     if dtype_is_object:             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
+ *                                            dst.strides, ndim, inc)
  */
-  if (__pyx_v_dtype_is_object) {
+  __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":1362
+    /* "View.MemoryView":1367
  * 
  *     if dtype_is_object:
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
+ *                                            dst.strides, ndim, inc)
  * 
- * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
-    /* "View.MemoryView":1361
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:
+    /* "View.MemoryView":1366
  * 
- *     if dtype_is_object:             # <<<<<<<<<<<<<<
- *         refcount_objects_in_slice_with_gil(dst.data, dst.shape, dst.strides, ndim, inc)
  * 
+ *     if dtype_is_object:             # <<<<<<<<<<<<<<
+ *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
+ *                                            dst.strides, ndim, inc)
  */
   }
 
-  /* "View.MemoryView":1359
+  /* "View.MemoryView":1362
  * 
  * @cname('__pyx_memoryview_refcount_copying')
- * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object, int ndim, bint inc) noexcept nogil:             # <<<<<<<<<<<<<<
+ * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
+ *                            int ndim, bint inc) nogil:
  * 
- *     if dtype_is_object:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1365
+/* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   __Pyx_RefNannyDeclarations
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
-  /* "View.MemoryView":1368
+  /* "View.MemoryView":1374
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
-  /* "View.MemoryView":1365
+  /* "View.MemoryView":1371
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
- *                                              bint inc) noexcept with gil:
+ *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "View.MemoryView":1371
+/* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+ *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
-  Py_ssize_t __pyx_v_stride;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
-  /* "View.MemoryView":1374
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+  /* "View.MemoryView":1381
  *     cdef Py_ssize_t i
- *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
- * 
- *     for i in range(shape[0]):
- */
-  __pyx_v_stride = (__pyx_v_strides[0]);
-
-  /* "View.MemoryView":1376
- *     cdef Py_ssize_t stride = strides[0]
  * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1377
+    /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
-    __pyx_t_4 = (__pyx_v_ndim == 1);
+    __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":1378
+      /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
-      if (__pyx_v_inc) {
+      __pyx_t_4 = (__pyx_v_inc != 0);
+      if (__pyx_t_4) {
 
-        /* "View.MemoryView":1379
+        /* "View.MemoryView":1384
  *         if ndim == 1:
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])
  */
         Py_INCREF((((PyObject **)__pyx_v_data)[0]));
 
-        /* "View.MemoryView":1378
+        /* "View.MemoryView":1383
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
         goto __pyx_L6;
       }
 
-      /* "View.MemoryView":1381
+      /* "View.MemoryView":1386
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *         else:
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
-      /* "View.MemoryView":1377
+      /* "View.MemoryView":1382
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":1383
+    /* "View.MemoryView":1388
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)             # <<<<<<<<<<<<<<
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
+ *                                       ndim - 1, inc)
  * 
- *         data += stride
  */
     /*else*/ {
+
+      /* "View.MemoryView":1389
+ *         else:
+ *             refcount_objects_in_slice(data, shape + 1, strides + 1,
+ *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
+ * 
+ *         data += strides[0]
+ */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":1385
- *             refcount_objects_in_slice(data, shape + 1, strides + 1, ndim - 1, inc)
+    /* "View.MemoryView":1391
+ *                                       ndim - 1, inc)
  * 
- *         data += stride             # <<<<<<<<<<<<<<
+ *         data += strides[0]             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
+    __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
-  /* "View.MemoryView":1371
+  /* "View.MemoryView":1377
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
- *                                     Py_ssize_t *strides, int ndim, bint inc) noexcept:
+ *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1391
+/* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
+ *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
 
-  /* "View.MemoryView":1394
+  /* "View.MemoryView":1400
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)             # <<<<<<<<<<<<<<
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)
+ *                               bint dtype_is_object) nogil:
+ *     refcount_copying(dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
+ *                          itemsize, item)
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1395
- *                               bint dtype_is_object) noexcept nogil:
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)             # <<<<<<<<<<<<<<
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)
- * 
+  /* "View.MemoryView":1401
+ *                               bint dtype_is_object) nogil:
+ *     refcount_copying(dst, dtype_is_object, ndim, False)
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,             # <<<<<<<<<<<<<<
+ *                          itemsize, item)
+ *     refcount_copying(dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
-  /* "View.MemoryView":1396
- *     refcount_copying(dst, dtype_is_object, ndim, inc=False)
- *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim, itemsize, item)
- *     refcount_copying(dst, dtype_is_object, ndim, inc=True)             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":1403
+ *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
+ *                          itemsize, item)
+ *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1391
+  /* "View.MemoryView":1397
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
- *                               bint dtype_is_object) noexcept nogil:
+ *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1400
+/* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
- *                               size_t itemsize, void *item) noexcept nogil:
+ *                               size_t itemsize, void *item) nogil:
  */
 
 static void __pyx_memoryview__slice_assign_scalar(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   Py_ssize_t __pyx_v_stride;
   Py_ssize_t __pyx_v_extent;
   int __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
 
-  /* "View.MemoryView":1404
- *                               size_t itemsize, void *item) noexcept nogil:
+  /* "View.MemoryView":1411
+ *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
  * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
-  /* "View.MemoryView":1405
+  /* "View.MemoryView":1412
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
-  /* "View.MemoryView":1407
+  /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
-  __pyx_t_1 = (__pyx_v_ndim == 1);
+  __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1408
+    /* "View.MemoryView":1415
  * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1409
+      /* "View.MemoryView":1416
  *     if ndim == 1:
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)             # <<<<<<<<<<<<<<
  *             data += stride
  *     else:
  */
       (void)(memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize));
 
-      /* "View.MemoryView":1410
+      /* "View.MemoryView":1417
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  *             data += stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
-    /* "View.MemoryView":1407
+    /* "View.MemoryView":1414
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1412
+  /* "View.MemoryView":1419
  *             data += stride
  *     else:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)
- *             data += stride
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,
+ *                                 ndim - 1, itemsize, item)
  */
   /*else*/ {
     __pyx_t_2 = __pyx_v_extent;
     __pyx_t_3 = __pyx_t_2;
     for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
       __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1413
+      /* "View.MemoryView":1420
  *     else:
  *         for i in range(extent):
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)             # <<<<<<<<<<<<<<
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
+ *                                 ndim - 1, itemsize, item)
  *             data += stride
- * 
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
-      /* "View.MemoryView":1414
- *         for i in range(extent):
- *             _slice_assign_scalar(data, shape + 1, strides + 1, ndim - 1, itemsize, item)
+      /* "View.MemoryView":1422
+ *             _slice_assign_scalar(data, shape + 1, strides + 1,
+ *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1400
+  /* "View.MemoryView":1407
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
- *                               size_t itemsize, void *item) noexcept nogil:
+ *                               size_t itemsize, void *item) nogil:
  */
 
   /* function exit code */
 }
 
 /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
+static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v___pyx_type = 0;
   long __pyx_v___pyx_checksum;
   PyObject *__pyx_v___pyx_state = 0;
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum (wrapper)", 0);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};
     PyObject* values[3] = {0,0,0};
-    if (__pyx_kwds) {
+    if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_type)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_pyx_state)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 3)) {
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v___pyx_type = values[0];
     __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
     __pyx_v___pyx_state = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 1, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);
 
@@ -16790,140 +16733,151 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
-  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__8, Py_NE)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_2) {
+  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
+  if (__pyx_t_1) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
-    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
-    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
+    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_INCREF(__pyx_t_1);
-    __pyx_v___pyx_PickleError = __pyx_t_1;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v___pyx_PickleError = __pyx_t_2;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):
+ *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_INCREF(__pyx_v___pyx_PickleError);
+    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+      }
+    }
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_Raise(__pyx_v___pyx_PickleError, __pyx_t_1, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
-  __pyx_t_5 = 0;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_5 = 1;
+      __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_v___pyx_type};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  }
-  __pyx_v___pyx_result = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v___pyx_result = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
-  __pyx_t_2 = (__pyx_v___pyx_state != Py_None);
-  if (__pyx_t_2) {
+  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
+  __pyx_t_6 = (__pyx_t_1 != 0);
+  if (__pyx_t_6) {
 
     /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None) || __Pyx_RaiseUnexpectedTypeError("tuple", __pyx_v___pyx_state))) __PYX_ERR(1, 9, __pyx_L1_error)
-    __pyx_t_1 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 9, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
+    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
@@ -16943,17 +16897,18 @@
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
@@ -16971,18 +16926,18 @@
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
-  int __pyx_t_8;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum__set_state", 0);
 
   /* "(tree fragment)":12
  *     return __pyx_result
@@ -17010,62 +16965,58 @@
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_4 = (__pyx_t_3 > 1);
+  __pyx_t_4 = ((__pyx_t_3 > 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_2 = __pyx_t_4;
+  __pyx_t_5 = (__pyx_t_4 != 0);
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
     /* "(tree fragment)":14
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 14, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_update); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 14, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = NULL;
-    __pyx_t_8 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-        __Pyx_INCREF(__pyx_t_7);
+    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+      if (likely(__pyx_t_8)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+        __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
-        __pyx_t_8 = 1;
+        __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
-    {
-      PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
-      __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_6, __pyx_callargs+1-__pyx_t_8, 1+__pyx_t_8);
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    }
+    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
  *         __pyx_result.__dict__.update(__pyx_state[1])
@@ -17081,1634 +17032,222 @@
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "chython/containers/_cpack.pyx":48
- * # 4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
- * 
- * @cython.nonecheck(False)             # <<<<<<<<<<<<<<
- * @cython.boundscheck(False)
- * @cython.cdivision(True)
- */
+static struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *__pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[8];
+static int __pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = 0;
 
-/* Python wrapper */
-static PyObject *__pyx_pw_7chython_10containers_6_cpack_1unpack(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-); /*proto*/
-static PyMethodDef __pyx_mdef_7chython_10containers_6_cpack_1unpack = {"unpack", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_7chython_10containers_6_cpack_1unpack, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_7chython_10containers_6_cpack_1unpack(PyObject *__pyx_self, 
-#if CYTHON_METH_FASTCALL
-PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
-#else
-PyObject *__pyx_args, PyObject *__pyx_kwds
-#endif
-) {
-  __Pyx_memviewslice __pyx_v_data = { 0, 0, { 0 }, { 0 }, { 0 } };
-  #if !CYTHON_METH_FASTCALL
-  CYTHON_UNUSED const Py_ssize_t __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #endif
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("unpack (wrapper)", 0);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,0};
-    PyObject* values[1] = {0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_data)) != 0)) kw_args--;
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "unpack") < 0)) __PYX_ERR(0, 48, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 1)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-    }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 52, __pyx_L3_error)
-  }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("unpack", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 48, __pyx_L3_error)
-  __pyx_L3_error:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_data, 1);
-  __Pyx_AddTraceback("chython.containers._cpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  if (unlikely(((PyObject *)__pyx_v_data.memview) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "data"); __PYX_ERR(0, 52, __pyx_L1_error)
+static PyObject *__pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p;
+  PyObject *o;
+  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping)))) {
+    o = (PyObject*)__pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[--__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping];
+    memset(o, 0, sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping));
+    (void) PyObject_INIT(o, t);
+    PyObject_GC_Track(o);
+  } else {
+    o = (*t->tp_alloc)(t, 0);
+    if (unlikely(!o)) return 0;
   }
-  __pyx_r = __pyx_pf_7chython_10containers_6_cpack_unpack(__pyx_self, __pyx_v_data);
-
-  /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_data, 1);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
+  p = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o);
+  p->__pyx_v_o_bits1.data = NULL;
+  p->__pyx_v_o_bits1.memview = NULL;
+  p->__pyx_v_o_bits2.data = NULL;
+  p->__pyx_v_o_bits2.memview = NULL;
+  p->__pyx_v_o_bits3.data = NULL;
+  p->__pyx_v_o_bits3.memview = NULL;
+  p->__pyx_v_o_bits4.data = NULL;
+  p->__pyx_v_o_bits4.memview = NULL;
+  p->__pyx_v_o_bonds.data = NULL;
+  p->__pyx_v_o_bonds.memview = NULL;
+  p->__pyx_v_o_from.data = NULL;
+  p->__pyx_v_o_from.memview = NULL;
+  p->__pyx_v_o_indices.data = NULL;
+  p->__pyx_v_o_indices.memview = NULL;
+  p->__pyx_v_o_numbers.data = NULL;
+  p->__pyx_v_o_numbers.memview = NULL;
+  p->__pyx_v_o_to.data = NULL;
+  p->__pyx_v_o_to.memview = NULL;
+  p->__pyx_v_q_back.data = NULL;
+  p->__pyx_v_q_back.memview = NULL;
+  p->__pyx_v_q_bonds.data = NULL;
+  p->__pyx_v_q_bonds.memview = NULL;
+  p->__pyx_v_q_closures.data = NULL;
+  p->__pyx_v_q_closures.memview = NULL;
+  p->__pyx_v_q_from.data = NULL;
+  p->__pyx_v_q_from.memview = NULL;
+  p->__pyx_v_q_indices.data = NULL;
+  p->__pyx_v_q_indices.memview = NULL;
+  p->__pyx_v_q_masks1.data = NULL;
+  p->__pyx_v_q_masks1.memview = NULL;
+  p->__pyx_v_q_masks2.data = NULL;
+  p->__pyx_v_q_masks2.memview = NULL;
+  p->__pyx_v_q_masks3.data = NULL;
+  p->__pyx_v_q_masks3.memview = NULL;
+  p->__pyx_v_q_masks4.data = NULL;
+  p->__pyx_v_q_masks4.memview = NULL;
+  p->__pyx_v_q_numbers.data = NULL;
+  p->__pyx_v_q_numbers.memview = NULL;
+  p->__pyx_v_q_to.data = NULL;
+  p->__pyx_v_q_to.memview = NULL;
+  p->__pyx_v_scope.data = NULL;
+  p->__pyx_v_scope.memview = NULL;
+  return o;
 }
 
-static PyObject *__pyx_pf_7chython_10containers_6_cpack_unpack(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_data) {
-  char *__pyx_v_charges;
-  unsigned char *__pyx_v_atoms;
-  unsigned char *__pyx_v_hydrogens;
-  unsigned char *__pyx_v_radicals;
-  unsigned char *__pyx_v_is_chiral;
-  unsigned char *__pyx_v_neighbors;
-  unsigned char **__pyx_v_orders;
-  unsigned char *__pyx_v_seen;
-  unsigned short **__pyx_v_connections;
-  unsigned short *__pyx_v_ct_stereo;
-  int *__pyx_v_stereo_sign;
-  int *__pyx_v_ct_sign;
-  unsigned char __pyx_v_a;
-  unsigned char __pyx_v_b;
-  unsigned char __pyx_v_i;
-  unsigned short __pyx_v_size;
-  unsigned short __pyx_v_shift;
-  unsigned short __pyx_v_n;
-  unsigned short __pyx_v_m;
-  unsigned short __pyx_v_bond_shift;
-  unsigned short __pyx_v_atoms_count;
-  unsigned short __pyx_v_ct_count;
-  unsigned short __pyx_v_ct_shift;
-  PyObject *__pyx_v_py_xy = 0;
-  PyObject *__pyx_v_bond = 0;
-  PyObject *__pyx_v_py_n = 0;
-  PyObject *__pyx_v_py_m = 0;
-  PyObject *__pyx_v_py_mapping = 0;
-  PyObject *__pyx_v_py_atoms = 0;
-  PyObject *__pyx_v_py_isotopes = 0;
-  PyObject *__pyx_v_py_bonds_flat = 0;
-  PyObject *__pyx_v_py_charges = 0;
-  PyObject *__pyx_v_py_radicals = 0;
-  PyObject *__pyx_v_py_hydrogens = 0;
-  PyObject *__pyx_v_py_plane = 0;
-  PyObject *__pyx_v_py_bonds = 0;
-  PyObject *__pyx_v_py_ngb = 0;
-  PyObject *__pyx_v_py_atoms_stereo = 0;
-  PyObject *__pyx_v_py_allenes_stereo = 0;
-  PyObject *__pyx_v_py_cis_trans_stereo = 0;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  Py_ssize_t __pyx_t_1;
-  long __pyx_t_2;
-  long __pyx_t_3;
-  unsigned short __pyx_t_4;
-  int __pyx_t_5;
-  size_t __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
-  unsigned short __pyx_t_8;
-  unsigned char __pyx_t_9;
-  unsigned char __pyx_t_10;
-  unsigned char __pyx_t_11;
-  unsigned short __pyx_t_12;
-  PyObject *__pyx_t_13 = NULL;
-  int __pyx_t_14;
-  PyObject *__pyx_t_15 = NULL;
-  PyObject *__pyx_t_16 = NULL;
-  PyObject *__pyx_t_17 = NULL;
-  int __pyx_t_18;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("unpack", 0);
-
-  /* "chython/containers/_cpack.pyx":59
- * 
- *     cdef unsigned char a, b, i
- *     cdef unsigned short size, shift = 1, n, m, bond_shift, atoms_count, ct_count = 0, ct_shift = 0             # <<<<<<<<<<<<<<
- * 
- *     cdef tuple py_xy
- */
-  __pyx_v_shift = 1;
-  __pyx_v_ct_count = 0;
-  __pyx_v_ct_shift = 0;
-
-  /* "chython/containers/_cpack.pyx":68
- * 
- *     # allocate memory
- *     size = len(data)             # <<<<<<<<<<<<<<
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- */
-  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_v_data); 
-  __pyx_v_size = __pyx_t_1;
-
-  /* "chython/containers/_cpack.pyx":69
- *     # allocate memory
- *     size = len(data)
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_atoms = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":70
- *     size = len(data)
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))             # <<<<<<<<<<<<<<
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_charges = ((char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(char)))));
-
-  /* "chython/containers/_cpack.pyx":71
- *     atoms = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_radicals = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":72
- *     charges = <char*> PyMem_Malloc(size / 3 * sizeof(char))
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- */
-  __pyx_v_hydrogens = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":73
- *     radicals = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- */
-  __pyx_v_is_chiral = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":74
- *     hydrogens = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))             # <<<<<<<<<<<<<<
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- */
-  __pyx_v_stereo_sign = ((int *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(int)))));
-
-  /* "chython/containers/_cpack.pyx":75
- *     is_chiral = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))             # <<<<<<<<<<<<<<
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_ct_stereo = ((unsigned short *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned short)))));
-
-  /* "chython/containers/_cpack.pyx":76
- *     stereo_sign = <bint*> PyMem_Malloc(size / 3 * sizeof(bint))
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))             # <<<<<<<<<<<<<<
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- */
-  __pyx_v_ct_sign = ((int *)PyMem_Malloc(((((long)__pyx_v_size) / 6) * (sizeof(int)))));
-
-  /* "chython/containers/_cpack.pyx":77
- *     ct_stereo = <unsigned short*> PyMem_Malloc(size / 3 * sizeof(unsigned short))
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- */
-  __pyx_v_seen = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":78
- *     ct_sign = <bint*> PyMem_Malloc(size / 6 * sizeof(bint))
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- */
-  __pyx_v_neighbors = ((unsigned char *)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char)))));
-
-  /* "chython/containers/_cpack.pyx":79
- *     seen = <unsigned char*> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))             # <<<<<<<<<<<<<<
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):
- */
-  __pyx_v_connections = ((unsigned short **)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned short *)))));
-
-  /* "chython/containers/_cpack.pyx":80
- *     neighbors = <unsigned char *> PyMem_Malloc(size / 3 * sizeof(unsigned char))
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))             # <<<<<<<<<<<<<<
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- */
-  __pyx_v_orders = ((unsigned char **)PyMem_Malloc(((((long)__pyx_v_size) / 3) * (sizeof(unsigned char *)))));
-
-  /* "chython/containers/_cpack.pyx":81
- *     connections = <unsigned short**> PyMem_Malloc(size / 3 * sizeof(unsigned short*))
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):             # <<<<<<<<<<<<<<
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))
- */
-  __pyx_t_2 = (((long)__pyx_v_size) / 3);
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_n = __pyx_t_4;
-
-    /* "chython/containers/_cpack.pyx":82
- *     orders = <unsigned char**> PyMem_Malloc(size / 3 * sizeof(unsigned char *))
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))             # <<<<<<<<<<<<<<
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))
- * 
- */
-    (__pyx_v_connections[__pyx_v_n]) = ((unsigned short *)PyMem_Malloc((15 * (sizeof(unsigned short)))));
-
-    /* "chython/containers/_cpack.pyx":83
- *     for n in range(size / 3):
- *         connections[n] = <unsigned short*> PyMem_Malloc(15 * sizeof(unsigned short))
- *         orders[n] = <unsigned char*> PyMem_Malloc(15 * sizeof(unsigned char))             # <<<<<<<<<<<<<<
- * 
- *     # unpack atom block to separate attributes arrays
- */
-    (__pyx_v_orders[__pyx_v_n]) = ((unsigned char *)PyMem_Malloc((15 * (sizeof(unsigned char)))));
-  }
-
-  /* "chython/containers/_cpack.pyx":86
- * 
- *     # unpack atom block to separate attributes arrays
- *     n = 0             # <<<<<<<<<<<<<<
- *     while shift < size:
- *         seen[n] = 0  # erase randomness
- */
-  __pyx_v_n = 0;
-
-  /* "chython/containers/_cpack.pyx":87
- *     # unpack atom block to separate attributes arrays
- *     n = 0
- *     while shift < size:             # <<<<<<<<<<<<<<
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- */
-  while (1) {
-    __pyx_t_5 = (__pyx_v_shift < __pyx_v_size);
-    if (!__pyx_t_5) break;
-
-    /* "chython/containers/_cpack.pyx":88
- *     n = 0
- *     while shift < size:
- *         seen[n] = 0  # erase randomness             # <<<<<<<<<<<<<<
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack
- */
-    (__pyx_v_seen[__pyx_v_n]) = 0;
-
-    /* "chython/containers/_cpack.pyx":89
- *     while shift < size:
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]             # <<<<<<<<<<<<<<
- *         if a & 0x80 == 0:  # end of pack
- *             break
- */
-    __pyx_t_6 = __pyx_v_shift;
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_6)) )));
-
-    /* "chython/containers/_cpack.pyx":90
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack             # <<<<<<<<<<<<<<
- *             break
- *         atoms[n] = a & 0x7f
- */
-    __pyx_t_5 = ((__pyx_v_a & 0x80) == 0);
-    if (__pyx_t_5) {
-
-      /* "chython/containers/_cpack.pyx":91
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack
- *             break             # <<<<<<<<<<<<<<
- *         atoms[n] = a & 0x7f
- * 
- */
-      goto __pyx_L6_break;
-
-      /* "chython/containers/_cpack.pyx":90
- *         seen[n] = 0  # erase randomness
- *         a = data[shift]
- *         if a & 0x80 == 0:  # end of pack             # <<<<<<<<<<<<<<
- *             break
- *         atoms[n] = a & 0x7f
- */
-    }
-
-    /* "chython/containers/_cpack.pyx":92
- *         if a & 0x80 == 0:  # end of pack
- *             break
- *         atoms[n] = a & 0x7f             # <<<<<<<<<<<<<<
- * 
- *         a = data[shift + 1]
- */
-    (__pyx_v_atoms[__pyx_v_n]) = (__pyx_v_a & 0x7f);
-
-    /* "chython/containers/_cpack.pyx":94
- *         atoms[n] = a & 0x7f
- * 
- *         a = data[shift + 1]             # <<<<<<<<<<<<<<
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4
- */
-    __pyx_t_7 = (__pyx_v_shift + 1);
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_7)) )));
-
-    /* "chython/containers/_cpack.pyx":95
- * 
- *         a = data[shift + 1]
- *         hydrogens[n] = a >> 5             # <<<<<<<<<<<<<<
- *         charges[n] = ((a >> 1) & 0x0f) - 4
- *         radicals[n] = a & 0x01
- */
-    (__pyx_v_hydrogens[__pyx_v_n]) = (__pyx_v_a >> 5);
-
-    /* "chython/containers/_cpack.pyx":96
- *         a = data[shift + 1]
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4             # <<<<<<<<<<<<<<
- *         radicals[n] = a & 0x01
- * 
- */
-    (__pyx_v_charges[__pyx_v_n]) = (((__pyx_v_a >> 1) & 0x0f) - 4);
-
-    /* "chython/containers/_cpack.pyx":97
- *         hydrogens[n] = a >> 5
- *         charges[n] = ((a >> 1) & 0x0f) - 4
- *         radicals[n] = a & 0x01             # <<<<<<<<<<<<<<
- * 
- *         a = data[shift + 2]
- */
-    (__pyx_v_radicals[__pyx_v_n]) = (__pyx_v_a & 0x01);
-
-    /* "chython/containers/_cpack.pyx":99
- *         radicals[n] = a & 0x01
- * 
- *         a = data[shift + 2]             # <<<<<<<<<<<<<<
- *         bond_shift = a & 0x0f
- *         b = a >> 4
- */
-    __pyx_t_7 = (__pyx_v_shift + 2);
-    __pyx_v_a = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_7)) )));
-
-    /* "chython/containers/_cpack.pyx":100
- * 
- *         a = data[shift + 2]
- *         bond_shift = a & 0x0f             # <<<<<<<<<<<<<<
- *         b = a >> 4
- *         if b == 0b0011:
- */
-    __pyx_v_bond_shift = (__pyx_v_a & 0x0f);
-
-    /* "chython/containers/_cpack.pyx":101
- *         a = data[shift + 2]
- *         bond_shift = a & 0x0f
- *         b = a >> 4             # <<<<<<<<<<<<<<
- *         if b == 0b0011:
- *             is_chiral[n] = 1
- */
-    __pyx_v_b = (__pyx_v_a >> 4);
-
-    /* "chython/containers/_cpack.pyx":102
- *         bond_shift = a & 0x0f
- *         b = a >> 4
- *         if b == 0b0011:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- */
-    switch (__pyx_v_b) {
-      case 3:
-
-      /* "chython/containers/_cpack.pyx":103
- *         b = a >> 4
- *         if b == 0b0011:
- *             is_chiral[n] = 1             # <<<<<<<<<<<<<<
- *             stereo_sign[n] = True
- *         elif b == 0b0010:
- */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 1;
-
-      /* "chython/containers/_cpack.pyx":104
- *         if b == 0b0011:
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True             # <<<<<<<<<<<<<<
- *         elif b == 0b0010:
- *             is_chiral[n] = 1
- */
-      (__pyx_v_stereo_sign[__pyx_v_n]) = 1;
-
-      /* "chython/containers/_cpack.pyx":102
- *         bond_shift = a & 0x0f
- *         b = a >> 4
- *         if b == 0b0011:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- */
-      break;
-      case 2:
-
-      /* "chython/containers/_cpack.pyx":106
- *             stereo_sign[n] = True
- *         elif b == 0b0010:
- *             is_chiral[n] = 1             # <<<<<<<<<<<<<<
- *             stereo_sign[n] = False
- *         else:
- */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 1;
-
-      /* "chython/containers/_cpack.pyx":107
- *         elif b == 0b0010:
- *             is_chiral[n] = 1
- *             stereo_sign[n] = False             # <<<<<<<<<<<<<<
- *         else:
- *             is_chiral[n] = 0
- */
-      (__pyx_v_stereo_sign[__pyx_v_n]) = 0;
-
-      /* "chython/containers/_cpack.pyx":105
- *             is_chiral[n] = 1
- *             stereo_sign[n] = True
- *         elif b == 0b0010:             # <<<<<<<<<<<<<<
- *             is_chiral[n] = 1
- *             stereo_sign[n] = False
- */
-      break;
-      default:
-
-      /* "chython/containers/_cpack.pyx":109
- *             stereo_sign[n] = False
- *         else:
- *             is_chiral[n] = 0             # <<<<<<<<<<<<<<
- * 
- *         shift += 3
- */
-      (__pyx_v_is_chiral[__pyx_v_n]) = 0;
-      break;
-    }
-
-    /* "chython/containers/_cpack.pyx":111
- *             is_chiral[n] = 0
- * 
- *         shift += 3             # <<<<<<<<<<<<<<
- *         neighbors[n] = 0
- *         for i in range(bond_shift):
- */
-    __pyx_v_shift = (__pyx_v_shift + 3);
-
-    /* "chython/containers/_cpack.pyx":112
- * 
- *         shift += 3
- *         neighbors[n] = 0             # <<<<<<<<<<<<<<
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]
- */
-    (__pyx_v_neighbors[__pyx_v_n]) = 0;
-
-    /* "chython/containers/_cpack.pyx":113
- *         shift += 3
- *         neighbors[n] = 0
- *         for i in range(bond_shift):             # <<<<<<<<<<<<<<
- *             a, b = data[shift], data[shift + 1]
- *             shift += 2
- */
-    __pyx_t_4 = __pyx_v_bond_shift;
-    __pyx_t_8 = __pyx_t_4;
-    for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
-      __pyx_v_i = __pyx_t_9;
-
-      /* "chython/containers/_cpack.pyx":114
- *         neighbors[n] = 0
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]             # <<<<<<<<<<<<<<
- *             shift += 2
- * 
- */
-      __pyx_t_6 = __pyx_v_shift;
-      __pyx_t_10 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_6)) )));
-      __pyx_t_7 = (__pyx_v_shift + 1);
-      __pyx_t_11 = (*((unsigned char const  *) ( /* dim=0 */ ((char *) (((unsigned char const  *) __pyx_v_data.data) + __pyx_t_7)) )));
-      __pyx_v_a = __pyx_t_10;
-      __pyx_v_b = __pyx_t_11;
-
-      /* "chython/containers/_cpack.pyx":115
- *         for i in range(bond_shift):
- *             a, b = data[shift], data[shift + 1]
- *             shift += 2             # <<<<<<<<<<<<<<
- * 
- *             m = n - (a << 4 | b >> 4)  # second atom index
- */
-      __pyx_v_shift = (__pyx_v_shift + 2);
-
-      /* "chython/containers/_cpack.pyx":117
- *             shift += 2
- * 
- *             m = n - (a << 4 | b >> 4)  # second atom index             # <<<<<<<<<<<<<<
- *             b &= 0x0f
- * 
- */
-      __pyx_v_m = (__pyx_v_n - ((__pyx_v_a << 4) | (__pyx_v_b >> 4)));
-
-      /* "chython/containers/_cpack.pyx":118
- * 
- *             m = n - (a << 4 | b >> 4)  # second atom index
- *             b &= 0x0f             # <<<<<<<<<<<<<<
- * 
- *             if b < 8:
- */
-      __pyx_v_b = (__pyx_v_b & 0x0f);
-
-      /* "chython/containers/_cpack.pyx":120
- *             b &= 0x0f
- * 
- *             if b < 8:             # <<<<<<<<<<<<<<
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
- */
-      __pyx_t_5 = (__pyx_v_b < 8);
-      if (__pyx_t_5) {
-
-        /* "chython/containers/_cpack.pyx":121
- * 
- *             if b < 8:
- *                 connections[n][neighbors[n]] = m             # <<<<<<<<<<<<<<
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- */
-        ((__pyx_v_connections[__pyx_v_n])[(__pyx_v_neighbors[__pyx_v_n])]) = __pyx_v_m;
-
-        /* "chython/containers/_cpack.pyx":122
- *             if b < 8:
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n             # <<<<<<<<<<<<<<
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1
- */
-        ((__pyx_v_connections[__pyx_v_m])[(__pyx_v_neighbors[__pyx_v_m])]) = __pyx_v_n;
-
-        /* "chython/containers/_cpack.pyx":123
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction             # <<<<<<<<<<<<<<
- *                 neighbors[n] += 1
- *                 neighbors[m] += 1
- */
-        ((__pyx_v_orders[__pyx_v_m])[(__pyx_v_neighbors[__pyx_v_m])]) = (__pyx_v_b + 1);
-
-        /* "chython/containers/_cpack.pyx":124
- *                 connections[m][neighbors[m]] = n
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1             # <<<<<<<<<<<<<<
- *                 neighbors[m] += 1
- *             else:  # CT stereo
- */
-        __pyx_t_12 = __pyx_v_n;
-        (__pyx_v_neighbors[__pyx_t_12]) = ((__pyx_v_neighbors[__pyx_t_12]) + 1);
-
-        /* "chython/containers/_cpack.pyx":125
- *                 orders[m][neighbors[m]] = b + 1  # only single direction
- *                 neighbors[n] += 1
- *                 neighbors[m] += 1             # <<<<<<<<<<<<<<
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1
- */
-        __pyx_t_12 = __pyx_v_m;
-        (__pyx_v_neighbors[__pyx_t_12]) = ((__pyx_v_neighbors[__pyx_t_12]) + 1);
-
-        /* "chython/containers/_cpack.pyx":120
- *             b &= 0x0f
- * 
- *             if b < 8:             # <<<<<<<<<<<<<<
- *                 connections[n][neighbors[n]] = m
- *                 connections[m][neighbors[m]] = n
- */
-        goto __pyx_L10;
-      }
-
-      /* "chython/containers/_cpack.pyx":127
- *                 neighbors[m] += 1
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1             # <<<<<<<<<<<<<<
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01
- */
-      /*else*/ {
-        (__pyx_v_ct_stereo[__pyx_v_ct_shift]) = (__pyx_v_m + 1);
-
-        /* "chython/containers/_cpack.pyx":128
- *             else:  # CT stereo
- *                 ct_stereo[ct_shift] = m + 1
- *                 ct_stereo[ct_shift + 1] = n + 1             # <<<<<<<<<<<<<<
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1
- */
-        (__pyx_v_ct_stereo[(__pyx_v_ct_shift + 1)]) = (__pyx_v_n + 1);
-
-        /* "chython/containers/_cpack.pyx":129
- *                 ct_stereo[ct_shift] = m + 1
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01             # <<<<<<<<<<<<<<
- *                 ct_count += 1
- *                 ct_shift += 2
- */
-        (__pyx_v_ct_sign[__pyx_v_ct_count]) = (__pyx_v_b & 0x01);
-
-        /* "chython/containers/_cpack.pyx":130
- *                 ct_stereo[ct_shift + 1] = n + 1
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1             # <<<<<<<<<<<<<<
- *                 ct_shift += 2
- *         n += 1
- */
-        __pyx_v_ct_count = (__pyx_v_ct_count + 1);
-
-        /* "chython/containers/_cpack.pyx":131
- *                 ct_sign[ct_count] = b & 0x01
- *                 ct_count += 1
- *                 ct_shift += 2             # <<<<<<<<<<<<<<
- *         n += 1
- *     atoms_count = n
- */
-        __pyx_v_ct_shift = (__pyx_v_ct_shift + 2);
-      }
-      __pyx_L10:;
-    }
-
-    /* "chython/containers/_cpack.pyx":132
- *                 ct_count += 1
- *                 ct_shift += 2
- *         n += 1             # <<<<<<<<<<<<<<
- *     atoms_count = n
- * 
- */
-    __pyx_v_n = (__pyx_v_n + 1);
-  }
-  __pyx_L6_break:;
-
-  /* "chython/containers/_cpack.pyx":133
- *                 ct_shift += 2
- *         n += 1
- *     atoms_count = n             # <<<<<<<<<<<<<<
- * 
- *     # define returned data
- */
-  __pyx_v_atoms_count = __pyx_v_n;
-
-  /* "chython/containers/_cpack.pyx":136
- * 
- *     # define returned data
- *     py_mapping = []             # <<<<<<<<<<<<<<
- *     py_atoms = []
- *     py_isotopes = []
- */
-  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 136, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_mapping = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":137
- *     # define returned data
- *     py_mapping = []
- *     py_atoms = []             # <<<<<<<<<<<<<<
- *     py_isotopes = []
- *     py_charges = {}
- */
-  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_atoms = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":138
- *     py_mapping = []
- *     py_atoms = []
- *     py_isotopes = []             # <<<<<<<<<<<<<<
- *     py_charges = {}
- *     py_radicals = {}
- */
-  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 138, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_isotopes = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":139
- *     py_atoms = []
- *     py_isotopes = []
- *     py_charges = {}             # <<<<<<<<<<<<<<
- *     py_radicals = {}
- *     py_hydrogens = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 139, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_charges = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":140
- *     py_isotopes = []
- *     py_charges = {}
- *     py_radicals = {}             # <<<<<<<<<<<<<<
- *     py_hydrogens = {}
- *     py_plane = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_radicals = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":141
- *     py_charges = {}
- *     py_radicals = {}
- *     py_hydrogens = {}             # <<<<<<<<<<<<<<
- *     py_plane = {}
- *     py_atoms_stereo = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 141, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_hydrogens = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":142
- *     py_radicals = {}
- *     py_hydrogens = {}
- *     py_plane = {}             # <<<<<<<<<<<<<<
- *     py_atoms_stereo = {}
- *     py_allenes_stereo = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 142, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_plane = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":143
- *     py_hydrogens = {}
- *     py_plane = {}
- *     py_atoms_stereo = {}             # <<<<<<<<<<<<<<
- *     py_allenes_stereo = {}
- *     py_cis_trans_stereo = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 143, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_atoms_stereo = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":144
- *     py_plane = {}
- *     py_atoms_stereo = {}
- *     py_allenes_stereo = {}             # <<<<<<<<<<<<<<
- *     py_cis_trans_stereo = {}
- *     py_bonds = {}
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 144, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_allenes_stereo = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":145
- *     py_atoms_stereo = {}
- *     py_allenes_stereo = {}
- *     py_cis_trans_stereo = {}             # <<<<<<<<<<<<<<
- *     py_bonds = {}
- *     py_bonds_flat = []
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 145, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_cis_trans_stereo = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":146
- *     py_allenes_stereo = {}
- *     py_cis_trans_stereo = {}
- *     py_bonds = {}             # <<<<<<<<<<<<<<
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)
- */
-  __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 146, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_bonds = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":147
- *     py_cis_trans_stereo = {}
- *     py_bonds = {}
- *     py_bonds_flat = []             # <<<<<<<<<<<<<<
- *     py_xy = (0., 0.)
- * 
- */
-  __pyx_t_13 = PyList_New(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_13);
-  __pyx_v_py_bonds_flat = ((PyObject*)__pyx_t_13);
-  __pyx_t_13 = 0;
-
-  /* "chython/containers/_cpack.pyx":148
- *     py_bonds = {}
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)             # <<<<<<<<<<<<<<
- * 
- *     for n in range(atoms_count):
- */
-  __Pyx_INCREF(__pyx_tuple__9);
-  __pyx_v_py_xy = __pyx_tuple__9;
-
-  /* "chython/containers/_cpack.pyx":150
- *     py_xy = (0., 0.)
- * 
- *     for n in range(atoms_count):             # <<<<<<<<<<<<<<
- *         seen[n] = 1
- *         py_n = n + 1  # shared py int obj
- */
-  __pyx_t_4 = __pyx_v_atoms_count;
-  __pyx_t_8 = __pyx_t_4;
-  for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_8; __pyx_t_12+=1) {
-    __pyx_v_n = __pyx_t_12;
-
-    /* "chython/containers/_cpack.pyx":151
- * 
- *     for n in range(atoms_count):
- *         seen[n] = 1             # <<<<<<<<<<<<<<
- *         py_n = n + 1  # shared py int obj
- * 
- */
-    (__pyx_v_seen[__pyx_v_n]) = 1;
-
-    /* "chython/containers/_cpack.pyx":152
- *     for n in range(atoms_count):
- *         seen[n] = 1
- *         py_n = n + 1  # shared py int obj             # <<<<<<<<<<<<<<
- * 
- *         # fill intermediate data
- */
-    __pyx_t_13 = __Pyx_PyInt_From_long((__pyx_v_n + 1)); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 152, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    __Pyx_XDECREF_SET(__pyx_v_py_n, __pyx_t_13);
-    __pyx_t_13 = 0;
-
-    /* "chython/containers/_cpack.pyx":155
- * 
- *         # fill intermediate data
- *         py_mapping.append(py_n)             # <<<<<<<<<<<<<<
- *         py_atoms.append(atoms[n])
- *         py_isotopes.append(None)
- */
-    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_mapping, __pyx_v_py_n); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 155, __pyx_L1_error)
-
-    /* "chython/containers/_cpack.pyx":156
- *         # fill intermediate data
- *         py_mapping.append(py_n)
- *         py_atoms.append(atoms[n])             # <<<<<<<<<<<<<<
- *         py_isotopes.append(None)
- * 
- */
-    __pyx_t_13 = __Pyx_PyInt_From_unsigned_char((__pyx_v_atoms[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 156, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_atoms, __pyx_t_13); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 156, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-
-    /* "chython/containers/_cpack.pyx":157
- *         py_mapping.append(py_n)
- *         py_atoms.append(atoms[n])
- *         py_isotopes.append(None)             # <<<<<<<<<<<<<<
- * 
- *         py_charges[py_n] = charges[n]
- */
-    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_isotopes, Py_None); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 157, __pyx_L1_error)
-
-    /* "chython/containers/_cpack.pyx":159
- *         py_isotopes.append(None)
- * 
- *         py_charges[py_n] = charges[n]             # <<<<<<<<<<<<<<
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:
- */
-    __pyx_t_13 = __Pyx_PyInt_From_char((__pyx_v_charges[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 159, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    if (unlikely((PyDict_SetItem(__pyx_v_py_charges, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 159, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-
-    /* "chython/containers/_cpack.pyx":160
- * 
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])             # <<<<<<<<<<<<<<
- *         if hydrogens[n] == 7:
- *             py_hydrogens[py_n] = None
- */
-    __pyx_t_13 = __Pyx_PyInt_From_unsigned_char((__pyx_v_radicals[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_13); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-    __pyx_t_13 = __Pyx_PyBool_FromLong((!(!__pyx_t_5))); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    if (unlikely((PyDict_SetItem(__pyx_v_py_radicals, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-
-    /* "chython/containers/_cpack.pyx":161
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:             # <<<<<<<<<<<<<<
- *             py_hydrogens[py_n] = None
- *         else:
- */
-    __pyx_t_5 = ((__pyx_v_hydrogens[__pyx_v_n]) == 7);
-    if (__pyx_t_5) {
-
-      /* "chython/containers/_cpack.pyx":162
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:
- *             py_hydrogens[py_n] = None             # <<<<<<<<<<<<<<
- *         else:
- *             py_hydrogens[py_n] = hydrogens[n]
- */
-      if (unlikely((PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_v_py_n, Py_None) < 0))) __PYX_ERR(0, 162, __pyx_L1_error)
-
-      /* "chython/containers/_cpack.pyx":161
- *         py_charges[py_n] = charges[n]
- *         py_radicals[py_n] = bool(radicals[n])
- *         if hydrogens[n] == 7:             # <<<<<<<<<<<<<<
- *             py_hydrogens[py_n] = None
- *         else:
- */
-      goto __pyx_L13;
-    }
-
-    /* "chython/containers/_cpack.pyx":164
- *             py_hydrogens[py_n] = None
- *         else:
- *             py_hydrogens[py_n] = hydrogens[n]             # <<<<<<<<<<<<<<
- * 
- *         py_plane[py_n] = py_xy
- */
-    /*else*/ {
-      __pyx_t_13 = __Pyx_PyInt_From_unsigned_char((__pyx_v_hydrogens[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 164, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_13);
-      if (unlikely((PyDict_SetItem(__pyx_v_py_hydrogens, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 164, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-    }
-    __pyx_L13:;
-
-    /* "chython/containers/_cpack.pyx":166
- *             py_hydrogens[py_n] = hydrogens[n]
- * 
- *         py_plane[py_n] = py_xy             # <<<<<<<<<<<<<<
- * 
- *         if is_chiral[n]:
- */
-    if (unlikely((PyDict_SetItem(__pyx_v_py_plane, __pyx_v_py_n, __pyx_v_py_xy) < 0))) __PYX_ERR(0, 166, __pyx_L1_error)
-
-    /* "chython/containers/_cpack.pyx":168
- *         py_plane[py_n] = py_xy
- * 
- *         if is_chiral[n]:             # <<<<<<<<<<<<<<
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- */
-    __pyx_t_5 = ((__pyx_v_is_chiral[__pyx_v_n]) != 0);
-    if (__pyx_t_5) {
-
-      /* "chython/containers/_cpack.pyx":169
- * 
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene             # <<<<<<<<<<<<<<
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
- */
-      __pyx_t_5 = ((__pyx_v_neighbors[__pyx_v_n]) == 2);
-      if (__pyx_t_5) {
-
-        /* "chython/containers/_cpack.pyx":170
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]             # <<<<<<<<<<<<<<
- *             else:
- *                 py_atoms_stereo[py_n] = stereo_sign[n]
- */
-        __pyx_t_13 = __Pyx_PyBool_FromLong((__pyx_v_stereo_sign[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 170, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_13);
-        if (unlikely((PyDict_SetItem(__pyx_v_py_allenes_stereo, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 170, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-
-        /* "chython/containers/_cpack.pyx":169
- * 
- *         if is_chiral[n]:
- *             if neighbors[n] == 2:  # allene             # <<<<<<<<<<<<<<
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
- */
-        goto __pyx_L15;
-      }
-
-      /* "chython/containers/_cpack.pyx":172
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- *             else:
- *                 py_atoms_stereo[py_n] = stereo_sign[n]             # <<<<<<<<<<<<<<
- * 
- *         py_bonds[py_n] = py_ngb = {}
- */
-      /*else*/ {
-        __pyx_t_13 = __Pyx_PyBool_FromLong((__pyx_v_stereo_sign[__pyx_v_n])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 172, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_13);
-        if (unlikely((PyDict_SetItem(__pyx_v_py_atoms_stereo, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 172, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-      }
-      __pyx_L15:;
-
-      /* "chython/containers/_cpack.pyx":168
- *         py_plane[py_n] = py_xy
- * 
- *         if is_chiral[n]:             # <<<<<<<<<<<<<<
- *             if neighbors[n] == 2:  # allene
- *                 py_allenes_stereo[py_n] = stereo_sign[n]
- */
-    }
-
-    /* "chython/containers/_cpack.pyx":174
- *                 py_atoms_stereo[py_n] = stereo_sign[n]
- * 
- *         py_bonds[py_n] = py_ngb = {}             # <<<<<<<<<<<<<<
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]
- */
-    __pyx_t_13 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 174, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    if (unlikely((PyDict_SetItem(__pyx_v_py_bonds, __pyx_v_py_n, __pyx_t_13) < 0))) __PYX_ERR(0, 174, __pyx_L1_error)
-    __Pyx_INCREF(__pyx_t_13);
-    __Pyx_XDECREF_SET(__pyx_v_py_ngb, __pyx_t_13);
-    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-
-    /* "chython/containers/_cpack.pyx":175
- * 
- *         py_bonds[py_n] = py_ngb = {}
- *         for i in range(neighbors[n]):             # <<<<<<<<<<<<<<
- *             m = connections[n][i]
- *             py_m = m + 1
- */
-    __pyx_t_9 = (__pyx_v_neighbors[__pyx_v_n]);
-    __pyx_t_11 = __pyx_t_9;
-    for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_11; __pyx_t_10+=1) {
-      __pyx_v_i = __pyx_t_10;
-
-      /* "chython/containers/_cpack.pyx":176
- *         py_bonds[py_n] = py_ngb = {}
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]             # <<<<<<<<<<<<<<
- *             py_m = m + 1
- *             if seen[m]:  # bond partially exists. need back-connection.
- */
-      __pyx_v_m = ((__pyx_v_connections[__pyx_v_n])[__pyx_v_i]);
-
-      /* "chython/containers/_cpack.pyx":177
- *         for i in range(neighbors[n]):
- *             m = connections[n][i]
- *             py_m = m + 1             # <<<<<<<<<<<<<<
- *             if seen[m]:  # bond partially exists. need back-connection.
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
- */
-      __pyx_t_13 = __Pyx_PyInt_From_long((__pyx_v_m + 1)); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 177, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_13);
-      __Pyx_XDECREF_SET(__pyx_v_py_m, __pyx_t_13);
-      __pyx_t_13 = 0;
-
-      /* "chython/containers/_cpack.pyx":178
- *             m = connections[n][i]
- *             py_m = m + 1
- *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
- *             else:
- */
-      __pyx_t_5 = ((__pyx_v_seen[__pyx_v_m]) != 0);
-      if (__pyx_t_5) {
-
-        /* "chython/containers/_cpack.pyx":179
- *             py_m = m + 1
- *             if seen[m]:  # bond partially exists. need back-connection.
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]             # <<<<<<<<<<<<<<
- *             else:
- *                 bond = object.__new__(Bond)
- */
-        __pyx_t_13 = __Pyx_PyDict_GetItem(__pyx_v_py_bonds, __pyx_v_py_m); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_13);
-        __pyx_t_15 = __Pyx_PyObject_GetItem(__pyx_t_13, __pyx_v_py_n); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_15);
-        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-        if (unlikely((PyDict_SetItem(__pyx_v_py_ngb, __pyx_v_py_m, __pyx_t_15) < 0))) __PYX_ERR(0, 179, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-
-        /* "chython/containers/_cpack.pyx":178
- *             m = connections[n][i]
- *             py_m = m + 1
- *             if seen[m]:  # bond partially exists. need back-connection.             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
- *             else:
- */
-        goto __pyx_L18;
-      }
-
-      /* "chython/containers/_cpack.pyx":181
- *                 py_ngb[py_m] = py_bonds[py_m][py_n]
- *             else:
- *                 bond = object.__new__(Bond)             # <<<<<<<<<<<<<<
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n
- */
-      /*else*/ {
-        __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_builtin_object, __pyx_n_s_new); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 181, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_13);
-        __Pyx_GetModuleGlobalName(__pyx_t_16, __pyx_n_s_Bond); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 181, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_16);
-        __pyx_t_17 = NULL;
-        __pyx_t_18 = 0;
-        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
-          __pyx_t_17 = PyMethod_GET_SELF(__pyx_t_13);
-          if (likely(__pyx_t_17)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
-            __Pyx_INCREF(__pyx_t_17);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_13, function);
-            __pyx_t_18 = 1;
-          }
-        }
-        {
-          PyObject *__pyx_callargs[2] = {__pyx_t_17, __pyx_t_16};
-          __pyx_t_15 = __Pyx_PyObject_FastCall(__pyx_t_13, __pyx_callargs+1-__pyx_t_18, 1+__pyx_t_18);
-          __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
-          __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
-          if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 181, __pyx_L1_error)
-          __Pyx_GOTREF(__pyx_t_15);
-          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-        }
-        __Pyx_XDECREF_SET(__pyx_v_bond, __pyx_t_15);
-        __pyx_t_15 = 0;
-
-        /* "chython/containers/_cpack.pyx":182
- *             else:
- *                 bond = object.__new__(Bond)
- *                 bond._Bond__order = orders[n][i]             # <<<<<<<<<<<<<<
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m
- */
-        __pyx_t_15 = __Pyx_PyInt_From_unsigned_char(((__pyx_v_orders[__pyx_v_n])[__pyx_v_i])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 182, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_15);
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__order, __pyx_t_15) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-
-        /* "chython/containers/_cpack.pyx":183
- *                 bond = object.__new__(Bond)
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n             # <<<<<<<<<<<<<<
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond
- */
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__n, __pyx_v_py_n) < 0) __PYX_ERR(0, 183, __pyx_L1_error)
-
-        /* "chython/containers/_cpack.pyx":184
- *                 bond._Bond__order = orders[n][i]
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m             # <<<<<<<<<<<<<<
- *                 py_ngb[py_m] = bond
- *                 py_bonds_flat.append(bond)
- */
-        if (__Pyx_PyObject_SetAttrStr(__pyx_v_bond, __pyx_n_s_Bond__m, __pyx_v_py_m) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
-
-        /* "chython/containers/_cpack.pyx":185
- *                 bond._Bond__n = py_n
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond             # <<<<<<<<<<<<<<
- *                 py_bonds_flat.append(bond)
- * 
- */
-        if (unlikely((PyDict_SetItem(__pyx_v_py_ngb, __pyx_v_py_m, __pyx_v_bond) < 0))) __PYX_ERR(0, 185, __pyx_L1_error)
-
-        /* "chython/containers/_cpack.pyx":186
- *                 bond._Bond__m = py_m
- *                 py_ngb[py_m] = bond
- *                 py_bonds_flat.append(bond)             # <<<<<<<<<<<<<<
- * 
- *     ct_shift = 0
- */
-        __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_py_bonds_flat, __pyx_v_bond); if (unlikely(__pyx_t_14 == ((int)-1))) __PYX_ERR(0, 186, __pyx_L1_error)
-      }
-      __pyx_L18:;
-    }
+static void __pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyObject *o) {
+  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o;
+  PyObject_GC_UnTrack(o);
+  Py_CLEAR(p->__pyx_v_mapping);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_bits1, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_bits2, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_bits3, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_bits4, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_bonds, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_from, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_indices, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_numbers, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_o_to, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_back, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_bonds, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_closures, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_from, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_indices, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_masks1, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_masks2, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_masks3, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_masks4, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_numbers, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_q_to, 1);
+  __PYX_XDEC_MEMVIEW(&p->__pyx_v_scope, 1);
+  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping)))) {
+    __pyx_freelist_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping[__pyx_freecount_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping++] = ((struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o);
+  } else {
+    (*Py_TYPE(o)->tp_free)(o);
   }
+}
 
-  /* "chython/containers/_cpack.pyx":188
- *                 py_bonds_flat.append(bond)
- * 
- *     ct_shift = 0             # <<<<<<<<<<<<<<
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- */
-  __pyx_v_ct_shift = 0;
-
-  /* "chython/containers/_cpack.pyx":189
- * 
- *     ct_shift = 0
- *     for n in range(ct_count):             # <<<<<<<<<<<<<<
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- *         ct_shift += 2
- */
-  __pyx_t_4 = __pyx_v_ct_count;
-  __pyx_t_8 = __pyx_t_4;
-  for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_8; __pyx_t_12+=1) {
-    __pyx_v_n = __pyx_t_12;
-
-    /* "chython/containers/_cpack.pyx":190
- *     ct_shift = 0
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]             # <<<<<<<<<<<<<<
- *         ct_shift += 2
- * 
- */
-    __pyx_t_15 = __Pyx_PyBool_FromLong((__pyx_v_ct_sign[__pyx_v_n])); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_15);
-    __pyx_t_13 = __Pyx_PyInt_From_unsigned_short((__pyx_v_ct_stereo[__pyx_v_ct_shift])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_13);
-    __pyx_t_16 = __Pyx_PyInt_From_unsigned_short((__pyx_v_ct_stereo[(__pyx_v_ct_shift + 1)])); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_16);
-    __pyx_t_17 = PyTuple_New(2); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_17);
-    __Pyx_GIVEREF(__pyx_t_13);
-    PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_13);
-    __Pyx_GIVEREF(__pyx_t_16);
-    PyTuple_SET_ITEM(__pyx_t_17, 1, __pyx_t_16);
-    __pyx_t_13 = 0;
-    __pyx_t_16 = 0;
-    if (unlikely((PyDict_SetItem(__pyx_v_py_cis_trans_stereo, __pyx_t_17, __pyx_t_15) < 0))) __PYX_ERR(0, 190, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
-    __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-
-    /* "chython/containers/_cpack.pyx":191
- *     for n in range(ct_count):
- *         py_cis_trans_stereo[(ct_stereo[ct_shift], ct_stereo[ct_shift + 1])] = ct_sign[n]
- *         ct_shift += 2             # <<<<<<<<<<<<<<
- * 
- *     PyMem_Free(atoms)
- */
-    __pyx_v_ct_shift = (__pyx_v_ct_shift + 2);
-  }
-
-  /* "chython/containers/_cpack.pyx":193
- *         ct_shift += 2
- * 
- *     PyMem_Free(atoms)             # <<<<<<<<<<<<<<
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)
- */
-  PyMem_Free(__pyx_v_atoms);
-
-  /* "chython/containers/_cpack.pyx":194
- * 
- *     PyMem_Free(atoms)
- *     PyMem_Free(charges)             # <<<<<<<<<<<<<<
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)
- */
-  PyMem_Free(__pyx_v_charges);
-
-  /* "chython/containers/_cpack.pyx":195
- *     PyMem_Free(atoms)
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)             # <<<<<<<<<<<<<<
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)
- */
-  PyMem_Free(__pyx_v_radicals);
-
-  /* "chython/containers/_cpack.pyx":196
- *     PyMem_Free(charges)
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)             # <<<<<<<<<<<<<<
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)
- */
-  PyMem_Free(__pyx_v_hydrogens);
-
-  /* "chython/containers/_cpack.pyx":197
- *     PyMem_Free(radicals)
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)             # <<<<<<<<<<<<<<
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)
- */
-  PyMem_Free(__pyx_v_is_chiral);
-
-  /* "chython/containers/_cpack.pyx":198
- *     PyMem_Free(hydrogens)
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)             # <<<<<<<<<<<<<<
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)
- */
-  PyMem_Free(__pyx_v_stereo_sign);
-
-  /* "chython/containers/_cpack.pyx":199
- *     PyMem_Free(is_chiral)
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)             # <<<<<<<<<<<<<<
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)
- */
-  PyMem_Free(__pyx_v_ct_stereo);
-
-  /* "chython/containers/_cpack.pyx":200
- *     PyMem_Free(stereo_sign)
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)             # <<<<<<<<<<<<<<
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)
- */
-  PyMem_Free(__pyx_v_ct_sign);
-
-  /* "chython/containers/_cpack.pyx":201
- *     PyMem_Free(ct_stereo)
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)             # <<<<<<<<<<<<<<
- *     PyMem_Free(seen)
- *     for n in range(size / 3):
- */
-  PyMem_Free(__pyx_v_neighbors);
-
-  /* "chython/containers/_cpack.pyx":202
- *     PyMem_Free(ct_sign)
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)             # <<<<<<<<<<<<<<
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])
- */
-  PyMem_Free(__pyx_v_seen);
-
-  /* "chython/containers/_cpack.pyx":203
- *     PyMem_Free(neighbors)
- *     PyMem_Free(seen)
- *     for n in range(size / 3):             # <<<<<<<<<<<<<<
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])
- */
-  __pyx_t_2 = (((long)__pyx_v_size) / 3);
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_n = __pyx_t_4;
-
-    /* "chython/containers/_cpack.pyx":204
- *     PyMem_Free(seen)
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])             # <<<<<<<<<<<<<<
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)
- */
-    PyMem_Free((__pyx_v_connections[__pyx_v_n]));
-
-    /* "chython/containers/_cpack.pyx":205
- *     for n in range(size / 3):
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])             # <<<<<<<<<<<<<<
- *     PyMem_Free(connections)
- *     PyMem_Free(orders)
- */
-    PyMem_Free((__pyx_v_orders[__pyx_v_n]));
+static int __pyx_tp_traverse_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *p = (struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping *)o;
+  if (p->__pyx_v_mapping) {
+    e = (*v)(p->__pyx_v_mapping, a); if (e) return e;
   }
-
-  /* "chython/containers/_cpack.pyx":206
- *         PyMem_Free(connections[n])
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)             # <<<<<<<<<<<<<<
- *     PyMem_Free(orders)
- * 
- */
-  PyMem_Free(__pyx_v_connections);
-
-  /* "chython/containers/_cpack.pyx":207
- *         PyMem_Free(orders[n])
- *     PyMem_Free(connections)
- *     PyMem_Free(orders)             # <<<<<<<<<<<<<<
- * 
- *     return (py_mapping, py_atoms, py_isotopes,
- */
-  PyMem_Free(__pyx_v_orders);
-
-  /* "chython/containers/_cpack.pyx":209
- *     PyMem_Free(orders)
- * 
- *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
- *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)
- */
-  __Pyx_XDECREF(__pyx_r);
-
-  /* "chython/containers/_cpack.pyx":211
- *     return (py_mapping, py_atoms, py_isotopes,
- *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)             # <<<<<<<<<<<<<<
- */
-  __pyx_t_15 = __Pyx_PyInt_From_unsigned_short(__pyx_v_shift); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 211, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_15);
-
-  /* "chython/containers/_cpack.pyx":209
- *     PyMem_Free(orders)
- * 
- *     return (py_mapping, py_atoms, py_isotopes,             # <<<<<<<<<<<<<<
- *             py_charges, py_radicals, py_hydrogens, py_plane, py_bonds,
- *             py_atoms_stereo, py_allenes_stereo, py_cis_trans_stereo, shift, py_bonds_flat)
- */
-  __pyx_t_17 = PyTuple_New(13); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 209, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_17);
-  __Pyx_INCREF(__pyx_v_py_mapping);
-  __Pyx_GIVEREF(__pyx_v_py_mapping);
-  PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_v_py_mapping);
-  __Pyx_INCREF(__pyx_v_py_atoms);
-  __Pyx_GIVEREF(__pyx_v_py_atoms);
-  PyTuple_SET_ITEM(__pyx_t_17, 1, __pyx_v_py_atoms);
-  __Pyx_INCREF(__pyx_v_py_isotopes);
-  __Pyx_GIVEREF(__pyx_v_py_isotopes);
-  PyTuple_SET_ITEM(__pyx_t_17, 2, __pyx_v_py_isotopes);
-  __Pyx_INCREF(__pyx_v_py_charges);
-  __Pyx_GIVEREF(__pyx_v_py_charges);
-  PyTuple_SET_ITEM(__pyx_t_17, 3, __pyx_v_py_charges);
-  __Pyx_INCREF(__pyx_v_py_radicals);
-  __Pyx_GIVEREF(__pyx_v_py_radicals);
-  PyTuple_SET_ITEM(__pyx_t_17, 4, __pyx_v_py_radicals);
-  __Pyx_INCREF(__pyx_v_py_hydrogens);
-  __Pyx_GIVEREF(__pyx_v_py_hydrogens);
-  PyTuple_SET_ITEM(__pyx_t_17, 5, __pyx_v_py_hydrogens);
-  __Pyx_INCREF(__pyx_v_py_plane);
-  __Pyx_GIVEREF(__pyx_v_py_plane);
-  PyTuple_SET_ITEM(__pyx_t_17, 6, __pyx_v_py_plane);
-  __Pyx_INCREF(__pyx_v_py_bonds);
-  __Pyx_GIVEREF(__pyx_v_py_bonds);
-  PyTuple_SET_ITEM(__pyx_t_17, 7, __pyx_v_py_bonds);
-  __Pyx_INCREF(__pyx_v_py_atoms_stereo);
-  __Pyx_GIVEREF(__pyx_v_py_atoms_stereo);
-  PyTuple_SET_ITEM(__pyx_t_17, 8, __pyx_v_py_atoms_stereo);
-  __Pyx_INCREF(__pyx_v_py_allenes_stereo);
-  __Pyx_GIVEREF(__pyx_v_py_allenes_stereo);
-  PyTuple_SET_ITEM(__pyx_t_17, 9, __pyx_v_py_allenes_stereo);
-  __Pyx_INCREF(__pyx_v_py_cis_trans_stereo);
-  __Pyx_GIVEREF(__pyx_v_py_cis_trans_stereo);
-  PyTuple_SET_ITEM(__pyx_t_17, 10, __pyx_v_py_cis_trans_stereo);
-  __Pyx_GIVEREF(__pyx_t_15);
-  PyTuple_SET_ITEM(__pyx_t_17, 11, __pyx_t_15);
-  __Pyx_INCREF(__pyx_v_py_bonds_flat);
-  __Pyx_GIVEREF(__pyx_v_py_bonds_flat);
-  PyTuple_SET_ITEM(__pyx_t_17, 12, __pyx_v_py_bonds_flat);
-  __pyx_t_15 = 0;
-  __pyx_r = __pyx_t_17;
-  __pyx_t_17 = 0;
-  goto __pyx_L0;
-
-  /* "chython/containers/_cpack.pyx":48
- * # 4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
- * 
- * @cython.nonecheck(False)             # <<<<<<<<<<<<<<
- * @cython.boundscheck(False)
- * @cython.cdivision(True)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_13);
-  __Pyx_XDECREF(__pyx_t_15);
-  __Pyx_XDECREF(__pyx_t_16);
-  __Pyx_XDECREF(__pyx_t_17);
-  __Pyx_AddTraceback("chython.containers._cpack.unpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_py_xy);
-  __Pyx_XDECREF(__pyx_v_bond);
-  __Pyx_XDECREF(__pyx_v_py_n);
-  __Pyx_XDECREF(__pyx_v_py_m);
-  __Pyx_XDECREF(__pyx_v_py_mapping);
-  __Pyx_XDECREF(__pyx_v_py_atoms);
-  __Pyx_XDECREF(__pyx_v_py_isotopes);
-  __Pyx_XDECREF(__pyx_v_py_bonds_flat);
-  __Pyx_XDECREF(__pyx_v_py_charges);
-  __Pyx_XDECREF(__pyx_v_py_radicals);
-  __Pyx_XDECREF(__pyx_v_py_hydrogens);
-  __Pyx_XDECREF(__pyx_v_py_plane);
-  __Pyx_XDECREF(__pyx_v_py_bonds);
-  __Pyx_XDECREF(__pyx_v_py_ngb);
-  __Pyx_XDECREF(__pyx_v_py_atoms_stereo);
-  __Pyx_XDECREF(__pyx_v_py_allenes_stereo);
-  __Pyx_XDECREF(__pyx_v_py_cis_trans_stereo);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
+  return 0;
 }
+
+static PyTypeObject __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "chython.algorithms._isomorphism.__pyx_scope_struct__get_mapping", /*tp_name*/
+  sizeof(struct __pyx_obj_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_traverse*/
+  0, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  0, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  0, /*tp_dictoffset*/
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  0, /*tp_finalize*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1
+  0, /*tp_vectorcall*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+  0, /*tp_print*/
+  #endif
+};
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_array_obj *)o);
   p->__pyx_vtab = __pyx_vtabptr_array;
   p->mode = ((PyObject*)Py_None); Py_INCREF(Py_None);
   p->_format = ((PyObject*)Py_None); Py_INCREF(Py_None);
   if (unlikely(__pyx_array___cinit__(o, a, k) < 0)) goto bad;
   return o;
   bad:
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_array(PyObject *o) {
   struct __pyx_array_obj *p = (struct __pyx_array_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_array) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
     __pyx_array___dealloc__(o);
@@ -18728,19 +17267,16 @@
 }
 
 static int __pyx_mp_ass_subscript_array(PyObject *o, PyObject *i, PyObject *v) {
   if (v) {
     return __pyx_array___setitem__(o, i, v);
   }
   else {
-    __Pyx_TypeName o_type_name;
-    o_type_name = __Pyx_PyType_GetName(Py_TYPE(o));
     PyErr_Format(PyExc_NotImplementedError,
-      "Subscript deletion not supported by " __Pyx_FMT_TYPENAME, o_type_name);
-    __Pyx_DECREF_TypeName(o_type_name);
+      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
     return -1;
   }
 }
 
 static PyObject *__pyx_tp_getattro_array(PyObject *o, PyObject *n) {
   PyObject *v = __Pyx_PyObject_GenericGetAttr(o, n);
   if (!v && PyErr_ExceptionMatches(PyExc_AttributeError)) {
@@ -18752,67 +17288,23 @@
 
 static PyObject *__pyx_getprop___pyx_array_memview(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_5array_7memview_1__get__(o);
 }
 
 static PyMethodDef __pyx_methods_array[] = {
   {"__getattr__", (PyCFunction)__pyx_array___getattr__, METH_O|METH_COEXIST, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_array_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_array_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_array_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_array_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_array[] = {
   {(char *)"memview", __pyx_getprop___pyx_array_memview, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-#if !CYTHON_COMPILING_IN_LIMITED_API
-
-static PyBufferProcs __pyx_tp_as_buffer_array = {
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getreadbuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getwritebuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getsegcount*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getcharbuffer*/
-  #endif
-  __pyx_array_getbuffer, /*bf_getbuffer*/
-  0, /*bf_releasebuffer*/
-};
-#endif
-static PyType_Slot __pyx_type___pyx_array_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_array},
-  {Py_sq_length, (void *)__pyx_array___len__},
-  {Py_sq_item, (void *)__pyx_sq_item_array},
-  {Py_mp_length, (void *)__pyx_array___len__},
-  {Py_mp_subscript, (void *)__pyx_array___getitem__},
-  {Py_mp_ass_subscript, (void *)__pyx_mp_ass_subscript_array},
-  {Py_tp_getattro, (void *)__pyx_tp_getattro_array},
-  #if defined(Py_bf_getbuffer)
-  {Py_bf_getbuffer, (void *)__pyx_array_getbuffer},
-  #endif
-  {Py_tp_methods, (void *)__pyx_methods_array},
-  {Py_tp_getset, (void *)__pyx_getsets_array},
-  {Py_tp_new, (void *)__pyx_tp_new_array},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_array_spec = {
-  "chython.containers._cpack.array",
-  sizeof(struct __pyx_array_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_SEQUENCE,
-  __pyx_type___pyx_array_slots,
-};
-#else
 
 static PySequenceMethods __pyx_tp_as_sequence_array = {
   __pyx_array___len__, /*sq_length*/
   0, /*sq_concat*/
   0, /*sq_repeat*/
   __pyx_sq_item_array, /*sq_item*/
   0, /*sq_slice*/
@@ -18844,15 +17336,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.""array", /*tp_name*/
+  "chython.algorithms._isomorphism.array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -18872,92 +17364,72 @@
   &__pyx_tp_as_mapping_array, /*tp_as_mapping*/
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   __pyx_tp_getattro_array, /*tp_getattro*/
   0, /*tp_setattro*/
   &__pyx_tp_as_buffer_array, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_SEQUENCE, /*tp_flags*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
   0, /*tp_doc*/
   0, /*tp_traverse*/
   0, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_array, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_array, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_array, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
-  #endif
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_MemviewEnum_obj *)o);
   p->name = Py_None; Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_Enum(PyObject *o) {
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_Enum) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->name);
   (*Py_TYPE(o)->tp_free)(o);
 }
 
@@ -18975,47 +17447,23 @@
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   tmp = ((PyObject*)p->name);
   p->name = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   return 0;
 }
 
-static PyObject *__pyx_specialmethod___pyx_MemviewEnum___repr__(PyObject *self, CYTHON_UNUSED PyObject *arg) {
-  return __pyx_MemviewEnum___repr__(self);
-}
-
 static PyMethodDef __pyx_methods_Enum[] = {
-  {"__repr__", (PyCFunction)__pyx_specialmethod___pyx_MemviewEnum___repr__, METH_NOARGS|METH_COEXIST, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type___pyx_MemviewEnum_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_Enum},
-  {Py_tp_repr, (void *)__pyx_MemviewEnum___repr__},
-  {Py_tp_traverse, (void *)__pyx_tp_traverse_Enum},
-  {Py_tp_clear, (void *)__pyx_tp_clear_Enum},
-  {Py_tp_methods, (void *)__pyx_methods_Enum},
-  {Py_tp_init, (void *)__pyx_MemviewEnum___init__},
-  {Py_tp_new, (void *)__pyx_tp_new_Enum},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_MemviewEnum_spec = {
-  "chython.containers._cpack.Enum",
-  sizeof(struct __pyx_MemviewEnum_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
-  __pyx_type___pyx_MemviewEnum_slots,
-};
-#else
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.""Enum", /*tp_name*/
+  "chython.algorithms._isomorphism.Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -19050,66 +17498,48 @@
   __pyx_methods_Enum, /*tp_methods*/
   0, /*tp_members*/
   0, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   __pyx_MemviewEnum___init__, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_Enum, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
   PyObject *o;
-  #if CYTHON_COMPILING_IN_LIMITED_API
-  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
-  o = alloc_func(t, 0);
-  #else
-  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  #endif
   p = ((struct __pyx_memoryview_obj *)o);
   p->__pyx_vtab = __pyx_vtabptr_memoryview;
   p->obj = Py_None; Py_INCREF(Py_None);
   p->_size = Py_None; Py_INCREF(Py_None);
   p->_array_interface = Py_None; Py_INCREF(Py_None);
   p->view.obj = NULL;
   if (unlikely(__pyx_memoryview___cinit__(o, a, k) < 0)) goto bad;
@@ -19118,18 +17548,16 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_memoryview(PyObject *o) {
   struct __pyx_memoryview_obj *p = (struct __pyx_memoryview_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_memoryview) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -19185,19 +17613,16 @@
 }
 
 static int __pyx_mp_ass_subscript_memoryview(PyObject *o, PyObject *i, PyObject *v) {
   if (v) {
     return __pyx_memoryview___setitem__(o, i, v);
   }
   else {
-    __Pyx_TypeName o_type_name;
-    o_type_name = __Pyx_PyType_GetName(Py_TYPE(o));
     PyErr_Format(PyExc_NotImplementedError,
-      "Subscript deletion not supported by " __Pyx_FMT_TYPENAME, o_type_name);
-    __Pyx_DECREF_TypeName(o_type_name);
+      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
     return -1;
   }
 }
 
 static PyObject *__pyx_getprop___pyx_memoryview_T(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_10memoryview_1T_1__get__(o);
 }
@@ -19230,26 +17655,21 @@
   return __pyx_pw_15View_dot_MemoryView_10memoryview_6nbytes_1__get__(o);
 }
 
 static PyObject *__pyx_getprop___pyx_memoryview_size(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_15View_dot_MemoryView_10memoryview_4size_1__get__(o);
 }
 
-static PyObject *__pyx_specialmethod___pyx_memoryview___repr__(PyObject *self, CYTHON_UNUSED PyObject *arg) {
-  return __pyx_memoryview___repr__(self);
-}
-
 static PyMethodDef __pyx_methods_memoryview[] = {
-  {"__repr__", (PyCFunction)__pyx_specialmethod___pyx_memoryview___repr__, METH_NOARGS|METH_COEXIST, 0},
-  {"is_c_contig", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_is_c_contig, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"is_f_contig", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_is_f_contig, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"copy", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_copy, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"copy_fortran", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_memoryview_copy_fortran, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryview_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryview_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"is_c_contig", (PyCFunction)__pyx_memoryview_is_c_contig, METH_NOARGS, 0},
+  {"is_f_contig", (PyCFunction)__pyx_memoryview_is_f_contig, METH_NOARGS, 0},
+  {"copy", (PyCFunction)__pyx_memoryview_copy, METH_NOARGS, 0},
+  {"copy_fortran", (PyCFunction)__pyx_memoryview_copy_fortran, METH_NOARGS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_memoryview[] = {
   {(char *)"T", __pyx_getprop___pyx_memoryview_T, 0, (char *)0, 0},
   {(char *)"base", __pyx_getprop___pyx_memoryview_base, 0, (char *)0, 0},
   {(char *)"shape", __pyx_getprop___pyx_memoryview_shape, 0, (char *)0, 0},
@@ -19257,61 +17677,14 @@
   {(char *)"suboffsets", __pyx_getprop___pyx_memoryview_suboffsets, 0, (char *)0, 0},
   {(char *)"ndim", __pyx_getprop___pyx_memoryview_ndim, 0, (char *)0, 0},
   {(char *)"itemsize", __pyx_getprop___pyx_memoryview_itemsize, 0, (char *)0, 0},
   {(char *)"nbytes", __pyx_getprop___pyx_memoryview_nbytes, 0, (char *)0, 0},
   {(char *)"size", __pyx_getprop___pyx_memoryview_size, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-#if !CYTHON_COMPILING_IN_LIMITED_API
-
-static PyBufferProcs __pyx_tp_as_buffer_memoryview = {
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getreadbuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getwritebuffer*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getsegcount*/
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  0, /*bf_getcharbuffer*/
-  #endif
-  __pyx_memoryview_getbuffer, /*bf_getbuffer*/
-  0, /*bf_releasebuffer*/
-};
-#endif
-static PyType_Slot __pyx_type___pyx_memoryview_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_memoryview},
-  {Py_tp_repr, (void *)__pyx_memoryview___repr__},
-  {Py_sq_length, (void *)__pyx_memoryview___len__},
-  {Py_sq_item, (void *)__pyx_sq_item_memoryview},
-  {Py_mp_length, (void *)__pyx_memoryview___len__},
-  {Py_mp_subscript, (void *)__pyx_memoryview___getitem__},
-  {Py_mp_ass_subscript, (void *)__pyx_mp_ass_subscript_memoryview},
-  {Py_tp_str, (void *)__pyx_memoryview___str__},
-  #if defined(Py_bf_getbuffer)
-  {Py_bf_getbuffer, (void *)__pyx_memoryview_getbuffer},
-  #endif
-  {Py_tp_traverse, (void *)__pyx_tp_traverse_memoryview},
-  {Py_tp_clear, (void *)__pyx_tp_clear_memoryview},
-  {Py_tp_methods, (void *)__pyx_methods_memoryview},
-  {Py_tp_getset, (void *)__pyx_getsets_memoryview},
-  {Py_tp_new, (void *)__pyx_tp_new_memoryview},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_memoryview_spec = {
-  "chython.containers._cpack.memoryview",
-  sizeof(struct __pyx_memoryview_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
-  __pyx_type___pyx_memoryview_slots,
-};
-#else
 
 static PySequenceMethods __pyx_tp_as_sequence_memoryview = {
   __pyx_memoryview___len__, /*sq_length*/
   0, /*sq_concat*/
   0, /*sq_repeat*/
   __pyx_sq_item_memoryview, /*sq_item*/
   0, /*sq_slice*/
@@ -19343,15 +17716,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.""memoryview", /*tp_name*/
+  "chython.algorithms._isomorphism.memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -19386,50 +17759,37 @@
   __pyx_methods_memoryview, /*tp_methods*/
   0, /*tp_members*/
   __pyx_getsets_memoryview, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_memoryview, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
   PyObject *o = __pyx_tp_new_memoryview(t, a, k);
   if (unlikely(!o)) return 0;
   p = ((struct __pyx_memoryviewslice_obj *)o);
@@ -19438,18 +17798,16 @@
   p->from_slice.memview = NULL;
   return o;
 }
 
 static void __pyx_tp_dealloc__memoryviewslice(PyObject *o) {
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
-    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc__memoryviewslice) {
-      if (PyObject_CallFinalizerFromDealloc(o)) return;
-    }
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+    if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -19475,45 +17833,36 @@
 static int __pyx_tp_clear__memoryviewslice(PyObject *o) {
   PyObject* tmp;
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   __pyx_tp_clear_memoryview(o);
   tmp = ((PyObject*)p->from_object);
   p->from_object = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
-  __PYX_XCLEAR_MEMVIEW(&p->from_slice, 1);
+  __PYX_XDEC_MEMVIEW(&p->from_slice, 1);
   return 0;
 }
 
+static PyObject *__pyx_getprop___pyx_memoryviewslice_base(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_15View_dot_MemoryView_16_memoryviewslice_4base_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods__memoryviewslice[] = {
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryviewslice_1__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw___pyx_memoryviewslice_3__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_1__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_type___pyx_memoryviewslice_slots[] = {
-  {Py_tp_dealloc, (void *)__pyx_tp_dealloc__memoryviewslice},
-  {Py_tp_doc, (void *)PyDoc_STR("Internal class for passing memoryview slices to Python")},
-  {Py_tp_traverse, (void *)__pyx_tp_traverse__memoryviewslice},
-  {Py_tp_clear, (void *)__pyx_tp_clear__memoryviewslice},
-  {Py_tp_methods, (void *)__pyx_methods__memoryviewslice},
-  {Py_tp_new, (void *)__pyx_tp_new__memoryviewslice},
-  {0, 0},
-};
-static PyType_Spec __pyx_type___pyx_memoryviewslice_spec = {
-  "chython.containers._cpack._memoryviewslice",
-  sizeof(struct __pyx_memoryviewslice_obj),
-  0,
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_SEQUENCE,
-  __pyx_type___pyx_memoryviewslice_slots,
+
+static struct PyGetSetDef __pyx_getsets__memoryviewslice[] = {
+  {(char *)"base", __pyx_getprop___pyx_memoryviewslice_base, 0, (char *)0, 0},
+  {0, 0, 0, 0, 0}
 };
-#else
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "chython.containers._cpack.""_memoryviewslice", /*tp_name*/
+  "chython.algorithms._isomorphism._memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -19523,500 +17872,575 @@
   0, /*tp_setattr*/
   #if PY_MAJOR_VERSION < 3
   0, /*tp_compare*/
   #endif
   #if PY_MAJOR_VERSION >= 3
   0, /*tp_as_async*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY || 0
+  #if CYTHON_COMPILING_IN_PYPY
   __pyx_memoryview___repr__, /*tp_repr*/
   #else
   0, /*tp_repr*/
   #endif
   0, /*tp_as_number*/
   0, /*tp_as_sequence*/
   0, /*tp_as_mapping*/
   0, /*tp_hash*/
   0, /*tp_call*/
-  #if CYTHON_COMPILING_IN_PYPY || 0
+  #if CYTHON_COMPILING_IN_PYPY
   __pyx_memoryview___str__, /*tp_str*/
   #else
   0, /*tp_str*/
   #endif
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_SEQUENCE, /*tp_flags*/
-  PyDoc_STR("Internal class for passing memoryview slices to Python"), /*tp_doc*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  "Internal class for passing memoryview slices to Python", /*tp_doc*/
   __pyx_tp_traverse__memoryviewslice, /*tp_traverse*/
   __pyx_tp_clear__memoryviewslice, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods__memoryviewslice, /*tp_methods*/
   0, /*tp_members*/
-  0, /*tp_getset*/
+  __pyx_getsets__memoryviewslice, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
-  #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
-  #endif
   0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new__memoryviewslice, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
-  #if CYTHON_USE_TP_FINALIZE
   0, /*tp_finalize*/
-  #else
-  NULL, /*tp_finalize*/
   #endif
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  #if PY_VERSION_HEX >= 0x030800b1
   0, /*tp_vectorcall*/
   #endif
-  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if PY_VERSION_HEX >= 0x030C0000
-  0, /*tp_watched*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-  0, /*tp_pypy_flags*/
-  #endif
 };
-#endif
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
+
+#if PY_MAJOR_VERSION >= 3
+#if CYTHON_PEP489_MULTI_PHASE_INIT
+static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
+static int __pyx_pymod_exec__isomorphism(PyObject* module); /*proto*/
+static PyModuleDef_Slot __pyx_moduledef_slots[] = {
+  {Py_mod_create, (void*)__pyx_pymod_create},
+  {Py_mod_exec, (void*)__pyx_pymod_exec__isomorphism},
+  {0, NULL}
+};
+#endif
+
+static struct PyModuleDef __pyx_moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "_isomorphism",
+    0, /* m_doc */
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    0, /* m_size */
+  #else
+    -1, /* m_size */
+  #endif
+    __pyx_methods /* m_methods */,
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+    __pyx_moduledef_slots, /* m_slots */
+  #else
+    NULL, /* m_reload */
+  #endif
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
 #ifndef CYTHON_SMALL_CODE
 #if defined(__clang__)
     #define CYTHON_SMALL_CODE
 #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
-/* #### Code section: pystring_table ### */
 
-static int __Pyx_CreateStringTabAndInitStrings(void) {
-  __Pyx_StringTabEntry __pyx_string_tab[] = {
-    {&__pyx_kp_u_, __pyx_k_, sizeof(__pyx_k_), 0, 1, 0, 0},
-    {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
-    {&__pyx_kp_s_All_dimensions_preceding_dimensi, __pyx_k_All_dimensions_preceding_dimensi, sizeof(__pyx_k_All_dimensions_preceding_dimensi), 0, 0, 1, 0},
-    {&__pyx_n_s_AssertionError, __pyx_k_AssertionError, sizeof(__pyx_k_AssertionError), 0, 0, 1, 1},
-    {&__pyx_n_s_Bond, __pyx_k_Bond, sizeof(__pyx_k_Bond), 0, 0, 1, 1},
-    {&__pyx_n_s_Bond__m, __pyx_k_Bond__m, sizeof(__pyx_k_Bond__m), 0, 0, 1, 1},
-    {&__pyx_n_s_Bond__n, __pyx_k_Bond__n, sizeof(__pyx_k_Bond__n), 0, 0, 1, 1},
-    {&__pyx_n_s_Bond__order, __pyx_k_Bond__order, sizeof(__pyx_k_Bond__order), 0, 0, 1, 1},
-    {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
-    {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
-    {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
-    {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
-    {&__pyx_kp_u_Cannot_index_with_type, __pyx_k_Cannot_index_with_type, sizeof(__pyx_k_Cannot_index_with_type), 0, 1, 0, 0},
-    {&__pyx_kp_s_Cannot_transpose_memoryview_with, __pyx_k_Cannot_transpose_memoryview_with, sizeof(__pyx_k_Cannot_transpose_memoryview_with), 0, 0, 1, 0},
-    {&__pyx_kp_s_Dimension_d_is_not_direct, __pyx_k_Dimension_d_is_not_direct, sizeof(__pyx_k_Dimension_d_is_not_direct), 0, 0, 1, 0},
-    {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
-    {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
-    {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
-    {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
-    {&__pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_k_Index_out_of_bounds_axis_d, sizeof(__pyx_k_Index_out_of_bounds_axis_d), 0, 0, 1, 0},
-    {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
-    {&__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 1, 0, 0},
-    {&__pyx_kp_u_Invalid_shape_in_axis, __pyx_k_Invalid_shape_in_axis, sizeof(__pyx_k_Invalid_shape_in_axis), 0, 1, 0, 0},
-    {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
-    {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
-    {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
-    {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
-    {&__pyx_kp_u_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 1, 0, 0},
-    {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
-    {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
-    {&__pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_k_Step_may_not_be_zero_axis_d, sizeof(__pyx_k_Step_may_not_be_zero_axis_d), 0, 0, 1, 0},
-    {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
-    {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
-    {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-    {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
-    {&__pyx_kp_u__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 1, 0, 0},
-    {&__pyx_n_s__23, __pyx_k__23, sizeof(__pyx_k__23), 0, 0, 1, 1},
-    {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
-    {&__pyx_kp_u__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 1, 0, 0},
-    {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
-    {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
-    {&__pyx_n_s_abc, __pyx_k_abc, sizeof(__pyx_k_abc), 0, 0, 1, 1},
-    {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
-    {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
-    {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
-    {&__pyx_n_s_atoms, __pyx_k_atoms, sizeof(__pyx_k_atoms), 0, 0, 1, 1},
-    {&__pyx_n_s_atoms_count, __pyx_k_atoms_count, sizeof(__pyx_k_atoms_count), 0, 0, 1, 1},
-    {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
-    {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
-    {&__pyx_n_s_bond, __pyx_k_bond, sizeof(__pyx_k_bond), 0, 0, 1, 1},
-    {&__pyx_n_s_bond_shift, __pyx_k_bond_shift, sizeof(__pyx_k_bond_shift), 0, 0, 1, 1},
-    {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
-    {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
-    {&__pyx_n_s_charges, __pyx_k_charges, sizeof(__pyx_k_charges), 0, 0, 1, 1},
-    {&__pyx_n_s_chython_containers__cpack, __pyx_k_chython_containers__cpack, sizeof(__pyx_k_chython_containers__cpack), 0, 0, 1, 1},
-    {&__pyx_kp_s_chython_containers__cpack_pyx, __pyx_k_chython_containers__cpack_pyx, sizeof(__pyx_k_chython_containers__cpack_pyx), 0, 0, 1, 0},
-    {&__pyx_n_s_chython_containers_bonds, __pyx_k_chython_containers_bonds, sizeof(__pyx_k_chython_containers_bonds), 0, 0, 1, 1},
-    {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
-    {&__pyx_n_s_class_getitem, __pyx_k_class_getitem, sizeof(__pyx_k_class_getitem), 0, 0, 1, 1},
-    {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-    {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
-    {&__pyx_kp_s_collections_abc, __pyx_k_collections_abc, sizeof(__pyx_k_collections_abc), 0, 0, 1, 0},
-    {&__pyx_n_s_connections, __pyx_k_connections, sizeof(__pyx_k_connections), 0, 0, 1, 1},
-    {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
-    {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
-    {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
-    {&__pyx_n_s_ct_count, __pyx_k_ct_count, sizeof(__pyx_k_ct_count), 0, 0, 1, 1},
-    {&__pyx_n_s_ct_shift, __pyx_k_ct_shift, sizeof(__pyx_k_ct_shift), 0, 0, 1, 1},
-    {&__pyx_n_s_ct_sign, __pyx_k_ct_sign, sizeof(__pyx_k_ct_sign), 0, 0, 1, 1},
-    {&__pyx_n_s_ct_stereo, __pyx_k_ct_stereo, sizeof(__pyx_k_ct_stereo), 0, 0, 1, 1},
-    {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
-    {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
-    {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
-    {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
-    {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
-    {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
-    {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
-    {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
-    {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
-    {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
-    {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
-    {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
-    {&__pyx_kp_u_gc, __pyx_k_gc, sizeof(__pyx_k_gc), 0, 1, 0, 0},
-    {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-    {&__pyx_kp_u_got, __pyx_k_got, sizeof(__pyx_k_got), 0, 1, 0, 0},
-    {&__pyx_kp_u_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 1, 0, 0},
-    {&__pyx_n_s_hydrogens, __pyx_k_hydrogens, sizeof(__pyx_k_hydrogens), 0, 0, 1, 1},
-    {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
-    {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
-    {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-    {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
-    {&__pyx_n_s_initializing, __pyx_k_initializing, sizeof(__pyx_k_initializing), 0, 0, 1, 1},
-    {&__pyx_n_s_is_chiral, __pyx_k_is_chiral, sizeof(__pyx_k_is_chiral), 0, 0, 1, 1},
-    {&__pyx_n_s_is_coroutine, __pyx_k_is_coroutine, sizeof(__pyx_k_is_coroutine), 0, 0, 1, 1},
-    {&__pyx_kp_u_isenabled, __pyx_k_isenabled, sizeof(__pyx_k_isenabled), 0, 1, 0, 0},
-    {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
-    {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
-    {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
-    {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-    {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
-    {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
-    {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
-    {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
-    {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
-    {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
-    {&__pyx_n_s_neighbors, __pyx_k_neighbors, sizeof(__pyx_k_neighbors), 0, 0, 1, 1},
-    {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
-    {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
-    {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
-    {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
-    {&__pyx_n_s_orders, __pyx_k_orders, sizeof(__pyx_k_orders), 0, 0, 1, 1},
-    {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
-    {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
-    {&__pyx_n_s_py_allenes_stereo, __pyx_k_py_allenes_stereo, sizeof(__pyx_k_py_allenes_stereo), 0, 0, 1, 1},
-    {&__pyx_n_s_py_atoms, __pyx_k_py_atoms, sizeof(__pyx_k_py_atoms), 0, 0, 1, 1},
-    {&__pyx_n_s_py_atoms_stereo, __pyx_k_py_atoms_stereo, sizeof(__pyx_k_py_atoms_stereo), 0, 0, 1, 1},
-    {&__pyx_n_s_py_bonds, __pyx_k_py_bonds, sizeof(__pyx_k_py_bonds), 0, 0, 1, 1},
-    {&__pyx_n_s_py_bonds_flat, __pyx_k_py_bonds_flat, sizeof(__pyx_k_py_bonds_flat), 0, 0, 1, 1},
-    {&__pyx_n_s_py_charges, __pyx_k_py_charges, sizeof(__pyx_k_py_charges), 0, 0, 1, 1},
-    {&__pyx_n_s_py_cis_trans_stereo, __pyx_k_py_cis_trans_stereo, sizeof(__pyx_k_py_cis_trans_stereo), 0, 0, 1, 1},
-    {&__pyx_n_s_py_hydrogens, __pyx_k_py_hydrogens, sizeof(__pyx_k_py_hydrogens), 0, 0, 1, 1},
-    {&__pyx_n_s_py_isotopes, __pyx_k_py_isotopes, sizeof(__pyx_k_py_isotopes), 0, 0, 1, 1},
-    {&__pyx_n_s_py_m, __pyx_k_py_m, sizeof(__pyx_k_py_m), 0, 0, 1, 1},
-    {&__pyx_n_s_py_mapping, __pyx_k_py_mapping, sizeof(__pyx_k_py_mapping), 0, 0, 1, 1},
-    {&__pyx_n_s_py_n, __pyx_k_py_n, sizeof(__pyx_k_py_n), 0, 0, 1, 1},
-    {&__pyx_n_s_py_ngb, __pyx_k_py_ngb, sizeof(__pyx_k_py_ngb), 0, 0, 1, 1},
-    {&__pyx_n_s_py_plane, __pyx_k_py_plane, sizeof(__pyx_k_py_plane), 0, 0, 1, 1},
-    {&__pyx_n_s_py_radicals, __pyx_k_py_radicals, sizeof(__pyx_k_py_radicals), 0, 0, 1, 1},
-    {&__pyx_n_s_py_xy, __pyx_k_py_xy, sizeof(__pyx_k_py_xy), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
-    {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-    {&__pyx_n_s_radicals, __pyx_k_radicals, sizeof(__pyx_k_radicals), 0, 0, 1, 1},
-    {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
-    {&__pyx_n_s_register, __pyx_k_register, sizeof(__pyx_k_register), 0, 0, 1, 1},
-    {&__pyx_n_s_seen, __pyx_k_seen, sizeof(__pyx_k_seen), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
-    {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
-    {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
-    {&__pyx_n_s_shift, __pyx_k_shift, sizeof(__pyx_k_shift), 0, 0, 1, 1},
-    {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
-    {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
-    {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
-    {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
-    {&__pyx_n_s_stereo_sign, __pyx_k_stereo_sign, sizeof(__pyx_k_stereo_sign), 0, 0, 1, 1},
-    {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
-    {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
-    {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
-    {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
-    {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
-    {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
-    {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
-    {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-    {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
-    {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
-    {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
-    {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
-    {&__pyx_n_s_version_info, __pyx_k_version_info, sizeof(__pyx_k_version_info), 0, 0, 1, 1},
-    {0, 0, 0, 0, 0, 0, 0}
-  };
-  return __Pyx_InitStrings(__pyx_string_tab);
-}
-/* #### Code section: cached_builtins ### */
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
+  {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
+  {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
+  {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
+  {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
+  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
+  {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
+  {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
+  {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
+  {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
+  {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
+  {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
+  {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
+  {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
+  {&__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 0, 1, 0},
+  {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
+  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
+  {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
+  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
+  {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
+  {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
+  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
+  {&__pyx_n_s_back, __pyx_k_back, sizeof(__pyx_k_back), 0, 0, 1, 1},
+  {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
+  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
+  {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
+  {&__pyx_n_s_chython_algorithms__isomorphism, __pyx_k_chython_algorithms__isomorphism, sizeof(__pyx_k_chython_algorithms__isomorphism), 0, 0, 1, 1},
+  {&__pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_k_chython_algorithms__isomorphism_2, sizeof(__pyx_k_chython_algorithms__isomorphism_2), 0, 0, 1, 0},
+  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
+  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
+  {&__pyx_n_s_closures_counter, __pyx_k_closures_counter, sizeof(__pyx_k_closures_counter), 0, 0, 1, 1},
+  {&__pyx_n_s_closures_num, __pyx_k_closures_num, sizeof(__pyx_k_closures_num), 0, 0, 1, 1},
+  {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
+  {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
+  {&__pyx_n_s_depth, __pyx_k_depth, sizeof(__pyx_k_depth), 0, 0, 1, 1},
+  {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
+  {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
+  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
+  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
+  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
+  {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
+  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
+  {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
+  {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
+  {&__pyx_n_s_front, __pyx_k_front, sizeof(__pyx_k_front), 0, 0, 1, 1},
+  {&__pyx_n_s_get_mapping, __pyx_k_get_mapping, sizeof(__pyx_k_get_mapping), 0, 0, 1, 1},
+  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
+  {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
+  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
+  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
+  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+  {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
+  {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
+  {&__pyx_n_s_j, __pyx_k_j, sizeof(__pyx_k_j), 0, 0, 1, 1},
+  {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
+  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
+  {&__pyx_n_s_mapping, __pyx_k_mapping, sizeof(__pyx_k_mapping), 0, 0, 1, 1},
+  {&__pyx_n_s_matched, __pyx_k_matched, sizeof(__pyx_k_matched), 0, 0, 1, 1},
+  {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
+  {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
+  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
+  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
+  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
+  {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
+  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
+  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
+  {&__pyx_n_s_o, __pyx_k_o, sizeof(__pyx_k_o), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bits1, __pyx_k_o_bits1, sizeof(__pyx_k_o_bits1), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bits2, __pyx_k_o_bits2, sizeof(__pyx_k_o_bits2), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bits3, __pyx_k_o_bits3, sizeof(__pyx_k_o_bits3), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bits4, __pyx_k_o_bits4, sizeof(__pyx_k_o_bits4), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bond, __pyx_k_o_bond, sizeof(__pyx_k_o_bond), 0, 0, 1, 1},
+  {&__pyx_n_s_o_bonds, __pyx_k_o_bonds, sizeof(__pyx_k_o_bonds), 0, 0, 1, 1},
+  {&__pyx_n_s_o_closures, __pyx_k_o_closures, sizeof(__pyx_k_o_closures), 0, 0, 1, 1},
+  {&__pyx_n_s_o_from, __pyx_k_o_from, sizeof(__pyx_k_o_from), 0, 0, 1, 1},
+  {&__pyx_n_s_o_indices, __pyx_k_o_indices, sizeof(__pyx_k_o_indices), 0, 0, 1, 1},
+  {&__pyx_n_s_o_numbers, __pyx_k_o_numbers, sizeof(__pyx_k_o_numbers), 0, 0, 1, 1},
+  {&__pyx_n_s_o_size, __pyx_k_o_size, sizeof(__pyx_k_o_size), 0, 0, 1, 1},
+  {&__pyx_n_s_o_to, __pyx_k_o_to, sizeof(__pyx_k_o_to), 0, 0, 1, 1},
+  {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
+  {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
+  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
+  {&__pyx_n_s_path_size, __pyx_k_path_size, sizeof(__pyx_k_path_size), 0, 0, 1, 1},
+  {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
+  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
+  {&__pyx_n_s_q_back, __pyx_k_q_back, sizeof(__pyx_k_q_back), 0, 0, 1, 1},
+  {&__pyx_n_s_q_bonds, __pyx_k_q_bonds, sizeof(__pyx_k_q_bonds), 0, 0, 1, 1},
+  {&__pyx_n_s_q_closures, __pyx_k_q_closures, sizeof(__pyx_k_q_closures), 0, 0, 1, 1},
+  {&__pyx_n_s_q_from, __pyx_k_q_from, sizeof(__pyx_k_q_from), 0, 0, 1, 1},
+  {&__pyx_n_s_q_indices, __pyx_k_q_indices, sizeof(__pyx_k_q_indices), 0, 0, 1, 1},
+  {&__pyx_n_s_q_mask1, __pyx_k_q_mask1, sizeof(__pyx_k_q_mask1), 0, 0, 1, 1},
+  {&__pyx_n_s_q_mask2, __pyx_k_q_mask2, sizeof(__pyx_k_q_mask2), 0, 0, 1, 1},
+  {&__pyx_n_s_q_mask3, __pyx_k_q_mask3, sizeof(__pyx_k_q_mask3), 0, 0, 1, 1},
+  {&__pyx_n_s_q_mask4, __pyx_k_q_mask4, sizeof(__pyx_k_q_mask4), 0, 0, 1, 1},
+  {&__pyx_n_s_q_masks1, __pyx_k_q_masks1, sizeof(__pyx_k_q_masks1), 0, 0, 1, 1},
+  {&__pyx_n_s_q_masks2, __pyx_k_q_masks2, sizeof(__pyx_k_q_masks2), 0, 0, 1, 1},
+  {&__pyx_n_s_q_masks3, __pyx_k_q_masks3, sizeof(__pyx_k_q_masks3), 0, 0, 1, 1},
+  {&__pyx_n_s_q_masks4, __pyx_k_q_masks4, sizeof(__pyx_k_q_masks4), 0, 0, 1, 1},
+  {&__pyx_n_s_q_numbers, __pyx_k_q_numbers, sizeof(__pyx_k_q_numbers), 0, 0, 1, 1},
+  {&__pyx_n_s_q_size, __pyx_k_q_size, sizeof(__pyx_k_q_size), 0, 0, 1, 1},
+  {&__pyx_n_s_q_size_dec, __pyx_k_q_size_dec, sizeof(__pyx_k_q_size_dec), 0, 0, 1, 1},
+  {&__pyx_n_s_q_to, __pyx_k_q_to, sizeof(__pyx_k_q_to), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
+  {&__pyx_n_s_scope, __pyx_k_scope, sizeof(__pyx_k_scope), 0, 0, 1, 1},
+  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
+  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
+  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
+  {&__pyx_n_s_stack, __pyx_k_stack, sizeof(__pyx_k_stack), 0, 0, 1, 1},
+  {&__pyx_n_s_stack_depth, __pyx_k_stack_depth, sizeof(__pyx_k_stack_depth), 0, 0, 1, 1},
+  {&__pyx_n_s_stack_index, __pyx_k_stack_index, sizeof(__pyx_k_stack_index), 0, 0, 1, 1},
+  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
+  {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
+  {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
+  {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
+  {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
+  {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
+  {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
+  {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
+  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
+  {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
+  {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
+  {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
+  {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {0, 0, 0, 0, 0, 0, 0}
+};
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 81, __pyx_L1_error)
-  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 181, __pyx_L1_error)
-  __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(1, 100, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 141, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 156, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 159, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 57, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 67, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 133, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 151, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(1, 373, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 408, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 618, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 914, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 404, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 613, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 832, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: cached_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "View.MemoryView":582
- *     def suboffsets(self):
- *         if self.view.suboffsets == NULL:
- *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":133
  * 
- *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
+ *         if not self.ndim:
+ *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
+ * 
+ *         if itemsize <= 0:
  */
-  __pyx_tuple__4 = PyTuple_New(1); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 582, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+
+  /* "View.MemoryView":136
+ * 
+ *         if itemsize <= 0:
+ *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
+ * 
+ *         if not isinstance(format, bytes):
+ */
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
+
+  /* "View.MemoryView":148
+ * 
+ *         if not self._shape:
+ *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 148, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_INCREF(__pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__4, 0, __pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* "View.MemoryView":679
- *     tup = <tuple>index if isinstance(index, tuple) else (index,)
+  /* "View.MemoryView":176
+ *             self.data = <char *>malloc(self.len)
+ *             if not self.data:
+ *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
- *     result = [slice(None)] * ndim             # <<<<<<<<<<<<<<
- *     have_slices = False
- *     seen_ellipsis = False
+ *             if self.dtype_is_object:
  */
-  __pyx_slice__5 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__5)) __PYX_ERR(1, 679, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__5);
-  __Pyx_GIVEREF(__pyx_slice__5);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
+
+  /* "View.MemoryView":192
+ *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
+ *         if not (flags & bufmode):
+ *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
+ *         info.buf = self.data
+ *         info.len = self.len
+ */
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
   /* "(tree fragment)":4
- *     cdef object __pyx_PickleError
- *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x82a3537, 0x6ae9995, 0xb068931):             # <<<<<<<<<<<<<<
- *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "chython/containers/_cpack.pyx":148
- *     py_bonds = {}
- *     py_bonds_flat = []
- *     py_xy = (0., 0.)             # <<<<<<<<<<<<<<
+  /* "View.MemoryView":418
+ *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
- *     for n in range(atoms_count):
+ *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-  __pyx_tuple__9 = PyTuple_Pack(2, __pyx_float_0_, __pyx_float_0_); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 418, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
+  /* "View.MemoryView":495
+ *             result = struct.unpack(self.view.format, bytesitem)
+ *         except struct.error:
+ *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
+ *         else:
+ *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_n_s_sys); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 100, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 495, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
-  __pyx_tuple__11 = PyTuple_Pack(2, __pyx_int_3, __pyx_int_3); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 100, __pyx_L1_error)
+
+  /* "View.MemoryView":520
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         if flags & PyBUF_ND:
+ */
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 520, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "View.MemoryView":101
- * try:
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
+  /* "View.MemoryView":570
+ *         if self.view.strides == NULL:
+ * 
+ *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
+ * 
+ *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_collections_abc); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 101, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 570, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
 
-  /* "View.MemoryView":103
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
- * except:
+  /* "View.MemoryView":577
+ *     def suboffsets(self):
+ *         if self.view.suboffsets == NULL:
+ *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
+ *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_n_s_collections); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 103, __pyx_L1_error)
+  __pyx_tuple__13 = PyTuple_New(1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 577, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
+  __Pyx_INCREF(__pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_int_neg_1);
+  PyTuple_SET_ITEM(__pyx_tuple__13, 0, __pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
-  /* "View.MemoryView":309
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__15);
+  __Pyx_GIVEREF(__pyx_tuple__15);
+
+  /* "View.MemoryView":682
+ *         if item is Ellipsis:
+ *             if not seen_ellipsis:
+ *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
+ *                 seen_ellipsis = True
+ *             else:
+ */
+  __pyx_slice__16 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__16)) __PYX_ERR(1, 682, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__16);
+  __Pyx_GIVEREF(__pyx_slice__16);
+
+  /* "View.MemoryView":703
+ *     for suboffset in suboffsets[:ndim]:
+ *         if suboffset >= 0:
+ *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 703, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
+
+  /* "(tree fragment)":2
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+
+  /* "(tree fragment)":4
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
+
+  /* "chython/algorithms/_isomorphism.pyx":30
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
+ *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+ *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
+ */
+  __pyx_tuple__20 = PyTuple_Pack(47, __pyx_n_s_q_numbers, __pyx_n_s_q_back, __pyx_n_s_q_masks1, __pyx_n_s_q_masks2, __pyx_n_s_q_masks3, __pyx_n_s_q_masks4, __pyx_n_s_q_closures, __pyx_n_s_q_from, __pyx_n_s_q_to, __pyx_n_s_q_indices, __pyx_n_s_q_bonds, __pyx_n_s_o_numbers, __pyx_n_s_o_bits1, __pyx_n_s_o_bits2, __pyx_n_s_o_bits3, __pyx_n_s_o_bits4, __pyx_n_s_o_bonds, __pyx_n_s_o_from, __pyx_n_s_o_to, __pyx_n_s_o_indices, __pyx_n_s_scope, __pyx_n_s_stack, __pyx_n_s_path_size, __pyx_n_s_q_size, __pyx_n_s_q_size_dec, __pyx_n_s_o_size, __pyx_n_s_depth, __pyx_n_s_front, __pyx_n_s_back, __pyx_n_s_closures_num, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_o, __pyx_n_s_i, __pyx_n_s_j, __pyx_n_s_closures_counter, __pyx_n_s_q_mask1, __pyx_n_s_q_mask2, __pyx_n_s_q_mask3, __pyx_n_s_q_mask4, __pyx_n_s_o_bond, __pyx_n_s_mapping, __pyx_n_s_path, __pyx_n_s_stack_index, __pyx_n_s_stack_depth, __pyx_n_s_matched, __pyx_n_s_o_closures); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(21, 0, 47, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_algorithms__isomorphism_2, __pyx_n_s_get_mapping, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 30, __pyx_L1_error)
+
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 309, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 310, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "View.MemoryView":311
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 311, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
-  /* "View.MemoryView":314
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 314, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
-  /* "View.MemoryView":315
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 315, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__19 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(1, 1, __pyx_L1_error)
-
-  /* "chython/containers/_cpack.pyx":48
- * # 4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
- * 
- * @cython.nonecheck(False)             # <<<<<<<<<<<<<<
- * @cython.boundscheck(False)
- * @cython.cdivision(True)
- */
-  __pyx_tuple__21 = PyTuple_Pack(41, __pyx_n_s_data, __pyx_n_s_charges, __pyx_n_s_atoms, __pyx_n_s_hydrogens, __pyx_n_s_radicals, __pyx_n_s_is_chiral, __pyx_n_s_neighbors, __pyx_n_s_orders, __pyx_n_s_seen, __pyx_n_s_connections, __pyx_n_s_ct_stereo, __pyx_n_s_stereo_sign, __pyx_n_s_ct_sign, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_i, __pyx_n_s_size, __pyx_n_s_shift, __pyx_n_s_n, __pyx_n_s_m, __pyx_n_s_bond_shift, __pyx_n_s_atoms_count, __pyx_n_s_ct_count, __pyx_n_s_ct_shift, __pyx_n_s_py_xy, __pyx_n_s_bond, __pyx_n_s_py_n, __pyx_n_s_py_m, __pyx_n_s_py_mapping, __pyx_n_s_py_atoms, __pyx_n_s_py_isotopes, __pyx_n_s_py_bonds_flat, __pyx_n_s_py_charges, __pyx_n_s_py_radicals, __pyx_n_s_py_hydrogens, __pyx_n_s_py_plane, __pyx_n_s_py_bonds, __pyx_n_s_py_ngb, __pyx_n_s_py_atoms_stereo, __pyx_n_s_py_allenes_stereo, __pyx_n_s_py_cis_trans_stereo); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 48, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 41, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_chython_containers__cpack_pyx, __pyx_n_s_unpack, 48, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(0, 48, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
-/* #### Code section: init_constants ### */
 
-static CYTHON_SMALL_CODE int __Pyx_InitConstants(void) {
-  if (__Pyx_CreateStringTabAndInitStrings() < 0) __PYX_ERR(0, 1, __pyx_L1_error);
-  __pyx_float_0_ = PyFloat_FromDouble(0.); if (unlikely(!__pyx_float_0_)) __PYX_ERR(0, 1, __pyx_L1_error)
+static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
-/* #### Code section: init_globals ### */
-
-static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  /* AssertionsEnabled.init */
-  __Pyx_init_assertions_enabled();
-
-if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
-
-  return 0;
-  __pyx_L1_error:;
-  return -1;
-}
-/* #### Code section: init_module ### */
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/
 
 static int __Pyx_modinit_global_init_code(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
   /*--- Global init code ---*/
-  __pyx_collections_abc_Sequence = Py_None; Py_INCREF(Py_None);
   generic = Py_None; Py_INCREF(Py_None);
   strided = Py_None; Py_INCREF(Py_None);
   indirect = Py_None; Py_INCREF(Py_None);
   contiguous = Py_None; Py_INCREF(Py_None);
   indirect_contiguous = Py_None; Py_INCREF(Py_None);
   __Pyx_RefNannyFinishContext();
   return 0;
@@ -20036,164 +18460,81 @@
   /*--- Function export code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
+  if (PyType_Ready(&__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_print = 0;
+  #endif
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_dictoffset && __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
+  }
+  __pyx_ptype_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping = &__pyx_type_7chython_10algorithms_12_isomorphism___pyx_scope_struct__get_mapping;
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_array_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_array_spec, NULL); if (unlikely(!__pyx_array_type)) __PYX_ERR(1, 114, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_array_type->tp_as_buffer = &__pyx_tp_as_buffer_array;
-  if (!__pyx_array_type->tp_as_buffer->bf_releasebuffer && __pyx_array_type->tp_base->tp_as_buffer && __pyx_array_type->tp_base->tp_as_buffer->bf_releasebuffer) {
-    __pyx_array_type->tp_as_buffer->bf_releasebuffer = __pyx_array_type->tp_base->tp_as_buffer->bf_releasebuffer;
-  }
-  #elif defined(Py_bf_getbuffer) && defined(Py_bf_releasebuffer)
-  /* PY_VERSION_HEX >= 0x03090000 || Py_LIMITED_API >= 0x030B0000 */
-  #elif defined(_MSC_VER)
-  #pragma message ("The buffer protocol is not supported in the Limited C-API < 3.11.")
-  #else
-  #warning "The buffer protocol is not supported in the Limited C-API < 3.11."
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_array.tp_print = 0;
   #endif
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_array_spec, __pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #else
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
   __pyx_array_type = &__pyx_type___pyx_array;
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_MemviewEnum.tp_print = 0;
   #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_array_type->tp_print = 0;
-  #endif
-  if (__Pyx_SetVtable(__pyx_array_type, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_array_type) < 0) __PYX_ERR(1, 114, __pyx_L1_error)
-  #endif
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_MemviewEnum_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_MemviewEnum_spec, NULL); if (unlikely(!__pyx_MemviewEnum_type)) __PYX_ERR(1, 302, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_MemviewEnum_spec, __pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #else
-  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_MemviewEnum_type->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_MemviewEnum_type->tp_dictoffset && __pyx_MemviewEnum_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_MemviewEnum_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_MemviewEnum_type) < 0) __PYX_ERR(1, 302, __pyx_L1_error)
-  #endif
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
   __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
   __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
   __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
   __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
   __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
   __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
   __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
   __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  __pyx_vtable_memoryview._get_base = (PyObject *(*)(struct __pyx_memoryview_obj *))__pyx_memoryview__get_base;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_memoryview_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_memoryview_spec, NULL); if (unlikely(!__pyx_memoryview_type)) __PYX_ERR(1, 337, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_memoryview_type->tp_as_buffer = &__pyx_tp_as_buffer_memoryview;
-  if (!__pyx_memoryview_type->tp_as_buffer->bf_releasebuffer && __pyx_memoryview_type->tp_base->tp_as_buffer && __pyx_memoryview_type->tp_base->tp_as_buffer->bf_releasebuffer) {
-    __pyx_memoryview_type->tp_as_buffer->bf_releasebuffer = __pyx_memoryview_type->tp_base->tp_as_buffer->bf_releasebuffer;
-  }
-  #elif defined(Py_bf_getbuffer) && defined(Py_bf_releasebuffer)
-  /* PY_VERSION_HEX >= 0x03090000 || Py_LIMITED_API >= 0x030B0000 */
-  #elif defined(_MSC_VER)
-  #pragma message ("The buffer protocol is not supported in the Limited C-API < 3.11.")
-  #else
-  #warning "The buffer protocol is not supported in the Limited C-API < 3.11."
-  #endif
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_memoryview_spec, __pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #else
-  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_memoryview.tp_print = 0;
   #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_memoryview_type->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_memoryview_type->tp_dictoffset && __pyx_memoryview_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_memoryview_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  if (__Pyx_SetVtable(__pyx_memoryview_type, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_memoryview_type) < 0) __PYX_ERR(1, 337, __pyx_L1_error)
-  #endif
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
   __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
   __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
   __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
   __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
-  __pyx_vtable__memoryviewslice.__pyx_base._get_base = (PyObject *(*)(struct __pyx_memoryview_obj *))__pyx_memoryviewslice__get_base;
-  #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_memoryview_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 952, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_memoryviewslice_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_memoryviewslice_spec, __pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_memoryviewslice_type)) __PYX_ERR(1, 952, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type___pyx_memoryviewslice_spec, __pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #else
-  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  __pyx_memoryviewslice_type->tp_base = __pyx_memoryview_type;
-  #endif
-  #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
+  __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  #if PY_VERSION_HEX < 0x030800B1
+  __pyx_type___pyx_memoryviewslice.tp_print = 0;
   #endif
-  #if PY_MAJOR_VERSION < 3
-  __pyx_memoryviewslice_type->tp_print = 0;
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_memoryviewslice_type->tp_dictoffset && __pyx_memoryviewslice_type->tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_memoryviewslice_type->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  #endif
-  if (__Pyx_SetVtable(__pyx_memoryviewslice_type, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #endif
-  #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_memoryviewslice_type) < 0) __PYX_ERR(1, 952, __pyx_L1_error)
-  #endif
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static int __Pyx_modinit_type_import_code(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
@@ -20215,63 +18556,14 @@
   __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
   /*--- Function import code ---*/
   __Pyx_RefNannyFinishContext();
   return 0;
 }
 
 
-#if PY_MAJOR_VERSION >= 3
-#if CYTHON_PEP489_MULTI_PHASE_INIT
-static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec__cpack(PyObject* module); /*proto*/
-static PyModuleDef_Slot __pyx_moduledef_slots[] = {
-  {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec__cpack},
-  {0, NULL}
-};
-#endif
-
-#ifdef __cplusplus
-namespace {
-  struct PyModuleDef __pyx_moduledef =
-  #else
-  static struct PyModuleDef __pyx_moduledef =
-  #endif
-  {
-      PyModuleDef_HEAD_INIT,
-      "_cpack",
-      0, /* m_doc */
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      0, /* m_size */
-    #elif CYTHON_USE_MODULE_STATE
-      sizeof(__pyx_mstate), /* m_size */
-    #else
-      -1, /* m_size */
-    #endif
-      __pyx_methods /* m_methods */,
-    #if CYTHON_PEP489_MULTI_PHASE_INIT
-      __pyx_moduledef_slots, /* m_slots */
-    #else
-      NULL, /* m_reload */
-    #endif
-    #if CYTHON_USE_MODULE_STATE
-      __pyx_m_traverse, /* m_traverse */
-      __pyx_m_clear, /* m_clear */
-      NULL /* m_free */
-    #else
-      NULL, /* m_traverse */
-      NULL, /* m_clear */
-      NULL /* m_free */
-    #endif
-  };
-  #ifdef __cplusplus
-} /* anonymous namespace */
-#endif
-#endif
-
 #ifndef CYTHON_NO_PYINIT_EXPORT
 #define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
 #elif PY_MAJOR_VERSION < 3
 #ifdef __cplusplus
 #define __Pyx_PyMODINIT_FUNC extern "C" void
 #else
 #define __Pyx_PyMODINIT_FUNC void
@@ -20282,19 +18574,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC init_cpack(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC init_cpack(void)
+__Pyx_PyMODINIT_FUNC init_isomorphism(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC init_isomorphism(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit__cpack(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit__cpack(void)
+__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -20314,807 +18606,362 @@
         PyErr_SetString(
             PyExc_ImportError,
             "Interpreter change detected - this module can only be loaded into one interpreter per process.");
         return -1;
     }
     return 0;
 }
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *module, const char* from_name, const char* to_name, int allow_none)
-#else
-static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none)
-#endif
-{
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
     PyObject *value = PyObject_GetAttrString(spec, from_name);
     int result = 0;
     if (likely(value)) {
         if (allow_none || value != Py_None) {
-#if CYTHON_COMPILING_IN_LIMITED_API
-            result = PyModule_AddObject(module, to_name, value);
-#else
             result = PyDict_SetItemString(moddict, to_name, value);
-#endif
         }
         Py_DECREF(value);
     } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Clear();
     } else {
         result = -1;
     }
     return result;
 }
-static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def) {
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
     PyObject *module = NULL, *moddict, *modname;
-    CYTHON_UNUSED_VAR(def);
     if (__Pyx_check_single_interpreter())
         return NULL;
     if (__pyx_m)
         return __Pyx_NewRef(__pyx_m);
     modname = PyObject_GetAttrString(spec, "name");
     if (unlikely(!modname)) goto bad;
     module = PyModule_NewObject(modname);
     Py_DECREF(modname);
     if (unlikely(!module)) goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    moddict = module;
-#else
     moddict = PyModule_GetDict(module);
     if (unlikely(!moddict)) goto bad;
-#endif
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
     if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec__cpack(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec__isomorphism(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
-  int stringtab_initialized = 0;
-  #if CYTHON_USE_MODULE_STATE
-  int pystate_addmodule_run = 0;
-  #endif
   PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  static PyThread_type_lock __pyx_t_8[8];
+  static PyThread_type_lock __pyx_t_2[8];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module '_cpack' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module '_isomorphism' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
-  /*--- Module creation code ---*/
-  #if CYTHON_PEP489_MULTI_PHASE_INIT
-  __pyx_m = __pyx_pyinit_module;
-  Py_INCREF(__pyx_m);
-  #else
-  #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("_cpack", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #elif CYTHON_USE_MODULE_STATE
-  __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  {
-    int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
-    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to _cpack pseudovariable */
-    if (unlikely((add_module_result < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
-    pystate_addmodule_run = 1;
-  }
-  #else
-  __pyx_m = PyModule_Create(&__pyx_moduledef);
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
-  #endif
-  #endif
-  CYTHON_UNUSED_VAR(__pyx_t_1);
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_b);
-  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
-  Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if CYTHON_REFNANNY
 __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__cpack(void)", 0);
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__isomorphism(void)", 0);
   if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init(__pyx_m) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   PyEval_InitThreads();
   #endif
+  /*--- Module creation code ---*/
+  #if CYTHON_PEP489_MULTI_PHASE_INIT
+  __pyx_m = __pyx_pyinit_module;
+  Py_INCREF(__pyx_m);
+  #else
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4("_isomorphism", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  #endif
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_d);
+  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_b);
+  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
+  Py_INCREF(__pyx_cython_runtime);
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
-  if (__Pyx_InitConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_chython__containers___cpack) {
+  if (__pyx_module_is_main_chython__algorithms___isomorphism) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "chython.containers._cpack")) {
-      if (unlikely((PyDict_SetItemString(modules, "chython.containers._cpack", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "chython.algorithms._isomorphism")) {
+      if (unlikely(PyDict_SetItemString(modules, "chython.algorithms._isomorphism", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Global type/function init code ---*/
   (void)__Pyx_modinit_global_init_code();
   (void)__Pyx_modinit_variable_export_code();
   (void)__Pyx_modinit_function_export_code();
-  if (unlikely((__Pyx_modinit_type_init_code() < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
   (void)__Pyx_modinit_type_import_code();
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "View.MemoryView":99
- * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_3);
-    /*try:*/ {
-
-      /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- */
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_version_info); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_tuple__11, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(1, 100, __pyx_L2_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (__pyx_t_6) {
-
-        /* "View.MemoryView":101
- * try:
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
- */
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_abc); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-        __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, __pyx_t_4);
-        __Pyx_GIVEREF(__pyx_t_4);
-        __pyx_t_4 = 0;
-
-        /* "View.MemoryView":100
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:
- *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- */
-        goto __pyx_L8;
-      }
-
-      /* "View.MemoryView":103
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
- * except:
- * 
- */
-      /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 103, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 103, __pyx_L2_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-        __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, __pyx_t_5);
-        __Pyx_GIVEREF(__pyx_t_5);
-        __pyx_t_5 = 0;
-      }
-      __pyx_L8:;
-
-      /* "View.MemoryView":99
- * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-    }
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L7_try_end;
-    __pyx_L2_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-    /* "View.MemoryView":104
- *     else:
- *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
- * except:             # <<<<<<<<<<<<<<
- * 
- *     __pyx_collections_abc_Sequence = None
- */
-    /*except:*/ {
-      __Pyx_AddTraceback("View.MemoryView", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(1, 104, __pyx_L4_except_error)
-      __Pyx_XGOTREF(__pyx_t_5);
-      __Pyx_XGOTREF(__pyx_t_4);
-      __Pyx_XGOTREF(__pyx_t_7);
-
-      /* "View.MemoryView":106
- * except:
- * 
- *     __pyx_collections_abc_Sequence = None             # <<<<<<<<<<<<<<
- * 
- * 
- */
-      __Pyx_INCREF(Py_None);
-      __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
-      __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, Py_None);
-      __Pyx_GIVEREF(Py_None);
-      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      goto __pyx_L3_exception_handled;
-    }
-
-    /* "View.MemoryView":99
- * 
- * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
- * try:             # <<<<<<<<<<<<<<
- *     if __import__("sys").version_info >= (3, 3):
- *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
- */
-    __pyx_L4_except_error:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    goto __pyx_L1_error;
-    __pyx_L3_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    __pyx_L7_try_end:;
-  }
-
-  /* "View.MemoryView":241
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_2, &__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_1);
-    /*try:*/ {
-
-      /* "View.MemoryView":242
- * 
- *     try:
- *         count = __pyx_collections_abc_Sequence.count             # <<<<<<<<<<<<<<
- *         index = __pyx_collections_abc_Sequence.index
- *     except:
+  /* "chython/algorithms/_isomorphism.pyx":30
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * def get_mapping(unsigned long[::1] q_numbers not None, unsigned int[::1] q_back not None,             # <<<<<<<<<<<<<<
+ *                 unsigned long long[::1] q_masks1 not None, unsigned long long[::1] q_masks2 not None,
+ *                 unsigned long long[::1] q_masks3 not None, unsigned long long[::1] q_masks4 not None,
  */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 242, __pyx_L11_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_array_type->tp_dict, __pyx_n_s_count, __pyx_t_7) < 0) __PYX_ERR(1, 242, __pyx_L11_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_array_type);
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_7chython_10algorithms_12_isomorphism_1get_mapping, NULL, __pyx_n_s_chython_algorithms__isomorphism); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_mapping, __pyx_t_1) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "View.MemoryView":243
- *     try:
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index             # <<<<<<<<<<<<<<
- *     except:
- *         pass
+  /* "chython/algorithms/_isomorphism.pyx":1
+ * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
+ * #
+ * #  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
  */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_index); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 243, __pyx_L11_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_array_type->tp_dict, __pyx_n_s_index, __pyx_t_7) < 0) __PYX_ERR(1, 243, __pyx_L11_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_array_type);
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "View.MemoryView":241
+  /* "View.MemoryView":209
+ *         info.obj = self
  * 
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-    }
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    goto __pyx_L16_try_end;
-    __pyx_L11_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":244
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- *     except:             # <<<<<<<<<<<<<<
- *         pass
- * 
+ *     def __dealloc__(array self):
  */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L12_exception_handled;
-    }
-    __pyx_L12_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_2, __pyx_t_1);
-    __pyx_L16_try_end:;
-  }
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 209, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 209, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_array_type);
 
-  /* "View.MemoryView":309
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 309, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
-  __Pyx_DECREF_SET(generic, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(generic, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":310
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 310, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
-  __Pyx_DECREF_SET(strided, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(strided, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":311
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 311, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
-  __Pyx_DECREF_SET(indirect, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(indirect, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":314
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 314, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
-  __Pyx_DECREF_SET(contiguous, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(contiguous, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":315
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 315, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
-  __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_7);
-  __Pyx_GIVEREF(__pyx_t_7);
-  __pyx_t_7 = 0;
+  __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "View.MemoryView":323
- * 
+  /* "View.MemoryView":316
  * 
+ * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
- * cdef PyThread_type_lock[8] __pyx_memoryview_thread_locks = [
+ * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
-  /* "View.MemoryView":324
- * 
+  /* "View.MemoryView":317
+ * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0
- * cdef PyThread_type_lock[8] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
+ * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
  *     PyThread_allocate_lock(),
  *     PyThread_allocate_lock(),
  */
-  __pyx_t_8[0] = PyThread_allocate_lock();
-  __pyx_t_8[1] = PyThread_allocate_lock();
-  __pyx_t_8[2] = PyThread_allocate_lock();
-  __pyx_t_8[3] = PyThread_allocate_lock();
-  __pyx_t_8[4] = PyThread_allocate_lock();
-  __pyx_t_8[5] = PyThread_allocate_lock();
-  __pyx_t_8[6] = PyThread_allocate_lock();
-  __pyx_t_8[7] = PyThread_allocate_lock();
-  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_8, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
-
-  /* "View.MemoryView":982
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_3);
-    /*try:*/ {
-
-      /* "View.MemoryView":983
- * 
- *     try:
- *         count = __pyx_collections_abc_Sequence.count             # <<<<<<<<<<<<<<
- *         index = __pyx_collections_abc_Sequence.index
- *     except:
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 983, __pyx_L17_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_count, __pyx_t_7) < 0) __PYX_ERR(1, 983, __pyx_L17_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_memoryviewslice_type);
+  __pyx_t_2[0] = PyThread_allocate_lock();
+  __pyx_t_2[1] = PyThread_allocate_lock();
+  __pyx_t_2[2] = PyThread_allocate_lock();
+  __pyx_t_2[3] = PyThread_allocate_lock();
+  __pyx_t_2[4] = PyThread_allocate_lock();
+  __pyx_t_2[5] = PyThread_allocate_lock();
+  __pyx_t_2[6] = PyThread_allocate_lock();
+  __pyx_t_2[7] = PyThread_allocate_lock();
+  memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_2, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
-      /* "View.MemoryView":984
- *     try:
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index             # <<<<<<<<<<<<<<
- *     except:
- *         pass
- */
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_index); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 984, __pyx_L17_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (PyDict_SetItem(__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_index, __pyx_t_7) < 0) __PYX_ERR(1, 984, __pyx_L17_error)
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      PyType_Modified(__pyx_memoryviewslice_type);
-
-      /* "View.MemoryView":982
- * 
- * 
- *     try:             # <<<<<<<<<<<<<<
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- */
-    }
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    goto __pyx_L22_try_end;
-    __pyx_L17_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":985
- *         count = __pyx_collections_abc_Sequence.count
- *         index = __pyx_collections_abc_Sequence.index
- *     except:             # <<<<<<<<<<<<<<
- *         pass
- * 
- */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L18_exception_handled;
-    }
-    __pyx_L18_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
-    __pyx_L22_try_end:;
-  }
-
-  /* "View.MemoryView":988
- *         pass
- * 
- * try:             # <<<<<<<<<<<<<<
- *     if __pyx_collections_abc_Sequence:
- * 
- */
-  {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_2, &__pyx_t_1);
-    __Pyx_XGOTREF(__pyx_t_3);
-    __Pyx_XGOTREF(__pyx_t_2);
-    __Pyx_XGOTREF(__pyx_t_1);
-    /*try:*/ {
-
-      /* "View.MemoryView":989
- * 
- * try:
- *     if __pyx_collections_abc_Sequence:             # <<<<<<<<<<<<<<
- * 
- * 
- */
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_collections_abc_Sequence); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(1, 989, __pyx_L23_error)
-      if (__pyx_t_6) {
-
-        /* "View.MemoryView":993
- * 
- * 
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)             # <<<<<<<<<<<<<<
- *         __pyx_collections_abc_Sequence.register(array)
- * except:
- */
-        __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_register); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 993, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_7, ((PyObject *)__pyx_memoryviewslice_type)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 993, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-        /* "View.MemoryView":994
- * 
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)
- *         __pyx_collections_abc_Sequence.register(array)             # <<<<<<<<<<<<<<
- * except:
- *     pass  # ignore failure, it's a minor issue
- */
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_collections_abc_Sequence, __pyx_n_s_register); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 994, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_4, ((PyObject *)__pyx_array_type)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 994, __pyx_L23_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-        /* "View.MemoryView":989
+  /* "View.MemoryView":549
+ *         info.obj = self
  * 
- * try:
- *     if __pyx_collections_abc_Sequence:             # <<<<<<<<<<<<<<
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      }
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 549, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 549, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryview_type);
 
-      /* "View.MemoryView":988
- *         pass
+  /* "View.MemoryView":995
+ *         return self.from_object
  * 
- * try:             # <<<<<<<<<<<<<<
- *     if __pyx_collections_abc_Sequence:
+ *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
- */
-    }
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    goto __pyx_L28_try_end;
-    __pyx_L23_error:;
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-    /* "View.MemoryView":995
- *         __pyx_collections_abc_Sequence.register(_memoryviewslice)
- *         __pyx_collections_abc_Sequence.register(array)
- * except:             # <<<<<<<<<<<<<<
- *     pass  # ignore failure, it's a minor issue
  * 
  */
-    /*except:*/ {
-      __Pyx_ErrRestore(0,0,0);
-      goto __pyx_L24_exception_handled;
-    }
-    __pyx_L24_exception_handled:;
-    __Pyx_XGIVEREF(__pyx_t_3);
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __Pyx_XGIVEREF(__pyx_t_1);
-    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_2, __pyx_t_1);
-    __pyx_L28_try_end:;
-  }
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 995, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 995, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-
-  /* "chython/containers/_cpack.pyx":23
- * from cpython.mem cimport PyMem_Malloc, PyMem_Free
- * 
- * from chython.containers.bonds import Bond             # <<<<<<<<<<<<<<
- * 
- * # Format specification::
- */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 23, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_INCREF(__pyx_n_s_Bond);
-  __Pyx_GIVEREF(__pyx_n_s_Bond);
-  PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_Bond);
-  __pyx_t_4 = __Pyx_Import(__pyx_n_s_chython_containers_bonds, __pyx_t_7, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 23, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_Bond); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 23, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Bond, __pyx_t_7) < 0) __PYX_ERR(0, 23, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-  /* "chython/containers/_cpack.pyx":48
- * # 4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
- * 
- * @cython.nonecheck(False)             # <<<<<<<<<<<<<<
- * @cython.boundscheck(False)
- * @cython.cdivision(True)
- */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_7chython_10containers_6_cpack_1unpack, 0, __pyx_n_s_unpack, NULL, __pyx_n_s_chython_containers__cpack, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 48, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unpack, __pyx_t_4) < 0) __PYX_ERR(0, 48, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "chython/containers/_cpack.pyx":1
- * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
- * # cython: language_level=3
- * #
+  /* "(tree fragment)":11
+ *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
+ *     return __pyx_result
+ * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
+ *     __pyx_result.name = __pyx_state[0]
+ *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_4) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_1);
   if (__pyx_m) {
-    if (__pyx_d && stringtab_initialized) {
-      __Pyx_AddTraceback("init chython.containers._cpack", __pyx_clineno, __pyx_lineno, __pyx_filename);
+    if (__pyx_d) {
+      __Pyx_AddTraceback("init chython.algorithms._isomorphism", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
-    #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
-    #else
-    Py_DECREF(__pyx_m);
-    if (pystate_addmodule_run) {
-      PyObject *tp, *value, *tb;
-      PyErr_Fetch(&tp, &value, &tb);
-      PyState_RemoveModule(&__pyx_moduledef);
-      PyErr_Restore(tp, value, tb);
-    }
-    #endif
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init chython.containers._cpack");
+    PyErr_SetString(PyExc_ImportError, "init chython.algorithms._isomorphism");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
   #else
   return;
   #endif
 }
-/* #### Code section: cleanup_globals ### */
-/* #### Code section: cleanup_module ### */
-/* #### Code section: main_method ### */
-/* #### Code section: utility_code_pragmas ### */
-#ifdef _MSC_VER
-#pragma warning( push )
-/* Warning 4127: conditional expression is constant
- * Cython uses constant conditional expressions to allow in inline functions to be optimized at
- * compile-time, so this warning is not useful
- */
-#pragma warning( disable : 4127 )
-#endif
-
-
-
-/* #### Code section: utility_code_def ### */
 
 /* --- Runtime support code --- */
 /* Refnanny */
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
@@ -21126,371 +18973,42 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif
 
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
-    }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    int result;
-    PyObject *exc_type;
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *current_exception = tstate->current_exception;
-    if (unlikely(!current_exception)) return 0;
-    exc_type = (PyObject*) Py_TYPE(current_exception);
-    if (exc_type == err) return 1;
-#else
-    exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-#endif
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_INCREF(exc_type);
-    #endif
-    if (unlikely(PyTuple_Check(err))) {
-        result = __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    } else {
-        result = __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
-    }
-    #if CYTHON_AVOID_BORROWED_REFS
-    Py_DECREF(exc_type);
-    #endif
-    return result;
-}
-#endif
-
-/* PyErrFetchRestore */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject *tmp_value;
-    assert(type == NULL || (value != NULL && type == (PyObject*) Py_TYPE(value)));
-    if (value) {
-        #if CYTHON_COMPILING_IN_CPYTHON
-        if (unlikely(((PyBaseExceptionObject*) value)->traceback != tb))
-        #endif
-            PyException_SetTraceback(value, tb);
-    }
-    tmp_value = tstate->current_exception;
-    tstate->current_exception = value;
-    Py_XDECREF(tmp_value);
-#else
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    tmp_type = tstate->curexc_type;
-    tmp_value = tstate->curexc_value;
-    tmp_tb = tstate->curexc_traceback;
-    tstate->curexc_type = type;
-    tstate->curexc_value = value;
-    tstate->curexc_traceback = tb;
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#endif
-}
-static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-#if PY_VERSION_HEX >= 0x030C00A6
-    PyObject* exc_value;
-    exc_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    *value = exc_value;
-    *type = NULL;
-    *tb = NULL;
-    if (exc_value) {
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        #if CYTHON_COMPILING_IN_CPYTHON
-        *tb = ((PyBaseExceptionObject*) exc_value)->traceback;
-        Py_XINCREF(*tb);
-        #else
-        *tb = PyException_GetTraceback(exc_value);
-        #endif
-    }
-#else
-    *type = tstate->curexc_type;
-    *value = tstate->curexc_value;
-    *tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-#endif
-}
-#endif
-
 /* PyObjectGetAttrStr */
 #if CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
     PyTypeObject* tp = Py_TYPE(obj);
     if (likely(tp->tp_getattro))
         return tp->tp_getattro(obj, attr_name);
 #if PY_MAJOR_VERSION < 3
     if (likely(tp->tp_getattr))
         return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
 #endif
     return PyObject_GetAttr(obj, attr_name);
 }
 #endif
 
-/* PyObjectGetAttrStrNoError */
-static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        __Pyx_PyErr_Clear();
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
-    PyObject *result;
-#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
-        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
-    }
-#endif
-    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
-    if (unlikely(!result)) {
-        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
-    }
-    return result;
-}
-
 /* GetBuiltinName */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStrNoError(__pyx_b, name);
-    if (unlikely(!result) && !PyErr_Occurred()) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
         PyErr_Format(PyExc_NameError,
 #if PY_MAJOR_VERSION >= 3
             "name '%U' is not defined", name);
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
-/* TupleAndListFromArray */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE void __Pyx_copy_object_array(PyObject *const *CYTHON_RESTRICT src, PyObject** CYTHON_RESTRICT dest, Py_ssize_t length) {
-    PyObject *v;
-    Py_ssize_t i;
-    for (i = 0; i < length; i++) {
-        v = dest[i] = src[i];
-        Py_INCREF(v);
-    }
-}
-static CYTHON_INLINE PyObject *
-__Pyx_PyTuple_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        Py_INCREF(__pyx_empty_tuple);
-        return __pyx_empty_tuple;
-    }
-    res = PyTuple_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyTupleObject*)res)->ob_item, n);
-    return res;
-}
-static CYTHON_INLINE PyObject *
-__Pyx_PyList_FromArray(PyObject *const *src, Py_ssize_t n)
-{
-    PyObject *res;
-    if (n <= 0) {
-        return PyList_New(0);
-    }
-    res = PyList_New(n);
-    if (unlikely(res == NULL)) return NULL;
-    __Pyx_copy_object_array(src, ((PyListObject*)res)->ob_item, n);
-    return res;
-}
-#endif
-
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
-        } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
-#endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-#endif
-}
-
-/* UnicodeEquals */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-#if PY_MAJOR_VERSION < 3
-    PyObject* owned_ref = NULL;
-#endif
-    int s1_is_unicode, s2_is_unicode;
-    if (s1 == s2) {
-        goto return_eq;
-    }
-    s1_is_unicode = PyUnicode_CheckExact(s1);
-    s2_is_unicode = PyUnicode_CheckExact(s2);
-#if PY_MAJOR_VERSION < 3
-    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
-        owned_ref = PyUnicode_FromObject(s2);
-        if (unlikely(!owned_ref))
-            return -1;
-        s2 = owned_ref;
-        s2_is_unicode = 1;
-    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
-        owned_ref = PyUnicode_FromObject(s1);
-        if (unlikely(!owned_ref))
-            return -1;
-        s1 = owned_ref;
-        s1_is_unicode = 1;
-    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
-        return __Pyx_PyBytes_Equals(s1, s2, equals);
-    }
-#endif
-    if (s1_is_unicode & s2_is_unicode) {
-        Py_ssize_t length;
-        int kind;
-        void *data1, *data2;
-        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
-            return -1;
-        length = __Pyx_PyUnicode_GET_LENGTH(s1);
-        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
-            goto return_ne;
-        }
-#if CYTHON_USE_UNICODE_INTERNALS
-        {
-            Py_hash_t hash1, hash2;
-        #if CYTHON_PEP393_ENABLED
-            hash1 = ((PyASCIIObject*)s1)->hash;
-            hash2 = ((PyASCIIObject*)s2)->hash;
-        #else
-            hash1 = ((PyUnicodeObject*)s1)->hash;
-            hash2 = ((PyUnicodeObject*)s2)->hash;
-        #endif
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                goto return_ne;
-            }
-        }
-#endif
-        kind = __Pyx_PyUnicode_KIND(s1);
-        if (kind != __Pyx_PyUnicode_KIND(s2)) {
-            goto return_ne;
-        }
-        data1 = __Pyx_PyUnicode_DATA(s1);
-        data2 = __Pyx_PyUnicode_DATA(s2);
-        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
-            goto return_ne;
-        } else if (length == 1) {
-            goto return_eq;
-        } else {
-            int result = memcmp(data1, data2, (size_t)(length * kind));
-            #if PY_MAJOR_VERSION < 3
-            Py_XDECREF(owned_ref);
-            #endif
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & s2_is_unicode) {
-        goto return_ne;
-    } else if ((s2 == Py_None) & s1_is_unicode) {
-        goto return_ne;
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        #if PY_MAJOR_VERSION < 3
-        Py_XDECREF(owned_ref);
-        #endif
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-return_eq:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_EQ);
-return_ne:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_NE);
-#endif
-}
-
-/* fastcall */
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE PyObject * __Pyx_GetKwValue_FASTCALL(PyObject *kwnames, PyObject *const *kwvalues, PyObject *s)
-{
-    Py_ssize_t i, n = PyTuple_GET_SIZE(kwnames);
-    for (i = 0; i < n; i++)
-    {
-        if (s == PyTuple_GET_ITEM(kwnames, i)) return kwvalues[i];
-    }
-    for (i = 0; i < n; i++)
-    {
-        int eq = __Pyx_PyUnicode_Equals(s, PyTuple_GET_ITEM(kwnames, i), Py_EQ);
-        if (unlikely(eq != 0)) {
-            if (unlikely(eq < 0)) return NULL;  // error
-            return kwvalues[i];
-        }
-    }
-    return NULL;  // not found (no exception set)
-}
-#endif
-
 /* RaiseArgTupleInvalid */
 static void __Pyx_RaiseArgtupleInvalid(
     const char* func_name,
     int exact,
     Py_ssize_t num_min,
     Py_ssize_t num_max,
     Py_ssize_t num_found)
@@ -21526,37 +19044,25 @@
         PyString_AsString(kw_name));
         #endif
 }
 
 /* ParseKeywords */
 static int __Pyx_ParseOptionalKeywords(
     PyObject *kwds,
-    PyObject *const *kwvalues,
     PyObject **argnames[],
     PyObject *kwds2,
     PyObject *values[],
     Py_ssize_t num_pos_args,
     const char* function_name)
 {
     PyObject *key = 0, *value = 0;
     Py_ssize_t pos = 0;
     PyObject*** name;
     PyObject*** first_kw_arg = argnames + num_pos_args;
-    int kwds_is_tuple = CYTHON_METH_FASTCALL && likely(PyTuple_Check(kwds));
-    while (1) {
-        if (kwds_is_tuple) {
-            if (pos >= PyTuple_GET_SIZE(kwds)) break;
-            key = PyTuple_GET_ITEM(kwds, pos);
-            value = kwvalues[pos];
-            pos++;
-        }
-        else
-        {
-            if (!PyDict_Next(kwds, &pos, &key, &value)) break;
-        }
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
         name = first_kw_arg;
         while (*name && (**name != key)) name++;
         if (*name) {
             values[name-argnames] = value;
             continue;
         }
         name = first_kw_arg;
@@ -21582,20 +19088,19 @@
                     argname++;
                 }
             }
         } else
         #endif
         if (likely(PyUnicode_Check(key))) {
             while (*name) {
-                int cmp = (
+                int cmp = (**name == key) ? 0 :
                 #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                     (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                 #endif
-                    PyUnicode_Compare(**name, key)
-                );
+                    PyUnicode_Compare(**name, key);
                 if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                 if (cmp == 0) {
                     values[name-argnames] = value;
                     break;
                 }
                 name++;
             }
@@ -21626,59 +19131,393 @@
     __Pyx_RaiseDoubleKeywordsError(function_name, key);
     goto bad;
 invalid_keyword_type:
     PyErr_Format(PyExc_TypeError,
         "%.200s() keywords must be strings", function_name);
     goto bad;
 invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
     PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
         "%.200s() got an unexpected keyword argument '%.200s'",
         function_name, PyString_AsString(key));
     #else
-    PyErr_Format(PyExc_TypeError,
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
     return -1;
 }
 
+/* MemviewSliceInit */
+static int
+__Pyx_init_memviewslice(struct __pyx_memoryview_obj *memview,
+                        int ndim,
+                        __Pyx_memviewslice *memviewslice,
+                        int memview_is_new_reference)
+{
+    __Pyx_RefNannyDeclarations
+    int i, retval=-1;
+    Py_buffer *buf = &memview->view;
+    __Pyx_RefNannySetupContext("init_memviewslice", 0);
+    if (unlikely(memviewslice->memview || memviewslice->data)) {
+        PyErr_SetString(PyExc_ValueError,
+            "memviewslice is already initialized!");
+        goto fail;
+    }
+    if (buf->strides) {
+        for (i = 0; i < ndim; i++) {
+            memviewslice->strides[i] = buf->strides[i];
+        }
+    } else {
+        Py_ssize_t stride = buf->itemsize;
+        for (i = ndim - 1; i >= 0; i--) {
+            memviewslice->strides[i] = stride;
+            stride *= buf->shape[i];
+        }
+    }
+    for (i = 0; i < ndim; i++) {
+        memviewslice->shape[i]   = buf->shape[i];
+        if (buf->suboffsets) {
+            memviewslice->suboffsets[i] = buf->suboffsets[i];
+        } else {
+            memviewslice->suboffsets[i] = -1;
+        }
+    }
+    memviewslice->memview = memview;
+    memviewslice->data = (char *)buf->buf;
+    if (__pyx_add_acquisition_count(memview) == 0 && !memview_is_new_reference) {
+        Py_INCREF(memview);
+    }
+    retval = 0;
+    goto no_fail;
+fail:
+    memviewslice->memview = 0;
+    memviewslice->data = 0;
+    retval = -1;
+no_fail:
+    __Pyx_RefNannyFinishContext();
+    return retval;
+}
+#ifndef Py_NO_RETURN
+#define Py_NO_RETURN
+#endif
+static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
+    va_list vargs;
+    char msg[200];
+#ifdef HAVE_STDARG_PROTOTYPES
+    va_start(vargs, fmt);
+#else
+    va_start(vargs);
+#endif
+    vsnprintf(msg, 200, fmt, vargs);
+    va_end(vargs);
+    Py_FatalError(msg);
+}
+static CYTHON_INLINE int
+__pyx_add_acquisition_count_locked(__pyx_atomic_int *acquisition_count,
+                                   PyThread_type_lock lock)
+{
+    int result;
+    PyThread_acquire_lock(lock, 1);
+    result = (*acquisition_count)++;
+    PyThread_release_lock(lock);
+    return result;
+}
+static CYTHON_INLINE int
+__pyx_sub_acquisition_count_locked(__pyx_atomic_int *acquisition_count,
+                                   PyThread_type_lock lock)
+{
+    int result;
+    PyThread_acquire_lock(lock, 1);
+    result = (*acquisition_count)--;
+    PyThread_release_lock(lock);
+    return result;
+}
+static CYTHON_INLINE void
+__Pyx_INC_MEMVIEW(__Pyx_memviewslice *memslice, int have_gil, int lineno)
+{
+    int first_time;
+    struct __pyx_memoryview_obj *memview = memslice->memview;
+    if (unlikely(!memview || (PyObject *) memview == Py_None))
+        return;
+    if (unlikely(__pyx_get_slice_count(memview) < 0))
+        __pyx_fatalerror("Acquisition count is %d (line %d)",
+                         __pyx_get_slice_count(memview), lineno);
+    first_time = __pyx_add_acquisition_count(memview) == 0;
+    if (unlikely(first_time)) {
+        if (have_gil) {
+            Py_INCREF((PyObject *) memview);
+        } else {
+            PyGILState_STATE _gilstate = PyGILState_Ensure();
+            Py_INCREF((PyObject *) memview);
+            PyGILState_Release(_gilstate);
+        }
+    }
+}
+static CYTHON_INLINE void __Pyx_XDEC_MEMVIEW(__Pyx_memviewslice *memslice,
+                                             int have_gil, int lineno) {
+    int last_time;
+    struct __pyx_memoryview_obj *memview = memslice->memview;
+    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
+        memslice->memview = NULL;
+        return;
+    }
+    if (unlikely(__pyx_get_slice_count(memview) <= 0))
+        __pyx_fatalerror("Acquisition count is %d (line %d)",
+                         __pyx_get_slice_count(memview), lineno);
+    last_time = __pyx_sub_acquisition_count(memview) == 1;
+    memslice->data = NULL;
+    if (unlikely(last_time)) {
+        if (have_gil) {
+            Py_CLEAR(memslice->memview);
+        } else {
+            PyGILState_STATE _gilstate = PyGILState_Ensure();
+            Py_CLEAR(memslice->memview);
+            PyGILState_Release(_gilstate);
+        }
+    } else {
+        memslice->memview = NULL;
+    }
+}
+
+/* PyErrFetchRestore */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+#endif
+
+/* GetException */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+#endif
+{
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_FAST_THREAD_STATE
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (local_tb) {
+        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+            goto bad;
+    }
+    #endif
+    Py_XINCREF(local_tb);
+    Py_XINCREF(local_type);
+    Py_XINCREF(local_value);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    #if CYTHON_USE_EXC_INFO_STACK
+    {
+        _PyErr_StackItem *exc_info = tstate->exc_info;
+        tmp_type = exc_info->exc_type;
+        tmp_value = exc_info->exc_value;
+        tmp_tb = exc_info->exc_traceback;
+        exc_info->exc_type = local_type;
+        exc_info->exc_value = local_value;
+        exc_info->exc_traceback = local_tb;
+    }
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+/* SwapException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = *type;
+    exc_info->exc_value = *value;
+    exc_info->exc_traceback = *tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = *type;
+    tstate->exc_value = *value;
+    tstate->exc_traceback = *tb;
+    #endif
+    *type = tmp_type;
+    *value = tmp_value;
+    *tb = tmp_tb;
+}
+#else
+static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
+    PyErr_SetExcInfo(*type, *value, *tb);
+    *type = tmp_type;
+    *value = tmp_value;
+    *tb = tmp_tb;
+}
+#endif
+
+/* GetTopmostException */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
+    }
+    return exc_info;
+}
+#endif
+
+/* SaveResetException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
+    #else
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    #endif
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+}
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+#endif
+
 /* ArgTypeTest */
 static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
 {
-    __Pyx_TypeName type_name;
-    __Pyx_TypeName obj_type_name;
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     else if (exact) {
         #if PY_MAJOR_VERSION == 2
         if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
         #endif
     }
     else {
         if (likely(__Pyx_TypeCheck(obj, type))) return 1;
     }
-    type_name = __Pyx_PyType_GetName(type);
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
     PyErr_Format(PyExc_TypeError,
-        "Argument '%.200s' has incorrect type (expected " __Pyx_FMT_TYPENAME
-        ", got " __Pyx_FMT_TYPENAME ")", name, type_name, obj_type_name);
-    __Pyx_DECREF_TypeName(type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
+        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
     return 0;
 }
 
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
 /* RaiseException */
 #if PY_MAJOR_VERSION < 3
-static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
+                        CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
-    CYTHON_UNUSED_VAR(cause);
     Py_XINCREF(type);
     if (!value || value == Py_None)
         value = NULL;
     else
         Py_INCREF(value);
     if (!tb || tb == Py_None)
         tb = NULL;
@@ -21803,40 +19642,61 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-      #if PY_VERSION_HEX >= 0x030C00A6
-        PyException_SetTraceback(value, tb);
-      #elif CYTHON_FAST_THREAD_STATE
+#if CYTHON_COMPILING_IN_PYPY
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
+#else
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
-#else
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
 
+/* PyCFunctionFastCall */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
+    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
+    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
+    PyObject *self = PyCFunction_GET_SELF(func);
+    int flags = PyCFunction_GET_FLAGS(func);
+    assert(PyCFunction_Check(func));
+    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
+    assert(nargs >= 0);
+    assert(nargs == 0 || args != NULL);
+    /* _PyCFunction_FastCallDict() must not be called with an exception set,
+       because it may clear it (directly or indirectly) and so the
+       caller loses its exception */
+    assert(!PyErr_Occurred());
+    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
+        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+    } else {
+        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+    }
+}
+#endif
+
 /* PyFunctionFastCall */
-#if CYTHON_FAST_PYCALL && !CYTHON_VECTORCALL
+#if CYTHON_FAST_PYCALL
 static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                                PyObject *globals) {
     PyFrameObject *f;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
     PyObject **fastlocals;
     Py_ssize_t i;
     PyObject *result;
@@ -21857,14 +19717,15 @@
     }
     result = PyEval_EvalFrameEx(f,0);
     ++tstate->recursion_depth;
     Py_DECREF(f);
     --tstate->recursion_depth;
     return result;
 }
+#if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
     PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
     PyObject *globals = PyFunction_GET_GLOBALS(func);
     PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
     PyObject *closure;
 #if PY_MAJOR_VERSION >= 3
     PyObject *kwdefs;
@@ -21872,15 +19733,15 @@
     PyObject *kwtuple, **k;
     PyObject **d;
     Py_ssize_t nd;
     Py_ssize_t nk;
     PyObject *result;
     assert(kwargs == NULL || PyDict_Check(kwargs));
     nk = kwargs ? PyDict_Size(kwargs) : 0;
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object"))) {
+    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
         return NULL;
     }
     if (
 #if PY_MAJOR_VERSION >= 3
             co->co_kwonlyargcount == 0 &&
 #endif
             likely(kwargs == NULL || nk == 0) &&
@@ -21943,34 +19804,44 @@
 #endif
     Py_XDECREF(kwtuple);
 done:
     Py_LeaveRecursiveCall();
     return result;
 }
 #endif
+#endif
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
+/* PyObjectCall2Args */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
+    PyObject *args, *result = NULL;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyFunction_FastCall(function, args, 2);
+    }
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyCFunction_FastCall(function, args, 2);
     }
+    #endif
+    args = PyTuple_New(2);
+    if (unlikely(!args)) goto done;
+    Py_INCREF(arg1);
+    PyTuple_SET_ITEM(args, 0, arg1);
+    Py_INCREF(arg2);
+    PyTuple_SET_ITEM(args, 1, arg2);
+    Py_INCREF(function);
+    result = __Pyx_PyObject_Call(function, args, NULL);
+    Py_DECREF(args);
+    Py_DECREF(function);
+done:
     return result;
 }
-#endif
 
 /* PyObjectCallMethO */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
     PyObject *self, *result;
     PyCFunction cfunc;
     cfunc = PyCFunction_GET_FUNCTION(func);
@@ -21984,417 +19855,211 @@
             PyExc_SystemError,
             "NULL result without error in PyObject_Call");
     }
     return result;
 }
 #endif
 
-/* PyObjectFastCall */
-static PyObject* __Pyx_PyObject_FastCall_fallback(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs) {
-    PyObject *argstuple;
+/* PyObjectCallOneArg */
+#if CYTHON_COMPILING_IN_CPYTHON
+static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
     PyObject *result;
-    size_t i;
-    argstuple = PyTuple_New((Py_ssize_t)nargs);
-    if (unlikely(!argstuple)) return NULL;
-    for (i = 0; i < nargs; i++) {
-        Py_INCREF(args[i]);
-        PyTuple_SET_ITEM(argstuple, (Py_ssize_t)i, args[i]);
-    }
-    result = __Pyx_PyObject_Call(func, argstuple, kwargs);
-    Py_DECREF(argstuple);
+    PyObject *args = PyTuple_New(1);
+    if (unlikely(!args)) return NULL;
+    Py_INCREF(arg);
+    PyTuple_SET_ITEM(args, 0, arg);
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
     return result;
 }
-static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t _nargs, PyObject *kwargs) {
-    Py_ssize_t nargs = __Pyx_PyVectorcall_NARGS(_nargs);
-#if CYTHON_COMPILING_IN_CPYTHON
-    if (nargs == 0 && kwargs == NULL) {
-#if defined(__Pyx_CyFunction_USED) && defined(NDEBUG)
-        if (__Pyx_IsCyOrPyCFunction(func))
-#else
-        if (PyCFunction_Check(func))
-#endif
-        {
-            if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
-                return __Pyx_PyObject_CallMethO(func, NULL);
-            }
-        }
-    }
-    else if (nargs == 1 && kwargs == NULL) {
-        if (PyCFunction_Check(func))
-        {
-            if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
-                return __Pyx_PyObject_CallMethO(func, args[0]);
-            }
-        }
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, &arg, 1);
     }
 #endif
-    #if PY_VERSION_HEX < 0x030800B1
-    #if CYTHON_FAST_PYCCALL
-    if (PyCFunction_Check(func)) {
-        if (kwargs) {
-            return _PyCFunction_FastCallDict(func, args, nargs, kwargs);
-        } else {
-            return _PyCFunction_FastCallKeywords(func, args, nargs, NULL);
+    if (likely(PyCFunction_Check(func))) {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
+            return __Pyx_PyObject_CallMethO(func, arg);
+#if CYTHON_FAST_PYCCALL
+        } else if (__Pyx_PyFastCFunction_Check(func)) {
+            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
+#endif
         }
     }
-    #if PY_VERSION_HEX >= 0x030700A1
-    if (!kwargs && __Pyx_IS_TYPE(func, &PyMethodDescr_Type)) {
-        return _PyMethodDescr_FastCallKeywords(func, args, nargs, NULL);
-    }
-    #endif
-    #endif
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs);
-    }
-    #endif
-    #endif
-    #if CYTHON_VECTORCALL
-    vectorcallfunc f = _PyVectorcall_Function(func);
-    if (f) {
-        return f(func, args, (size_t)nargs, kwargs);
-    }
-    #elif defined(__Pyx_CyFunction_USED) && CYTHON_BACKPORT_VECTORCALL
-    if (__Pyx_CyFunction_CheckExact(func)) {
-        __pyx_vectorcallfunc f = __Pyx_CyFunction_func_vectorcall(func);
-        if (f) return f(func, args, (size_t)nargs, kwargs);
-    }
-    #endif
-    if (nargs == 0) {
-        return __Pyx_PyObject_Call(func, __pyx_empty_tuple, kwargs);
-    }
-    return __Pyx_PyObject_FastCall_fallback(func, args, (size_t)nargs, kwargs);
+    return __Pyx__PyObject_CallOneArg(func, arg);
 }
-
-/* RaiseUnexpectedTypeError */
-static int
-__Pyx_RaiseUnexpectedTypeError(const char *expected, PyObject *obj)
-{
-    __Pyx_TypeName obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError, "Expected %s, got " __Pyx_FMT_TYPENAME,
-                 expected, obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    return 0;
+#else
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_Pack(1, arg);
+    if (unlikely(!args)) return NULL;
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
 }
+#endif
 
-/* CIntToDigits */
-static const char DIGIT_PAIRS_10[2*10*10+1] = {
-    "00010203040506070809"
-    "10111213141516171819"
-    "20212223242526272829"
-    "30313233343536373839"
-    "40414243444546474849"
-    "50515253545556575859"
-    "60616263646566676869"
-    "70717273747576777879"
-    "80818283848586878889"
-    "90919293949596979899"
-};
-static const char DIGIT_PAIRS_8[2*8*8+1] = {
-    "0001020304050607"
-    "1011121314151617"
-    "2021222324252627"
-    "3031323334353637"
-    "4041424344454647"
-    "5051525354555657"
-    "6061626364656667"
-    "7071727374757677"
-};
-static const char DIGITS_HEX[2*16+1] = {
-    "0123456789abcdef"
-    "0123456789ABCDEF"
-};
-
-/* BuildPyUnicode */
-static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
-                                                int prepend_sign, char padding_char) {
-    PyObject *uval;
-    Py_ssize_t uoffset = ulength - clength;
-#if CYTHON_USE_UNICODE_INTERNALS
-    Py_ssize_t i;
-#if CYTHON_PEP393_ENABLED
-    void *udata;
-    uval = PyUnicode_New(ulength, 127);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_DATA(uval);
-#else
-    Py_UNICODE *udata;
-    uval = PyUnicode_FromUnicode(NULL, ulength);
-    if (unlikely(!uval)) return NULL;
-    udata = PyUnicode_AS_UNICODE(uval);
-#endif
-    if (uoffset > 0) {
-        i = 0;
-        if (prepend_sign) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, 0, '-');
-            i++;
-        }
-        for (; i < uoffset; i++) {
-            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, i, padding_char);
-        }
-    }
-    for (i=0; i < clength; i++) {
-        __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, uoffset+i, chars[i]);
-    }
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
 #else
-    {
-        PyObject *sign = NULL, *padding = NULL;
-        uval = NULL;
-        if (uoffset > 0) {
-            prepend_sign = !!prepend_sign;
-            if (uoffset > prepend_sign) {
-                padding = PyUnicode_FromOrdinal(padding_char);
-                if (likely(padding) && uoffset > prepend_sign + 1) {
-                    PyObject *tmp;
-                    PyObject *repeat = PyInt_FromSsize_t(uoffset - prepend_sign);
-                    if (unlikely(!repeat)) goto done_or_error;
-                    tmp = PyNumber_Multiply(padding, repeat);
-                    Py_DECREF(repeat);
-                    Py_DECREF(padding);
-                    padding = tmp;
-                }
-                if (unlikely(!padding)) goto done_or_error;
-            }
-            if (prepend_sign) {
-                sign = PyUnicode_FromOrdinal('-');
-                if (unlikely(!sign)) goto done_or_error;
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
             }
-        }
-        uval = PyUnicode_DecodeASCII(chars, clength, NULL);
-        if (likely(uval) && padding) {
-            PyObject *tmp = PyNumber_Add(padding, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-        if (likely(uval) && sign) {
-            PyObject *tmp = PyNumber_Add(sign, uval);
-            Py_DECREF(uval);
-            uval = tmp;
-        }
-done_or_error:
-        Py_XDECREF(padding);
-        Py_XDECREF(sign);
-    }
-#endif
-    return uval;
-}
-
-/* CIntToPyUnicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_int(int value, Py_ssize_t width, char padding_char, char format_char) {
-    char digits[sizeof(int)*3+2];
-    char *dpos, *end = digits + sizeof(int)*3+2;
-    const char *hex_digits = DIGITS_HEX;
-    Py_ssize_t length, ulength;
-    int prepend_sign, last_one_off;
-    int remaining;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (format_char == 'X') {
-        hex_digits += 16;
-        format_char = 'x';
-    }
-    remaining = value;
-    last_one_off = 0;
-    dpos = end;
-    do {
-        int digit_pos;
-        switch (format_char) {
-        case 'o':
-            digit_pos = abs((int)(remaining % (8*8)));
-            remaining = (int) (remaining / (8*8));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 8);
-            break;
-        case 'd':
-            digit_pos = abs((int)(remaining % (10*10)));
-            remaining = (int) (remaining / (10*10));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 10);
-            break;
-        case 'x':
-            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
-            remaining = (int) (remaining / 16);
-            break;
-        default:
-            assert(0);
-            break;
-        }
-    } while (unlikely(remaining != 0));
-    assert(!last_one_off || *dpos == '0');
-    dpos += last_one_off;
-    length = end - dpos;
-    ulength = length;
-    prepend_sign = 0;
-    if (!is_unsigned && value <= neg_one) {
-        if (padding_char == ' ' || width <= length + 1) {
-            *(--dpos) = '-';
-            ++length;
-        } else {
-            prepend_sign = 1;
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
         }
-        ++ulength;
-    }
-    if (width > ulength) {
-        ulength = width;
-    }
-    if (ulength == 1) {
-        return PyUnicode_FromOrdinal(*dpos);
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
+#endif
 }
 
-/* CIntToPyUnicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char) {
-    char digits[sizeof(Py_ssize_t)*3+2];
-    char *dpos, *end = digits + sizeof(Py_ssize_t)*3+2;
-    const char *hex_digits = DIGITS_HEX;
-    Py_ssize_t length, ulength;
-    int prepend_sign, last_one_off;
-    Py_ssize_t remaining;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const Py_ssize_t neg_one = (Py_ssize_t) -1, const_zero = (Py_ssize_t) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
+/* UnicodeEquals */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+#if PY_MAJOR_VERSION < 3
+    PyObject* owned_ref = NULL;
 #endif
-    const int is_unsigned = neg_one > const_zero;
-    if (format_char == 'X') {
-        hex_digits += 16;
-        format_char = 'x';
-    }
-    remaining = value;
-    last_one_off = 0;
-    dpos = end;
-    do {
-        int digit_pos;
-        switch (format_char) {
-        case 'o':
-            digit_pos = abs((int)(remaining % (8*8)));
-            remaining = (Py_ssize_t) (remaining / (8*8));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 8);
-            break;
-        case 'd':
-            digit_pos = abs((int)(remaining % (10*10)));
-            remaining = (Py_ssize_t) (remaining / (10*10));
-            dpos -= 2;
-            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
-            last_one_off = (digit_pos < 10);
-            break;
-        case 'x':
-            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
-            remaining = (Py_ssize_t) (remaining / 16);
-            break;
-        default:
-            assert(0);
-            break;
-        }
-    } while (unlikely(remaining != 0));
-    assert(!last_one_off || *dpos == '0');
-    dpos += last_one_off;
-    length = end - dpos;
-    ulength = length;
-    prepend_sign = 0;
-    if (!is_unsigned && value <= neg_one) {
-        if (padding_char == ' ' || width <= length + 1) {
-            *(--dpos) = '-';
-            ++length;
-        } else {
-            prepend_sign = 1;
-        }
-        ++ulength;
+    int s1_is_unicode, s2_is_unicode;
+    if (s1 == s2) {
+        goto return_eq;
     }
-    if (width > ulength) {
-        ulength = width;
+    s1_is_unicode = PyUnicode_CheckExact(s1);
+    s2_is_unicode = PyUnicode_CheckExact(s2);
+#if PY_MAJOR_VERSION < 3
+    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
+        owned_ref = PyUnicode_FromObject(s2);
+        if (unlikely(!owned_ref))
+            return -1;
+        s2 = owned_ref;
+        s2_is_unicode = 1;
+    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
+        owned_ref = PyUnicode_FromObject(s1);
+        if (unlikely(!owned_ref))
+            return -1;
+        s1 = owned_ref;
+        s1_is_unicode = 1;
+    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
+        return __Pyx_PyBytes_Equals(s1, s2, equals);
     }
-    if (ulength == 1) {
-        return PyUnicode_FromOrdinal(*dpos);
-    }
-    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
-}
-
-/* JoinPyUnicode */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char) {
-#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyObject *result_uval;
-    int result_ukind, kind_shift;
-    Py_ssize_t i, char_pos;
-    void *result_udata;
-    CYTHON_MAYBE_UNUSED_VAR(max_char);
-#if CYTHON_PEP393_ENABLED
-    result_uval = PyUnicode_New(result_ulength, max_char);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    kind_shift = (result_ukind == PyUnicode_4BYTE_KIND) ? 2 : result_ukind - 1;
-    result_udata = PyUnicode_DATA(result_uval);
-#else
-    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = sizeof(Py_UNICODE);
-    kind_shift = (result_ukind == 4) ? 2 : result_ukind - 1;
-    result_udata = PyUnicode_AS_UNICODE(result_uval);
-#endif
-    assert(kind_shift == 2 || kind_shift == 1 || kind_shift == 0);
-    char_pos = 0;
-    for (i=0; i < value_count; i++) {
-        int ukind;
-        Py_ssize_t ulength;
-        void *udata;
-        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
-        if (unlikely(__Pyx_PyUnicode_READY(uval)))
-            goto bad;
-        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
-        if (unlikely(!ulength))
-            continue;
-        if (unlikely((PY_SSIZE_T_MAX >> kind_shift) - ulength < char_pos))
-            goto overflow;
-        ukind = __Pyx_PyUnicode_KIND(uval);
-        udata = __Pyx_PyUnicode_DATA(uval);
-        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + (char_pos << kind_shift), udata, (size_t) (ulength << kind_shift));
-        } else {
-            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
-            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
-            #else
-            Py_ssize_t j;
-            for (j=0; j < ulength; j++) {
-                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
-                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
+#endif
+    if (s1_is_unicode & s2_is_unicode) {
+        Py_ssize_t length;
+        int kind;
+        void *data1, *data2;
+        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
+            return -1;
+        length = __Pyx_PyUnicode_GET_LENGTH(s1);
+        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
+            goto return_ne;
+        }
+#if CYTHON_USE_UNICODE_INTERNALS
+        {
+            Py_hash_t hash1, hash2;
+        #if CYTHON_PEP393_ENABLED
+            hash1 = ((PyASCIIObject*)s1)->hash;
+            hash2 = ((PyASCIIObject*)s2)->hash;
+        #else
+            hash1 = ((PyUnicodeObject*)s1)->hash;
+            hash2 = ((PyUnicodeObject*)s2)->hash;
+        #endif
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                goto return_ne;
             }
+        }
+#endif
+        kind = __Pyx_PyUnicode_KIND(s1);
+        if (kind != __Pyx_PyUnicode_KIND(s2)) {
+            goto return_ne;
+        }
+        data1 = __Pyx_PyUnicode_DATA(s1);
+        data2 = __Pyx_PyUnicode_DATA(s2);
+        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
+            goto return_ne;
+        } else if (length == 1) {
+            goto return_eq;
+        } else {
+            int result = memcmp(data1, data2, (size_t)(length * kind));
+            #if PY_MAJOR_VERSION < 3
+            Py_XDECREF(owned_ref);
             #endif
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
         }
-        char_pos += ulength;
+    } else if ((s1 == Py_None) & s2_is_unicode) {
+        goto return_ne;
+    } else if ((s2 == Py_None) & s1_is_unicode) {
+        goto return_ne;
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-    return result_uval;
-overflow:
-    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
-bad:
-    Py_DECREF(result_uval);
-    return NULL;
-#else
-    CYTHON_UNUSED_VAR(max_char);
-    CYTHON_UNUSED_VAR(result_ulength);
-    CYTHON_UNUSED_VAR(value_count);
-    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
+return_eq:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_EQ);
+return_ne:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_NE);
 #endif
 }
 
+/* None */
+static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
+    Py_ssize_t q = a / b;
+    Py_ssize_t r = a - q*b;
+    q -= ((r != 0) & ((r ^ b) < 0));
+    return q;
+}
+
 /* GetAttr */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
 #if CYTHON_USE_TYPE_SLOTS
 #if PY_MAJOR_VERSION >= 3
     if (likely(PyUnicode_Check(n)))
 #else
     if (likely(PyString_Check(n)))
@@ -22403,15 +20068,15 @@
 #endif
     return PyObject_GetAttr(o, n);
 }
 
 /* GetItemInt */
 static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
     PyObject *r;
-    if (unlikely(!j)) return NULL;
+    if (!j) return NULL;
     r = PyObject_GetItem(o, j);
     Py_DECREF(j);
     return r;
 }
 static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                               CYTHON_NCP_UNUSED int wraparound,
                                                               CYTHON_NCP_UNUSED int boundscheck) {
@@ -22464,186 +20129,136 @@
         Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
         if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
             PyObject *r = PyTuple_GET_ITEM(o, n);
             Py_INCREF(r);
             return r;
         }
     } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_subscript) {
-            PyObject *r, *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return NULL;
-            r = mm->mp_subscript(o, key);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
                 if (likely(l >= 0)) {
                     i += l;
                 } else {
                     if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                         return NULL;
                     PyErr_Clear();
                 }
             }
-            return sm->sq_item(o, i);
+            return m->sq_item(o, i);
         }
     }
 #else
     if (is_list || PySequence_Check(o)) {
         return PySequence_GetItem(o, i);
     }
 #endif
     return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
 }
 
-/* PyObjectCallOneArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *args[2] = {NULL, arg};
-    return __Pyx_PyObject_FastCall(func, args+1, 1 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
 /* ObjectGetItem */
 #if CYTHON_USE_TYPE_SLOTS
-static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject *index) {
-    PyObject *runerr = NULL;
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr;
     Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
     key_value = __Pyx_PyIndex_AsSsize_t(index);
     if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
         return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
     }
     if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
-        __Pyx_TypeName index_type_name = __Pyx_PyType_GetName(Py_TYPE(index));
         PyErr_Clear();
-        PyErr_Format(PyExc_IndexError,
-            "cannot fit '" __Pyx_FMT_TYPENAME "' into an index-sized integer", index_type_name);
-        __Pyx_DECREF_TypeName(index_type_name);
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
     }
     return NULL;
 }
-static PyObject *__Pyx_PyObject_GetItem_Slow(PyObject *obj, PyObject *key) {
-    __Pyx_TypeName obj_type_name;
-    if (likely(PyType_Check(obj))) {
-        PyObject *meth = __Pyx_PyObject_GetAttrStrNoError(obj, __pyx_n_s_class_getitem);
-        if (meth) {
-            PyObject *result = __Pyx_PyObject_CallOneArg(meth, key);
-            Py_DECREF(meth);
-            return result;
-        }
-    }
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError,
-        "'" __Pyx_FMT_TYPENAME "' object is not subscriptable", obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    return NULL;
-}
-static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject *key) {
-    PyTypeObject *tp = Py_TYPE(obj);
-    PyMappingMethods *mm = tp->tp_as_mapping;
-    PySequenceMethods *sm = tp->tp_as_sequence;
-    if (likely(mm && mm->mp_subscript)) {
-        return mm->mp_subscript(obj, key);
-    }
-    if (likely(sm && sm->sq_item)) {
-        return __Pyx_PyObject_GetIndex(obj, key);
-    }
-    return __Pyx_PyObject_GetItem_Slow(obj, key);
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
 }
 #endif
 
-/* KeywordStringCheck */
-static int __Pyx_CheckKeywordStrings(
-    PyObject *kw,
-    const char* function_name,
-    int kw_allowed)
-{
-    PyObject* key = 0;
-    Py_ssize_t pos = 0;
-#if CYTHON_COMPILING_IN_PYPY
-    if (!kw_allowed && PyDict_Next(kw, &pos, &key, 0))
-        goto invalid_keyword;
-    return 1;
-#else
-    if (CYTHON_METH_FASTCALL && likely(PyTuple_Check(kw))) {
-        if (unlikely(PyTuple_GET_SIZE(kw) == 0))
-            return 1;
-        if (!kw_allowed) {
-            key = PyTuple_GET_ITEM(kw, 0);
-            goto invalid_keyword;
-        }
-#if PY_VERSION_HEX < 0x03090000
-        for (pos = 0; pos < PyTuple_GET_SIZE(kw); pos++) {
-            key = PyTuple_GET_ITEM(kw, pos);
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
+/* decode_c_string */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    Py_ssize_t length;
+    if (unlikely((start < 0) | (stop < 0))) {
+        size_t slen = strlen(cstring);
+        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "c-string too long to convert to Python");
+            return NULL;
         }
-#endif
-        return 1;
+        length = (Py_ssize_t) slen;
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    if (unlikely(stop <= start))
+        return __Pyx_NewRef(__pyx_empty_unicode);
+    length = stop - start;
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
     }
-    while (PyDict_Next(kw, &pos, &key, 0)) {
-        #if PY_MAJOR_VERSION < 3
-        if (unlikely(!PyString_Check(key)))
-        #endif
-            if (unlikely(!PyUnicode_Check(key)))
-                goto invalid_keyword_type;
+}
+
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
     }
-    if (!kw_allowed && unlikely(key))
-        goto invalid_keyword;
-    return 1;
-invalid_keyword_type:
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() keywords must be strings", function_name);
-    return 0;
 #endif
-invalid_keyword:
-    #if PY_MAJOR_VERSION < 3
-    PyErr_Format(PyExc_TypeError,
-        "%.200s() got an unexpected keyword argument '%.200s'",
-        function_name, PyString_AsString(key));
-    #else
-    PyErr_Format(PyExc_TypeError,
-        "%s() got an unexpected keyword argument '%U'",
-        function_name, key);
-    #endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
     return 0;
 }
-
-/* DivInt[Py_ssize_t] */
-static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
-    Py_ssize_t q = a / b;
-    Py_ssize_t r = a - q*b;
-    q -= ((r != 0) & ((r ^ b) < 0));
-    return q;
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
 }
+#endif
 
 /* GetAttr3 */
 static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
         return NULL;
     __Pyx_PyErr_Clear();
     Py_INCREF(d);
     return d;
 }
 static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
-    PyObject *r;
-#if CYTHON_USE_TYPE_SLOTS
-    if (likely(PyString_Check(n))) {
-        r = __Pyx_PyObject_GetAttrStrNoError(o, n);
-        if (unlikely(!r) && likely(!PyErr_Occurred())) {
-            r = __Pyx_NewRef(d);
-        }
-        return r;
-    }
-#endif
-    r = PyObject_GetAttr(o, n);
+    PyObject *r = __Pyx_GetAttr(o, n);
     return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
 }
 
 /* PyDictVersioning */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
     PyObject *dict = Py_TYPE(obj)->tp_dict;
@@ -22682,22 +20297,14 @@
     result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
     __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
     if (likely(result)) {
         return __Pyx_NewRef(result);
     } else if (unlikely(PyErr_Occurred())) {
         return NULL;
     }
-#elif CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(!__pyx_m)) {
-        return NULL;
-    }
-    result = PyObject_GetAttr(__pyx_m, name);
-    if (likely(result)) {
-        return result;
-    }
 #else
     result = PyDict_GetItem(__pyx_d, name);
     __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
     if (likely(result)) {
         return __Pyx_NewRef(result);
     }
 #endif
@@ -22728,474 +20335,95 @@
 /* RaiseNoneIterError */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
 /* ExtTypeTest */
 static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    __Pyx_TypeName obj_type_name;
-    __Pyx_TypeName type_name;
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     if (likely(__Pyx_TypeCheck(obj, type)))
         return 1;
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    type_name = __Pyx_PyType_GetName(type);
-    PyErr_Format(PyExc_TypeError,
-                 "Cannot convert " __Pyx_FMT_TYPENAME " to " __Pyx_FMT_TYPENAME,
-                 obj_type_name, type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
-    __Pyx_DECREF_TypeName(type_name);
-    return 0;
-}
-
-/* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK && CYTHON_FAST_THREAD_STATE
-static _PyErr_StackItem *
-__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
-{
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_value == NULL || exc_info->exc_value == Py_None) &&
-           exc_info->previous_item != NULL)
-    {
-        exc_info = exc_info->previous_item;
-    }
-    return exc_info;
-}
-#endif
-
-/* SaveResetException */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    PyObject *exc_value = exc_info->exc_value;
-    if (exc_value == NULL || exc_value == Py_None) {
-        *value = NULL;
-        *type = NULL;
-        *tb = NULL;
-    } else {
-        *value = exc_value;
-        Py_INCREF(*value);
-        *type = (PyObject*) Py_TYPE(exc_value);
-        Py_INCREF(*type);
-        *tb = PyException_GetTraceback(exc_value);
-    }
-  #elif CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    *type = exc_info->exc_type;
-    *value = exc_info->exc_value;
-    *tb = exc_info->exc_traceback;
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-  #else
-    *type = tstate->exc_type;
-    *value = tstate->exc_value;
-    *tb = tstate->exc_traceback;
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-  #endif
-}
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    PyObject *tmp_value = exc_info->exc_value;
-    exc_info->exc_value = value;
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(type);
-    Py_XDECREF(tb);
-  #else
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = type;
-    exc_info->exc_value = value;
-    exc_info->exc_traceback = tb;
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = type;
-    tstate->exc_value = value;
-    tstate->exc_traceback = tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-  #endif
-}
-#endif
-
-/* GetException */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
-#else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
-#endif
-{
-    PyObject *local_type = NULL, *local_value, *local_tb = NULL;
-#if CYTHON_FAST_THREAD_STATE
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-  #if PY_VERSION_HEX >= 0x030C00A6
-    local_value = tstate->current_exception;
-    tstate->current_exception = 0;
-    if (likely(local_value)) {
-        local_type = (PyObject*) Py_TYPE(local_value);
-        Py_INCREF(local_type);
-        local_tb = PyException_GetTraceback(local_value);
-    }
-  #else
-    local_type = tstate->curexc_type;
-    local_value = tstate->curexc_value;
-    local_tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-  #endif
-#else
-    PyErr_Fetch(&local_type, &local_value, &local_tb);
-#endif
-    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE && PY_VERSION_HEX >= 0x030C00A6
-    if (unlikely(tstate->current_exception))
-#elif CYTHON_FAST_THREAD_STATE
-    if (unlikely(tstate->curexc_type))
-#else
-    if (unlikely(PyErr_Occurred()))
-#endif
-        goto bad;
-    #if PY_MAJOR_VERSION >= 3
-    if (local_tb) {
-        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
-            goto bad;
-    }
-    #endif
-    Py_XINCREF(local_tb);
-    Py_XINCREF(local_type);
-    Py_XINCREF(local_value);
-    *type = local_type;
-    *value = local_value;
-    *tb = local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    #if CYTHON_USE_EXC_INFO_STACK
-    {
-        _PyErr_StackItem *exc_info = tstate->exc_info;
-      #if PY_VERSION_HEX >= 0x030B00a4
-        tmp_value = exc_info->exc_value;
-        exc_info->exc_value = local_value;
-        tmp_type = NULL;
-        tmp_tb = NULL;
-        Py_XDECREF(local_type);
-        Py_XDECREF(local_tb);
-      #else
-        tmp_type = exc_info->exc_type;
-        tmp_value = exc_info->exc_value;
-        tmp_tb = exc_info->exc_traceback;
-        exc_info->exc_type = local_type;
-        exc_info->exc_value = local_value;
-        exc_info->exc_traceback = local_tb;
-      #endif
-    }
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = local_type;
-    tstate->exc_value = local_value;
-    tstate->exc_traceback = local_tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#else
-    PyErr_SetExcInfo(local_type, local_value, local_tb);
-#endif
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
-bad:
-    *type = 0;
-    *value = 0;
-    *tb = 0;
-    Py_XDECREF(local_type);
-    Py_XDECREF(local_value);
-    Py_XDECREF(local_tb);
-    return -1;
-}
-
-/* SwapException */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_value = exc_info->exc_value;
-    exc_info->exc_value = *value;
-    if (tmp_value == NULL || tmp_value == Py_None) {
-        Py_XDECREF(tmp_value);
-        tmp_value = NULL;
-        tmp_type = NULL;
-        tmp_tb = NULL;
-    } else {
-        tmp_type = (PyObject*) Py_TYPE(tmp_value);
-        Py_INCREF(tmp_type);
-        #if CYTHON_COMPILING_IN_CPYTHON
-        tmp_tb = ((PyBaseExceptionObject*) tmp_value)->traceback;
-        Py_XINCREF(tmp_tb);
-        #else
-        tmp_tb = PyException_GetTraceback(tmp_value);
-        #endif
-    }
-  #elif CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = *type;
-    exc_info->exc_value = *value;
-    exc_info->exc_traceback = *tb;
-  #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = *type;
-    tstate->exc_value = *value;
-    tstate->exc_traceback = *tb;
-  #endif
-    *type = tmp_type;
-    *value = tmp_value;
-    *tb = tmp_tb;
 }
-#else
-static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
-    PyErr_SetExcInfo(*type, *value, *tb);
-    *type = tmp_type;
-    *value = tmp_value;
-    *tb = tmp_tb;
-}
-#endif
 
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+    PyObject *empty_list = 0;
     PyObject *module = 0;
+    PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
-    PyObject *empty_list = 0;
+    PyObject *list;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
     py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
-    if (unlikely(!py_import))
+    if (!py_import)
         goto bad;
-    if (!from_list) {
+    #endif
+    if (from_list)
+        list = from_list;
+    else {
         empty_list = PyList_New(0);
-        if (unlikely(!empty_list))
+        if (!empty_list)
             goto bad;
-        from_list = empty_list;
+        list = empty_list;
     }
-    #endif
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
     empty_dict = PyDict_New();
-    if (unlikely(!empty_dict))
+    if (!empty_dict)
         goto bad;
     {
         #if PY_MAJOR_VERSION >= 3
         if (level == -1) {
             if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
-                #if CYTHON_COMPILING_IN_LIMITED_API
-                module = PyImport_ImportModuleLevelObject(
-                    name, empty_dict, empty_dict, from_list, 1);
-                #else
                 module = PyImport_ImportModuleLevelObject(
-                    name, __pyx_d, empty_dict, from_list, 1);
-                #endif
-                if (unlikely(!module)) {
-                    if (unlikely(!PyErr_ExceptionMatches(PyExc_ImportError)))
+                    name, global_dict, empty_dict, list, 1);
+                if (!module) {
+                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                         goto bad;
                     PyErr_Clear();
                 }
             }
             level = 0;
         }
         #endif
         if (!module) {
             #if PY_MAJOR_VERSION < 3
             PyObject *py_level = PyInt_FromLong(level);
-            if (unlikely(!py_level))
+            if (!py_level)
                 goto bad;
             module = PyObject_CallFunctionObjArgs(py_import,
-                name, __pyx_d, empty_dict, from_list, py_level, (PyObject *)NULL);
+                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
             Py_DECREF(py_level);
             #else
-            #if CYTHON_COMPILING_IN_LIMITED_API
             module = PyImport_ImportModuleLevelObject(
-                name, empty_dict, empty_dict, from_list, level);
-            #else
-            module = PyImport_ImportModuleLevelObject(
-                name, __pyx_d, empty_dict, from_list, level);
-            #endif
+                name, global_dict, empty_dict, list, level);
             #endif
         }
     }
 bad:
-    Py_XDECREF(empty_dict);
-    Py_XDECREF(empty_list);
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_import);
     #endif
+    Py_XDECREF(empty_list);
+    Py_XDECREF(empty_dict);
     return module;
 }
 
-/* ImportDottedModule */
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Error(PyObject *name, PyObject *parts_tuple, Py_ssize_t count) {
-    PyObject *partial_name = NULL, *slice = NULL, *sep = NULL;
-    if (unlikely(PyErr_Occurred())) {
-        PyErr_Clear();
-    }
-    if (likely(PyTuple_GET_SIZE(parts_tuple) == count)) {
-        partial_name = name;
-    } else {
-        slice = PySequence_GetSlice(parts_tuple, 0, count);
-        if (unlikely(!slice))
-            goto bad;
-        sep = PyUnicode_FromStringAndSize(".", 1);
-        if (unlikely(!sep))
-            goto bad;
-        partial_name = PyUnicode_Join(sep, slice);
-    }
-    PyErr_Format(
-#if PY_MAJOR_VERSION < 3
-        PyExc_ImportError,
-        "No module named '%s'", PyString_AS_STRING(partial_name));
-#else
-#if PY_VERSION_HEX >= 0x030600B1
-        PyExc_ModuleNotFoundError,
-#else
-        PyExc_ImportError,
-#endif
-        "No module named '%U'", partial_name);
-#endif
-bad:
-    Py_XDECREF(sep);
-    Py_XDECREF(slice);
-    Py_XDECREF(partial_name);
-    return NULL;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx__ImportDottedModule_Lookup(PyObject *name) {
-    PyObject *imported_module;
-#if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-    PyObject *modules = PyImport_GetModuleDict();
-    if (unlikely(!modules))
-        return NULL;
-    imported_module = __Pyx_PyDict_GetItemStr(modules, name);
-    Py_XINCREF(imported_module);
-#else
-    imported_module = PyImport_GetModule(name);
-#endif
-    return imported_module;
-}
-#endif
-#if PY_MAJOR_VERSION >= 3
-static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple) {
-    Py_ssize_t i, nparts;
-    nparts = PyTuple_GET_SIZE(parts_tuple);
-    for (i=1; i < nparts && module; i++) {
-        PyObject *part, *submodule;
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        part = PyTuple_GET_ITEM(parts_tuple, i);
-#else
-        part = PySequence_ITEM(parts_tuple, i);
-#endif
-        submodule = __Pyx_PyObject_GetAttrStrNoError(module, part);
-#if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-        Py_DECREF(part);
-#endif
-        Py_DECREF(module);
-        module = submodule;
-    }
-    if (unlikely(!module)) {
-        return __Pyx__ImportDottedModule_Error(name, parts_tuple, i);
-    }
-    return module;
-}
-#endif
-static PyObject *__Pyx__ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if PY_MAJOR_VERSION < 3
-    PyObject *module, *from_list, *star = __pyx_n_s__3;
-    CYTHON_UNUSED_VAR(parts_tuple);
-    from_list = PyList_New(1);
-    if (unlikely(!from_list))
-        return NULL;
-    Py_INCREF(star);
-    PyList_SET_ITEM(from_list, 0, star);
-    module = __Pyx_Import(name, from_list, 0);
-    Py_DECREF(from_list);
-    return module;
-#else
-    PyObject *imported_module;
-    PyObject *module = __Pyx_Import(name, NULL, 0);
-    if (!parts_tuple || unlikely(!module))
-        return module;
-    imported_module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(imported_module)) {
-        Py_DECREF(module);
-        return imported_module;
-    }
-    PyErr_Clear();
-    return __Pyx_ImportDottedModule_WalkParts(module, name, parts_tuple);
-#endif
-}
-static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple) {
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030400B1
-    PyObject *module = __Pyx__ImportDottedModule_Lookup(name);
-    if (likely(module)) {
-        PyObject *spec = __Pyx_PyObject_GetAttrStrNoError(module, __pyx_n_s_spec);
-        if (likely(spec)) {
-            PyObject *unsafe = __Pyx_PyObject_GetAttrStrNoError(spec, __pyx_n_s_initializing);
-            if (likely(!unsafe || !__Pyx_PyObject_IsTrue(unsafe))) {
-                Py_DECREF(spec);
-                spec = NULL;
-            }
-            Py_XDECREF(unsafe);
-        }
-        if (likely(!spec)) {
-            PyErr_Clear();
-            return module;
-        }
-        Py_DECREF(spec);
-        Py_DECREF(module);
-    } else if (PyErr_Occurred()) {
-        PyErr_Clear();
-    }
-#endif
-    return __Pyx__ImportDottedModule(name, parts_tuple);
-}
-
-/* ssize_strlen */
-static CYTHON_INLINE Py_ssize_t __Pyx_ssize_strlen(const char *s) {
-    size_t len = strlen(s);
-    if (unlikely(len > PY_SSIZE_T_MAX)) {
-        PyErr_SetString(PyExc_OverflowError, "byte string is too long");
-        return -1;
-    }
-    return (Py_ssize_t) len;
-}
-
 /* FastTypeChecks */
 #if CYTHON_COMPILING_IN_CPYTHON
 static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
     while (a) {
-        a = __Pyx_PyType_GetSlot(a, tp_base, PyTypeObject*);
+        a = a->tp_base;
         if (a == b)
             return 1;
     }
     return b == &PyBaseObject_Type;
 }
 static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
     PyObject *mro;
@@ -23208,30 +20436,14 @@
             if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                 return 1;
         }
         return 0;
     }
     return __Pyx_InBases(a, b);
 }
-static CYTHON_INLINE int __Pyx_IsAnySubtype2(PyTypeObject *cls, PyTypeObject *a, PyTypeObject *b) {
-    PyObject *mro;
-    if (cls == a || cls == b) return 1;
-    mro = cls->tp_mro;
-    if (likely(mro)) {
-        Py_ssize_t i, n;
-        n = PyTuple_GET_SIZE(mro);
-        for (i = 0; i < n; i++) {
-            PyObject *base = PyTuple_GET_ITEM(mro, i);
-            if (base == (PyObject *)a || base == (PyObject *)b)
-                return 1;
-        }
-        return 0;
-    }
-    return __Pyx_InBases(cls, a) || __Pyx_InBases(cls, b);
-}
 #if PY_MAJOR_VERSION == 2
 static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
     PyObject *exception, *value, *tb;
     int res;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     __Pyx_ErrFetch(&exception, &value, &tb);
@@ -23248,19 +20460,19 @@
         }
     }
     __Pyx_ErrRestore(exception, value, tb);
     return res;
 }
 #else
 static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    if (exc_type1) {
-        return __Pyx_IsAnySubtype2((PyTypeObject*)err, (PyTypeObject*)exc_type1, (PyTypeObject*)exc_type2);
-    } else {
-        return __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
+    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
+    if (!res) {
+        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
     }
+    return res;
 }
 #endif
 static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
     Py_ssize_t i, n;
     assert(PyExceptionClass_Check(exc_type));
     n = PyTuple_GET_SIZE(tuple);
 #if PY_MAJOR_VERSION >= 3
@@ -23299,139 +20511,155 @@
     if (likely(PyExceptionClass_Check(err))) {
         return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
     }
     return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
 }
 #endif
 
-/* PySequenceMultiply */
-static PyObject* __Pyx_PySequence_Multiply_Generic(PyObject *seq, Py_ssize_t mul) {
-    PyObject *result, *pymul = PyInt_FromSsize_t(mul);
-    if (unlikely(!pymul))
-        return NULL;
-    result = PyNumber_Multiply(seq, pymul);
-    Py_DECREF(pymul);
-    return result;
-}
-static CYTHON_INLINE PyObject* __Pyx_PySequence_Multiply(PyObject *seq, Py_ssize_t mul) {
-#if CYTHON_USE_TYPE_SLOTS
-    PyTypeObject *type = Py_TYPE(seq);
-    if (likely(type->tp_as_sequence && type->tp_as_sequence->sq_repeat)) {
-        return type->tp_as_sequence->sq_repeat(seq, mul);
-    } else
-#endif
-    {
-        return __Pyx_PySequence_Multiply_Generic(seq, mul);
+/* PyIntBinop */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, int inplace, int zerodivision_check) {
+    (void)inplace;
+    (void)zerodivision_check;
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyInt_CheckExact(op1))) {
+        const long b = intval;
+        long x;
+        long a = PyInt_AS_LONG(op1);
+            x = (long)((unsigned long)a + b);
+            if (likely((x^a) >= 0 || (x^b) >= 0))
+                return PyInt_FromLong(x);
+            return PyLong_Type.tp_as_number->nb_add(op1, op2);
     }
-}
-
-/* SetItemInt */
-static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
-    int r;
-    if (unlikely(!j)) return -1;
-    r = PyObject_SetItem(o, j, v);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
-                                               CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = (!wraparound) ? i : ((likely(i >= 0)) ? i : i + PyList_GET_SIZE(o));
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o)))) {
-            PyObject* old = PyList_GET_ITEM(o, n);
-            Py_INCREF(v);
-            PyList_SET_ITEM(o, n, v);
-            Py_DECREF(old);
-            return 1;
-        }
-    } else {
-        PyMappingMethods *mm = Py_TYPE(o)->tp_as_mapping;
-        PySequenceMethods *sm = Py_TYPE(o)->tp_as_sequence;
-        if (mm && mm->mp_ass_subscript) {
-            int r;
-            PyObject *key = PyInt_FromSsize_t(i);
-            if (unlikely(!key)) return -1;
-            r = mm->mp_ass_subscript(o, key, v);
-            Py_DECREF(key);
-            return r;
-        }
-        if (likely(sm && sm->sq_ass_item)) {
-            if (wraparound && unlikely(i < 0) && likely(sm->sq_length)) {
-                Py_ssize_t l = sm->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return -1;
-                    PyErr_Clear();
-                }
+    #endif
+    #if CYTHON_USE_PYLONG_INTERNALS
+    if (likely(PyLong_CheckExact(op1))) {
+        const long b = intval;
+        long a, x;
+#ifdef HAVE_LONG_LONG
+        const PY_LONG_LONG llb = intval;
+        PY_LONG_LONG lla, llx;
+#endif
+        const digit* digits = ((PyLongObject*)op1)->ob_digit;
+        const Py_ssize_t size = Py_SIZE(op1);
+        if (likely(__Pyx_sst_abs(size) <= 1)) {
+            a = likely(size) ? digits[0] : 0;
+            if (size == -1) a = -a;
+        } else {
+            switch (size) {
+                case -2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 2:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 3:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                case 4:
+                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
+                        break;
+#ifdef HAVE_LONG_LONG
+                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
+                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
+                        goto long_long;
+#endif
+                    }
+                    CYTHON_FALLTHROUGH;
+                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
             }
-            return sm->sq_ass_item(o, i, v);
         }
-    }
-#else
-#if CYTHON_COMPILING_IN_PYPY
-    if (is_list || (PySequence_Check(o) && !PyDict_Check(o)))
-#else
-    if (is_list || PySequence_Check(o))
+                x = a + b;
+            return PyLong_FromLong(x);
+#ifdef HAVE_LONG_LONG
+        long_long:
+                llx = lla + llb;
+            return PyLong_FromLongLong(llx);
 #endif
-    {
-        return PySequence_SetItem(o, i, v);
+        
+        
     }
-#endif
-    return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
+    #endif
+    if (PyFloat_CheckExact(op1)) {
+        const long b = intval;
+        double a = PyFloat_AS_DOUBLE(op1);
+            double result;
+            PyFPE_START_PROTECT("add", return NULL)
+            result = ((double)a) + (double)b;
+            PyFPE_END_PROTECT(result)
+            return PyFloat_FromDouble(result);
+    }
+    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
 }
+#endif
 
-/* RaiseUnboundLocalError */
+/* None */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
-/* DivInt[long] */
+/* None */
 static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
     long q = a / b;
     long r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
 /* ImportFrom */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
     PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
     if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        const char* module_name_str = 0;
-        PyObject* module_name = 0;
-        PyObject* module_dot = 0;
-        PyObject* full_name = 0;
-        PyErr_Clear();
-        module_name_str = PyModule_GetName(module);
-        if (unlikely(!module_name_str)) { goto modbad; }
-        module_name = PyUnicode_FromString(module_name_str);
-        if (unlikely(!module_name)) { goto modbad; }
-        module_dot = PyUnicode_Concat(module_name, __pyx_kp_u__2);
-        if (unlikely(!module_dot)) { goto modbad; }
-        full_name = PyUnicode_Concat(module_dot, name);
-        if (unlikely(!full_name)) { goto modbad; }
-        #if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-        {
-            PyObject *modules = PyImport_GetModuleDict();
-            if (unlikely(!modules))
-                goto modbad;
-            value = PyObject_GetItem(modules, full_name);
-        }
-        #else
-        value = PyImport_GetModule(full_name);
-        #endif
-      modbad:
-        Py_XDECREF(full_name);
-        Py_XDECREF(module_dot);
-        Py_XDECREF(module_name);
-    }
-    if (unlikely(!value)) {
         PyErr_Format(PyExc_ImportError,
         #if PY_MAJOR_VERSION < 3
             "cannot import name %.230s", PyString_AS_STRING(name));
         #else
             "cannot import name %S", name);
         #endif
     }
@@ -23443,74 +20671,34 @@
     PyObject *r;
     if (unlikely(!__Pyx_PyBaseString_Check(n))) {
         PyErr_SetString(PyExc_TypeError,
                         "hasattr(): attribute name must be string");
         return -1;
     }
     r = __Pyx_GetAttr(o, n);
-    if (!r) {
+    if (unlikely(!r)) {
         PyErr_Clear();
         return 0;
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 
-/* DictGetItem */
-#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
-static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
-    PyObject *value;
-    value = PyDict_GetItemWithError(d, key);
-    if (unlikely(!value)) {
-        if (!PyErr_Occurred()) {
-            if (unlikely(PyTuple_Check(key))) {
-                PyObject* args = PyTuple_Pack(1, key);
-                if (likely(args)) {
-                    PyErr_SetObject(PyExc_KeyError, args);
-                    Py_DECREF(args);
-                }
-            } else {
-                PyErr_SetObject(PyExc_KeyError, key);
-            }
-        }
-        return NULL;
-    }
-    Py_INCREF(value);
-    return value;
-}
-#endif
-
-/* PyObjectSetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_setattro))
-        return tp->tp_setattro(obj, attr_name, value);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_setattr))
-        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
-#endif
-    return PyObject_SetAttr(obj, attr_name, value);
-}
-#endif
-
 /* PyObject_GenericGetAttrNoDict */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
-    __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, attr_name);
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, attr_name);
 #else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(attr_name));
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(attr_name));
 #endif
-    __Pyx_DECREF_TypeName(type_name);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
     PyObject *descr;
     PyTypeObject *tp = Py_TYPE(obj);
     if (unlikely(!PyString_Check(attr_name))) {
         return PyObject_GenericGetAttr(obj, attr_name);
@@ -23542,431 +20730,59 @@
     if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
         return PyObject_GenericGetAttr(obj, attr_name);
     }
     return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
 }
 #endif
 
-/* FixUpExtensionType */
-#if CYTHON_USE_TYPE_SPECS
-static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
-#if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
-    CYTHON_UNUSED_VAR(spec);
-    CYTHON_UNUSED_VAR(type);
-#else
-    const PyType_Slot *slot = spec->slots;
-    while (slot && slot->slot && slot->slot != Py_tp_members)
-        slot++;
-    if (slot && slot->slot == Py_tp_members) {
-        int changed = 0;
-#if !(PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON)
-        const
-#endif
-            PyMemberDef *memb = (PyMemberDef*) slot->pfunc;
-        while (memb && memb->name) {
-            if (memb->name[0] == '_' && memb->name[1] == '_') {
-#if PY_VERSION_HEX < 0x030900b1
-                if (strcmp(memb->name, "__weaklistoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_weaklistoffset = memb->offset;
-                    changed = 1;
-                }
-                else if (strcmp(memb->name, "__dictoffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-                    type->tp_dictoffset = memb->offset;
-                    changed = 1;
-                }
-#if CYTHON_METH_FASTCALL
-                else if (strcmp(memb->name, "__vectorcalloffset__") == 0) {
-                    assert(memb->type == T_PYSSIZET);
-                    assert(memb->flags == READONLY);
-#if PY_VERSION_HEX >= 0x030800b4
-                    type->tp_vectorcall_offset = memb->offset;
-#else
-                    type->tp_print = (printfunc) memb->offset;
-#endif
-                    changed = 1;
-                }
-#endif
-#else
-                if ((0));
-#endif
-#if PY_VERSION_HEX <= 0x030900b1 && CYTHON_COMPILING_IN_CPYTHON
-                else if (strcmp(memb->name, "__module__") == 0) {
-                    PyObject *descr;
-                    assert(memb->type == T_OBJECT);
-                    assert(memb->flags == 0 || memb->flags == READONLY);
-                    descr = PyDescr_NewMember(type, memb);
-                    if (unlikely(!descr))
-                        return -1;
-                    if (unlikely(PyDict_SetItem(type->tp_dict, PyDescr_NAME(descr), descr) < 0)) {
-                        Py_DECREF(descr);
-                        return -1;
-                    }
-                    Py_DECREF(descr);
-                    changed = 1;
-                }
-#endif
-            }
-            memb++;
-        }
-        if (changed)
-            PyType_Modified(type);
-    }
-#endif
-    return 0;
-}
-#endif
-
-/* PyObjectCallNoArg */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
-    PyObject *arg = NULL;
-    return __Pyx_PyObject_FastCall(func, (&arg)+1, 0 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
-}
-
-/* PyObjectGetMethod */
-static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
-    PyObject *attr;
-#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
-    __Pyx_TypeName type_name;
-    PyTypeObject *tp = Py_TYPE(obj);
-    PyObject *descr;
-    descrgetfunc f = NULL;
-    PyObject **dictptr, *dict;
-    int meth_found = 0;
-    assert (*method == NULL);
-    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
-        attr = __Pyx_PyObject_GetAttrStr(obj, name);
-        goto try_unpack;
-    }
-    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
-        return 0;
-    }
-    descr = _PyType_Lookup(tp, name);
-    if (likely(descr != NULL)) {
-        Py_INCREF(descr);
-#if defined(Py_TPFLAGS_METHOD_DESCRIPTOR) && Py_TPFLAGS_METHOD_DESCRIPTOR
-        if (__Pyx_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR))
-#elif PY_MAJOR_VERSION >= 3
-        #ifdef __Pyx_CyFunction_USED
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
-        #else
-        if (likely(PyFunction_Check(descr) || __Pyx_IS_TYPE(descr, &PyMethodDescr_Type)))
-        #endif
-#else
-        #ifdef __Pyx_CyFunction_USED
-        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
-        #else
-        if (likely(PyFunction_Check(descr)))
-        #endif
-#endif
-        {
-            meth_found = 1;
-        } else {
-            f = Py_TYPE(descr)->tp_descr_get;
-            if (f != NULL && PyDescr_IsData(descr)) {
-                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
-                Py_DECREF(descr);
-                goto try_unpack;
-            }
-        }
-    }
-    dictptr = _PyObject_GetDictPtr(obj);
-    if (dictptr != NULL && (dict = *dictptr) != NULL) {
-        Py_INCREF(dict);
-        attr = __Pyx_PyDict_GetItemStr(dict, name);
-        if (attr != NULL) {
-            Py_INCREF(attr);
-            Py_DECREF(dict);
-            Py_XDECREF(descr);
-            goto try_unpack;
-        }
-        Py_DECREF(dict);
-    }
-    if (meth_found) {
-        *method = descr;
-        return 1;
-    }
-    if (f != NULL) {
-        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
-        Py_DECREF(descr);
-        goto try_unpack;
-    }
-    if (likely(descr != NULL)) {
-        *method = descr;
-        return 0;
-    }
-    type_name = __Pyx_PyType_GetName(tp);
-    PyErr_Format(PyExc_AttributeError,
-#if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, name);
-#else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(name));
-#endif
-    __Pyx_DECREF_TypeName(type_name);
-    return 0;
-#else
-    attr = __Pyx_PyObject_GetAttrStr(obj, name);
-    goto try_unpack;
-#endif
-try_unpack:
-#if CYTHON_UNPACK_METHODS
-    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
-        PyObject *function = PyMethod_GET_FUNCTION(attr);
-        Py_INCREF(function);
-        Py_DECREF(attr);
-        *method = function;
-        return 1;
-    }
-#endif
-    *method = attr;
-    return 0;
-}
-
-/* PyObjectCallMethod0 */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
-    PyObject *method = NULL, *result = NULL;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_CallOneArg(method, obj);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) goto bad;
-    result = __Pyx_PyObject_CallNoArg(method);
-    Py_DECREF(method);
-bad:
-    return result;
-}
-
-/* ValidateBasesTuple */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
-    Py_ssize_t i, n = PyTuple_GET_SIZE(bases);
-    for (i = 1; i < n; i++)
-    {
-        PyObject *b0 = PyTuple_GET_ITEM(bases, i);
-        PyTypeObject *b;
-#if PY_MAJOR_VERSION < 3
-        if (PyClass_Check(b0))
-        {
-            PyErr_Format(PyExc_TypeError, "base class '%.200s' is an old-style class",
-                         PyString_AS_STRING(((PyClassObject*)b0)->cl_name));
-            return -1;
-        }
-#endif
-        b = (PyTypeObject*) b0;
-        if (!__Pyx_PyType_HasFeature(b, Py_TPFLAGS_HEAPTYPE))
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "base class '" __Pyx_FMT_TYPENAME "' is not a heap type", b_name);
-            __Pyx_DECREF_TypeName(b_name);
-            return -1;
-        }
-        if (dictoffset == 0 && b->tp_dictoffset)
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "extension type '%.200s' has no __dict__ slot, "
-                "but base type '" __Pyx_FMT_TYPENAME "' has: "
-                "either add 'cdef dict __dict__' to the extension type "
-                "or add '__slots__ = [...]' to the base type",
-                type_name, b_name);
-            __Pyx_DECREF_TypeName(b_name);
-            return -1;
-        }
-    }
-    return 0;
-}
-#endif
-
-/* PyType_Ready */
-static int __Pyx_PyType_Ready(PyTypeObject *t) {
-#if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
-    (void)__Pyx_PyObject_CallMethod0;
-#if CYTHON_USE_TYPE_SPECS
-    (void)__Pyx_validate_bases_tuple;
-#endif
-    return PyType_Ready(t);
-#else
-    int r;
-    PyObject *bases = __Pyx_PyType_GetSlot(t, tp_bases, PyObject*);
-    if (bases && unlikely(__Pyx_validate_bases_tuple(t->tp_name, t->tp_dictoffset, bases) == -1))
-        return -1;
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-    {
-        int gc_was_enabled;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        gc_was_enabled = PyGC_Disable();
-        (void)__Pyx_PyObject_CallMethod0;
-    #else
-        PyObject *ret, *py_status;
-        PyObject *gc = NULL;
-        #if PY_VERSION_HEX >= 0x030700a1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM+0 >= 0x07030400)
-        gc = PyImport_GetModule(__pyx_kp_u_gc);
-        #endif
-        if (unlikely(!gc)) gc = PyImport_Import(__pyx_kp_u_gc);
-        if (unlikely(!gc)) return -1;
-        py_status = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_isenabled);
-        if (unlikely(!py_status)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-        gc_was_enabled = __Pyx_PyObject_IsTrue(py_status);
-        Py_DECREF(py_status);
-        if (gc_was_enabled > 0) {
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_disable);
-            if (unlikely(!ret)) {
-                Py_DECREF(gc);
-                return -1;
-            }
-            Py_DECREF(ret);
-        } else if (unlikely(gc_was_enabled == -1)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-    #endif
-        t->tp_flags |= Py_TPFLAGS_HEAPTYPE;
-#if PY_VERSION_HEX >= 0x030A0000
-        t->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;
-#endif
-#else
-        (void)__Pyx_PyObject_CallMethod0;
-#endif
-    r = PyType_Ready(t);
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-        t->tp_flags &= ~Py_TPFLAGS_HEAPTYPE;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        if (gc_was_enabled)
-            PyGC_Enable();
-    #else
-        if (gc_was_enabled) {
-            PyObject *tp, *v, *tb;
-            PyErr_Fetch(&tp, &v, &tb);
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_enable);
-            if (likely(ret || r == -1)) {
-                Py_XDECREF(ret);
-                PyErr_Restore(tp, v, tb);
-            } else {
-                Py_XDECREF(tp);
-                Py_XDECREF(v);
-                Py_XDECREF(tb);
-                r = -1;
-            }
-        }
-        Py_DECREF(gc);
-    #endif
-    }
-#endif
-    return r;
-#endif
-}
-
 /* SetVTable */
-static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
+static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+#if PY_VERSION_HEX >= 0x02070000
     PyObject *ob = PyCapsule_New(vtable, 0, 0);
-    if (unlikely(!ob))
-        goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
 #else
-    if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
+    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
 #endif
+    if (!ob)
+        goto bad;
+    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
         goto bad;
     Py_DECREF(ob);
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
-/* GetVTable */
-static void* __Pyx_GetVtable(PyTypeObject *type) {
-    void* ptr;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
-#else
-    PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
-#endif
-    if (!ob)
-        goto bad;
-    ptr = PyCapsule_GetPointer(ob, 0);
-    if (!ptr && !PyErr_Occurred())
-        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
-    Py_DECREF(ob);
-    return ptr;
-bad:
-    Py_XDECREF(ob);
-    return NULL;
+/* PyObjectGetAttrStrNoError */
+static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        __Pyx_PyErr_Clear();
 }
-
-/* MergeVTables */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type) {
-    int i;
-    void** base_vtables;
-    __Pyx_TypeName tp_base_name;
-    __Pyx_TypeName base_name;
-    void* unknown = (void*)-1;
-    PyObject* bases = type->tp_bases;
-    int base_depth = 0;
-    {
-        PyTypeObject* base = type->tp_base;
-        while (base) {
-            base_depth += 1;
-            base = base->tp_base;
-        }
-    }
-    base_vtables = (void**) malloc(sizeof(void*) * (size_t)(base_depth + 1));
-    base_vtables[0] = unknown;
-    for (i = 1; i < PyTuple_GET_SIZE(bases); i++) {
-        void* base_vtable = __Pyx_GetVtable(((PyTypeObject*)PyTuple_GET_ITEM(bases, i)));
-        if (base_vtable != NULL) {
-            int j;
-            PyTypeObject* base = type->tp_base;
-            for (j = 0; j < base_depth; j++) {
-                if (base_vtables[j] == unknown) {
-                    base_vtables[j] = __Pyx_GetVtable(base);
-                    base_vtables[j + 1] = unknown;
-                }
-                if (base_vtables[j] == base_vtable) {
-                    break;
-                } else if (base_vtables[j] == NULL) {
-                    goto bad;
-                }
-                base = base->tp_base;
-            }
-        }
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
+    PyObject *result;
+#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
+        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
     }
-    PyErr_Clear();
-    free(base_vtables);
-    return 0;
-bad:
-    tp_base_name = __Pyx_PyType_GetName(type->tp_base);
-    base_name = __Pyx_PyType_GetName((PyTypeObject*)PyTuple_GET_ITEM(bases, i));
-    PyErr_Format(PyExc_TypeError,
-        "multiple bases have vtable conflict: '" __Pyx_FMT_TYPENAME "' and '" __Pyx_FMT_TYPENAME "'", tp_base_name, base_name);
-    __Pyx_DECREF_TypeName(tp_base_name);
-    __Pyx_DECREF_TypeName(base_name);
-    free(base_vtables);
-    return -1;
-}
 #endif
+    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
+    if (unlikely(!result)) {
+        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
+    }
+    return result;
+}
 
 /* SetupReduce */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
   int ret;
   PyObject *name_attr;
-  name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name_2);
+  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name_2);
   if (likely(name_attr)) {
       ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
   } else {
       ret = -1;
   }
   if (unlikely(ret < 0)) {
       PyErr_Clear();
@@ -23974,43 +20790,25 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
-#if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
-#else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
-#endif
-    if (getstate) {
 #if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
+    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
+    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
 #endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -24024,15 +20822,15 @@
             reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
             if (likely(reduce_cython)) {
                 ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
             } else if (reduce == object_reduce || PyErr_Occurred()) {
                 goto __PYX_BAD;
             }
-            setstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate);
+            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
             if (!setstate) PyErr_Clear();
             if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                 setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
                 if (likely(setstate_cython)) {
                     ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                     ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                 } else if (!setstate || PyErr_Occurred()) {
@@ -24040,1132 +20838,73 @@
                 }
             }
             PyType_Modified((PyTypeObject*)type_obj);
         }
     }
     goto __PYX_GOOD;
 __PYX_BAD:
-    if (!PyErr_Occurred()) {
-        __Pyx_TypeName type_obj_name =
-            __Pyx_PyType_GetName((PyTypeObject*)type_obj);
-        PyErr_Format(PyExc_RuntimeError,
-            "Unable to initialize pickling for " __Pyx_FMT_TYPENAME, type_obj_name);
-        __Pyx_DECREF_TypeName(type_obj_name);
-    }
+    if (!PyErr_Occurred())
+        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
-#endif
-
-/* FetchSharedCythonModule */
-static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
-    PyObject *abi_module = PyImport_AddModule((char*) __PYX_ABI_MODULE_NAME);
-    if (unlikely(!abi_module)) return NULL;
-    Py_INCREF(abi_module);
-    return abi_module;
-}
-
-/* FetchCommonType */
-static int __Pyx_VerifyCachedType(PyObject *cached_type,
-                               const char *name,
-                               Py_ssize_t basicsize,
-                               Py_ssize_t expected_basicsize) {
-    if (!PyType_Check(cached_type)) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s is not a type object", name);
-        return -1;
-    }
-    if (basicsize != expected_basicsize) {
-        PyErr_Format(PyExc_TypeError,
-            "Shared Cython type %.200s has the wrong size, try recompiling",
-            name);
-        return -1;
-    }
-    return 0;
-}
-#if !CYTHON_USE_TYPE_SPECS
-static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
-    PyObject* abi_module;
-    const char* object_name;
-    PyTypeObject *cached_type = NULL;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    object_name = strrchr(type->tp_name, '.');
-    object_name = object_name ? object_name+1 : type->tp_name;
-    cached_type = (PyTypeObject*) PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        if (__Pyx_VerifyCachedType(
-              (PyObject *)cached_type,
-              object_name,
-              cached_type->tp_basicsize,
-              type->tp_basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    if (PyType_Ready(type) < 0) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, (PyObject *)type) < 0)
-        goto bad;
-    Py_INCREF(type);
-    cached_type = type;
-done:
-    Py_DECREF(abi_module);
-    return cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#else
-static PyTypeObject *__Pyx_FetchCommonTypeFromSpec(PyObject *module, PyType_Spec *spec, PyObject *bases) {
-    PyObject *abi_module, *cached_type = NULL;
-    const char* object_name = strrchr(spec->name, '.');
-    object_name = object_name ? object_name+1 : spec->name;
-    abi_module = __Pyx_FetchSharedCythonABIModule();
-    if (!abi_module) return NULL;
-    cached_type = PyObject_GetAttrString(abi_module, object_name);
-    if (cached_type) {
-        Py_ssize_t basicsize;
-#if CYTHON_COMPILING_IN_LIMITED_API
-        PyObject *py_basicsize;
-        py_basicsize = PyObject_GetAttrString(cached_type, "__basicsize__");
-        if (unlikely(!py_basicsize)) goto bad;
-        basicsize = PyLong_AsSsize_t(py_basicsize);
-        Py_DECREF(py_basicsize);
-        py_basicsize = 0;
-        if (unlikely(basicsize == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
-#else
-        basicsize = likely(PyType_Check(cached_type)) ? ((PyTypeObject*) cached_type)->tp_basicsize : -1;
-#endif
-        if (__Pyx_VerifyCachedType(
-              cached_type,
-              object_name,
-              basicsize,
-              spec->basicsize) < 0) {
-            goto bad;
-        }
-        goto done;
-    }
-    if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
-    PyErr_Clear();
-    CYTHON_UNUSED_VAR(module);
-    cached_type = __Pyx_PyType_FromModuleAndSpec(abi_module, spec, bases);
-    if (unlikely(!cached_type)) goto bad;
-    if (unlikely(__Pyx_fix_up_extension_type_from_spec(spec, (PyTypeObject *) cached_type) < 0)) goto bad;
-    if (PyObject_SetAttrString(abi_module, object_name, cached_type) < 0) goto bad;
-done:
-    Py_DECREF(abi_module);
-    assert(cached_type == NULL || PyType_Check(cached_type));
-    return (PyTypeObject *) cached_type;
-bad:
-    Py_XDECREF(cached_type);
-    cached_type = NULL;
-    goto done;
-}
-#endif
-
-/* PyVectorcallFastCallDict */
-#if CYTHON_METH_FASTCALL
-static PyObject *__Pyx_PyVectorcall_FastCallDict_kw(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    PyObject *res = NULL;
-    PyObject *kwnames;
-    PyObject **newargs;
-    PyObject **kwvalues;
-    Py_ssize_t i, pos;
-    size_t j;
-    PyObject *key, *value;
-    unsigned long keys_are_strings;
-    Py_ssize_t nkw = PyDict_GET_SIZE(kw);
-    newargs = (PyObject **)PyMem_Malloc((nargs + (size_t)nkw) * sizeof(args[0]));
-    if (unlikely(newargs == NULL)) {
-        PyErr_NoMemory();
-        return NULL;
-    }
-    for (j = 0; j < nargs; j++) newargs[j] = args[j];
-    kwnames = PyTuple_New(nkw);
-    if (unlikely(kwnames == NULL)) {
-        PyMem_Free(newargs);
-        return NULL;
-    }
-    kwvalues = newargs + nargs;
-    pos = i = 0;
-    keys_are_strings = Py_TPFLAGS_UNICODE_SUBCLASS;
-    while (PyDict_Next(kw, &pos, &key, &value)) {
-        keys_are_strings &= Py_TYPE(key)->tp_flags;
-        Py_INCREF(key);
-        Py_INCREF(value);
-        PyTuple_SET_ITEM(kwnames, i, key);
-        kwvalues[i] = value;
-        i++;
-    }
-    if (unlikely(!keys_are_strings)) {
-        PyErr_SetString(PyExc_TypeError, "keywords must be strings");
-        goto cleanup;
-    }
-    res = vc(func, newargs, nargs, kwnames);
-cleanup:
-    Py_DECREF(kwnames);
-    for (i = 0; i < nkw; i++)
-        Py_DECREF(kwvalues[i]);
-    PyMem_Free(newargs);
-    return res;
-}
-static CYTHON_INLINE PyObject *__Pyx_PyVectorcall_FastCallDict(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
-{
-    if (likely(kw == NULL) || PyDict_GET_SIZE(kw) == 0) {
-        return vc(func, args, nargs, NULL);
-    }
-    return __Pyx_PyVectorcall_FastCallDict_kw(func, vc, args, nargs, kw);
-}
-#endif
-
-/* CythonFunctionShared */
-static CYTHON_INLINE void __Pyx__CyFunction_SetClassObj(__pyx_CyFunctionObject* f, PyObject* classobj) {
-#if PY_VERSION_HEX < 0x030900B1
-    __Pyx_Py_XDECREF_SET(
-        __Pyx_CyFunction_GetClassObj(f),
-            ((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#else
-    __Pyx_Py_XDECREF_SET(
-        ((PyCMethodObject *) (f))->mm_class,
-        (PyTypeObject*)((classobj) ? __Pyx_NewRef(classobj) : NULL));
-#endif
-}
-static PyObject *
-__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, void *closure)
-{
-    CYTHON_UNUSED_VAR(closure);
-    if (unlikely(op->func_doc == NULL)) {
-        if (((PyCFunctionObject*)op)->m_ml->ml_doc) {
-#if PY_MAJOR_VERSION >= 3
-            op->func_doc = PyUnicode_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#else
-            op->func_doc = PyString_FromString(((PyCFunctionObject*)op)->m_ml->ml_doc);
-#endif
-            if (unlikely(op->func_doc == NULL))
-                return NULL;
-        } else {
-            Py_INCREF(Py_None);
-            return Py_None;
-        }
-    }
-    Py_INCREF(op->func_doc);
-    return op->func_doc;
-}
-static int
-__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (value == NULL) {
-        value = Py_None;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_doc, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_name == NULL)) {
-#if PY_MAJOR_VERSION >= 3
-        op->func_name = PyUnicode_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#else
-        op->func_name = PyString_InternFromString(((PyCFunctionObject*)op)->m_ml->ml_name);
-#endif
-        if (unlikely(op->func_name == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_name);
-    return op->func_name;
-}
-static int
-__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__name__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_name, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_qualname);
-    return op->func_qualname;
-}
-static int
-__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-#if PY_MAJOR_VERSION >= 3
-    if (unlikely(value == NULL || !PyUnicode_Check(value)))
-#else
-    if (unlikely(value == NULL || !PyString_Check(value)))
-#endif
-    {
-        PyErr_SetString(PyExc_TypeError,
-                        "__qualname__ must be set to a string object");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_qualname, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(op->func_dict == NULL)) {
-        op->func_dict = PyDict_New();
-        if (unlikely(op->func_dict == NULL))
-            return NULL;
-    }
-    Py_INCREF(op->func_dict);
-    return op->func_dict;
-}
-static int
-__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(value == NULL)) {
-        PyErr_SetString(PyExc_TypeError,
-               "function's dictionary may not be deleted");
-        return -1;
-    }
-    if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-               "setting function's dictionary to a non-dict");
-        return -1;
-    }
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_dict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(op->func_globals);
-    return op->func_globals;
-}
-static PyObject *
-__Pyx_CyFunction_get_closure(__pyx_CyFunctionObject *op, void *context)
-{
-    CYTHON_UNUSED_VAR(op);
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-static PyObject *
-__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, void *context)
-{
-    PyObject* result = (op->func_code) ? op->func_code : Py_None;
-    CYTHON_UNUSED_VAR(context);
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
-    int result = 0;
-    PyObject *res = op->defaults_getter((PyObject *) op);
-    if (unlikely(!res))
-        return -1;
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
-    Py_INCREF(op->defaults_tuple);
-    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
-    Py_INCREF(op->defaults_kwdict);
-    #else
-    op->defaults_tuple = PySequence_ITEM(res, 0);
-    if (unlikely(!op->defaults_tuple)) result = -1;
-    else {
-        op->defaults_kwdict = PySequence_ITEM(res, 1);
-        if (unlikely(!op->defaults_kwdict)) result = -1;
-    }
-    #endif
-    Py_DECREF(res);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyTuple_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__defaults__ must be set to a tuple object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__defaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_tuple, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_tuple;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_tuple;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value) {
-        value = Py_None;
-    } else if (unlikely(value != Py_None && !PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__kwdefaults__ must be set to a dict object");
-        return -1;
-    }
-    PyErr_WarnEx(PyExc_RuntimeWarning, "changes to cyfunction.__kwdefaults__ will not "
-                 "currently affect the values used in function calls", 1);
-    Py_INCREF(value);
-    __Pyx_Py_XDECREF_SET(op->defaults_kwdict, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->defaults_kwdict;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        if (op->defaults_getter) {
-            if (unlikely(__Pyx_CyFunction_init_defaults(op) < 0)) return NULL;
-            result = op->defaults_kwdict;
-        } else {
-            result = Py_None;
-        }
-    }
-    Py_INCREF(result);
-    return result;
-}
-static int
-__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, void *context) {
-    CYTHON_UNUSED_VAR(context);
-    if (!value || value == Py_None) {
-        value = NULL;
-    } else if (unlikely(!PyDict_Check(value))) {
-        PyErr_SetString(PyExc_TypeError,
-                        "__annotations__ must be set to a dict object");
-        return -1;
-    }
-    Py_XINCREF(value);
-    __Pyx_Py_XDECREF_SET(op->func_annotations, value);
-    return 0;
-}
-static PyObject *
-__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, void *context) {
-    PyObject* result = op->func_annotations;
-    CYTHON_UNUSED_VAR(context);
-    if (unlikely(!result)) {
-        result = PyDict_New();
-        if (unlikely(!result)) return NULL;
-        op->func_annotations = result;
-    }
-    Py_INCREF(result);
-    return result;
-}
-static PyObject *
-__Pyx_CyFunction_get_is_coroutine(__pyx_CyFunctionObject *op, void *context) {
-    int is_coroutine;
-    CYTHON_UNUSED_VAR(context);
-    if (op->func_is_coroutine) {
-        return __Pyx_NewRef(op->func_is_coroutine);
-    }
-    is_coroutine = op->flags & __Pyx_CYFUNCTION_COROUTINE;
-#if PY_VERSION_HEX >= 0x03050000
-    if (is_coroutine) {
-        PyObject *module, *fromlist, *marker = __pyx_n_s_is_coroutine;
-        fromlist = PyList_New(1);
-        if (unlikely(!fromlist)) return NULL;
-        Py_INCREF(marker);
-        PyList_SET_ITEM(fromlist, 0, marker);
-        module = PyImport_ImportModuleLevelObject(__pyx_n_s_asyncio_coroutines, NULL, NULL, fromlist, 0);
-        Py_DECREF(fromlist);
-        if (unlikely(!module)) goto ignore;
-        op->func_is_coroutine = __Pyx_PyObject_GetAttrStr(module, marker);
-        Py_DECREF(module);
-        if (likely(op->func_is_coroutine)) {
-            return __Pyx_NewRef(op->func_is_coroutine);
-        }
-ignore:
-        PyErr_Clear();
-    }
-#endif
-    op->func_is_coroutine = __Pyx_PyBool_FromLong(is_coroutine);
-    return __Pyx_NewRef(op->func_is_coroutine);
-}
-static PyGetSetDef __pyx_CyFunction_getsets[] = {
-    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
-    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
-    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
-    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
-    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
-    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
-    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
-    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
-    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
-    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
-    {(char *) "_is_coroutine", (getter)__Pyx_CyFunction_get_is_coroutine, 0, 0, 0},
-    {0, 0, 0, 0, 0}
-};
-static PyMemberDef __pyx_CyFunction_members[] = {
-    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), 0, 0},
-#if CYTHON_USE_TYPE_SPECS
-    {(char *) "__dictoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_dict), READONLY, 0},
-#if CYTHON_METH_FASTCALL
-#if CYTHON_BACKPORT_VECTORCALL
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_vectorcall), READONLY, 0},
-#else
-    {(char *) "__vectorcalloffset__", T_PYSSIZET, offsetof(PyCFunctionObject, vectorcall), READONLY, 0},
-#endif
-#endif
-#if PY_VERSION_HEX < 0x030500A0
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(__pyx_CyFunctionObject, func_weakreflist), READONLY, 0},
-#else
-    {(char *) "__weaklistoffset__", T_PYSSIZET, offsetof(PyCFunctionObject, m_weakreflist), READONLY, 0},
-#endif
-#endif
-    {0, 0, 0,  0, 0}
-};
-static PyObject *
-__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, PyObject *args)
-{
-    CYTHON_UNUSED_VAR(args);
-#if PY_MAJOR_VERSION >= 3
-    Py_INCREF(m->func_qualname);
-    return m->func_qualname;
-#else
-    return PyString_FromString(((PyCFunctionObject*)m)->m_ml->ml_name);
-#endif
-}
-static PyMethodDef __pyx_CyFunction_methods[] = {
-    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
-    {0, 0, 0, 0}
-};
-#if PY_VERSION_HEX < 0x030500A0
-#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
-#else
-#define __Pyx_CyFunction_weakreflist(cyfunc) (((PyCFunctionObject*)cyfunc)->m_weakreflist)
-#endif
-static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
-                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyCFunctionObject *cf = (PyCFunctionObject*) op;
-    if (unlikely(op == NULL))
-        return NULL;
-    op->flags = flags;
-    __Pyx_CyFunction_weakreflist(op) = NULL;
-    cf->m_ml = ml;
-    cf->m_self = (PyObject *) op;
-    Py_XINCREF(closure);
-    op->func_closure = closure;
-    Py_XINCREF(module);
-    cf->m_module = module;
-    op->func_dict = NULL;
-    op->func_name = NULL;
-    Py_INCREF(qualname);
-    op->func_qualname = qualname;
-    op->func_doc = NULL;
-#if PY_VERSION_HEX < 0x030900B1
-    op->func_classobj = NULL;
-#else
-    ((PyCMethodObject*)op)->mm_class = NULL;
-#endif
-    op->func_globals = globals;
-    Py_INCREF(op->func_globals);
-    Py_XINCREF(code);
-    op->func_code = code;
-    op->defaults_pyobjects = 0;
-    op->defaults_size = 0;
-    op->defaults = NULL;
-    op->defaults_tuple = NULL;
-    op->defaults_kwdict = NULL;
-    op->defaults_getter = NULL;
-    op->func_annotations = NULL;
-    op->func_is_coroutine = NULL;
-#if CYTHON_METH_FASTCALL
-    switch (ml->ml_flags & (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS | METH_METHOD)) {
-    case METH_NOARGS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_NOARGS;
-        break;
-    case METH_O:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_O;
-        break;
-    case METH_METHOD | METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD;
-        break;
-    case METH_FASTCALL | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS;
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        __Pyx_CyFunction_func_vectorcall(op) = NULL;
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        Py_DECREF(op);
-        return NULL;
-    }
-#endif
-    return (PyObject *) op;
-}
-static int
-__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
-{
-    Py_CLEAR(m->func_closure);
-    Py_CLEAR(((PyCFunctionObject*)m)->m_module);
-    Py_CLEAR(m->func_dict);
-    Py_CLEAR(m->func_name);
-    Py_CLEAR(m->func_qualname);
-    Py_CLEAR(m->func_doc);
-    Py_CLEAR(m->func_globals);
-    Py_CLEAR(m->func_code);
-#if PY_VERSION_HEX < 0x030900B1
-    Py_CLEAR(__Pyx_CyFunction_GetClassObj(m));
-#else
-    {
-        PyObject *cls = (PyObject*) ((PyCMethodObject *) (m))->mm_class;
-        ((PyCMethodObject *) (m))->mm_class = NULL;
-        Py_XDECREF(cls);
-    }
-#endif
-    Py_CLEAR(m->defaults_tuple);
-    Py_CLEAR(m->defaults_kwdict);
-    Py_CLEAR(m->func_annotations);
-    Py_CLEAR(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_XDECREF(pydefaults[i]);
-        PyObject_Free(m->defaults);
-        m->defaults = NULL;
-    }
-    return 0;
-}
-static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    if (__Pyx_CyFunction_weakreflist(m) != NULL)
-        PyObject_ClearWeakRefs((PyObject *) m);
-    __Pyx_CyFunction_clear(m);
-    __Pyx_PyHeapTypeObject_GC_Del(m);
-}
-static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
-{
-    PyObject_GC_UnTrack(m);
-    __Pyx__CyFunction_dealloc(m);
-}
-static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
-{
-    Py_VISIT(m->func_closure);
-    Py_VISIT(((PyCFunctionObject*)m)->m_module);
-    Py_VISIT(m->func_dict);
-    Py_VISIT(m->func_name);
-    Py_VISIT(m->func_qualname);
-    Py_VISIT(m->func_doc);
-    Py_VISIT(m->func_globals);
-    Py_VISIT(m->func_code);
-    Py_VISIT(__Pyx_CyFunction_GetClassObj(m));
-    Py_VISIT(m->defaults_tuple);
-    Py_VISIT(m->defaults_kwdict);
-    Py_VISIT(m->func_is_coroutine);
-    if (m->defaults) {
-        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
-        int i;
-        for (i = 0; i < m->defaults_pyobjects; i++)
-            Py_VISIT(pydefaults[i]);
-    }
-    return 0;
-}
-static PyObject*
-__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
-{
-#if PY_MAJOR_VERSION >= 3
-    return PyUnicode_FromFormat("<cyfunction %U at %p>",
-                                op->func_qualname, (void *)op);
-#else
-    return PyString_FromFormat("<cyfunction %s at %p>",
-                               PyString_AsString(op->func_qualname), (void *)op);
-#endif
-}
-static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
-    PyCFunctionObject* f = (PyCFunctionObject*)func;
-    PyCFunction meth = f->m_ml->ml_meth;
-    Py_ssize_t size;
-    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
-    case METH_VARARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0))
-            return (*meth)(self, arg);
-        break;
-    case METH_VARARGS | METH_KEYWORDS:
-        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
-    case METH_NOARGS:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 0))
-                return (*meth)(self, NULL);
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    case METH_O:
-        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
-            size = PyTuple_GET_SIZE(arg);
-            if (likely(size == 1)) {
-                PyObject *result, *arg0;
-                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-                arg0 = PyTuple_GET_ITEM(arg, 0);
-                #else
-                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
-                #endif
-                result = (*meth)(self, arg0);
-                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
-                Py_DECREF(arg0);
-                #endif
-                return result;
-            }
-            PyErr_Format(PyExc_TypeError,
-                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                f->m_ml->ml_name, size);
-            return NULL;
-        }
-        break;
-    default:
-        PyErr_SetString(PyExc_SystemError, "Bad call flags for CyFunction");
-        return NULL;
-    }
-    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
-                 f->m_ml->ml_name);
-    return NULL;
-}
-static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
-}
-static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
-    PyObject *result;
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
-#if CYTHON_METH_FASTCALL
-     __pyx_vectorcallfunc vc = __Pyx_CyFunction_func_vectorcall(cyfunc);
-    if (vc) {
-#if CYTHON_ASSUME_SAFE_MACROS
-        return __Pyx_PyVectorcall_FastCallDict(func, vc, &PyTuple_GET_ITEM(args, 0), (size_t)PyTuple_GET_SIZE(args), kw);
-#else
-        (void) &__Pyx_PyVectorcall_FastCallDict;
-        return PyVectorcall_Call(func, args, kw);
-#endif
-    }
-#endif
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        Py_ssize_t argc;
-        PyObject *new_args;
-        PyObject *self;
-        argc = PyTuple_GET_SIZE(args);
-        new_args = PyTuple_GetSlice(args, 1, argc);
-        if (unlikely(!new_args))
-            return NULL;
-        self = PyTuple_GetItem(args, 0);
-        if (unlikely(!self)) {
-            Py_DECREF(new_args);
-#if PY_MAJOR_VERSION > 2
-            PyErr_Format(PyExc_TypeError,
-                         "unbound method %.200S() needs an argument",
-                         cyfunc->func_qualname);
-#else
-            PyErr_SetString(PyExc_TypeError,
-                            "unbound method needs an argument");
-#endif
-            return NULL;
-        }
-        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
-        Py_DECREF(new_args);
-    } else {
-        result = __Pyx_CyFunction_Call(func, args, kw);
-    }
-    return result;
-}
-#if CYTHON_METH_FASTCALL
-static CYTHON_INLINE int __Pyx_CyFunction_Vectorcall_CheckArgs(__pyx_CyFunctionObject *cyfunc, Py_ssize_t nargs, PyObject *kwnames)
-{
-    int ret = 0;
-    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
-        if (unlikely(nargs < 1)) {
-            PyErr_Format(PyExc_TypeError, "%.200s() needs an argument",
-                         ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-            return -1;
-        }
-        ret = 1;
-    }
-    if (unlikely(kwnames) && unlikely(PyTuple_GET_SIZE(kwnames))) {
-        PyErr_Format(PyExc_TypeError,
-                     "%.200s() takes no keyword arguments", ((PyCFunctionObject*)cyfunc)->m_ml->ml_name);
-        return -1;
-    }
-    return ret;
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_NOARGS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 0)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, NULL);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_O(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, kwnames)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    if (unlikely(nargs != 1)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
-            def->ml_name, nargs);
-        return NULL;
-    }
-    return def->ml_meth(self, args[0]);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
-}
-static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
-{
-    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
-    PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
-    PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
-#if CYTHON_BACKPORT_VECTORCALL
-    Py_ssize_t nargs = (Py_ssize_t)nargsf;
-#else
-    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
-#endif
-    PyObject *self;
-    switch (__Pyx_CyFunction_Vectorcall_CheckArgs(cyfunc, nargs, NULL)) {
-    case 1:
-        self = args[0];
-        args += 1;
-        nargs -= 1;
-        break;
-    case 0:
-        self = ((PyCFunctionObject*)cyfunc)->m_self;
-        break;
-    default:
-        return NULL;
-    }
-    return ((__Pyx_PyCMethod)(void(*)(void))def->ml_meth)(self, cls, args, (size_t)nargs, kwnames);
-}
-#endif
-#if CYTHON_USE_TYPE_SPECS
-static PyType_Slot __pyx_CyFunctionType_slots[] = {
-    {Py_tp_dealloc, (void *)__Pyx_CyFunction_dealloc},
-    {Py_tp_repr, (void *)__Pyx_CyFunction_repr},
-    {Py_tp_call, (void *)__Pyx_CyFunction_CallAsMethod},
-    {Py_tp_traverse, (void *)__Pyx_CyFunction_traverse},
-    {Py_tp_clear, (void *)__Pyx_CyFunction_clear},
-    {Py_tp_methods, (void *)__pyx_CyFunction_methods},
-    {Py_tp_members, (void *)__pyx_CyFunction_members},
-    {Py_tp_getset, (void *)__pyx_CyFunction_getsets},
-    {Py_tp_descr_get, (void *)__Pyx_PyMethod_New},
-    {0, 0},
-};
-static PyType_Spec __pyx_CyFunctionType_spec = {
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#if (defined(_Py_TPFLAGS_HAVE_VECTORCALL) && CYTHON_METH_FASTCALL)
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    __pyx_CyFunctionType_slots
-};
-#else
-static PyTypeObject __pyx_CyFunctionType_type = {
-    PyVarObject_HEAD_INIT(0, 0)
-    __PYX_TYPE_MODULE_PREFIX "cython_function_or_method",
-    sizeof(__pyx_CyFunctionObject),
-    0,
-    (destructor) __Pyx_CyFunction_dealloc,
-#if !CYTHON_METH_FASTCALL
-    0,
-#elif CYTHON_BACKPORT_VECTORCALL
-    (printfunc)offsetof(__pyx_CyFunctionObject, func_vectorcall),
-#else
-    offsetof(PyCFunctionObject, vectorcall),
-#endif
-    0,
-    0,
-#if PY_MAJOR_VERSION < 3
-    0,
-#else
-    0,
-#endif
-    (reprfunc) __Pyx_CyFunction_repr,
-    0,
-    0,
-    0,
-    0,
-    __Pyx_CyFunction_CallAsMethod,
-    0,
-    0,
-    0,
-    0,
-#ifdef Py_TPFLAGS_METHOD_DESCRIPTOR
-    Py_TPFLAGS_METHOD_DESCRIPTOR |
-#endif
-#ifdef _Py_TPFLAGS_HAVE_VECTORCALL
-    _Py_TPFLAGS_HAVE_VECTORCALL |
-#endif
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
-    0,
-    (traverseproc) __Pyx_CyFunction_traverse,
-    (inquiry) __Pyx_CyFunction_clear,
-    0,
-#if PY_VERSION_HEX < 0x030500A0
-    offsetof(__pyx_CyFunctionObject, func_weakreflist),
-#else
-    offsetof(PyCFunctionObject, m_weakreflist),
-#endif
-    0,
-    0,
-    __pyx_CyFunction_methods,
-    __pyx_CyFunction_members,
-    __pyx_CyFunction_getsets,
-    0,
-    0,
-    __Pyx_PyMethod_New,
-    0,
-    offsetof(__pyx_CyFunctionObject, func_dict),
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-    0,
-#if PY_VERSION_HEX >= 0x030400a1
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-    0,
-#endif
-#if __PYX_NEED_TP_PRINT_SLOT
-    0,
-#endif
-#if PY_VERSION_HEX >= 0x030C0000
-    0,
-#endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
-    0,
-#endif
-};
-#endif
-static int __pyx_CyFunction_init(PyObject *module) {
-#if CYTHON_USE_TYPE_SPECS
-    __pyx_CyFunctionType = __Pyx_FetchCommonTypeFromSpec(module, &__pyx_CyFunctionType_spec, NULL);
-#else
-    CYTHON_UNUSED_VAR(module);
-    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
-#endif
-    if (unlikely(__pyx_CyFunctionType == NULL)) {
-        return -1;
-    }
-    return 0;
-}
-static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults = PyObject_Malloc(size);
-    if (unlikely(!m->defaults))
-        return PyErr_NoMemory();
-    memset(m->defaults, 0, size);
-    m->defaults_pyobjects = pyobjects;
-    m->defaults_size = size;
-    return m->defaults;
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_tuple = tuple;
-    Py_INCREF(tuple);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->defaults_kwdict = dict;
-    Py_INCREF(dict);
-}
-static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
-    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
-    m->func_annotations = dict;
-    Py_INCREF(dict);
-}
-
-/* CythonFunction */
-static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
-                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
-    PyObject *op = __Pyx_CyFunction_Init(
-        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
-        ml, flags, qualname, closure, module, globals, code
-    );
-    if (likely(op)) {
-        PyObject_GC_Track(op);
-    }
-    return op;
-}
 
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
+static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
-    CYTHON_MAYBE_UNUSED_VAR(tstate);
     if (unlikely(!__pyx_cython_runtime)) {
         return c_line;
     }
     __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
 #if CYTHON_COMPILING_IN_CPYTHON
     cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
     if (likely(cython_runtime_dict)) {
         __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
             use_cline, *cython_runtime_dict,
             __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
     } else
 #endif
     {
-      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStrNoError(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
+      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
       if (use_cline_obj) {
         use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
         Py_DECREF(use_cline_obj);
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
-        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
     else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
@@ -25236,118 +20975,84 @@
         entries[i] = entries[i-1];
     }
     entries[pos].code_line = code_line;
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
-#endif
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-#if CYTHON_COMPILING_IN_LIMITED_API
-static void __Pyx_AddTraceback(const char *funcname, int c_line,
-                               int py_line, const char *filename) {
-    if (c_line) {
-        (void) __pyx_cfilenm;
-        (void) __Pyx_CLineForTraceback(__Pyx_PyThreadState_Current, c_line);
-    }
-    _PyTraceback_Add(funcname, filename, py_line);
-}
-#else
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
-    PyCodeObject *py_code = NULL;
-    PyObject *py_funcname = NULL;
+    PyCodeObject *py_code = 0;
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
     #if PY_MAJOR_VERSION < 3
-    PyObject *py_srcfile = NULL;
     py_srcfile = PyString_FromString(filename);
-    if (!py_srcfile) goto bad;
+    #else
+    py_srcfile = PyUnicode_FromString(filename);
     #endif
+    if (!py_srcfile) goto bad;
     if (c_line) {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
         #else
         py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
-        if (!py_funcname) goto bad;
-        funcname = PyUnicode_AsUTF8(py_funcname);
-        if (!funcname) goto bad;
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
-        if (!py_funcname) goto bad;
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
         #endif
     }
-    #if PY_MAJOR_VERSION < 3
+    if (!py_funcname) goto bad;
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
-        0,
         __pyx_empty_bytes, /*PyObject *code,*/
         __pyx_empty_tuple, /*PyObject *consts,*/
         __pyx_empty_tuple, /*PyObject *names,*/
         __pyx_empty_tuple, /*PyObject *varnames,*/
         __pyx_empty_tuple, /*PyObject *freevars,*/
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
-    #else
-    py_code = PyCode_NewEmpty(filename, funcname, py_line);
-    #endif
-    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
+    Py_DECREF(py_funcname);
     return py_code;
 bad:
-    Py_XDECREF(py_funcname);
-    #if PY_MAJOR_VERSION < 3
     Py_XDECREF(py_srcfile);
-    #endif
+    Py_XDECREF(py_funcname);
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
-        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) {
-            /* If the code object creation fails, then we should clear the
-               fetched exception references and propagate the new exception */
-            Py_XDECREF(ptype);
-            Py_XDECREF(pvalue);
-            Py_XDECREF(ptraceback);
-            goto bad;
-        }
-        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
+        if (!py_code) goto bad;
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -25355,27 +21060,21 @@
     if (!py_frame) goto bad;
     __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
     PyTraceBack_Here(py_frame);
 bad:
     Py_XDECREF(py_code);
     Py_XDECREF(py_frame);
 }
-#endif
 
 #if PY_MAJOR_VERSION < 3
 static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
-    __Pyx_TypeName obj_type_name;
     if (PyObject_CheckBuffer(obj)) return PyObject_GetBuffer(obj, view, flags);
         if (__Pyx_TypeCheck(obj, __pyx_array_type)) return __pyx_array_getbuffer(obj, view, flags);
         if (__Pyx_TypeCheck(obj, __pyx_memoryview_type)) return __pyx_memoryview_getbuffer(obj, view, flags);
-    obj_type_name = __Pyx_PyType_GetName(Py_TYPE(obj));
-    PyErr_Format(PyExc_TypeError,
-                 "'" __Pyx_FMT_TYPENAME "' does not have the buffer interface",
-                 obj_type_name);
-    __Pyx_DECREF_TypeName(obj_type_name);
+    PyErr_Format(PyExc_TypeError, "'%.200s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
     return -1;
 }
 static void __Pyx_ReleaseBuffer(Py_buffer *view) {
     PyObject *obj = view->obj;
     if (!obj) return;
     if (PyObject_CheckBuffer(obj)) {
         PyBuffer_Release(view);
@@ -25442,14 +21141,27 @@
 {
     void *start1, *end1, *start2, *end2;
     __pyx_get_array_memory_extents(slice1, &start1, &end1, ndim, itemsize);
     __pyx_get_array_memory_extents(slice2, &start2, &end2, ndim, itemsize);
     return (start1 < end2) && (start2 < end1);
 }
 
+/* Capsule */
+static CYTHON_INLINE PyObject *
+__pyx_capsule_create(void *p, CYTHON_UNUSED const char *sig)
+{
+    PyObject *cobj;
+#if PY_VERSION_HEX >= 0x02070000
+    cobj = PyCapsule_New(p, sig, NULL);
+#else
+    cobj = PyCObject_FromVoidPtr(p, NULL);
+#endif
+    return cobj;
+}
+
 /* IsLittleEndian */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
 {
   union {
     uint32_t u32;
     uint8_t u8[4];
   } S;
@@ -25529,15 +21241,15 @@
     case 'd': return (is_complex ? "'complex double'" : "'double'");
     case 'g': return (is_complex ? "'complex long double'" : "'long double'");
     case 'T': return "a struct";
     case 'O': return "Python object";
     case 'P': return "a pointer";
     case 's': case 'p': return "a string";
     case 0: return "end";
-    default: return "unparsable format string";
+    default: return "unparseable format string";
   }
 }
 static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return 2;
     case 'i': case 'I': case 'l': case 'L': return 4;
@@ -25579,16 +21291,15 @@
 typedef struct { char c; float x; } __Pyx_st_float;
 typedef struct { char c; double x; } __Pyx_st_double;
 typedef struct { char c; long double x; } __Pyx_st_longdouble;
 typedef struct { char c; void *x; } __Pyx_st_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, CYTHON_UNUSED int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
@@ -25612,16 +21323,15 @@
 typedef struct { float x; char c; } __Pyx_pad_float;
 typedef struct { double x; char c; } __Pyx_pad_double;
 typedef struct { long double x; char c; } __Pyx_pad_longdouble;
 typedef struct { void *x; char c; } __Pyx_pad_void_p;
 #ifdef HAVE_LONG_LONG
 typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
 #endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
+static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, CYTHON_UNUSED int is_complex) {
   switch (ch) {
     case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
     case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
     case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
     case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
 #ifdef HAVE_LONG_LONG
     case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
@@ -26053,17 +21763,16 @@
         }
     }
     return 1;
 fail:
     return 0;
 }
 static int
-__pyx_check_suboffsets(Py_buffer *buf, int dim, int ndim, int spec)
+__pyx_check_suboffsets(Py_buffer *buf, int dim, CYTHON_UNUSED int ndim, int spec)
 {
-    CYTHON_UNUSED_VAR(ndim);
     if (spec & __Pyx_MEMVIEW_DIRECT) {
         if (unlikely(buf->suboffsets && buf->suboffsets[dim] >= 0)) {
             PyErr_Format(PyExc_ValueError,
                          "Buffer not compatible with direct access "
                          "in dimension %d.", dim);
             goto fail;
         }
@@ -26181,39 +21890,80 @@
     retval = -1;
 no_fail:
     __Pyx_RefNannyFinishContext();
     return retval;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_char__const__(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_long(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
     int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
     retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
                                                  (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_unsigned_char__const__, stack,
+                                                 &__Pyx_TypeInfo_unsigned_long, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
-/* MemviewDtypeToObject */
-  static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_char__const__(const char *itemp) {
-    return (PyObject *) __Pyx_PyInt_From_unsigned_char(*(unsigned char const  *) itemp);
+/* ObjectToMemviewSlice */
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_int(PyObject *obj, int writable_flag) {
+    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
+    __Pyx_BufFmt_StackElem stack[1];
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
+    int retcode;
+    if (obj == Py_None) {
+        result.memview = (struct __pyx_memoryview_obj *) Py_None;
+        return result;
+    }
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
+                                                 &__Pyx_TypeInfo_unsigned_int, stack,
+                                                 &result, obj);
+    if (unlikely(retcode == -1))
+        goto __pyx_fail;
+    return result;
+__pyx_fail:
+    result.memview = NULL;
+    result.data = NULL;
+    return result;
+}
+
+/* ObjectToMemviewSlice */
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_unsigned_PY_LONG_LONG(PyObject *obj, int writable_flag) {
+    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
+    __Pyx_BufFmt_StackElem stack[1];
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
+    int retcode;
+    if (obj == Py_None) {
+        result.memview = (struct __pyx_memoryview_obj *) Py_None;
+        return result;
+    }
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
+                                                 &__Pyx_TypeInfo_unsigned_PY_LONG_LONG, stack,
+                                                 &result, obj);
+    if (unlikely(retcode == -1))
+        goto __pyx_fail;
+    return result;
+__pyx_fail:
+    result.memview = NULL;
+    result.data = NULL;
+    return result;
 }
 
 /* CIntFromPyVerify */
   #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
 #define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
@@ -26230,14 +21980,26 @@
                 else\
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
+/* MemviewDtypeToObject */
+  static CYTHON_INLINE PyObject *__pyx_memview_get_unsigned_long(const char *itemp) {
+    return (PyObject *) __Pyx_PyInt_From_unsigned_long(*(unsigned long *) itemp);
+}
+static CYTHON_INLINE int __pyx_memview_set_unsigned_long(const char *itemp, PyObject *obj) {
+    unsigned long value = __Pyx_PyInt_As_unsigned_long(obj);
+    if ((value == (unsigned long)-1) && PyErr_Occurred())
+        return 0;
+    *(unsigned long *) itemp = value;
+    return 1;
+}
+
 /* MemviewSliceCopyTemplate */
   static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object)
 {
@@ -26297,843 +22059,516 @@
     __Pyx_XDECREF(shape_tuple);
     __Pyx_XDECREF(temp_int);
     __Pyx_XDECREF(array_obj);
     __Pyx_RefNannyFinishContext();
     return new_mvs;
 }
 
-/* MemviewSliceInit */
-  static int
-__Pyx_init_memviewslice(struct __pyx_memoryview_obj *memview,
-                        int ndim,
-                        __Pyx_memviewslice *memviewslice,
-                        int memview_is_new_reference)
-{
-    __Pyx_RefNannyDeclarations
-    int i, retval=-1;
-    Py_buffer *buf = &memview->view;
-    __Pyx_RefNannySetupContext("init_memviewslice", 0);
-    if (unlikely(memviewslice->memview || memviewslice->data)) {
-        PyErr_SetString(PyExc_ValueError,
-            "memviewslice is already initialized!");
-        goto fail;
-    }
-    if (buf->strides) {
-        for (i = 0; i < ndim; i++) {
-            memviewslice->strides[i] = buf->strides[i];
-        }
-    } else {
-        Py_ssize_t stride = buf->itemsize;
-        for (i = ndim - 1; i >= 0; i--) {
-            memviewslice->strides[i] = stride;
-            stride *= buf->shape[i];
-        }
-    }
-    for (i = 0; i < ndim; i++) {
-        memviewslice->shape[i]   = buf->shape[i];
-        if (buf->suboffsets) {
-            memviewslice->suboffsets[i] = buf->suboffsets[i];
-        } else {
-            memviewslice->suboffsets[i] = -1;
-        }
-    }
-    memviewslice->memview = memview;
-    memviewslice->data = (char *)buf->buf;
-    if (__pyx_add_acquisition_count(memview) == 0 && !memview_is_new_reference) {
-        Py_INCREF(memview);
-    }
-    retval = 0;
-    goto no_fail;
-fail:
-    memviewslice->memview = 0;
-    memviewslice->data = 0;
-    retval = -1;
-no_fail:
-    __Pyx_RefNannyFinishContext();
-    return retval;
-}
-#ifndef Py_NO_RETURN
-#define Py_NO_RETURN
-#endif
-static void __pyx_fatalerror(const char *fmt, ...) Py_NO_RETURN {
-    va_list vargs;
-    char msg[200];
-#if PY_VERSION_HEX >= 0x030A0000 || defined(HAVE_STDARG_PROTOTYPES)
-    va_start(vargs, fmt);
-#else
-    va_start(vargs);
-#endif
-    vsnprintf(msg, 200, fmt, vargs);
-    va_end(vargs);
-    Py_FatalError(msg);
-}
-static CYTHON_INLINE int
-__pyx_add_acquisition_count_locked(__pyx_atomic_int_type *acquisition_count,
-                                   PyThread_type_lock lock)
-{
-    int result;
-    PyThread_acquire_lock(lock, 1);
-    result = (*acquisition_count)++;
-    PyThread_release_lock(lock);
-    return result;
-}
-static CYTHON_INLINE int
-__pyx_sub_acquisition_count_locked(__pyx_atomic_int_type *acquisition_count,
-                                   PyThread_type_lock lock)
-{
-    int result;
-    PyThread_acquire_lock(lock, 1);
-    result = (*acquisition_count)--;
-    PyThread_release_lock(lock);
-    return result;
-}
-static CYTHON_INLINE void
-__Pyx_INC_MEMVIEW(__Pyx_memviewslice *memslice, int have_gil, int lineno)
-{
-    __pyx_nonatomic_int_type old_acquisition_count;
-    struct __pyx_memoryview_obj *memview = memslice->memview;
-    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
-        return;
-    }
-    old_acquisition_count = __pyx_add_acquisition_count(memview);
-    if (unlikely(old_acquisition_count <= 0)) {
-        if (likely(old_acquisition_count == 0)) {
-            if (have_gil) {
-                Py_INCREF((PyObject *) memview);
-            } else {
-                PyGILState_STATE _gilstate = PyGILState_Ensure();
-                Py_INCREF((PyObject *) memview);
-                PyGILState_Release(_gilstate);
-            }
-        } else {
-            __pyx_fatalerror("Acquisition count is %d (line %d)",
-                             old_acquisition_count+1, lineno);
-        }
-    }
-}
-static CYTHON_INLINE void __Pyx_XCLEAR_MEMVIEW(__Pyx_memviewslice *memslice,
-                                             int have_gil, int lineno) {
-    __pyx_nonatomic_int_type old_acquisition_count;
-    struct __pyx_memoryview_obj *memview = memslice->memview;
-    if (unlikely(!memview || (PyObject *) memview == Py_None)) {
-        memslice->memview = NULL;
-        return;
-    }
-    old_acquisition_count = __pyx_sub_acquisition_count(memview);
-    memslice->data = NULL;
-    if (likely(old_acquisition_count > 1)) {
-        memslice->memview = NULL;
-    } else if (likely(old_acquisition_count == 1)) {
-        if (have_gil) {
-            Py_CLEAR(memslice->memview);
-        } else {
-            PyGILState_STATE _gilstate = PyGILState_Ensure();
-            Py_CLEAR(memslice->memview);
-            PyGILState_Release(_gilstate);
-        }
-    } else {
-        __pyx_fatalerror("Acquisition count is %d (line %d)",
-                         old_acquisition_count-1, lineno);
-    }
-}
-
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_long(unsigned long value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned char neg_one = (unsigned char) -1, const_zero = (unsigned char) 0;
+    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned char) < sizeof(long)) {
+        if (sizeof(unsigned long) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned char) <= sizeof(unsigned long)) {
+        } else if (sizeof(unsigned long) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned char) <= sizeof(long)) {
+        if (sizeof(unsigned long) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned char) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(unsigned long) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned char),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(long),
+        return _PyLong_FromByteArray(bytes, sizeof(unsigned long),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
-  static CYTHON_INLINE unsigned short __Pyx_PyInt_As_unsigned_short(PyObject *x) {
+  static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned short neg_one = (unsigned short) -1, const_zero = (unsigned short) 0;
+    const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(unsigned short) < sizeof(long))) {
-            __PYX_VERIFY_RETURN_INT(unsigned short, long, PyInt_AS_LONG(x))
+        if (sizeof(unsigned long) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(unsigned long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (unsigned short) val;
+            return (unsigned long) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned short, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(unsigned short) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) >= 2 * PyLong_SHIFT)) {
-                                return (unsigned short) (((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned long) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned long, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(unsigned long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) >= 2 * PyLong_SHIFT) {
+                            return (unsigned long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned short) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) >= 3 * PyLong_SHIFT)) {
-                                return (unsigned short) (((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) >= 3 * PyLong_SHIFT) {
+                            return (unsigned long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned short) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) >= 4 * PyLong_SHIFT)) {
-                                return (unsigned short) (((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) >= 4 * PyLong_SHIFT) {
+                            return (unsigned long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (unsigned short) -1;
+                    return (unsigned long) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(unsigned short) <= sizeof(unsigned long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, unsigned long, PyLong_AsUnsignedLong(x))
+            if (sizeof(unsigned long) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned short) <= sizeof(unsigned PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if (sizeof(unsigned long) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned short, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(unsigned short) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned short) (((unsigned short)-1)*(((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned long) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(unsigned long, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned long,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(unsigned long) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned long) (((unsigned long)-1)*(((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(unsigned short) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned short) ((((((unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(unsigned long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned long) ((((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(unsigned short) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned short) (((unsigned short)-1)*(((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(unsigned long) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned long) (((unsigned long)-1)*(((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned short) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned short) ((((((((unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned long) ((((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(unsigned short) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned short) (((unsigned short)-1)*(((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(unsigned long) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned long) (((unsigned long)-1)*(((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned short) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned short, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned short) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned short) ((((((((((unsigned short)digits[3]) << PyLong_SHIFT) | (unsigned short)digits[2]) << PyLong_SHIFT) | (unsigned short)digits[1]) << PyLong_SHIFT) | (unsigned short)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned long) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned long) ((((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(unsigned short) <= sizeof(long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, long, PyLong_AsLong(x))
+            if (sizeof(unsigned long) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned short) <= sizeof(PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned short, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if (sizeof(unsigned long) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned long, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-            unsigned short val;
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            unsigned long val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (unsigned short) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (unsigned short) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (unsigned short) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (unsigned short) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (unsigned short) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(unsigned short) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((unsigned short) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(unsigned short) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((unsigned short) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((unsigned short) 1) << (sizeof(unsigned short) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-            return (unsigned short) -1;
+#endif
+            return (unsigned long) -1;
         }
     } else {
-        unsigned short val;
+        unsigned long val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned short) -1;
-        val = __Pyx_PyInt_As_unsigned_short(tmp);
+        if (!tmp) return (unsigned long) -1;
+        val = __Pyx_PyInt_As_unsigned_long(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned short");
-    return (unsigned short) -1;
+        "value too large to convert to unsigned long");
+    return (unsigned long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned short");
-    return (unsigned short) -1;
+        "can't convert negative value to unsigned long");
+    return (unsigned long) -1;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_short(unsigned short value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_int(unsigned int value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned short neg_one = (unsigned short) -1, const_zero = (unsigned short) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(unsigned short) < sizeof(long)) {
+        if (sizeof(unsigned int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(unsigned short) <= sizeof(unsigned long)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned short) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(unsigned short) <= sizeof(long)) {
+        if (sizeof(unsigned int) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(unsigned short) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(unsigned short),
+        return _PyLong_FromByteArray(bytes, sizeof(unsigned int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
-  static CYTHON_INLINE unsigned char __Pyx_PyInt_As_unsigned_char(PyObject *x) {
+  static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const unsigned char neg_one = (unsigned char) -1, const_zero = (unsigned char) 0;
+    const unsigned int neg_one = (unsigned int) -1, const_zero = (unsigned int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(unsigned char) < sizeof(long))) {
-            __PYX_VERIFY_RETURN_INT(unsigned char, long, PyInt_AS_LONG(x))
+        if (sizeof(unsigned int) < sizeof(long)) {
+            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
-            return (unsigned char) val;
+            return (unsigned int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned char, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(unsigned char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) >= 2 * PyLong_SHIFT)) {
-                                return (unsigned char) (((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) >= 3 * PyLong_SHIFT)) {
-                                return (unsigned char) (((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) >= 4 * PyLong_SHIFT)) {
-                                return (unsigned char) (((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
-                    return (unsigned char) -1;
+                    return (unsigned int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(unsigned char) <= sizeof(unsigned long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned long, PyLong_AsUnsignedLong(x))
+            if (sizeof(unsigned int) <= sizeof(unsigned long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(unsigned char, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(unsigned char) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned char) (((unsigned char)-1)*(((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (unsigned int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(unsigned int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(unsigned int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(unsigned char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (unsigned char) ((((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned char) (((unsigned char)-1)*(((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(unsigned char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (unsigned char) ((((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned char) (((unsigned char)-1)*(((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(unsigned char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (unsigned char) ((((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
+                            return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(unsigned char) <= sizeof(long))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, long, PyLong_AsLong(x))
+            if (sizeof(unsigned int) <= sizeof(long)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(unsigned char) <= sizeof(PY_LONG_LONG))) {
-                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, PY_LONG_LONG, PyLong_AsLongLong(x))
+            } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
+                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
-            unsigned char val;
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
+            unsigned int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (unsigned char) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (unsigned char) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (unsigned char) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (unsigned char) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (unsigned char) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(unsigned char) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((unsigned char) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(unsigned char) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((unsigned char) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((unsigned char) 1) << (sizeof(unsigned char) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
-            return (unsigned char) -1;
+#endif
+            return (unsigned int) -1;
         }
     } else {
-        unsigned char val;
+        unsigned int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
-        if (!tmp) return (unsigned char) -1;
-        val = __Pyx_PyInt_As_unsigned_char(tmp);
+        if (!tmp) return (unsigned int) -1;
+        val = __Pyx_PyInt_As_unsigned_int(tmp);
         Py_DECREF(tmp);
         return val;
     }
 raise_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "value too large to convert to unsigned char");
-    return (unsigned char) -1;
+        "value too large to convert to unsigned int");
+    return (unsigned int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
-        "can't convert negative value to unsigned char");
-    return (unsigned char) -1;
+        "can't convert negative value to unsigned int");
+    return (unsigned int) -1;
 }
 
 /* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value) {
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_PY_LONG_LONG(unsigned PY_LONG_LONG value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
-    const char neg_one = (char) -1, const_zero = (char) 0;
+    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG) -1, const_zero = (unsigned PY_LONG_LONG) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
-        if (sizeof(char) < sizeof(long)) {
+        if (sizeof(unsigned PY_LONG_LONG) < sizeof(long)) {
             return PyInt_FromLong((long) value);
-        } else if (sizeof(char) <= sizeof(unsigned long)) {
+        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(char) <= sizeof(unsigned PY_LONG_LONG)) {
+        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
             return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
 #endif
         }
     } else {
-        if (sizeof(char) <= sizeof(long)) {
+        if (sizeof(unsigned PY_LONG_LONG) <= sizeof(long)) {
             return PyInt_FromLong((long) value);
 #ifdef HAVE_LONG_LONG
-        } else if (sizeof(char) <= sizeof(PY_LONG_LONG)) {
+        } else if (sizeof(unsigned PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
             return PyLong_FromLongLong((PY_LONG_LONG) value);
 #endif
         }
     }
     {
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(char),
+        return _PyLong_FromByteArray(bytes, sizeof(unsigned PY_LONG_LONG),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
   static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
@@ -27143,254 +22578,177 @@
     const int neg_one = (int) -1, const_zero = (int) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(int) < sizeof(long))) {
+        if (sizeof(int) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (int) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 2 * PyLong_SHIFT)) {
-                                return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
+                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 3 * PyLong_SHIFT)) {
-                                return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
+                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) >= 4 * PyLong_SHIFT)) {
-                                return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
+                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (int) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(int) <= sizeof(unsigned long))) {
+            if (sizeof(int) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(int, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(int) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (int) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(int) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                                return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(int) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(int) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                                return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(int) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(int) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(int) - 1 > 4 * PyLong_SHIFT)) {
-                                return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
+                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(int) <= sizeof(long))) {
+            if (sizeof(int) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(int) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             int val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (int) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (int) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (int) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (int) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (int) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(int) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((int) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(int) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((int) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((int) 1) << (sizeof(int) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (int) -1;
         }
     } else {
         int val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (int) -1;
         val = __Pyx_PyInt_As_int(tmp);
@@ -27416,254 +22774,177 @@
     const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(long) < sizeof(long))) {
+        if (sizeof(long) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (long) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 2 * PyLong_SHIFT)) {
-                                return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
+                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 3 * PyLong_SHIFT)) {
-                                return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
+                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) >= 4 * PyLong_SHIFT)) {
-                                return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
+                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (long) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(long) <= sizeof(unsigned long))) {
+            if (sizeof(long) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(long, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(long) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (long) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(long) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                                return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(long) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(long) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                                return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(long) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(long) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(long) - 1 > 4 * PyLong_SHIFT)) {
-                                return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
+                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(long) <= sizeof(long))) {
+            if (sizeof(long) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(long) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             long val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (long) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (long) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (long) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (long) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (long) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(long) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((long) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(long) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((long) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((long) 1) << (sizeof(long) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (long) -1;
         }
     } else {
         long val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (long) -1;
         val = __Pyx_PyInt_As_long(tmp);
@@ -27714,267 +22995,228 @@
         int one = 1; int little = (int)*(unsigned char *)&one;
         unsigned char *bytes = (unsigned char *)&value;
         return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
     }
 }
 
+/* CIntToPy */
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const long neg_one = (long) -1, const_zero = (long) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(long) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(long) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+        return _PyLong_FromByteArray(bytes, sizeof(long),
+                                     little, !is_unsigned);
+    }
+}
+
 /* CIntFromPy */
   static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const char neg_one = (char) -1, const_zero = (char) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic pop
 #endif
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
-        if ((sizeof(char) < sizeof(long))) {
+        if (sizeof(char) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(char, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
             if (is_unsigned && unlikely(val < 0)) {
                 goto raise_neg_overflow;
             }
             return (char) val;
         }
     } else
 #endif
     if (likely(PyLong_Check(x))) {
         if (is_unsigned) {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (unlikely(__Pyx_PyLong_IsNeg(x))) {
-                goto raise_neg_overflow;
-            } else if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(char, __Pyx_compact_upylong, __Pyx_PyLong_CompactValueUnsigned(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_DigitCount(x)) {
-                    case 2:
-                        if ((8 * sizeof(char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 2 * PyLong_SHIFT)) {
-                                return (char) (((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (char) 0;
+                case  1: __PYX_VERIFY_RETURN_INT(char, digit, digits[0])
+                case 2:
+                    if (8 * sizeof(char) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 2 * PyLong_SHIFT) {
+                            return (char) (((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 3 * PyLong_SHIFT)) {
-                                return (char) (((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(char) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 3 * PyLong_SHIFT) {
+                            return (char) (((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) >= 4 * PyLong_SHIFT)) {
-                                return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(char) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) >= 4 * PyLong_SHIFT) {
+                            return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
+#if CYTHON_COMPILING_IN_CPYTHON
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
                     return (char) -1;
                 if (unlikely(result == 1))
                     goto raise_neg_overflow;
             }
 #endif
-            if ((sizeof(char) <= sizeof(unsigned long))) {
+            if (sizeof(char) <= sizeof(unsigned long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, unsigned long, PyLong_AsUnsignedLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(char) <= sizeof(unsigned PY_LONG_LONG))) {
+            } else if (sizeof(char) <= sizeof(unsigned PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
 #endif
             }
         } else {
 #if CYTHON_USE_PYLONG_INTERNALS
-            if (__Pyx_PyLong_IsCompact(x)) {
-                __PYX_VERIFY_RETURN_INT(char, __Pyx_compact_pylong, __Pyx_PyLong_CompactValue(x))
-            } else {
-                const digit* digits = __Pyx_PyLong_Digits(x);
-                assert(__Pyx_PyLong_DigitCount(x) > 1);
-                switch (__Pyx_PyLong_SignedDigitCount(x)) {
-                    case -2:
-                        if ((8 * sizeof(char) - 1 > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+            const digit* digits = ((PyLongObject*)x)->ob_digit;
+            switch (Py_SIZE(x)) {
+                case  0: return (char) 0;
+                case -1: __PYX_VERIFY_RETURN_INT(char, sdigit, (sdigit) (-(sdigit)digits[0]))
+                case  1: __PYX_VERIFY_RETURN_INT(char,  digit, +digits[0])
+                case -2:
+                    if (8 * sizeof(char) - 1 > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 2:
-                        if ((8 * sizeof(char) > 1 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 2 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                                return (char) ((((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 2:
+                    if (8 * sizeof(char) > 1 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                            return (char) ((((((char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case -3:
-                        if ((8 * sizeof(char) - 1 > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case -3:
+                    if (8 * sizeof(char) - 1 > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 3:
-                        if ((8 * sizeof(char) > 2 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 3 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                                return (char) ((((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 3:
+                    if (8 * sizeof(char) > 2 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                            return (char) ((((((((char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case -4:
-                        if ((8 * sizeof(char) - 1 > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (char) (((char)-1)*(((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case -4:
+                    if (8 * sizeof(char) - 1 > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 4 * PyLong_SHIFT) {
+                            return (char) (((char)-1)*(((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                    case 4:
-                        if ((8 * sizeof(char) > 3 * PyLong_SHIFT)) {
-                            if ((8 * sizeof(unsigned long) > 4 * PyLong_SHIFT)) {
-                                __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
-                            } else if ((8 * sizeof(char) - 1 > 4 * PyLong_SHIFT)) {
-                                return (char) ((((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
-                            }
+                    }
+                    break;
+                case 4:
+                    if (8 * sizeof(char) > 3 * PyLong_SHIFT) {
+                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
+                            __PYX_VERIFY_RETURN_INT(char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
+                        } else if (8 * sizeof(char) - 1 > 4 * PyLong_SHIFT) {
+                            return (char) ((((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0])));
                         }
-                        break;
-                }
+                    }
+                    break;
             }
 #endif
-            if ((sizeof(char) <= sizeof(long))) {
+            if (sizeof(char) <= sizeof(long)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, long, PyLong_AsLong(x))
 #ifdef HAVE_LONG_LONG
-            } else if ((sizeof(char) <= sizeof(PY_LONG_LONG))) {
+            } else if (sizeof(char) <= sizeof(PY_LONG_LONG)) {
                 __PYX_VERIFY_RETURN_INT_EXC(char, PY_LONG_LONG, PyLong_AsLongLong(x))
 #endif
             }
         }
         {
+#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
+            PyErr_SetString(PyExc_RuntimeError,
+                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
+#else
             char val;
             PyObject *v = __Pyx_PyNumber_IntOrLong(x);
-#if PY_MAJOR_VERSION < 3
+ #if PY_MAJOR_VERSION < 3
             if (likely(v) && !PyLong_Check(v)) {
                 PyObject *tmp = v;
                 v = PyNumber_Long(tmp);
                 Py_DECREF(tmp);
             }
-#endif
+ #endif
             if (likely(v)) {
-                int ret = -1;
-#if !(CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_LIMITED_API) || defined(_PyLong_AsByteArray)
                 int one = 1; int is_little = (int)*(unsigned char *)&one;
                 unsigned char *bytes = (unsigned char *)&val;
-                ret = _PyLong_AsByteArray((PyLongObject *)v,
-                                           bytes, sizeof(val),
-                                           is_little, !is_unsigned);
-#else
-                PyObject *stepval = NULL, *mask = NULL, *shift = NULL;
-                int bits, remaining_bits, is_negative = 0;
-                long idigit;
-                int chunk_size = (sizeof(long) < 8) ? 30 : 62;
-                if (unlikely(!PyLong_CheckExact(v))) {
-                    PyObject *tmp = v;
-                    v = PyNumber_Long(v);
-                    assert(PyLong_CheckExact(v));
-                    Py_DECREF(tmp);
-                    if (unlikely(!v)) return (char) -1;
-                }
-#if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                if (Py_SIZE(x) == 0)
-                    return (char) 0;
-                is_negative = Py_SIZE(x) < 0;
-#else
-                {
-                    int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
-                    if (unlikely(result < 0))
-                        return (char) -1;
-                    is_negative = result == 1;
-                }
-#endif
-                if (is_unsigned && unlikely(is_negative)) {
-                    goto raise_neg_overflow;
-                } else if (is_negative) {
-                    stepval = PyNumber_Invert(v);
-                    if (unlikely(!stepval))
-                        return (char) -1;
-                } else {
-                    stepval = __Pyx_NewRef(v);
-                }
-                val = (char) 0;
-                mask = PyLong_FromLong((1L << chunk_size) - 1); if (unlikely(!mask)) goto done;
-                shift = PyLong_FromLong(chunk_size); if (unlikely(!shift)) goto done;
-                for (bits = 0; bits < (int) sizeof(char) * 8 - chunk_size; bits += chunk_size) {
-                    PyObject *tmp, *digit;
-                    digit = PyNumber_And(stepval, mask);
-                    if (unlikely(!digit)) goto done;
-                    idigit = PyLong_AsLong(digit);
-                    Py_DECREF(digit);
-                    if (unlikely(idigit < 0)) goto done;
-                    tmp = PyNumber_Rshift(stepval, shift);
-                    if (unlikely(!tmp)) goto done;
-                    Py_DECREF(stepval); stepval = tmp;
-                    val |= ((char) idigit) << bits;
-                    #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-                    if (Py_SIZE(stepval) == 0)
-                        goto unpacking_done;
-                    #endif
-                }
-                idigit = PyLong_AsLong(stepval);
-                if (unlikely(idigit < 0)) goto done;
-                remaining_bits = ((int) sizeof(char) * 8) - bits - (is_unsigned ? 0 : 1);
-                if (unlikely(idigit >= (1L << remaining_bits)))
-                    goto raise_overflow;
-                val |= ((char) idigit) << bits;
-            #if CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030B0000
-            unpacking_done:
-            #endif
-                if (!is_unsigned) {
-                    if (unlikely(val & (((char) 1) << (sizeof(char) * 8 - 1))))
-                        goto raise_overflow;
-                    if (is_negative)
-                        val = ~val;
-                }
-                ret = 0;
-            done:
-                Py_XDECREF(shift);
-                Py_XDECREF(mask);
-                Py_XDECREF(stepval);
-#endif
+                int ret = _PyLong_AsByteArray((PyLongObject *)v,
+                                              bytes, sizeof(val),
+                                              is_little, !is_unsigned);
                 Py_DECREF(v);
                 if (likely(!ret))
                     return val;
             }
+#endif
             return (char) -1;
         }
     } else {
         char val;
         PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
         if (!tmp) return (char) -1;
         val = __Pyx_PyInt_As_char(tmp);
@@ -27987,105 +23229,1192 @@
     return (char) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to char");
     return (char) -1;
 }
 
-/* FormatTypeName */
-  #if CYTHON_COMPILING_IN_LIMITED_API
-static __Pyx_TypeName
-__Pyx_PyType_GetName(PyTypeObject* tp)
-{
-    PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
-                                               __pyx_n_s_name_2);
-    if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
+/* FetchCommonType */
+  static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
+    PyObject* fake_module;
+    PyTypeObject* cached_type = NULL;
+    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
+    if (!fake_module) return NULL;
+    Py_INCREF(fake_module);
+    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
+    if (cached_type) {
+        if (!PyType_Check((PyObject*)cached_type)) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s is not a type object",
+                type->tp_name);
+            goto bad;
+        }
+        if (cached_type->tp_basicsize != type->tp_basicsize) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s has the wrong size, try recompiling",
+                type->tp_name);
+            goto bad;
+        }
+    } else {
+        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
         PyErr_Clear();
-        Py_XSETREF(name, __Pyx_NewRef(__pyx_n_s__23));
+        if (PyType_Ready(type) < 0) goto bad;
+        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
+            goto bad;
+        Py_INCREF(type);
+        cached_type = type;
     }
-    return name;
+done:
+    Py_DECREF(fake_module);
+    return cached_type;
+bad:
+    Py_XDECREF(cached_type);
+    cached_type = NULL;
+    goto done;
 }
+
+/* PyObjectGetMethod */
+  static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
+    PyObject *attr;
+#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
+    PyTypeObject *tp = Py_TYPE(obj);
+    PyObject *descr;
+    descrgetfunc f = NULL;
+    PyObject **dictptr, *dict;
+    int meth_found = 0;
+    assert (*method == NULL);
+    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
+        attr = __Pyx_PyObject_GetAttrStr(obj, name);
+        goto try_unpack;
+    }
+    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
+        return 0;
+    }
+    descr = _PyType_Lookup(tp, name);
+    if (likely(descr != NULL)) {
+        Py_INCREF(descr);
+#if PY_MAJOR_VERSION >= 3
+        #ifdef __Pyx_CyFunction_USED
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
+        #else
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
+        #endif
+#else
+        #ifdef __Pyx_CyFunction_USED
+        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
+        #else
+        if (likely(PyFunction_Check(descr)))
+        #endif
+#endif
+        {
+            meth_found = 1;
+        } else {
+            f = Py_TYPE(descr)->tp_descr_get;
+            if (f != NULL && PyDescr_IsData(descr)) {
+                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
+                Py_DECREF(descr);
+                goto try_unpack;
+            }
+        }
+    }
+    dictptr = _PyObject_GetDictPtr(obj);
+    if (dictptr != NULL && (dict = *dictptr) != NULL) {
+        Py_INCREF(dict);
+        attr = __Pyx_PyDict_GetItemStr(dict, name);
+        if (attr != NULL) {
+            Py_INCREF(attr);
+            Py_DECREF(dict);
+            Py_XDECREF(descr);
+            goto try_unpack;
+        }
+        Py_DECREF(dict);
+    }
+    if (meth_found) {
+        *method = descr;
+        return 1;
+    }
+    if (f != NULL) {
+        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
+        Py_DECREF(descr);
+        goto try_unpack;
+    }
+    if (descr != NULL) {
+        *method = descr;
+        return 0;
+    }
+    PyErr_Format(PyExc_AttributeError,
+#if PY_MAJOR_VERSION >= 3
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, name);
+#else
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(name));
+#endif
+    return 0;
+#else
+    attr = __Pyx_PyObject_GetAttrStr(obj, name);
+    goto try_unpack;
 #endif
+try_unpack:
+#if CYTHON_UNPACK_METHODS
+    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
+        PyObject *function = PyMethod_GET_FUNCTION(attr);
+        Py_INCREF(function);
+        Py_DECREF(attr);
+        *method = function;
+        return 1;
+    }
+#endif
+    *method = attr;
+    return 0;
+}
 
-/* CheckBinaryVersion */
-  static int __Pyx_check_binary_version(void) {
-    char ctversion[5];
-    int same=1, i, found_dot;
-    const char* rt_from_call = Py_GetVersion();
-    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    found_dot = 0;
-    for (i = 0; i < 4; i++) {
-        if (!ctversion[i]) {
-            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
-            break;
-        }
-        if (rt_from_call[i] != ctversion[i]) {
-            same = 0;
-            break;
+/* PyObjectCallMethod1 */
+  static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
+    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
+    Py_DECREF(method);
+    return result;
+}
+static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
+    PyObject *method = NULL, *result;
+    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
+    if (likely(is_method)) {
+        result = __Pyx_PyObject_Call2Args(method, obj, arg);
+        Py_DECREF(method);
+        return result;
+    }
+    if (unlikely(!method)) return NULL;
+    return __Pyx__PyObject_CallMethod1(method, arg);
+}
+
+/* CoroutineBase */
+  #include <structmember.h>
+#include <frameobject.h>
+#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
+static int __Pyx_PyGen__FetchStopIterationValue(CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject **pvalue) {
+    PyObject *et, *ev, *tb;
+    PyObject *value = NULL;
+    __Pyx_ErrFetch(&et, &ev, &tb);
+    if (!et) {
+        Py_XDECREF(tb);
+        Py_XDECREF(ev);
+        Py_INCREF(Py_None);
+        *pvalue = Py_None;
+        return 0;
+    }
+    if (likely(et == PyExc_StopIteration)) {
+        if (!ev) {
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+#if PY_VERSION_HEX >= 0x030300A0
+        else if (Py_TYPE(ev) == (PyTypeObject*)PyExc_StopIteration) {
+            value = ((PyStopIterationObject *)ev)->value;
+            Py_INCREF(value);
+            Py_DECREF(ev);
+        }
+#endif
+        else if (unlikely(PyTuple_Check(ev))) {
+            if (PyTuple_GET_SIZE(ev) >= 1) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+                value = PyTuple_GET_ITEM(ev, 0);
+                Py_INCREF(value);
+#else
+                value = PySequence_ITEM(ev, 0);
+#endif
+            } else {
+                Py_INCREF(Py_None);
+                value = Py_None;
+            }
+            Py_DECREF(ev);
+        }
+        else if (!__Pyx_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
+            value = ev;
+        }
+        if (likely(value)) {
+            Py_XDECREF(tb);
+            Py_DECREF(et);
+            *pvalue = value;
+            return 0;
         }
+    } else if (!__Pyx_PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
+        __Pyx_ErrRestore(et, ev, tb);
+        return -1;
     }
-    if (!same) {
-        char rtversion[5] = {'\0'};
-        char message[200];
-        for (i=0; i<4; ++i) {
-            if (rt_from_call[i] == '.') {
-                if (found_dot) break;
-                found_dot = 1;
-            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
-                break;
+    PyErr_NormalizeException(&et, &ev, &tb);
+    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
+        __Pyx_ErrRestore(et, ev, tb);
+        return -1;
+    }
+    Py_XDECREF(tb);
+    Py_DECREF(et);
+#if PY_VERSION_HEX >= 0x030300A0
+    value = ((PyStopIterationObject *)ev)->value;
+    Py_INCREF(value);
+    Py_DECREF(ev);
+#else
+    {
+        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
+        Py_DECREF(ev);
+        if (likely(args)) {
+            value = PySequence_GetItem(args, 0);
+            Py_DECREF(args);
+        }
+        if (unlikely(!value)) {
+            __Pyx_ErrRestore(NULL, NULL, NULL);
+            Py_INCREF(Py_None);
+            value = Py_None;
+        }
+    }
+#endif
+    *pvalue = value;
+    return 0;
+}
+static CYTHON_INLINE
+void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
+    PyObject *t, *v, *tb;
+    t = exc_state->exc_type;
+    v = exc_state->exc_value;
+    tb = exc_state->exc_traceback;
+    exc_state->exc_type = NULL;
+    exc_state->exc_value = NULL;
+    exc_state->exc_traceback = NULL;
+    Py_XDECREF(t);
+    Py_XDECREF(v);
+    Py_XDECREF(tb);
+}
+#define __Pyx_Coroutine_AlreadyRunningError(gen)  (__Pyx__Coroutine_AlreadyRunningError(gen), (PyObject*)NULL)
+static void __Pyx__Coroutine_AlreadyRunningError(CYTHON_UNUSED __pyx_CoroutineObject *gen) {
+    const char *msg;
+    if ((0)) {
+    #ifdef __Pyx_Coroutine_USED
+    } else if (__Pyx_Coroutine_Check((PyObject*)gen)) {
+        msg = "coroutine already executing";
+    #endif
+    #ifdef __Pyx_AsyncGen_USED
+    } else if (__Pyx_AsyncGen_CheckExact((PyObject*)gen)) {
+        msg = "async generator already executing";
+    #endif
+    } else {
+        msg = "generator already executing";
+    }
+    PyErr_SetString(PyExc_ValueError, msg);
+}
+#define __Pyx_Coroutine_NotStartedError(gen)  (__Pyx__Coroutine_NotStartedError(gen), (PyObject*)NULL)
+static void __Pyx__Coroutine_NotStartedError(CYTHON_UNUSED PyObject *gen) {
+    const char *msg;
+    if ((0)) {
+    #ifdef __Pyx_Coroutine_USED
+    } else if (__Pyx_Coroutine_Check(gen)) {
+        msg = "can't send non-None value to a just-started coroutine";
+    #endif
+    #ifdef __Pyx_AsyncGen_USED
+    } else if (__Pyx_AsyncGen_CheckExact(gen)) {
+        msg = "can't send non-None value to a just-started async generator";
+    #endif
+    } else {
+        msg = "can't send non-None value to a just-started generator";
+    }
+    PyErr_SetString(PyExc_TypeError, msg);
+}
+#define __Pyx_Coroutine_AlreadyTerminatedError(gen, value, closing)  (__Pyx__Coroutine_AlreadyTerminatedError(gen, value, closing), (PyObject*)NULL)
+static void __Pyx__Coroutine_AlreadyTerminatedError(CYTHON_UNUSED PyObject *gen, PyObject *value, CYTHON_UNUSED int closing) {
+    #ifdef __Pyx_Coroutine_USED
+    if (!closing && __Pyx_Coroutine_Check(gen)) {
+        PyErr_SetString(PyExc_RuntimeError, "cannot reuse already awaited coroutine");
+    } else
+    #endif
+    if (value) {
+        #ifdef __Pyx_AsyncGen_USED
+        if (__Pyx_AsyncGen_CheckExact(gen))
+            PyErr_SetNone(__Pyx_PyExc_StopAsyncIteration);
+        else
+        #endif
+        PyErr_SetNone(PyExc_StopIteration);
+    }
+}
+static
+PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, int closing) {
+    __Pyx_PyThreadState_declare
+    PyThreadState *tstate;
+    __Pyx_ExcInfoStruct *exc_state;
+    PyObject *retval;
+    assert(!self->is_running);
+    if (unlikely(self->resume_label == 0)) {
+        if (unlikely(value && value != Py_None)) {
+            return __Pyx_Coroutine_NotStartedError((PyObject*)self);
+        }
+    }
+    if (unlikely(self->resume_label == -1)) {
+        return __Pyx_Coroutine_AlreadyTerminatedError((PyObject*)self, value, closing);
+    }
+#if CYTHON_FAST_THREAD_STATE
+    __Pyx_PyThreadState_assign
+    tstate = __pyx_tstate;
+#else
+    tstate = __Pyx_PyThreadState_Current;
+#endif
+    exc_state = &self->gi_exc_state;
+    if (exc_state->exc_type) {
+        #if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
+        #else
+        if (exc_state->exc_traceback) {
+            PyTracebackObject *tb = (PyTracebackObject *) exc_state->exc_traceback;
+            PyFrameObject *f = tb->tb_frame;
+            Py_XINCREF(tstate->frame);
+            assert(f->f_back == NULL);
+            f->f_back = tstate->frame;
+        }
+        #endif
+    }
+#if CYTHON_USE_EXC_INFO_STACK
+    exc_state->previous_item = tstate->exc_info;
+    tstate->exc_info = exc_state;
+#else
+    if (exc_state->exc_type) {
+        __Pyx_ExceptionSwap(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
+    } else {
+        __Pyx_Coroutine_ExceptionClear(exc_state);
+        __Pyx_ExceptionSave(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
+    }
+#endif
+    self->is_running = 1;
+    retval = self->body((PyObject *) self, tstate, value);
+    self->is_running = 0;
+#if CYTHON_USE_EXC_INFO_STACK
+    exc_state = &self->gi_exc_state;
+    tstate->exc_info = exc_state->previous_item;
+    exc_state->previous_item = NULL;
+    __Pyx_Coroutine_ResetFrameBackpointer(exc_state);
+#endif
+    return retval;
+}
+static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state) {
+    PyObject *exc_tb = exc_state->exc_traceback;
+    if (likely(exc_tb)) {
+#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
+#else
+        PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
+        PyFrameObject *f = tb->tb_frame;
+        Py_CLEAR(f->f_back);
+#endif
+    }
+}
+static CYTHON_INLINE
+PyObject *__Pyx_Coroutine_MethodReturn(CYTHON_UNUSED PyObject* gen, PyObject *retval) {
+    if (unlikely(!retval)) {
+        __Pyx_PyThreadState_declare
+        __Pyx_PyThreadState_assign
+        if (!__Pyx_PyErr_Occurred()) {
+            PyObject *exc = PyExc_StopIteration;
+            #ifdef __Pyx_AsyncGen_USED
+            if (__Pyx_AsyncGen_CheckExact(gen))
+                exc = __Pyx_PyExc_StopAsyncIteration;
+            #endif
+            __Pyx_PyErr_SetNone(exc);
+        }
+    }
+    return retval;
+}
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
+static CYTHON_INLINE
+PyObject *__Pyx_PyGen_Send(PyGenObject *gen, PyObject *arg) {
+#if PY_VERSION_HEX <= 0x030A00A1
+    return _PyGen_Send(gen, arg);
+#else
+    PyObject *result;
+    if (PyIter_Send((PyObject*)gen, arg ? arg : Py_None, &result) == PYGEN_RETURN) {
+        if (PyAsyncGen_CheckExact(gen)) {
+            assert(result == Py_None);
+            PyErr_SetNone(PyExc_StopAsyncIteration);
+        }
+        else if (result == Py_None) {
+            PyErr_SetNone(PyExc_StopIteration);
+        }
+        else {
+            _PyGen_SetStopIterationValue(result);
+        }
+        Py_CLEAR(result);
+    }
+    return result;
+#endif
+}
+#endif
+static CYTHON_INLINE
+PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
+    PyObject *ret;
+    PyObject *val = NULL;
+    __Pyx_Coroutine_Undelegate(gen);
+    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, &val);
+    ret = __Pyx_Coroutine_SendEx(gen, val, 0);
+    Py_XDECREF(val);
+    return ret;
+}
+static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
+    PyObject *retval;
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
+    PyObject *yf = gen->yieldfrom;
+    if (unlikely(gen->is_running))
+        return __Pyx_Coroutine_AlreadyRunningError(gen);
+    if (yf) {
+        PyObject *ret;
+        gen->is_running = 1;
+        #ifdef __Pyx_Generator_USED
+        if (__Pyx_Generator_CheckExact(yf)) {
+            ret = __Pyx_Coroutine_Send(yf, value);
+        } else
+        #endif
+        #ifdef __Pyx_Coroutine_USED
+        if (__Pyx_Coroutine_Check(yf)) {
+            ret = __Pyx_Coroutine_Send(yf, value);
+        } else
+        #endif
+        #ifdef __Pyx_AsyncGen_USED
+        if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
+            ret = __Pyx_async_gen_asend_send(yf, value);
+        } else
+        #endif
+        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
+        if (PyGen_CheckExact(yf)) {
+            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
+        } else
+        #endif
+        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03050000 && defined(PyCoro_CheckExact) && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
+        if (PyCoro_CheckExact(yf)) {
+            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
+        } else
+        #endif
+        {
+            if (value == Py_None)
+                ret = Py_TYPE(yf)->tp_iternext(yf);
+            else
+                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
+        }
+        gen->is_running = 0;
+        if (likely(ret)) {
+            return ret;
+        }
+        retval = __Pyx_Coroutine_FinishDelegation(gen);
+    } else {
+        retval = __Pyx_Coroutine_SendEx(gen, value, 0);
+    }
+    return __Pyx_Coroutine_MethodReturn(self, retval);
+}
+static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
+    PyObject *retval = NULL;
+    int err = 0;
+    #ifdef __Pyx_Generator_USED
+    if (__Pyx_Generator_CheckExact(yf)) {
+        retval = __Pyx_Coroutine_Close(yf);
+        if (!retval)
+            return -1;
+    } else
+    #endif
+    #ifdef __Pyx_Coroutine_USED
+    if (__Pyx_Coroutine_Check(yf)) {
+        retval = __Pyx_Coroutine_Close(yf);
+        if (!retval)
+            return -1;
+    } else
+    if (__Pyx_CoroutineAwait_CheckExact(yf)) {
+        retval = __Pyx_CoroutineAwait_Close((__pyx_CoroutineAwaitObject*)yf, NULL);
+        if (!retval)
+            return -1;
+    } else
+    #endif
+    #ifdef __Pyx_AsyncGen_USED
+    if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
+        retval = __Pyx_async_gen_asend_close(yf, NULL);
+    } else
+    if (__pyx_PyAsyncGenAThrow_CheckExact(yf)) {
+        retval = __Pyx_async_gen_athrow_close(yf, NULL);
+    } else
+    #endif
+    {
+        PyObject *meth;
+        gen->is_running = 1;
+        meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_close);
+        if (unlikely(!meth)) {
+            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
+                PyErr_WriteUnraisable(yf);
             }
-            rtversion[i] = rt_from_call[i];
+            PyErr_Clear();
+        } else {
+            retval = PyObject_CallFunction(meth, NULL);
+            Py_DECREF(meth);
+            if (!retval)
+                err = -1;
         }
-        PyOS_snprintf(message, sizeof(message),
-                      "compile time version %s of module '%.100s' "
-                      "does not match runtime version %s",
-                      ctversion, __Pyx_MODULE_NAME, rtversion);
-        return PyErr_WarnEx(NULL, message, 1);
+        gen->is_running = 0;
     }
+    Py_XDECREF(retval);
+    return err;
+}
+static PyObject *__Pyx_Generator_Next(PyObject *self) {
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
+    PyObject *yf = gen->yieldfrom;
+    if (unlikely(gen->is_running))
+        return __Pyx_Coroutine_AlreadyRunningError(gen);
+    if (yf) {
+        PyObject *ret;
+        gen->is_running = 1;
+        #ifdef __Pyx_Generator_USED
+        if (__Pyx_Generator_CheckExact(yf)) {
+            ret = __Pyx_Generator_Next(yf);
+        } else
+        #endif
+        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
+        if (PyGen_CheckExact(yf)) {
+            ret = __Pyx_PyGen_Send((PyGenObject*)yf, NULL);
+        } else
+        #endif
+        #ifdef __Pyx_Coroutine_USED
+        if (__Pyx_Coroutine_Check(yf)) {
+            ret = __Pyx_Coroutine_Send(yf, Py_None);
+        } else
+        #endif
+            ret = Py_TYPE(yf)->tp_iternext(yf);
+        gen->is_running = 0;
+        if (likely(ret)) {
+            return ret;
+        }
+        return __Pyx_Coroutine_FinishDelegation(gen);
+    }
+    return __Pyx_Coroutine_SendEx(gen, Py_None, 0);
+}
+static PyObject *__Pyx_Coroutine_Close_Method(PyObject *self, CYTHON_UNUSED PyObject *arg) {
+    return __Pyx_Coroutine_Close(self);
+}
+static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
+    PyObject *retval, *raised_exception;
+    PyObject *yf = gen->yieldfrom;
+    int err = 0;
+    if (unlikely(gen->is_running))
+        return __Pyx_Coroutine_AlreadyRunningError(gen);
+    if (yf) {
+        Py_INCREF(yf);
+        err = __Pyx_Coroutine_CloseIter(gen, yf);
+        __Pyx_Coroutine_Undelegate(gen);
+        Py_DECREF(yf);
+    }
+    if (err == 0)
+        PyErr_SetNone(PyExc_GeneratorExit);
+    retval = __Pyx_Coroutine_SendEx(gen, NULL, 1);
+    if (unlikely(retval)) {
+        const char *msg;
+        Py_DECREF(retval);
+        if ((0)) {
+        #ifdef __Pyx_Coroutine_USED
+        } else if (__Pyx_Coroutine_Check(self)) {
+            msg = "coroutine ignored GeneratorExit";
+        #endif
+        #ifdef __Pyx_AsyncGen_USED
+        } else if (__Pyx_AsyncGen_CheckExact(self)) {
+#if PY_VERSION_HEX < 0x03060000
+            msg = "async generator ignored GeneratorExit - might require Python 3.6+ finalisation (PEP 525)";
+#else
+            msg = "async generator ignored GeneratorExit";
+#endif
+        #endif
+        } else {
+            msg = "generator ignored GeneratorExit";
+        }
+        PyErr_SetString(PyExc_RuntimeError, msg);
+        return NULL;
+    }
+    raised_exception = PyErr_Occurred();
+    if (likely(!raised_exception || __Pyx_PyErr_GivenExceptionMatches2(raised_exception, PyExc_GeneratorExit, PyExc_StopIteration))) {
+        if (raised_exception) PyErr_Clear();
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+    return NULL;
+}
+static PyObject *__Pyx__Coroutine_Throw(PyObject *self, PyObject *typ, PyObject *val, PyObject *tb,
+                                        PyObject *args, int close_on_genexit) {
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
+    PyObject *yf = gen->yieldfrom;
+    if (unlikely(gen->is_running))
+        return __Pyx_Coroutine_AlreadyRunningError(gen);
+    if (yf) {
+        PyObject *ret;
+        Py_INCREF(yf);
+        if (__Pyx_PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit) && close_on_genexit) {
+            int err = __Pyx_Coroutine_CloseIter(gen, yf);
+            Py_DECREF(yf);
+            __Pyx_Coroutine_Undelegate(gen);
+            if (err < 0)
+                return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
+            goto throw_here;
+        }
+        gen->is_running = 1;
+        if (0
+        #ifdef __Pyx_Generator_USED
+            || __Pyx_Generator_CheckExact(yf)
+        #endif
+        #ifdef __Pyx_Coroutine_USED
+            || __Pyx_Coroutine_Check(yf)
+        #endif
+            ) {
+            ret = __Pyx__Coroutine_Throw(yf, typ, val, tb, args, close_on_genexit);
+        #ifdef __Pyx_Coroutine_USED
+        } else if (__Pyx_CoroutineAwait_CheckExact(yf)) {
+            ret = __Pyx__Coroutine_Throw(((__pyx_CoroutineAwaitObject*)yf)->coroutine, typ, val, tb, args, close_on_genexit);
+        #endif
+        } else {
+            PyObject *meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_throw);
+            if (unlikely(!meth)) {
+                Py_DECREF(yf);
+                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
+                    gen->is_running = 0;
+                    return NULL;
+                }
+                PyErr_Clear();
+                __Pyx_Coroutine_Undelegate(gen);
+                gen->is_running = 0;
+                goto throw_here;
+            }
+            if (likely(args)) {
+                ret = PyObject_CallObject(meth, args);
+            } else {
+                ret = PyObject_CallFunctionObjArgs(meth, typ, val, tb, NULL);
+            }
+            Py_DECREF(meth);
+        }
+        gen->is_running = 0;
+        Py_DECREF(yf);
+        if (!ret) {
+            ret = __Pyx_Coroutine_FinishDelegation(gen);
+        }
+        return __Pyx_Coroutine_MethodReturn(self, ret);
+    }
+throw_here:
+    __Pyx_Raise(typ, val, tb, NULL);
+    return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
+}
+static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
+    PyObject *typ;
+    PyObject *val = NULL;
+    PyObject *tb = NULL;
+    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
+        return NULL;
+    return __Pyx__Coroutine_Throw(self, typ, val, tb, args, 1);
+}
+static CYTHON_INLINE int __Pyx_Coroutine_traverse_excstate(__Pyx_ExcInfoStruct *exc_state, visitproc visit, void *arg) {
+    Py_VISIT(exc_state->exc_type);
+    Py_VISIT(exc_state->exc_value);
+    Py_VISIT(exc_state->exc_traceback);
     return 0;
 }
-
-/* InitStrings */
-  #if PY_MAJOR_VERSION >= 3
-static int __Pyx_InitString(__Pyx_StringTabEntry t, PyObject **str) {
-    if (t.is_unicode | t.is_str) {
-        if (t.intern) {
-            *str = PyUnicode_InternFromString(t.s);
-        } else if (t.encoding) {
-            *str = PyUnicode_Decode(t.s, t.n - 1, t.encoding, NULL);
+static int __Pyx_Coroutine_traverse(__pyx_CoroutineObject *gen, visitproc visit, void *arg) {
+    Py_VISIT(gen->closure);
+    Py_VISIT(gen->classobj);
+    Py_VISIT(gen->yieldfrom);
+    return __Pyx_Coroutine_traverse_excstate(&gen->gi_exc_state, visit, arg);
+}
+static int __Pyx_Coroutine_clear(PyObject *self) {
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
+    Py_CLEAR(gen->closure);
+    Py_CLEAR(gen->classobj);
+    Py_CLEAR(gen->yieldfrom);
+    __Pyx_Coroutine_ExceptionClear(&gen->gi_exc_state);
+#ifdef __Pyx_AsyncGen_USED
+    if (__Pyx_AsyncGen_CheckExact(self)) {
+        Py_CLEAR(((__pyx_PyAsyncGenObject*)gen)->ag_finalizer);
+    }
+#endif
+    Py_CLEAR(gen->gi_code);
+    Py_CLEAR(gen->gi_frame);
+    Py_CLEAR(gen->gi_name);
+    Py_CLEAR(gen->gi_qualname);
+    Py_CLEAR(gen->gi_modulename);
+    return 0;
+}
+static void __Pyx_Coroutine_dealloc(PyObject *self) {
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
+    PyObject_GC_UnTrack(gen);
+    if (gen->gi_weakreflist != NULL)
+        PyObject_ClearWeakRefs(self);
+    if (gen->resume_label >= 0) {
+        PyObject_GC_Track(self);
+#if PY_VERSION_HEX >= 0x030400a1 && CYTHON_USE_TP_FINALIZE
+        if (PyObject_CallFinalizerFromDealloc(self))
+#else
+        Py_TYPE(gen)->tp_del(self);
+        if (Py_REFCNT(self) > 0)
+#endif
+        {
+            return;
+        }
+        PyObject_GC_UnTrack(self);
+    }
+#ifdef __Pyx_AsyncGen_USED
+    if (__Pyx_AsyncGen_CheckExact(self)) {
+        /* We have to handle this case for asynchronous generators
+           right here, because this code has to be between UNTRACK
+           and GC_Del. */
+        Py_CLEAR(((__pyx_PyAsyncGenObject*)self)->ag_finalizer);
+    }
+#endif
+    __Pyx_Coroutine_clear(self);
+    PyObject_GC_Del(gen);
+}
+static void __Pyx_Coroutine_del(PyObject *self) {
+    PyObject *error_type, *error_value, *error_traceback;
+    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
+    __Pyx_PyThreadState_declare
+    if (gen->resume_label < 0) {
+        return;
+    }
+#if !CYTHON_USE_TP_FINALIZE
+    assert(self->ob_refcnt == 0);
+    __Pyx_SET_REFCNT(self, 1);
+#endif
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
+#ifdef __Pyx_AsyncGen_USED
+    if (__Pyx_AsyncGen_CheckExact(self)) {
+        __pyx_PyAsyncGenObject *agen = (__pyx_PyAsyncGenObject*)self;
+        PyObject *finalizer = agen->ag_finalizer;
+        if (finalizer && !agen->ag_closed) {
+            PyObject *res = __Pyx_PyObject_CallOneArg(finalizer, self);
+            if (unlikely(!res)) {
+                PyErr_WriteUnraisable(self);
+            } else {
+                Py_DECREF(res);
+            }
+            __Pyx_ErrRestore(error_type, error_value, error_traceback);
+            return;
+        }
+    }
+#endif
+    if (unlikely(gen->resume_label == 0 && !error_value)) {
+#ifdef __Pyx_Coroutine_USED
+#ifdef __Pyx_Generator_USED
+    if (!__Pyx_Generator_CheckExact(self))
+#endif
+        {
+        PyObject_GC_UnTrack(self);
+#if PY_MAJOR_VERSION >= 3  || defined(PyErr_WarnFormat)
+        if (unlikely(PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "coroutine '%.50S' was never awaited", gen->gi_qualname) < 0))
+            PyErr_WriteUnraisable(self);
+#else
+        {PyObject *msg;
+        char *cmsg;
+        #if CYTHON_COMPILING_IN_PYPY
+        msg = NULL;
+        cmsg = (char*) "coroutine was never awaited";
+        #else
+        char *cname;
+        PyObject *qualname;
+        qualname = gen->gi_qualname;
+        cname = PyString_AS_STRING(qualname);
+        msg = PyString_FromFormat("coroutine '%.50s' was never awaited", cname);
+        if (unlikely(!msg)) {
+            PyErr_Clear();
+            cmsg = (char*) "coroutine was never awaited";
         } else {
-            *str = PyUnicode_FromStringAndSize(t.s, t.n - 1);
+            cmsg = PyString_AS_STRING(msg);
+        }
+        #endif
+        if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, cmsg, 1) < 0))
+            PyErr_WriteUnraisable(self);
+        Py_XDECREF(msg);}
+#endif
+        PyObject_GC_Track(self);
         }
+#endif
     } else {
-        *str = PyBytes_FromStringAndSize(t.s, t.n - 1);
+        PyObject *res = __Pyx_Coroutine_Close(self);
+        if (unlikely(!res)) {
+            if (PyErr_Occurred())
+                PyErr_WriteUnraisable(self);
+        } else {
+            Py_DECREF(res);
+        }
     }
-    if (!*str)
+    __Pyx_ErrRestore(error_type, error_value, error_traceback);
+#if !CYTHON_USE_TP_FINALIZE
+    assert(Py_REFCNT(self) > 0);
+    if (--self->ob_refcnt == 0) {
+        return;
+    }
+    {
+        Py_ssize_t refcnt = Py_REFCNT(self);
+        _Py_NewReference(self);
+        __Pyx_SET_REFCNT(self, refcnt);
+    }
+#if CYTHON_COMPILING_IN_CPYTHON
+    assert(PyType_IS_GC(Py_TYPE(self)) &&
+           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
+    _Py_DEC_REFTOTAL;
+#endif
+#ifdef COUNT_ALLOCS
+    --Py_TYPE(self)->tp_frees;
+    --Py_TYPE(self)->tp_allocs;
+#endif
+#endif
+}
+static PyObject *
+__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
+{
+    PyObject *name = self->gi_name;
+    if (unlikely(!name)) name = Py_None;
+    Py_INCREF(name);
+    return name;
+}
+static int
+__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__name__ must be set to a string object");
         return -1;
-    if (PyObject_Hash(*str) == -1)
+    }
+    tmp = self->gi_name;
+    Py_INCREF(value);
+    self->gi_name = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
+{
+    PyObject *name = self->gi_qualname;
+    if (unlikely(!name)) name = Py_None;
+    Py_INCREF(name);
+    return name;
+}
+static int
+__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__qualname__ must be set to a string object");
         return -1;
+    }
+    tmp = self->gi_qualname;
+    Py_INCREF(value);
+    self->gi_qualname = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_Coroutine_get_frame(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
+{
+    PyObject *frame = self->gi_frame;
+    if (!frame) {
+        if (unlikely(!self->gi_code)) {
+            Py_RETURN_NONE;
+        }
+        frame = (PyObject *) PyFrame_New(
+            PyThreadState_Get(),            /*PyThreadState *tstate,*/
+            (PyCodeObject*) self->gi_code,  /*PyCodeObject *code,*/
+            __pyx_d,                 /*PyObject *globals,*/
+            0                               /*PyObject *locals*/
+        );
+        if (unlikely(!frame))
+            return NULL;
+        self->gi_frame = frame;
+    }
+    Py_INCREF(frame);
+    return frame;
+}
+static __pyx_CoroutineObject *__Pyx__Coroutine_New(
+            PyTypeObject* type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
+            PyObject *name, PyObject *qualname, PyObject *module_name) {
+    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
+    if (unlikely(!gen))
+        return NULL;
+    return __Pyx__Coroutine_NewInit(gen, body, code, closure, name, qualname, module_name);
+}
+static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
+            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
+            PyObject *name, PyObject *qualname, PyObject *module_name) {
+    gen->body = body;
+    gen->closure = closure;
+    Py_XINCREF(closure);
+    gen->is_running = 0;
+    gen->resume_label = 0;
+    gen->classobj = NULL;
+    gen->yieldfrom = NULL;
+    gen->gi_exc_state.exc_type = NULL;
+    gen->gi_exc_state.exc_value = NULL;
+    gen->gi_exc_state.exc_traceback = NULL;
+#if CYTHON_USE_EXC_INFO_STACK
+    gen->gi_exc_state.previous_item = NULL;
+#endif
+    gen->gi_weakreflist = NULL;
+    Py_XINCREF(qualname);
+    gen->gi_qualname = qualname;
+    Py_XINCREF(name);
+    gen->gi_name = name;
+    Py_XINCREF(module_name);
+    gen->gi_modulename = module_name;
+    Py_XINCREF(code);
+    gen->gi_code = code;
+    gen->gi_frame = NULL;
+    PyObject_GC_Track(gen);
+    return gen;
+}
+
+/* PatchModuleWithCoroutine */
+  static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
+#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
+    int result;
+    PyObject *globals, *result_obj;
+    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
+    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
+    #ifdef __Pyx_Coroutine_USED
+        (PyObject*)__pyx_CoroutineType);
+    #else
+        Py_None);
+    #endif
+    if (unlikely(result < 0)) goto ignore;
+    result = PyDict_SetItemString(globals, "_cython_generator_type",
+    #ifdef __Pyx_Generator_USED
+        (PyObject*)__pyx_GeneratorType);
+    #else
+        Py_None);
+    #endif
+    if (unlikely(result < 0)) goto ignore;
+    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
+    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
+    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
+    if (unlikely(!result_obj)) goto ignore;
+    Py_DECREF(result_obj);
+    Py_DECREF(globals);
+    return module;
+ignore:
+    Py_XDECREF(globals);
+    PyErr_WriteUnraisable(module);
+    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
+        Py_DECREF(module);
+        module = NULL;
+    }
+#else
+    py_code++;
+#endif
+    return module;
+}
+
+/* PatchGeneratorABC */
+  #ifndef CYTHON_REGISTER_ABCS
+#define CYTHON_REGISTER_ABCS 1
+#endif
+#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
+static PyObject* __Pyx_patch_abc_module(PyObject *module);
+static PyObject* __Pyx_patch_abc_module(PyObject *module) {
+    module = __Pyx_Coroutine_patch_module(
+        module, ""
+"if _cython_generator_type is not None:\n"
+"    try: Generator = _module.Generator\n"
+"    except AttributeError: pass\n"
+"    else: Generator.register(_cython_generator_type)\n"
+"if _cython_coroutine_type is not None:\n"
+"    try: Coroutine = _module.Coroutine\n"
+"    except AttributeError: pass\n"
+"    else: Coroutine.register(_cython_coroutine_type)\n"
+    );
+    return module;
+}
+#endif
+static int __Pyx_patch_abc(void) {
+#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
+    static int abc_patched = 0;
+    if (CYTHON_REGISTER_ABCS && !abc_patched) {
+        PyObject *module;
+        module = PyImport_ImportModule((PY_MAJOR_VERSION >= 3) ? "collections.abc" : "collections");
+        if (!module) {
+            PyErr_WriteUnraisable(NULL);
+            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
+                    ((PY_MAJOR_VERSION >= 3) ?
+                        "Cython module failed to register with collections.abc module" :
+                        "Cython module failed to register with collections module"), 1) < 0)) {
+                return -1;
+            }
+        } else {
+            module = __Pyx_patch_abc_module(module);
+            abc_patched = 1;
+            if (unlikely(!module))
+                return -1;
+            Py_DECREF(module);
+        }
+        module = PyImport_ImportModule("backports_abc");
+        if (module) {
+            module = __Pyx_patch_abc_module(module);
+            Py_XDECREF(module);
+        }
+        if (!module) {
+            PyErr_Clear();
+        }
+    }
+#else
+    if ((0)) __Pyx_Coroutine_patch_module(NULL, NULL);
+#endif
     return 0;
 }
+
+/* Generator */
+  static PyMethodDef __pyx_Generator_methods[] = {
+    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
+     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
+    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
+     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
+    {"close", (PyCFunction) __Pyx_Coroutine_Close_Method, METH_NOARGS,
+     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
+    {0, 0, 0, 0}
+};
+static PyMemberDef __pyx_Generator_memberlist[] = {
+    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
+    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
+     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
+    {(char*) "gi_code", T_OBJECT, offsetof(__pyx_CoroutineObject, gi_code), READONLY, NULL},
+    {0, 0, 0, 0, 0}
+};
+static PyGetSetDef __pyx_Generator_getsets[] = {
+    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
+     (char*) PyDoc_STR("name of the generator"), 0},
+    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
+     (char*) PyDoc_STR("qualified name of the generator"), 0},
+    {(char *) "gi_frame", (getter)__Pyx_Coroutine_get_frame, NULL,
+     (char*) PyDoc_STR("Frame of the generator"), 0},
+    {0, 0, 0, 0, 0}
+};
+static PyTypeObject __pyx_GeneratorType_type = {
+    PyVarObject_HEAD_INIT(0, 0)
+    "generator",
+    sizeof(__pyx_CoroutineObject),
+    0,
+    (destructor) __Pyx_Coroutine_dealloc,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
+    0,
+    (traverseproc) __Pyx_Coroutine_traverse,
+    0,
+    0,
+    offsetof(__pyx_CoroutineObject, gi_weakreflist),
+    0,
+    (iternextfunc) __Pyx_Generator_Next,
+    __pyx_Generator_methods,
+    __pyx_Generator_memberlist,
+    __pyx_Generator_getsets,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+#if CYTHON_USE_TP_FINALIZE
+    0,
+#else
+    __Pyx_Coroutine_del,
+#endif
+    0,
+#if CYTHON_USE_TP_FINALIZE
+    __Pyx_Coroutine_del,
+#elif PY_VERSION_HEX >= 0x030400a1
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b1
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+    0,
 #endif
-static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+};
+static int __pyx_Generator_init(void) {
+    __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
+    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
+    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
+    if (unlikely(!__pyx_GeneratorType)) {
+        return -1;
+    }
+    return 0;
+}
+
+/* CheckBinaryVersion */
+  static int __Pyx_check_binary_version(void) {
+    char ctversion[4], rtversion[4];
+    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
+    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+        char message[200];
+        PyOS_snprintf(message, sizeof(message),
+                      "compiletime version %s of module '%.100s' "
+                      "does not match runtime version %s",
+                      ctversion, __Pyx_MODULE_NAME, rtversion);
+        return PyErr_WarnEx(NULL, message, 1);
+    }
+    return 0;
+}
+
+/* InitStrings */
+  static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
-        #if PY_MAJOR_VERSION >= 3
-        __Pyx_InitString(*t, t->p);
-        #else
+        #if PY_MAJOR_VERSION < 3
         if (t->is_unicode) {
             *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
         } else if (t->intern) {
             *t->p = PyString_InternFromString(t->s);
         } else {
             *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
         }
+        #else
+        if (t->is_unicode | t->is_str) {
+            if (t->intern) {
+                *t->p = PyUnicode_InternFromString(t->s);
+            } else if (t->encoding) {
+                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
+            } else {
+                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+            }
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
         if (!*t->p)
             return -1;
         if (PyObject_Hash(*t->p) == -1)
             return -1;
-        #endif
         ++t;
     }
     return 0;
 }
 
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
     return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
@@ -28139,15 +24468,15 @@
 #if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
             __Pyx_sys_getdefaultencoding_not_ascii &&
 #endif
             PyUnicode_Check(o)) {
         return __Pyx_PyUnicode_AsStringAndSize(o, length);
     } else
 #endif
-#if (!CYTHON_COMPILING_IN_PYPY && !CYTHON_COMPILING_IN_LIMITED_API) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
+#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
     if (PyByteArray_Check(o)) {
         *length = PyByteArray_GET_SIZE(o);
         return PyByteArray_AS_STRING(o);
     } else
 #endif
     {
         char* result;
@@ -28168,34 +24497,30 @@
     int retval;
     if (unlikely(!x)) return -1;
     retval = __Pyx_PyObject_IsTrue(x);
     Py_DECREF(x);
     return retval;
 }
 static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
-    __Pyx_TypeName result_type_name = __Pyx_PyType_GetName(Py_TYPE(result));
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(result)) {
         if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
-                "__int__ returned non-int (type " __Pyx_FMT_TYPENAME ").  "
-                "The ability to return an instance of a strict subclass of int is deprecated, "
-                "and may be removed in a future version of Python.",
-                result_type_name)) {
-            __Pyx_DECREF_TypeName(result_type_name);
+                "__int__ returned non-int (type %.200s).  "
+                "The ability to return an instance of a strict subclass of int "
+                "is deprecated, and may be removed in a future version of Python.",
+                Py_TYPE(result)->tp_name)) {
             Py_DECREF(result);
             return NULL;
         }
-        __Pyx_DECREF_TypeName(result_type_name);
         return result;
     }
 #endif
     PyErr_Format(PyExc_TypeError,
-                 "__%.4s__ returned non-%.4s (type " __Pyx_FMT_TYPENAME ")",
-                 type_name, type_name, result_type_name);
-    __Pyx_DECREF_TypeName(result_type_name);
+                 "__%.4s__ returned non-%.4s (type %.200s)",
+                 type_name, type_name, Py_TYPE(result)->tp_name);
     Py_DECREF(result);
     return NULL;
 }
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
 #if CYTHON_USE_TYPE_SLOTS
   PyNumberMethods *m;
 #endif
@@ -28253,19 +24578,21 @@
         return PyInt_AS_LONG(b);
     else
         return PyInt_AsSsize_t(b);
   }
 #endif
   if (likely(PyLong_CheckExact(b))) {
     #if CYTHON_USE_PYLONG_INTERNALS
-    if (likely(__Pyx_PyLong_IsCompact(b))) {
-        return __Pyx_PyLong_CompactValue(b);
+    const digit* digits = ((PyLongObject*)b)->ob_digit;
+    const Py_ssize_t size = Py_SIZE(b);
+    if (likely(__Pyx_sst_abs(size) <= 1)) {
+        ival = likely(size) ? digits[0] : 0;
+        if (size == -1) ival = -ival;
+        return ival;
     } else {
-      const digit* digits = __Pyx_PyLong_Digits(b);
-      const Py_ssize_t size = __Pyx_PyLong_SignedDigitCount(b);
       switch (size) {
          case 2:
            if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
              return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
            }
            break;
          case -2:
@@ -28300,41 +24627,16 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
-static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
-  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
-    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
-#if PY_MAJOR_VERSION < 3
-  } else if (likely(PyInt_CheckExact(o))) {
-    return PyInt_AS_LONG(o);
-#endif
-  } else {
-    Py_ssize_t ival;
-    PyObject *x;
-    x = PyNumber_Index(o);
-    if (!x) return -1;
-    ival = PyInt_AsLong(x);
-    Py_DECREF(x);
-    return ival;
-  }
-}
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
 
 
-/* #### Code section: utility_code_pragmas_end ### */
-#ifdef _MSC_VER
-#pragma warning( pop )
-#endif
-
-
-
-/* #### Code section: end ### */
 #endif /* Py_PYTHON_H */
```

### Comparing `chython-1.67/chython/containers/cgr.py` & `chython-1.8/chython/containers/cgr.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,153 +1,193 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from functools import cached_property
-from typing import Dict, Iterator, Tuple, Optional, Collection
-from .bonds import DynamicBond
-from ..algorithms.isomorphism import Isomorphism
-from ..algorithms.morgan import Morgan
-from ..algorithms.rings import Rings
-from ..algorithms.smiles import CGRSmiles
-from ..periodictable import DynamicElement
-
-
-class CGRContainer(CGRSmiles, Morgan, Rings, Isomorphism):
-    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_p_charges', '_p_radicals', '__dict__', '__weakref__')
-    _atoms: Dict[int, DynamicElement]
-    _bonds: Dict[int, Dict[int, DynamicBond]]
-    _charges: Dict[int, int]
-    _radicals: Dict[int, bool]
-    _p_charges: Dict[int, int]
-    _p_radicals: Dict[int, bool]
-
-    def __init__(self):
-        self._atoms = {}
-        self._bonds = {}
-        self._charges = {}
-        self._radicals = {}
-        self._p_charges = {}
-        self._p_radicals = {}
-
-    def bonds(self) -> Iterator[Tuple[int, int, DynamicBond]]:
-        """
-        Iterate other all bonds
-        """
-        seen = set()
-        for n, m_bond in self._bonds.items():
-            seen.add(n)
-            for m, bond in m_bond.items():
-                if m not in seen:
-                    yield n, m, bond
-
-    @cached_property
-    def center_atoms(self) -> Tuple[int, ...]:
-        """ Get list of atoms of reaction center (atoms with dynamic: bonds, charges, radicals).
-        """
-        radicals = self._radicals
-        p_charges = self._p_charges
-        p_radicals = self._p_radicals
-
-        center = set()
-        for n, c in self._charges.items():
-            if c != p_charges[n] or radicals[n] != p_radicals[n]:
-                center.add(n)
-
-        for n, m_bond in self._bonds.items():
-            if any(bond.order != bond.p_order for bond in m_bond.values()):
-                center.add(n)
-
-        return tuple(center)
-
-    def substructure(self, atoms) -> 'CGRContainer':
-        """
-        Create substructure containing atoms from atoms list
-
-        :param atoms: list of atoms numbers of substructure
-        """
-        atoms = set(atoms)
-        sa = self._atoms
-        sc = self._charges
-        sr = self._radicals
-        sb = self._bonds
-        spc = self._p_charges
-        spr = self._p_radicals
-
-        sub = object.__new__(self.__class__)
-        sub._charges = {n: sc[n] for n in atoms}
-        sub._radicals = {n: sr[n] for n in atoms}
-        sub._p_charges = {n: spc[n] for n in atoms}
-        sub._p_radicals = {n: spr[n] for n in atoms}
-
-        sub._atoms = ca = {}
-        for n in atoms:
-            ca[n] = atom = sa[n].copy()
-            atom._attach_graph(sub, n)
-
-        sub._bonds = cb = {}
-        for n in atoms:
-            cb[n] = cbn = {}
-            for m, bond in sb[n].items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                elif m in atoms:
-                    cbn[m] = bond.copy()
-        return sub
-
-    def augmented_substructure(self, atoms, deep: int = 1):
-        atoms = set(atoms)
-        bonds = self._bonds
-
-        for _ in range(deep):
-            n = {y for x in atoms for y in bonds[x]} | atoms
-            if n == atoms:
-                break
-            atoms = n
-        return self.substructure(atoms)
-
-    def get_mapping(self, other: 'CGRContainer', /, *, automorphism_filter: bool = True,
-                    searching_scope: Optional[Collection[int]] = None):
-        """
-        Get self to other CGR substructure mapping generator.
-
-        :param other: CGR
-        :param automorphism_filter: skip matches to the same atoms.
-        :param searching_scope: substructure atoms list to localize isomorphism.
-        """
-        if isinstance(other, CGRContainer):
-            return self._get_mapping(other, automorphism_filter=automorphism_filter, searching_scope=searching_scope)
-        raise TypeError('CGRContainer expected')
-
-    def __iter__(self):
-        return iter(self._atoms)
-
-    def __getstate__(self):
-        return {'atoms': self._atoms, 'bonds': self._bonds, 'charges': self._charges, 'radicals': self._radicals,
-                'p_charges': self._p_charges, 'p_radicals': self._p_radicals}
-
-    def __setstate__(self, state):
-        self._atoms = state['atoms']
-        for n, a in state['atoms'].items():
-            a._attach_graph(self, n)
-        self._charges = state['charges']
-        self._radicals = state['radicals']
-        self._bonds = state['bonds']
-        self._p_charges = state['p_charges']
-        self._p_radicals = state['p_radicals']
-
-
-__all__ = ['CGRContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from functools import cached_property
+from typing import Dict, Iterator, List, Tuple
+from . import molecule  # cyclic imports resolve
+from .bonds import DynamicBond
+from ..algorithms.calculate2d import Calculate2DCGR
+from ..algorithms.depict import DepictCGR
+from ..algorithms.isomorphism import Isomorphism
+from ..algorithms.morgan import Morgan
+from ..algorithms.rings import Rings
+from ..algorithms.smiles import CGRSmiles
+from ..algorithms.x3dom import X3domCGR
+from ..periodictable import DynamicElement, Element
+
+
+class CGRContainer(CGRSmiles, Morgan, Rings, Isomorphism, DepictCGR, Calculate2DCGR, X3domCGR):
+    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_p_charges', '_p_radicals', '_plane', '_conformers',
+                 '__dict__', '__weakref__')
+    _atoms: Dict[int, DynamicElement]
+    _bonds: Dict[int, Dict[int, DynamicBond]]
+    _charges: Dict[int, int]
+    _radicals: Dict[int, bool]
+    _p_charges: Dict[int, int]
+    _p_radicals: Dict[int, bool]
+    _plane: Dict[int, Tuple[float, float]]
+    _conformers: List[Dict[int, Tuple[float, float, float]]]
+
+    def __init__(self):
+        self._atoms = {}
+        self._bonds = {}
+        self._charges = {}
+        self._radicals = {}
+        self._p_charges = {}
+        self._p_radicals = {}
+        self._plane = {}
+        self._conformers = []
+
+    def bonds(self) -> Iterator[Tuple[int, int, DynamicBond]]:
+        """
+        Iterate other all bonds
+        """
+        seen = set()
+        for n, m_bond in self._bonds.items():
+            seen.add(n)
+            for m, bond in m_bond.items():
+                if m not in seen:
+                    yield n, m, bond
+
+    @cached_property
+    def center_atoms(self) -> Tuple[int, ...]:
+        """ Get list of atoms of reaction center (atoms with dynamic: bonds, charges, radicals).
+        """
+        radicals = self._radicals
+        p_charges = self._p_charges
+        p_radicals = self._p_radicals
+
+        center = set()
+        for n, c in self._charges.items():
+            if c != p_charges[n] or radicals[n] != p_radicals[n]:
+                center.add(n)
+
+        for n, m_bond in self._bonds.items():
+            if any(bond.order != bond.p_order for bond in m_bond.values()):
+                center.add(n)
+
+        return tuple(center)
+
+    @cached_property
+    def aromatic_rings(self) -> Tuple[Tuple[int, ...], ...]:
+        """
+        existed or formed aromatic rings atoms numbers
+        """
+        adj = self._bonds
+        return tuple(ring for ring in self.sssr if
+                     adj[ring[0]][ring[-1]].order == 4 and all(adj[n][m].order == 4 for n, m in zip(ring, ring[1:])) or
+                     adj[ring[0]][ring[-1]].p_order == 4 and all(adj[n][m].p_order == 4 for n, m in zip(ring, ring[1:]))
+                     )
+
+    def substructure(self, atoms) -> 'CGRContainer':
+        """
+        Create substructure containing atoms from atoms list
+
+        :param atoms: list of atoms numbers of substructure
+        """
+        atoms = set(atoms)
+        sa = self._atoms
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+        sb = self._bonds
+        spc = self._p_charges
+        spr = self._p_radicals
+
+        sub = object.__new__(self.__class__)
+        sub._charges = {n: sc[n] for n in atoms}
+        sub._radicals = {n: sr[n] for n in atoms}
+        sub._p_charges = {n: spc[n] for n in atoms}
+        sub._p_radicals = {n: spr[n] for n in atoms}
+        sub._plane = {n: sp[n] for n in atoms}
+        sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
+
+        sub._atoms = ca = {}
+        for n in atoms:
+            ca[n] = atom = sa[n].copy()
+            atom._attach_to_graph(sub, n)
+
+        sub._bonds = cb = {}
+        for n in atoms:
+            cb[n] = cbn = {}
+            for m, bond in sb[n].items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                elif m in atoms:
+                    cbn[m] = bond.copy()
+        return sub
+
+    def decompose(self) -> Tuple['molecule.MoleculeContainer', 'molecule.MoleculeContainer']:
+        """
+        decompose CGR to pair of Molecules, which represents reactants and products state of reaction
+
+        :return: tuple of two molecules
+        """
+        charges = self._charges
+        p_charges = self._p_charges
+        radicals = self._radicals
+        p_radicals = self._p_radicals
+        plane = self._plane
+
+        reactants = molecule.MoleculeContainer()
+        products = molecule.MoleculeContainer()
+
+        for n, atom in self._atoms.items():
+            atom = Element.from_atomic_number(atom.atomic_number)(atom.isotope)
+            reactants.add_atom(atom, n, charge=charges[n], is_radical=radicals[n], xy=plane[n])
+            products.add_atom(atom.copy(), n, charge=p_charges[n], is_radical=p_radicals[n], xy=plane[n])
+
+        for n, m, bond in self.bonds():
+            if bond.order:
+                reactants.add_bond(n, m, bond.order)
+            if bond.p_order:
+                products.add_bond(n, m, bond.p_order)
+        return reactants, products
+
+    def get_mapping(self, other: 'CGRContainer', /, **kwargs):
+        if isinstance(other, CGRContainer):
+            return super().get_mapping(other, **kwargs)
+        raise TypeError('CGRContainer expected')
+
+    def __iter__(self):
+        return iter(self._atoms)
+
+    def __invert__(self):
+        """
+        decompose CGR
+        """
+        return self.decompose()
+
+    def __getstate__(self):
+        return {'atoms': self._atoms, 'bonds': self._bonds, 'plane': self._plane, 'conformers': self._conformers,
+                'charges': self._charges, 'radicals': self._radicals,
+                'p_charges': self._p_charges, 'p_radicals': self._p_radicals}
+
+    def __setstate__(self, state):
+        self._atoms = state['atoms']
+        for n, a in state['atoms'].items():
+            a._attach_to_graph(self, n)
+        self._charges = state['charges']
+        self._radicals = state['radicals']
+        self._plane = state['plane']
+        self._bonds = state['bonds']
+        self._p_charges = state['p_charges']
+        self._p_radicals = state['p_radicals']
+        self._conformers = state['conformers']
+
+
+__all__ = ['CGRContainer']
```

### Comparing `chython-1.67/chython/containers/graph.py` & `chython-1.8/chython/containers/graph.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,300 +1,254 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC, abstractmethod
-from functools import cached_property
-from typing import Dict, Generic, Iterator, Optional, Tuple, TypeVar
-from ..algorithms.morgan import Morgan
-from ..algorithms.rings import Rings
-from ..exceptions import AtomNotFound, MappingError, BondNotFound
-
-
-Atom = TypeVar('Atom')
-Bond = TypeVar('Bond')
-
-
-class Graph(Generic[Atom, Bond], Morgan, Rings, ABC):
-    __slots__ = ('_atoms', '_bonds', '_charges', '_radicals', '_atoms_stereo', '_cis_trans_stereo', '_allenes_stereo',
-                 '__dict__', '__weakref__')
-    __class_cache__ = {}
-
-    _atoms: Dict[int, Atom]
-    _bonds: Dict[int, Dict[int, Bond]]
-    _charges: Dict[int, int]
-    _radicals: Dict[int, bool]
-    _atoms_stereo: Dict[int, bool]
-    _allenes_stereo: Dict[int, bool]
-    _cis_trans_stereo: Dict[Tuple[int, int], bool]
-
-    def __init__(self):
-        self._atoms = {}
-        self._bonds = {}
-        self._charges = {}
-        self._radicals = {}
-        self._atoms_stereo = {}
-        self._allenes_stereo = {}
-        self._cis_trans_stereo = {}
-
-    def atom(self, n: int) -> Atom:
-        return self._atoms[n]
-
-    def has_atom(self, n: int) -> bool:
-        return n in self._atoms
-
-    def atoms(self) -> Iterator[Tuple[int, Atom]]:
-        """
-        iterate over all atoms
-        """
-        return iter(self._atoms.items())
-
-    @property
-    def atoms_count(self) -> int:
-        return len(self._atoms)
-
-    @property
-    def atoms_numbers(self) -> Iterator[int]:
-        return iter(self._atoms)
-
-    def bond(self, n: int, m: int) -> Bond:
-        try:
-            return self._bonds[n][m]
-        except KeyError as e:
-            raise BondNotFound from e
-
-    def has_bond(self, n: int, m: int) -> bool:
-        try:
-            self._bonds[n]  # check if atom exists
-            return n in self._bonds[m]
-        except KeyError:
-            raise AtomNotFound
-
-    def bonds(self) -> Iterator[Tuple[int, int, Bond]]:
-        """
-        iterate other all bonds
-        """
-        seen = set()
-        for n, m_bond in self._bonds.items():
-            seen.add(n)
-            for m, bond in m_bond.items():
-                if m not in seen:
-                    yield n, m, bond
-
-    @cached_property
-    def bonds_count(self) -> int:
-        return sum(len(x) for x in self._bonds.values()) // 2
-
-    @abstractmethod
-    def add_atom(self, atom: Atom, n: Optional[int] = None, *, charge: int = 0, is_radical: bool = False) -> int:
-        """
-        new atom addition
-        """
-        if n is None:
-            n = max(self._atoms, default=0) + 1
-        elif not isinstance(n, int):
-            raise TypeError('mapping should be integer')
-        elif n in self._atoms:
-            raise MappingError('atom with same number exists')
-        elif not isinstance(is_radical, bool):
-            raise TypeError('bool expected')
-        elif not isinstance(charge, int):
-            raise TypeError('formal charge should be int in range [-4, 4]')
-        elif charge > 4 or charge < -4:
-            raise ValueError('formal charge should be in range [-4, 4]')
-
-        atom._attach_graph(self, n)
-        self._atoms[n] = atom
-        self._charges[n] = charge
-        self._radicals[n] = is_radical
-        self._bonds[n] = {}
-        self.__dict__.clear()
-        return n
-
-    @abstractmethod
-    def add_bond(self, n: int, m: int, bond: Bond):
-        """
-        Add bond.
-        """
-        if n == m:
-            raise MappingError('atom loops impossible')
-        if n not in self._bonds or m not in self._bonds:
-            raise AtomNotFound('atoms not found')
-        if n in self._bonds[m]:
-            raise MappingError('atoms already bonded')
-
-        self._bonds[n][m] = self._bonds[m][n] = bond
-        self.__dict__.clear()
-
-    @abstractmethod
-    def copy(self):
-        """
-        copy of graph
-        """
-        copy = object.__new__(self.__class__)
-        copy._charges = self._charges.copy()
-        copy._radicals = self._radicals.copy()
-
-        copy._atoms = ca = {}
-        for n, atom in self._atoms.items():
-            atom = atom.copy()
-            ca[n] = atom
-            atom._attach_graph(copy, n)
-        return copy
-
-    @abstractmethod
-    def remap(self, mapping: Dict[int, int], *, copy=False):
-        """
-        Change atom numbers
-
-        :param mapping: mapping of old numbers to the new
-        :param copy: keep original graph
-        """
-        if len(mapping) != len(set(mapping.values())) or \
-                not (self._atoms.keys() - mapping.keys()).isdisjoint(mapping.values()):
-            raise ValueError('mapping overlap')
-
-        mg = mapping.get
-        sc = self._charges
-        sr = self._radicals
-
-        if copy:
-            h = self.__class__()
-            ha = h._atoms
-            hc = h._charges
-            hr = h._radicals
-            has = h._atoms_stereo
-            hal = h._allenes_stereo
-            hcs = h._cis_trans_stereo
-
-            for n, atom in self._atoms.items():
-                m = mg(n, n)
-                atom = atom.copy()
-                ha[m] = atom
-                atom._attach_graph(h, m)
-        else:
-            ha = {}
-            hc = {}
-            hr = {}
-            has = {}
-            hal = {}
-            hcs = {}
-
-            for n, atom in self._atoms.items():
-                m = mg(n, n)
-                ha[m] = atom
-                atom._change_map(m)  # change mapping number
-
-        for n in self._atoms:
-            m = mg(n, n)
-            hc[m] = sc[n]
-            hr[m] = sr[n]
-
-        for n, stereo in self._atoms_stereo.items():
-            has[mg(n, n)] = stereo
-        for n, stereo in self._allenes_stereo.items():
-            hal[mg(n, n)] = stereo
-        for (n, m), stereo in self._cis_trans_stereo.items():
-            hcs[(mg(n, n), mg(m, m))] = stereo
-
-        if copy:
-            return h  # noqa
-
-        self._atoms = ha
-        self._charges = hc
-        self._radicals = hr
-        self._atoms_stereo = has
-        self._allenes_stereo = hal
-        self._cis_trans_stereo = hcs
-        self.flush_cache()
-        return self
-
-    @abstractmethod
-    def union(self, other: 'Graph', *, remap: bool = False, copy: bool = True):
-        """
-        Merge Graphs into one.
-
-        :param remap: if atoms has collisions then remap other graph atoms else raise exception.
-        :param copy: keep original structure and return new object
-        """
-        if self._atoms.keys() & other._atoms.keys():
-            if remap:
-                other = other.remap({n: i for i, n in enumerate(other, start=max(self._atoms) + 1)}, copy=True)
-            else:
-                raise MappingError('mapping of graphs is not disjoint')
-
-        u = self.copy() if copy else self
-        u._charges.update(other._charges)
-        u._radicals.update(other._radicals)
-
-        ua = u._atoms
-        for n, atom in other._atoms.items():
-            ua[n] = atom = atom.copy()
-            atom._attach_graph(u, n)
-
-        u._atoms_stereo.update(other._atoms_stereo)
-        u._allenes_stereo.update(other._allenes_stereo)
-        u._cis_trans_stereo.update(other._cis_trans_stereo)
-        return u, other
-
-    def flush_cache(self):
-        self.__dict__.clear()
-
-    def __copy__(self):
-        return self.copy()
-
-    def __or__(self, other):
-        """
-        G | H is union of graphs
-        """
-        return self.union(other, remap=True)
-
-    def __ior__(self, other):
-        """
-        G =| H is union of graphs
-        """
-        return self.union(other, remap=True, copy=False)
-
-    def __len__(self):
-        return len(self._atoms)
-
-    def __iter__(self) -> Iterator[int]:
-        return iter(self._atoms)
-
-    def __bool__(self):
-        return bool(self._atoms)
-
-    def __getstate__(self):
-        state = {'atoms': self._atoms, 'bonds': self._bonds, 'charges': self._charges,
-                 'radicals': self._radicals}
-        from chython import pickle_cache
-
-        if pickle_cache:
-            state['cache'] = {k: v for k, v in self.__dict__.items() if k != '__cached_method___hash__'}
-        return state
-
-    def __setstate__(self, state):
-        self._atoms = state['atoms']
-        for n, a in state['atoms'].items():
-            a._attach_graph(self, n)
-        self._charges = state['charges']
-        self._radicals = state['radicals']
-        self._bonds = state['bonds']
-        if 'cache' in state:
-            self.__dict__.update(state['cache'])
-
-
-__all__ = ['Graph']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC, abstractmethod
+from functools import cached_property
+from typing import Dict, Generic, Iterator, Optional, Tuple, TypeVar
+from ..algorithms.isomorphism import Isomorphism
+from ..algorithms.morgan import Morgan
+from ..algorithms.rings import Rings
+from ..exceptions import AtomNotFound, MappingError
+
+
+Atom = TypeVar('Atom')
+Bond = TypeVar('Bond')
+
+
+class Graph(Generic[Atom, Bond], Morgan, Rings, Isomorphism, ABC):
+    __slots__ = ('_atoms', '_bonds', '_plane', '_charges', '_radicals', '__dict__', '__weakref__')
+    __class_cache__ = {}
+
+    _atoms: Dict[int, Atom]
+    _bonds: Dict[int, Dict[int, Bond]]
+    _charges: Dict[int, int]
+    _radicals: Dict[int, bool]
+    _plane: Dict[int, Tuple[float, float]]
+
+    def __init__(self):
+        self._atoms = {}
+        self._bonds = {}
+        self._charges = {}
+        self._radicals = {}
+        self._plane = {}
+
+    def atom(self, n: int) -> Atom:
+        return self._atoms[n]
+
+    def has_atom(self, n: int) -> bool:
+        return n in self._atoms
+
+    def atoms(self) -> Iterator[Tuple[int, Atom]]:
+        """
+        iterate over all atoms
+        """
+        return iter(self._atoms.items())
+
+    @property
+    def atoms_count(self) -> int:
+        return len(self._atoms)
+
+    @property
+    def atoms_numbers(self) -> Iterator[int]:
+        return iter(self._atoms)
+
+    def bond(self, n: int, m: int) -> Bond:
+        return self._bonds[n][m]
+
+    def has_bond(self, n: int, m: int) -> bool:
+        try:
+            self._bonds[n]  # check if atom exists
+            return n in self._bonds[m]
+        except KeyError:
+            raise AtomNotFound
+
+    def bonds(self) -> Iterator[Tuple[int, int, Bond]]:
+        """
+        iterate other all bonds
+        """
+        seen = set()
+        for n, m_bond in self._bonds.items():
+            seen.add(n)
+            for m, bond in m_bond.items():
+                if m not in seen:
+                    yield n, m, bond
+
+    @cached_property
+    def bonds_count(self) -> int:
+        return sum(len(x) for x in self._bonds.values()) // 2
+
+    @abstractmethod
+    def add_atom(self, atom: Atom, _map: Optional[int] = None, *, charge: int = 0,
+                 is_radical: bool = False, xy: Tuple[float, float] = (0., 0.)) -> int:
+        """
+        new atom addition
+        """
+        if _map is None:
+            _map = max(self._atoms, default=0) + 1
+        elif not isinstance(_map, int):
+            raise TypeError('mapping should be integer')
+        elif _map in self._atoms:
+            raise MappingError('atom with same number exists')
+        elif not isinstance(xy, tuple) or len(xy) != 2 or not isinstance(xy[0], float) or not isinstance(xy[1], float):
+            raise TypeError('XY should be tuple with 2 float')
+        elif not isinstance(is_radical, bool):
+            raise TypeError('bool expected')
+        elif not isinstance(charge, int):
+            raise TypeError('formal charge should be int in range [-4, 4]')
+        elif charge > 4 or charge < -4:
+            raise ValueError('formal charge should be in range [-4, 4]')
+
+        self._atoms[_map] = atom
+        self._charges[_map] = charge
+        self._radicals[_map] = is_radical
+        self._plane[_map] = xy
+        self._bonds[_map] = {}
+        atom._attach_to_graph(self, _map)
+        self.__dict__.clear()
+        return _map
+
+    @abstractmethod
+    def add_bond(self, n: int, m: int, bond: Bond):
+        """
+        Add bond.
+        """
+        if n == m:
+            raise ValueError('atom loops impossible')
+        if n not in self._bonds or m not in self._bonds:
+            raise AtomNotFound('atoms not found')
+        if n in self._bonds[m]:
+            raise ValueError('atoms already bonded')
+
+        self._bonds[n][m] = self._bonds[m][n] = bond
+        self.__dict__.clear()
+
+    @abstractmethod
+    def delete_atom(self, n: int):
+        """
+        Remove atom.
+        """
+        del self._atoms[n]
+        del self._charges[n]
+        del self._radicals[n]
+        del self._plane[n]
+        sb = self._bonds
+        for m in sb.pop(n):
+            del sb[m][n]
+        self.__dict__.clear()
+
+    @abstractmethod
+    def delete_bond(self, n: int, m: int):
+        """
+        Remove bond.
+        """
+        del self._bonds[n][m]
+        del self._bonds[m][n]
+        self.__dict__.clear()
+
+    @abstractmethod
+    def copy(self):
+        """
+        copy of graph
+        """
+        copy = object.__new__(self.__class__)
+        copy._charges = self._charges.copy()
+        copy._radicals = self._radicals.copy()
+        copy._plane = self._plane.copy()
+
+        copy._bonds = cb = {}
+        for n, m_bond in self._bonds.items():
+            cb[n] = cbn = {}
+            for m, bond in m_bond.items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                else:
+                    cbn[m] = bond.copy()
+
+        copy._atoms = ca = {}
+        for n, atom in self._atoms.items():
+            atom = atom.copy()
+            ca[n] = atom
+            atom._attach_to_graph(copy, n)
+        return copy
+
+    @abstractmethod
+    def union(self, other: 'Graph'):
+        """
+        Merge Graphs into one.
+        """
+        u = self.copy()
+        u._charges.update(other._charges)
+        u._radicals.update(other._radicals)
+        u._plane.update(other._plane)
+
+        ua = u._atoms
+        for n, atom in other._atoms.items():
+            ua[n] = atom = atom.copy()
+            atom._attach_to_graph(u, n)
+
+        ub = u._bonds
+        for n, m_bond in other._bonds.items():
+            ub[n] = ubn = {}
+            for m, bond in m_bond.items():
+                if m in ub:  # bond partially exists. need back-connection.
+                    ubn[m] = ub[m][n]
+                else:
+                    ubn[m] = bond.copy()
+        return u
+
+    def flush_cache(self):
+        self.__dict__.clear()
+
+    def __copy__(self):
+        return self.copy()
+
+    def __or__(self, other):
+        """
+        G | H is union of graphs
+        """
+        return self.union(other)
+
+    def __len__(self):
+        return len(self._atoms)
+
+    def __iter__(self) -> Iterator[int]:
+        return iter(self._atoms)
+
+    def __bool__(self):
+        return bool(self._atoms)
+
+    def __getstate__(self):
+        state = {'atoms': self._atoms, 'bonds': self._bonds, 'plane': self._plane, 'charges': self._charges,
+                 'radicals': self._radicals}
+        import chython
+        if chython.pickle_cache:
+            state['cache'] = {k: v for k, v in self.__dict__.items() if k != '__cached_method___hash__'}
+        return state
+
+    def __setstate__(self, state):
+        self._atoms = state['atoms']
+        for n, a in state['atoms'].items():
+            a._attach_to_graph(self, n)
+        self._charges = state['charges']
+        self._radicals = state['radicals']
+        self._plane = state['plane']
+        self._bonds = state['bonds']
+        if 'cache' in state:
+            self.__dict__.update(state['cache'])
+
+
+__all__ = ['Graph']
```

### Comparing `chython-1.67/chython/containers/molecule.py` & `chython-1.8/chython/containers/molecule.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,1144 +1,1206 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_args_method
-from collections import Counter, defaultdict
-from functools import cached_property
-from numpy import uint, zeros
-from typing import Dict, Iterable, List, Optional, Tuple, Union
-from weakref import ref
-from zlib import compress, decompress
-from .bonds import Bond, DynamicBond, QueryBond
-from .cgr import CGRContainer
-from .graph import Graph
-from .query import QueryContainer
-from ..algorithms.aromatics import Aromatize
-from ..algorithms.calculate2d import Calculate2DMolecule
-from ..algorithms.depict import DepictMolecule
-from ..algorithms.isomorphism import MoleculeIsomorphism
-from ..algorithms.fingerprints import Fingerprints
-from ..algorithms.mcs import MCS
-from ..algorithms.smiles import MoleculeSmiles
-from ..algorithms.standardize import StandardizeMolecule
-from ..algorithms.stereo import MoleculeStereo
-from ..algorithms.tautomers import Tautomers
-from ..algorithms.x3dom import X3domMolecule
-from ..exceptions import MappingError, ValenceError
-from ..periodictable import DynamicElement, Element, QueryElement, H
-
-
-class MoleculeContainer(MoleculeStereo, Graph[Element, Bond], MoleculeIsomorphism, Aromatize, StandardizeMolecule,
-                        MoleculeSmiles, DepictMolecule, Calculate2DMolecule, Fingerprints, Tautomers, MCS,
-                        X3domMolecule):
-    __slots__ = ('_plane', '_conformers', '_hydrogens', '_parsed_mapping', '_backup', '__meta', '__name')
-
-    _conformers: List[Dict[int, Tuple[float, float, float]]]
-    _hydrogens: Dict[int, Optional[int]]
-    _parsed_mapping: Dict[int, int]
-    _plane: Dict[int, Tuple[float, float]]
-
-    def __init__(self):
-        super().__init__()
-        self._conformers = []
-        self._hydrogens = {}
-        self._parsed_mapping = {}
-        self._plane = {}
-        self.__meta = None
-        self.__name = None
-
-    @property
-    def meta(self) -> Dict:
-        if self.__meta is None:
-            self.__meta = {}  # lazy
-        return self.__meta
-
-    @property
-    def name(self) -> str:
-        return self.__name or ''
-
-    @name.setter
-    def name(self, name):
-        if not isinstance(name, str):
-            raise TypeError('name should be string up to 80 symbols')
-        self.__name = name
-
-    def environment(self, atom: int, include_bond: bool = True, include_atom: bool = True) -> \
-            Tuple[Union[Tuple[int, Bond, Element],
-                        Tuple[int, Element],
-                        Tuple[int, Bond],
-                        int], ...]:
-        """
-        groups of (atom_number, bond, atom) connected to atom or
-        groups of (atom_number, bond) connected to atom or
-        groups of (atom_number, atom) connected to atom or
-        neighbors atoms connected to atom
-
-        :param atom: number
-        :param include_atom: include atom object
-        :param include_bond: include bond object
-        """
-        if include_atom:
-            atoms = self._atoms
-            if include_bond:
-                return tuple((n, bond, atoms[n]) for n, bond in self._bonds[atom].items())
-            return tuple((n, atoms[n]) for n in self._bonds[atom])
-        elif include_bond:
-            return tuple(self._bonds[atom].items())
-        return tuple(self._bonds[atom])
-
-    @cached_args_method
-    def neighbors(self, n: int) -> int:
-        """number of neighbors atoms excluding any-bonded"""
-        return sum(b.order != 8 for b in self._bonds[n].values())
-
-    @cached_args_method
-    def hybridization(self, n: int) -> int:
-        """
-        Atom hybridization.
-
-        1 - if atom has zero or only single bonded neighbors, 2 - if has only one double bonded neighbor and any amount
-        of single bonded, 3 - if has one triple bonded and any amount of double and single bonded neighbors or
-        two and more double bonded and any amount of single bonded neighbors, 4 - if atom in aromatic ring.
-        """
-        hybridization = 1
-        for bond in self._bonds[n].values():
-            order = bond.order
-            if order == 4:
-                return 4
-            elif order == 3:
-                if hybridization != 3:
-                    hybridization = 3
-            elif order == 2:
-                if hybridization == 1:
-                    hybridization = 2
-                elif hybridization == 2:
-                    hybridization = 3
-        return hybridization
-
-    @cached_args_method
-    def heteroatoms(self, n: int) -> int:
-        """
-        Number of neighbored heteroatoms (not carbon or hydrogen) except any-bond connected.
-        """
-        atoms = self._atoms
-        return sum(atoms[m].atomic_number not in (1, 6) for m, b in self._bonds[n].items() if b.order != 8)
-
-    def implicit_hydrogens(self, n: int) -> Optional[int]:
-        """
-        Number of implicit hydrogen atoms connected to atom.
-
-        Returns None if count are ambiguous.
-        """
-        return self._hydrogens[n]
-
-    @cached_args_method
-    def explicit_hydrogens(self, n: int) -> int:
-        """
-        Number of explicit hydrogen atoms connected to atom.
-
-        Take into account any type of bonds with hydrogen atoms.
-        """
-        atoms = self._atoms
-        return sum(atoms[m].atomic_number == 1 for m in self._bonds[n])
-
-    @cached_args_method
-    def total_hydrogens(self, n: int) -> int:
-        """
-        Number of hydrogen atoms connected to atom.
-
-        Take into account any type of bonds with hydrogen atoms.
-        """
-        return self._hydrogens[n] + self.explicit_hydrogens(n)
-
-    @cached_args_method
-    def adjacency_matrix(self, set_bonds=False, /):
-        """
-        Adjacency matrix of Graph.
-
-        :param set_bonds: if True set bond orders instead of 1.
-        """
-        adj = zeros((len(self), len(self)), dtype=uint)
-        mapping = {n: x for x, n in enumerate(self._atoms)}
-        if set_bonds:
-            for n, ms in self._bonds.items():
-                n = mapping[n]
-                for m, b in ms.items():
-                    adj[n, mapping[m]] = int(b)
-        else:
-            for n, ms in self._bonds.items():
-                n = mapping[n]
-                for m, b in ms.items():
-                    adj[n, mapping[m]] = 1
-        return adj
-
-    @cached_property
-    def molecular_charge(self) -> int:
-        """
-        Total charge of molecule
-        """
-        return sum(self._charges.values())
-
-    @cached_property
-    def is_radical(self) -> bool:
-        """
-        True if at least one atom is radical
-        """
-        return any(self._radicals.values())
-
-    @cached_property
-    def molecular_mass(self) -> float:
-        return sum(x.atomic_mass for x in self._atoms.values()) + sum(self._hydrogens.values()) * H().atomic_mass
-
-    @cached_property
-    def brutto(self) -> Dict[str, int]:
-        """Counted atoms dict"""
-        c = Counter(x.atomic_symbol for x in self._atoms.values())
-        c['H'] += sum(self._hydrogens.values())
-        return dict(c)
-
-    @cached_property
-    def aromatic_rings(self) -> Tuple[Tuple[int, ...], ...]:
-        """
-        Aromatic rings atoms numbers
-        """
-        bonds = self._bonds
-        return tuple(ring for ring in self.sssr if bonds[ring[0]][ring[-1]] == 4
-                     and all(bonds[n][m] == 4 for n, m in zip(ring, ring[1:])))
-
-    def add_atom(self, atom: Union[Element, int, str], *args, charge=0, is_radical=False,
-                 xy: Tuple[float, float] = (0., 0.), _skip_hydrogen_calculation=False, **kwargs):
-        """
-        Add new atom.
-        """
-        if not isinstance(atom, Element):
-            if isinstance(atom, str):
-                atom = Element.from_symbol(atom)()
-            elif isinstance(atom, int):
-                atom = Element.from_atomic_number(atom)()
-            else:
-                raise TypeError('Element object expected')
-        if not isinstance(xy, tuple) or len(xy) != 2 or not isinstance(xy[0], float) or not isinstance(xy[1], float):
-            raise TypeError('XY should be tuple with 2 float')
-
-        n = super().add_atom(atom, *args, charge=charge, is_radical=is_radical, **kwargs)
-        self._plane[n] = xy
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        if _skip_hydrogen_calculation:
-            self._hydrogens[n] = None
-        elif atom.atomic_number != 1:
-            try:
-                rules = atom.valence_rules(charge, is_radical, 0)
-            except ValenceError:
-                self._hydrogens[n] = None
-            else:
-                self._hydrogens[n] = rules[0][2]  # first rule without neighbors
-        else:
-            self._hydrogens[n] = 0
-        return n
-
-    def add_bond(self, n, m, bond: Union[Bond, int], *, _skip_hydrogen_calculation=False):
-        """
-        Connect atoms with bonds.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        if not isinstance(bond, Bond):
-            bond = Bond(bond)
-
-        bond._attach_graph(self, n, m)
-        super().add_bond(n, m, bond)
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        if _skip_hydrogen_calculation:  # skip stereo fixing too
-            return
-
-        self._calc_implicit(n)
-        self._calc_implicit(m)
-
-        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:  # not hydrogen
-            # fix stereo if formed not to hydrogen bond
-            self.fix_stereo()
-
-    def delete_atom(self, n: int):
-        """
-        Remove atom.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        ngb = self._bonds.pop(n)
-        fix = self._atoms.pop(n).atomic_number != 1 and ngb
-
-        del self._charges[n]
-        del self._radicals[n]
-        del self._hydrogens[n]
-        del self._plane[n]
-
-        for m in ngb:
-            del self._bonds[m][n]
-            self._calc_implicit(m)
-
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-        try:
-            del self._parsed_mapping[n]
-        except KeyError:
-            pass
-
-        if fix:  # hydrogen atom not used for stereo coding
-            self.fix_stereo()
-        self.flush_cache()
-
-    def delete_bond(self, n: int, m: int):
-        """
-        Disconnect atoms.
-
-        For Thiele forms of molecule causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-        """
-        del self._bonds[n][m]
-        del self._bonds[m][n]
-        self._conformers.clear()  # clean conformers. need full recalculation for new system
-
-        self._calc_implicit(n)
-        self._calc_implicit(m)
-
-        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:
-            self.fix_stereo()
-        self.flush_cache()
-
-    def remap(self, mapping: Dict[int, int], *, copy: bool = False) -> 'MoleculeContainer':
-        atoms = self._atoms  # keep original atoms dict
-        h = super().remap(mapping, copy=copy)
-
-        mg = mapping.get
-        sp = self._plane
-        shg = self._hydrogens
-
-        if copy:
-            h._MoleculeContainer__name = self.__name
-            if self.__meta is not None:
-                h._MoleculeContainer__meta = self.__meta.copy()
-            hb = h._bonds
-            hp = h._plane
-            hhg = h._hydrogens
-            hcf = h._conformers
-            hm = h._parsed_mapping
-
-            # deep copy of bonds
-            for n, m_bond in self._bonds.items():
-                n = mg(n, n)
-                hb[n] = hbn = {}
-                for m, bond in m_bond.items():
-                    m = mg(m, m)
-                    if m in hb:  # bond partially exists. need back-connection.
-                        hbn[m] = hb[m][n]
-                    else:
-                        hbn[m] = bond = bond.copy()
-                        bond._attach_graph(h, n, m)
-        else:
-            hb = {}
-            hp = {}
-            hhg = {}
-            hcf = []
-            hm = {}
-
-            for n, m_bond in self._bonds.items():
-                n = mg(n, n)
-                hb[n] = hbn = {}
-                for m, bond in m_bond.items():
-                    m = mg(m, m)
-                    if m in hb:  # bond partially exists. need back-connection.
-                        hbn[m] = hb[m][n]
-                    else:
-                        hbn[m] = bond
-                        bond._change_map(n, m)
-
-        for n in atoms:
-            m = mg(n, n)
-            hp[m] = sp[n]
-            hhg[m] = shg[n]
-
-        hcf.extend({mg(n, n): x for n, x in c.items()} for c in self._conformers)
-        for n, m in self._parsed_mapping.items():
-            hm[mg(n, n)] = m
-
-        if copy:
-            return h
-
-        self._bonds = hb
-        self._plane = hp
-        self._hydrogens = hhg
-        self._conformers = hcf
-        self._parsed_mapping = hm
-        return self
-
-    def copy(self) -> 'MoleculeContainer':
-        copy = super().copy()
-
-        copy._bonds = cb = {}
-        for n, m_bond in self._bonds.items():
-            cb[n] = cbn = {}
-            for m, bond in m_bond.items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                else:
-                    cbn[m] = bond = bond.copy()
-                    bond._attach_graph(copy, n, m)
-
-        copy._MoleculeContainer__name = self.__name
-        if self.__meta is None:
-            copy._MoleculeContainer__meta = None
-        else:
-            copy._MoleculeContainer__meta = self.__meta.copy()
-        copy._plane = self._plane.copy()
-        copy._hydrogens = self._hydrogens.copy()
-        copy._parsed_mapping = self._parsed_mapping.copy()
-        copy._conformers = [c.copy() for c in self._conformers]
-        copy._atoms_stereo = self._atoms_stereo.copy()
-        copy._allenes_stereo = self._allenes_stereo.copy()
-        copy._cis_trans_stereo = self._cis_trans_stereo.copy()
-        return copy
-
-    def union(self, other: 'MoleculeContainer', *, remap: bool = False, copy: bool = True) -> 'MoleculeContainer':
-        if not isinstance(other, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        u, o = super().union(other, remap=remap, copy=copy)
-
-        ub = u._bonds
-        for n, m_bond in o._bonds.items():
-            ub[n] = ubn = {}
-            for m, bond in m_bond.items():
-                if m in ub:  # bond partially exists. need back-connection.
-                    ubn[m] = ub[m][n]
-                else:
-                    ubn[m] = bond = bond.copy()
-                    bond._attach_graph(u, n, m)
-
-        u._MoleculeContainer__name = u._MoleculeContainer__meta = None
-        u._conformers.clear()
-        u._plane.update(o._plane)
-        u._hydrogens.update(o._hydrogens)
-        u._parsed_mapping.update(o._parsed_mapping)
-        return u
-
-    def substructure(self, atoms: Iterable[int], *, as_query: bool = False, recalculate_hydrogens=True,
-                     skip_neighbors_marks=False, skip_hybridizations_marks=False, skip_hydrogens_marks=False,
-                     skip_rings_sizes_marks=False, skip_heteroatoms_marks=False) -> \
-            Union['MoleculeContainer', 'QueryContainer']:
-        """
-        Create substructure containing atoms from atoms list.
-
-        For Thiele forms of molecule In Molecule substructure causes invalidation of internal state.
-        Implicit hydrogens marks will not be set if atoms in aromatic rings.
-        Call `kekule()` and `thiele()` in sequence to fix marks.
-
-        :param atoms: list of atoms numbers of substructure
-        :param as_query: return Query object based on graph substructure
-        :param recalculate_hydrogens: calculate implicit H count in substructure
-        :param skip_neighbors_marks: Don't set neighbors count marks on substructured queries
-        :param skip_hybridizations_marks: Don't set hybridizations marks on substructured queries
-        :param skip_hydrogens_marks: Don't set hydrogens count marks on substructured queries
-        :param skip_rings_sizes_marks: Don't set rings_sizes marks on substructured queries
-        :param skip_heteroatoms_marks: Don't set heteroatoms count marks
-        """
-        if not atoms:
-            raise ValueError('empty atoms list not allowed')
-        if set(atoms) - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        atoms = tuple(n for n in self._atoms if n in atoms)  # save original order
-        if as_query:
-            atom_type = QueryElement
-            bond_type = QueryBond
-            sub = object.__new__(QueryContainer)
-        else:
-            atom_type = Element
-            bond_type = Bond
-            sub = object.__new__(self.__class__)
-            sub._MoleculeContainer__name = sub._MoleculeContainer__meta = None
-
-        sa = self._atoms
-        sb = self._bonds
-        sc = self._charges
-        sr = self._radicals
-
-        sub._charges = {n: sc[n] for n in atoms}
-        sub._radicals = {n: sr[n] for n in atoms}
-
-        sub._atoms = ca = {}
-        for n in atoms:
-            ca[n] = atom = atom_type.from_atom(sa[n])
-            atom._attach_graph(sub, n)
-
-        sub._bonds = cb = {}
-        for n in atoms:
-            cb[n] = cbn = {}
-            for m, bond in sb[n].items():
-                if m in cb:  # bond partially exists. need back-connection.
-                    cbn[m] = cb[m][n]
-                elif m in atoms:
-                    cbn[m] = bond = bond_type.from_bond(bond)
-                    if not as_query:
-                        bond._attach_graph(sub, n, m)
-
-        if as_query:
-            lost = {n for n, a in sa.items() if a.atomic_number != 1} - set(atoms)  # atoms not in substructure
-            not_skin = {n for n in atoms if lost.isdisjoint(sb[n])}
-            sub._atoms_stereo = {n: s for n, s in self._atoms_stereo.items() if n in not_skin}
-            sub._allenes_stereo = {n: s for n, s in self._allenes_stereo.items()
-                                   if not_skin.issuperset(self._stereo_allenes_paths[n]) and
-                                      not_skin.issuperset(x for x in self._stereo_allenes[n] if x)}
-            sub._cis_trans_stereo = {nm: s for nm, s in self._cis_trans_stereo.items()
-                                     if not_skin.issuperset(self._stereo_cis_trans_paths[nm]) and
-                                        not_skin.issuperset(x for x in self._stereo_cis_trans[nm] if x)}
-
-            sub._masked = {n: False for n in atoms}
-            if skip_heteroatoms_marks:
-                sub._heteroatoms = {n: () for n in atoms}
-            else:
-                sha = self.heteroatoms
-                sub._heteroatoms = {n: (sha(n),) for n in atoms}
-
-            if skip_hybridizations_marks:
-                sub._hybridizations = {n: () for n in atoms}
-            else:
-                sh = self.hybridization
-                sub._hybridizations = {n: (sh(n),) for n in atoms}
-            if skip_neighbors_marks:
-                sub._neighbors = {n: () for n in atoms}
-            else:
-                sn = self.neighbors
-                sub._neighbors = {n: (sn(n),) for n in atoms}
-            if skip_hydrogens_marks:
-                sub._hydrogens = {n: () for n in atoms}
-            else:
-                shg = self._hydrogens
-                sub._hydrogens = {n: () if shg[n] is None else (shg[n],) for n in atoms}
-            if skip_rings_sizes_marks:
-                sub._rings_sizes = {n: () for n in atoms}
-            else:
-                rs = self.atoms_rings_sizes
-                sub._rings_sizes = {n: rs.get(n, ()) for n in atoms}
-        else:
-            sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
-
-            if recalculate_hydrogens:
-                sub._hydrogens = {}
-                for n in atoms:
-                    sub._calc_implicit(n)
-            else:
-                hg = self._hydrogens
-                sub._hydrogens = {n: hg[n] for n in atoms}
-
-            sp = self._plane
-            sub._plane = {n: sp[n] for n in atoms}
-            sub._parsed_mapping = {n: m for n, m in self._parsed_mapping.items() if n in atoms}
-
-            # fix_stereo will repair data
-            sub._atoms_stereo = self._atoms_stereo.copy()
-            sub._allenes_stereo = self._allenes_stereo.copy()
-            sub._cis_trans_stereo = self._cis_trans_stereo.copy()
-            sub.fix_stereo()
-        return sub
-
-    def augmented_substructure(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> 'MoleculeContainer':
-        """
-        Create substructure containing atoms and their neighbors
-
-        :param atoms: list of core atoms in graph
-        :param deep: number of bonds between atoms and neighbors
-        """
-        return self.substructure(self._augmented_substructure(atoms, deep)[-1], **kwargs)
-
-    def augmented_substructures(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> List['MoleculeContainer']:
-        """
-        Create list of substructures containing atoms and their neighbors
-
-        :param atoms: list of core atoms in graph
-        :param deep: number of bonds between atoms and neighbors
-        :return: list of graphs containing atoms, atoms + first circle, atoms + 1st + 2nd,
-            etc up to deep or while new nodes available
-        """
-        return [self.substructure(a, **kwargs) for a in self._augmented_substructure(atoms, deep)]
-
-    def split(self) -> List['MoleculeContainer']:
-        """
-        Split disconnected structure to connected substructures
-        """
-        return [self.substructure(c, recalculate_hydrogens=False) for c in self.connected_components]
-
-    def compose(self, other: 'MoleculeContainer') -> 'CGRContainer':
-        """
-        Compose 2 graphs to CGR.
-        """
-        if not isinstance(other, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        sa = self._atoms
-        sc = self._charges
-        sr = self._radicals
-        sb = self._bonds
-
-        bonds = []
-        adj = defaultdict(lambda: defaultdict(lambda: [None, None]))
-
-        oa = other._atoms
-        oc = other._charges
-        or_ = other._radicals
-        ob = other._bonds
-
-        common = sa.keys() & oa.keys()
-
-        h = CGRContainer()
-        ha = h._atoms
-        hb = h._bonds
-        hc = h._charges
-        hpc = h._p_charges
-        hr = h._radicals
-        hpr = h._p_radicals
-
-        for n in sa.keys() - common:  # cleavage atoms
-            hc[n] = hpc[n] = sc[n]
-            hr[n] = hpr[n] = sr[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(sa[n])
-            a._attach_graph(h, n)
-
-            for m, bond in sb[n].items():
-                if m not in ha:
-                    if m in common:  # bond to common atoms is broken bond
-                        bond = DynamicBond(bond.order, None)
-                    else:
-                        bond = DynamicBond(bond.order, bond.order)
-                    bonds.append((n, m, bond))
-        for n in oa.keys() - common:  # coupling atoms
-            hc[n] = hpc[n] = oc[n]
-            hr[n] = hpr[n] = or_[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(oa[n])
-            a._attach_graph(h, n)
-
-            for m, bond in ob[n].items():
-                if m not in ha:
-                    if m in common:  # bond to common atoms is formed bond
-                        bond = DynamicBond(None, bond.order)
-                    else:
-                        bond = DynamicBond(bond.order, bond.order)
-                    bonds.append((n, m, bond))
-        for n in common:
-            an = adj[n]
-            for m, bond in sb[n].items():
-                if m in common:
-                    an[m][0] = bond.order
-            for m, bond in ob[n].items():
-                if m in common:
-                    an[m][1] = bond.order
-        for n in common:
-            san = sa[n]
-            if san.atomic_number != oa[n].atomic_number or san.isotope != oa[n].isotope:
-                raise MappingError(f'atoms with number {n} not equal')
-
-            hc[n] = sc[n]
-            hpc[n] = oc[n]
-            hr[n] = sr[n]
-            hpr[n] = or_[n]
-            hb[n] = {}
-            ha[n] = a = DynamicElement.from_atom(san)
-            a._attach_graph(h, n)
-
-            for m, (o1, o2) in adj[n].items():
-                if m not in ha:
-                    bonds.append((n, m, DynamicBond(o1, o2)))
-
-        for n, m, bond in bonds:
-            hb[n][m] = hb[m][n] = bond
-        return h
-
-    def get_fast_mapping(self, other: 'MoleculeContainer') -> Optional[Dict[int, int]]:
-        """
-        Get self to other fast (suboptimal) structure mapping.
-        Only one possible atoms mapping returned.
-        Effective only for big molecules.
-        """
-        if isinstance(other, MoleculeContainer):
-            if len(self) != len(other):
-                return
-            so = self.smiles_atoms_order
-            oo = other.smiles_atoms_order
-            if self != other:
-                return
-            return dict(zip(so, oo))
-        raise TypeError('MoleculeContainer expected')
-
-    def pack(self, *, compressed=True, check=True, version=2, order: List[int] = None) -> bytes:
-        """
-        Pack into compressed bytes.
-
-        Note:
-
-        * Less than 4096 atoms supported. Atoms mapping should be in range 1-4095.
-        * Implicit hydrogens count should be in range 0-6 or unspecified.
-        * Isotope shift should be in range -15 - 15 relatively chython.files._mdl.mol.common_isotopes
-        * Atoms neighbors should be in range 0-15
-
-        Format V2 specification::
-
-            Big endian bytes order
-            8 bit - 0x02 (format specification version)
-            12 bit - number of atoms
-            12 bit - cis/trans stereo block size
-            Atom block 9 bytes (repeated):
-            12 bit - atom number
-            4 bit - number of neighbors
-            2 bit tetrahedron sign (00 - not stereo, 10 or 11 - has stereo)
-            2 bit - allene sign
-            5 bit - isotope (00000 - not specified, over = isotope - common_isotope + 16)
-            7 bit - atomic number (<=118)
-            32 bit - XY float16 coordinates
-            3 bit - hydrogens (0-7). Note: 7 == None
-            4 bit - charge (charge + 4. possible range -4 - 4)
-            1 bit - radical state
-            Connection table: flatten list of neighbors. neighbors count stored in atom block.
-            For example CC(=O)O - {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]} >> [2, 1, 3, 4, 2, 2].
-            Repeated block (equal to bonds count).
-            24 bit - paired 12 bit numbers.
-            Bonds order block 3 bit per bond zero-padded to full byte at the end.
-            Cis/trans data block (repeated):
-            24 bit - atoms pair
-            7 bit - zero padding. in future can be used for extra bond-level stereo, like atropoisomers.
-            1 bit - sign
-
-        Format V3 specification::
-
-            Big endian bytes order
-            8 bit - 0x03 (format specification version)
-            Atom block 3 bytes (repeated):
-            1 bit - atom entrance flag (always 1)
-            7 bit - atomic number (<=118)
-            3 bit - hydrogens (0-7). Note: 7 == None
-            4 bit - charge (charge + 4. possible range -4 - 4)
-            1 bit - radical state
-            1 bit padding
-            3 bit tetrahedron/allene sign
-                (000 - not stereo or unknown, 001 - pure-unknown-enantiomer, 010 or 011 - has stereo)
-            4 bit - number of following bonds and CT blocks (0-15)
-
-            Bond block 2 bytes (repeated 0-15 times)
-            12 bit - negative shift from current atom to connected (e.g. 0x001 = -1 - connected to previous atom)
-            4 bit - bond order: 0000 - single, 0001 - double, 0010 - triple, 0011 - aromatic, 0111 - special
-
-            Cis-Trans 2 bytes
-            12 bit - negative shift from current atom to connected (e.g. 0x001 = -1 - connected to previous atom)
-            4 bit - CT sign: 1000 or 1001 - to avoid overlap with bond
-
-        V2 format is faster than V3. V3 format doesn't include isotopes, atom numbers and XY coordinates.
-
-        :param compressed: return zlib-compressed pack.
-        :param check: check molecule for format restrictions.
-        :param version: format version
-        :param order: atom order in V3
-        """
-        from ._pack import pack
-
-        if check:
-            bonds = self._bonds
-            if not bonds:
-                raise ValueError('Empty molecules not supported')
-            if max(bonds) > 4095:
-                raise ValueError('Big molecules not supported')
-            if any(len(x) > 15 for x in bonds.values()):
-                raise ValueError('To many neighbors not supported')
-
-        if version == 2:
-            data = pack(self)
-        elif version == 3:
-            data = self._cpack(order, check)
-        else:
-            raise ValueError('invalid specification version')
-        if compressed:
-            return compress(data, 9)
-        return data
-
-    @classmethod
-    def pack_len(cls, data: bytes, /, *, compressed=True) -> int:
-        """
-        Returns atoms count in molecule pack.
-        """
-        if compressed:
-            data = decompress(data)
-        if data[0] not in (0, 2):
-            raise ValueError('invalid pack header')
-        return int.from_bytes(data[1:3], 'big') >> 4
-
-    @classmethod
-    def unpack(cls, data: Union[bytes, memoryview], /, *, compressed=True,
-               _return_pack_length=False) -> 'MoleculeContainer':
-        """
-        Unpack from compressed bytes.
-
-        :param compressed: decompress data before processing.
-        """
-        from ._unpack import unpack
-        from ._cpack import unpack as cpack
-
-        if compressed:
-            data = decompress(data)
-        if data[0] in (0, 2):
-            (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
-             atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length, bonds_flat) = unpack(data)
-        elif data[0] == 3:
-            (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
-             atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length, bonds_flat) = cpack(data)
-        else:
-            raise ValueError('invalid pack header')
-
-        mol = object.__new__(cls)
-        mol._bonds = bonds
-        mol._plane = plane
-        mol._charges = charges
-        mol._radicals = radicals
-        mol._hydrogens = hydrogens
-        mol._atoms_stereo = atoms_stereo
-        mol._allenes_stereo = allenes_stereo
-        mol._cis_trans_stereo = cis_trans_stereo
-
-        mol._conformers = []
-        mol._parsed_mapping = {}
-        mol._MoleculeContainer__meta = None
-        mol._MoleculeContainer__name = None
-        mol._atoms = atoms = {}
-
-        for n, a, i in zip(mapping, atom_numbers, isotopes):
-            atoms[n] = a = object.__new__(Element.from_atomic_number(a))
-            a._Core__isotope = i
-            a._graph = ref(mol)
-            a._n = n
-        for b in bonds_flat:
-            b._Bond__graph = ref(mol)
-
-        if _return_pack_length:
-            return mol, pack_length
-        return mol
-
-    def _cpack(self, order=None, check=True):
-        if order is None:
-            order = list(self._atoms)
-        elif check:
-            if not isinstance(order, (list, tuple)):
-                raise TypeError('invalid atoms order')
-            elif len(so := set(order)) != len(order) or not so.issubset(self._atoms):
-                raise ValueError('invalid atoms order')
-
-        atoms = self._atoms
-        bonds = self._bonds
-        charges = self._charges
-        radicals = self._radicals
-        hydrogens = self._hydrogens
-        atoms_stereo = self._atoms_stereo
-        allenes_stereo = self._allenes_stereo
-        allenes_terminals = self._stereo_allenes_terminals
-
-        cumulenes = {}
-        ct_map = {}
-        for n, m in self._cis_trans_stereo:
-            ct_map[n] = m
-            ct_map[m] = n
-            cumulenes[n] = [x for x, b in bonds[n].items() if b.order in (1, 4)]
-            cumulenes[m] = [x for x, b in bonds[m].items() if b.order in (1, 4)]
-
-        for c in self._allenes_stereo:
-            n, m = allenes_terminals[c]
-            cumulenes[n] = [x for x, b in bonds[n].items() if b.order in (1, 4)]
-            cumulenes[m] = [x for x, b in bonds[m].items() if b.order in (1, 4)]
-
-        seen = {}
-        data = [b'\x03']
-        for i, n in enumerate(order):
-            seen[n] = i
-            env = bonds[n]
-
-            data.append((0x80 | atoms[n].atomic_number).to_bytes(1, 'big'))
-
-            # 3 bit - hydrogens (0-6, None) | 4 bit - charge | 1 bit - radical
-            hcr = (charges[n] + 4) << 1 | radicals[n]
-            if (h := hydrogens[n]) is None:
-                hcr |= 0b11100000
-            else:
-                hcr |= h << 5
-            data.append(hcr.to_bytes(1, 'big'))
-
-            if n in atoms_stereo:
-                if self._translate_tetrahedron_sign(n, [x for x in order if x in env]):
-                    s = 0b0011_0000
-                else:
-                    s = 0b0010_0000
-            elif n in allenes_stereo:
-                t1, t2 = allenes_terminals[n]
-                nn = None
-                for x in order:
-                    if nn is None:
-                        if x in cumulenes[t1]:
-                            nn = x
-                            flag = True
-                        elif x in cumulenes[t2]:
-                            flag = False
-                            nn = x
-                    elif flag:  # noqa
-                        if x in cumulenes[t2]:
-                            nm = x
-                            break
-                    elif x in cumulenes[t1]:
-                        nm = x
-                        break
-                if self._translate_allene_sign(n, nn, nm):  # noqa
-                    s = 0b0011_0000
-                else:
-                    s = 0b0010_0000
-            else:
-                s = 0
-
-            tmp = []
-            for m in order[:i]:
-                if (b := env.get(m)) is not None:
-                    tmp.append(((i - seen[m]) << 4 | b.order - 1).to_bytes(2, 'big'))
-            if n in ct_map and (m := ct_map[n]) in seen:  # only right atom codes stereo sign
-                nm = None
-                for x in order:
-                    if nm is None:
-                        if x in cumulenes[n]:
-                            nm = x
-                            flag = True
-                        elif x in cumulenes[m]:
-                            nm = x
-                            flag = False
-                    elif flag:  # noqa
-                        if x in cumulenes[m]:
-                            nn = x
-                            break
-                    elif x in cumulenes[n]:
-                        nn = x
-                        break
-                if self._translate_cis_trans_sign(m, n, nm, nn):  # noqa
-                    cs = 0b1001
-                else:
-                    cs = 0b1000
-                tmp.append(((i - seen[m]) << 4 | cs).to_bytes(2, 'big'))
-
-            data.append((s | len(tmp)).to_bytes(1, 'big'))
-            data.extend(tmp)
-        return b''.join(data)
-
-    def _augmented_substructure(self, atoms: Iterable[int], deep: int):
-        atoms = set(atoms)
-        bonds = self._bonds
-        if atoms - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        nodes = [atoms]
-        for _ in range(deep):
-            n = {y for x in nodes[-1] for y in bonds[x]} | nodes[-1]
-            if n in nodes:
-                break
-            nodes.append(n)
-        return nodes
-
-    def _calc_implicit(self, n: int):
-        """
-        Set firs possible hydrogens count based on rules
-        """
-        atoms = self._atoms
-        atom = atoms[n]
-        if (an := atom.atomic_number) == 1:  # hydrogen nether has implicit H
-            self._hydrogens[n] = 0
-            return
-
-        charge: int = self._charges[n]
-        is_radical = self._radicals[n]
-        explicit_sum = 0
-        explicit_dict = defaultdict(int)
-        aroma = 0
-        for m, bond in self._bonds[n].items():
-            order = bond.order
-            if order == 4:  # only neutral carbon aromatic rings supported
-                if not charge and not is_radical and an == 6:
-                    aroma += 1
-                else:  # use `kekule()` to calculate proper implicit hydrogens count
-                    self._hydrogens[n] = None
-                    return
-            elif order != 8:  # any bond used for complexes
-                explicit_sum += order
-                explicit_dict[(order, atoms[m].atomic_number)] += 1
-
-        if aroma == 2:
-            if explicit_sum == 0:  # H-Ar
-                self._hydrogens[n] = 1
-            elif explicit_sum == 1:  # R-Ar
-                self._hydrogens[n] = 0
-            else:  # invalid aromaticity
-                self._hydrogens[n] = None
-            return
-        elif aroma == 3:  # condensed rings
-            if explicit_sum:  # invalid aromaticity
-                self._hydrogens[n] = None
-            else:
-                self._hydrogens[n] = 0
-            return
-        elif aroma:
-            self._hydrogens[n] = None
-            return
-
-        try:
-            rules = atom.valence_rules(charge, is_radical, explicit_sum)
-        except ValenceError:
-            self._hydrogens[n] = None
-            return
-        for s, d, h in rules:
-            if s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
-                self._hydrogens[n] = h
-                return
-        self._hydrogens[n] = None  # rule not found
-
-    def _check_implicit(self, n: int, h: int) -> bool:
-        atoms = self._atoms
-        atom = atoms[n]
-        if atom.atomic_number == 1:  # hydrogen nether has implicit H
-            return h == 0
-
-        explicit_sum = 0
-        explicit_dict = defaultdict(int)
-
-        for m, bond in self._bonds[n].items():
-            order = bond.order
-            if order == 4:  # can't check aromatic rings
-                return False
-            elif order != 8:  # any bond used for complexes
-                explicit_sum += order
-                explicit_dict[(order, atoms[m].atomic_number)] += 1
-
-        try:
-            rules = atom.valence_rules(self._charges[n], self._radicals[n], explicit_sum)
-        except ValenceError:
-            return False
-        for s, d, _h in rules:
-            if h == _h and s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
-                return True
-        return False
-
-    def __int__(self):
-        """
-        Total charge of molecule
-        """
-        return self.molecular_charge
-
-    def __float__(self):
-        return self.molecular_mass
-
-    def __xor__(self, other):
-        """
-        G ^ H is CGR generation
-        """
-        return self.compose(other)
-
-    def __and__(self, other: Iterable[int]):
-        """
-        Substructure of graph with given nodes.
-        """
-        return self.substructure(other)
-
-    def __sub__(self, other: Iterable[int]):
-        """
-        Given nodes excluded substructure of graph.
-        """
-        atoms = set(other)
-        if atoms - self._atoms.keys():
-            raise ValueError('invalid atom numbers')
-        atoms = self._atoms.keys() - atoms
-        if atoms:
-            return self.substructure(atoms)
-        raise ValueError('full substitution not allowed')
-
-    def __enter__(self):
-        """
-        Transaction of changes. Keep current state for restoring on errors.
-        """
-        atoms = {}
-        for n, atom in self._atoms.items():
-            atom = atom.copy()
-            atoms[n] = atom
-            atom._attach_graph(self, n)
-
-        bonds = {}
-        for n, m_bond in self._bonds.items():
-            bonds[n] = cbn = {}
-            for m, bond in m_bond.items():
-                if m in bonds:  # bond partially exists. need back-connection.
-                    cbn[m] = bonds[m][n]
-                else:
-                    cbn[m] = bond = bond.copy()
-                    bond._attach_graph(self, n, m)
-
-        self._backup = {'atoms': atoms, 'bonds': bonds, 'parsed_mapping': self._parsed_mapping.copy(),
-                        'plane': self._plane.copy(), 'charges': self._charges.copy(), 'radicals': self._radicals.copy(),
-                        'hydrogens': self._hydrogens.copy(), 'conformers': [x.copy() for x in self._conformers],
-                        'atoms_stereo': self._atoms_stereo.copy(), 'allenes_stereo': self._allenes_stereo.copy(),
-                        'cis_trans_stereo': self._cis_trans_stereo.copy()}
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        if exc_type:  # restore state
-            backup = self._backup
-            self._atoms = backup['atoms']
-            self._bonds = backup['bonds']
-            self._parsed_mapping = backup['parsed_mapping']
-            self._plane = backup['plane']
-            self._charges = backup['charges']
-            self._radicals = backup['radicals']
-            self._hydrogens = backup['hydrogens']
-            self._conformers = backup['conformers']
-            self._atoms_stereo = backup['atoms_stereo']
-            self._allenes_stereo = backup['allenes_stereo']
-            self._cis_trans_stereo = backup['cis_trans_stereo']
-            self.flush_cache()
-        del self._backup
-
-    def __getstate__(self):
-        return {'conformers': self._conformers, 'hydrogens': self._hydrogens, 'atoms_stereo': self._atoms_stereo,
-                'allenes_stereo': self._allenes_stereo, 'cis_trans_stereo': self._cis_trans_stereo,
-                'parsed_mapping': self._parsed_mapping, 'meta': self.__meta, 'name': self.__name,
-                'plane': self._plane, **super().__getstate__()}
-
-    def __setstate__(self, state):
-        super().__setstate__(state)
-        self._conformers = state['conformers']
-        self._atoms_stereo = state['atoms_stereo']
-        self._allenes_stereo = state['allenes_stereo']
-        self._cis_trans_stereo = state['cis_trans_stereo']
-        self._hydrogens = state['hydrogens']
-        self._parsed_mapping = state['parsed_mapping']
-        self._plane = state['plane']
-        self.__meta = state['meta']
-        self.__name = state['name']
-
-        # attach bonds to graph
-        for n, m, b in self.bonds():
-            b._attach_graph(self, n, m)
-
-
-__all__ = ['MoleculeContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from array import array
+from CachedMethods import cached_args_method
+from collections import Counter, defaultdict
+from functools import cached_property
+from itertools import zip_longest
+from math import ceil
+from numpy import uint, zeros
+from struct import pack_into, unpack_from
+from typing import Dict, Iterable, List, Optional, Set, Tuple, Union
+from weakref import ref
+from zlib import compress, decompress
+from . import cgr, query  # cyclic imports resolve
+from .bonds import Bond, DynamicBond, QueryBond
+from .graph import Graph
+from ..algorithms.aromatics import Aromatize
+from ..algorithms.calculate2d import Calculate2DMolecule
+from ..algorithms.depict import DepictMolecule
+from ..algorithms.fingerprints import Fingerprints
+from ..algorithms.huckel import Huckel
+from ..algorithms.mcs import MCS
+from ..algorithms.smiles import MoleculeSmiles
+from ..algorithms.standardize import StandardizeMolecule
+from ..algorithms.stereo import MoleculeStereo
+from ..algorithms.tautomers import Tautomers
+from ..algorithms.x3dom import X3domMolecule
+from ..exceptions import MappingError, ValenceError
+from ..periodictable import DynamicElement, Element, QueryElement
+
+
+class MoleculeContainer(MoleculeStereo, Graph[Element, Bond], Aromatize, StandardizeMolecule, MoleculeSmiles,
+                        DepictMolecule, Calculate2DMolecule, Fingerprints, Tautomers, MCS, Huckel, X3domMolecule):
+    __slots__ = ('_conformers', '_atoms_stereo', '_hydrogens', '_cis_trans_stereo', '_allenes_stereo',
+                 '_parsed_mapping', '_backup', '__meta', '__name')
+
+    def __init__(self):
+        super().__init__()
+        self._conformers: List[Dict[int, Tuple[float, float, float]]] = []
+        self._hydrogens: Dict[int, Optional[int]] = {}
+        self._atoms_stereo: Dict[int, bool] = {}
+        self._allenes_stereo: Dict[int, bool] = {}
+        self._cis_trans_stereo: Dict[Tuple[int, int], bool] = {}
+        self._parsed_mapping: Dict[int, int] = {}
+        self.__meta = None
+        self.__name = None
+
+    @property
+    def meta(self) -> Dict:
+        if self.__meta is None:
+            self.__meta = {}  # lazy
+        return self.__meta
+
+    @property
+    def name(self) -> str:
+        return self.__name or ''
+
+    @name.setter
+    def name(self, name):
+        if not isinstance(name, str):
+            raise TypeError('name should be string up to 80 symbols')
+        self.__name = name
+
+    @cached_args_method
+    def environment(self, atom: int, include_bond: bool = True, include_atom: bool = True) -> \
+            Tuple[Union[Tuple[int, Bond, Element],
+                        Tuple[int, Element],
+                        Tuple[int, Bond],
+                        int], ...]:
+        """
+        groups of (atom_number, bond, atom) connected to atom or
+        groups of (atom_number, bond) connected to atom or
+        groups of (atom_number, atom) connected to atom or
+        neighbors atoms connected to atom
+
+        :param atom: number
+        :param include_atom: include atom object
+        :param include_bond: include bond object
+        """
+        if include_atom:
+            atoms = self._atoms
+            if include_bond:
+                return tuple((n, bond, atoms[n]) for n, bond in self._bonds[atom].items())
+            return tuple((n, atoms[n]) for n in self._bonds[atom])
+        elif include_bond:
+            return tuple(self._bonds[atom].items())
+        return tuple(self._bonds[atom])
+
+    @cached_args_method
+    def neighbors(self, n: int) -> int:
+        """number of neighbors atoms excluding any-bonded"""
+        return sum(b.order != 8 for b in self._bonds[n].values())
+
+    @cached_args_method
+    def hybridization(self, n: int) -> int:
+        """
+        Atom hybridization.
+
+        1 - if atom has zero or only single bonded neighbors, 2 - if has only one double bonded neighbor and any amount
+        of single bonded, 3 - if has one triple bonded and any amount of double and single bonded neighbors or
+        two and more double bonded and any amount of single bonded neighbors, 4 - if atom in aromatic ring.
+        """
+        hybridization = 1
+        for bond in self._bonds[n].values():
+            order = bond.order
+            if order == 4:
+                return 4
+            elif order == 3:
+                if hybridization != 3:
+                    hybridization = 3
+            elif order == 2:
+                if hybridization == 1:
+                    hybridization = 2
+                elif hybridization == 2:
+                    hybridization = 3
+        return hybridization
+
+    @cached_args_method
+    def heteroatoms(self, n: int) -> int:
+        """
+        Number of neighbored heteroatoms (not carbon or hydrogen)
+        """
+        atoms = self._atoms
+        return sum(atoms[m].atomic_number not in (1, 6) for m in self._bonds[n])
+
+    def implicit_hydrogens(self, n: int) -> Optional[int]:
+        """
+        Number of implicit hydrogen atoms connected to atom.
+
+        Returns None if count are ambiguous.
+        """
+        return self._hydrogens[n]
+
+    @cached_args_method
+    def explicit_hydrogens(self, n: int) -> int:
+        """
+        Number of explicit hydrogen atoms connected to atom.
+
+        Take into account any type of bonds with hydrogen atoms.
+        """
+        atoms = self._atoms
+        return sum(atoms[m].atomic_number == 1 for m in self._bonds[n])
+
+    @cached_args_method
+    def total_hydrogens(self, n: int) -> int:
+        """
+        Number of hydrogen atoms connected to atom.
+
+        Take into account any type of bonds with hydrogen atoms.
+        """
+        return self._hydrogens[n] + self.explicit_hydrogens(n)
+
+    def adjacency_matrix(self, set_bonds=False):
+        """
+        Adjacency matrix of Graph.
+
+        :param set_bonds: if True set bond orders instead of 1.
+        """
+        adj = zeros((len(self), len(self)), dtype=uint)
+        mapping = {n: x for x, n in enumerate(self._atoms)}
+        if set_bonds:
+            for n, ms in self._bonds.items():
+                n = mapping[n]
+                for m, b in ms.items():
+                    adj[n, mapping[m]] = int(b)
+        else:
+            for n, ms in self._bonds.items():
+                n = mapping[n]
+                for m, b in ms.items():
+                    adj[n, mapping[m]] = 1
+        return adj
+
+    @cached_property
+    def molecular_charge(self) -> int:
+        """
+        Total charge of molecule
+        """
+        return sum(self._charges.values())
+
+    @cached_property
+    def is_radical(self) -> bool:
+        """
+        True if at least one atom is radical
+        """
+        return any(self._radicals.values())
+
+    @cached_property
+    def molecular_mass(self) -> float:
+        return sum(x.atomic_mass for x in self._atoms.values())
+
+    @cached_property
+    def brutto(self) -> Dict[str, int]:
+        """Counted atoms dict"""
+        return Counter(x.atomic_symbol for x in self._atoms.values())
+
+    def add_atom(self, atom: Union[Element, int, str], *args, charge=0, is_radical=False, **kwargs):
+        """
+        Add new atom.
+        """
+        if not isinstance(atom, Element):
+            if isinstance(atom, str):
+                atom = Element.from_symbol(atom)()
+            elif isinstance(atom, int):
+                atom = Element.from_atomic_number(atom)()
+            else:
+                raise TypeError('Element object expected')
+
+        _map = super().add_atom(atom, *args, charge=charge, is_radical=is_radical, **kwargs)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        if atom.atomic_number != 1:
+            try:
+                rules = atom.valence_rules(charge, is_radical, 0)
+            except ValenceError:
+                self._hydrogens[_map] = None
+            else:
+                self._hydrogens[_map] = rules[0][2]  # first rule without neighbors
+        else:
+            self._hydrogens[_map] = 0
+        return _map
+
+    def add_bond(self, n, m, bond: Union[Bond, int]):
+        """
+        Connect atoms with bonds.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        if not isinstance(bond, Bond):
+            bond = Bond(bond)
+
+        super().add_bond(n, m, bond)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        self._calc_implicit(n)
+        self._calc_implicit(m)
+
+        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:  # not hydrogen
+            # fix stereo if formed not to hydrogen bond
+            self.fix_stereo()
+
+    def delete_atom(self, n):
+        """
+        Remove atom.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        old_bonds = self._bonds[n]  # save bonds
+        isnt_hydrogen = self._atoms[n].atomic_number != 1
+        super().delete_atom(n)
+
+        del self._hydrogens[n]
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+        try:
+            del self._parsed_mapping[n]
+        except KeyError:
+            pass
+
+        for m in old_bonds:
+            self._calc_implicit(m)
+
+        if isnt_hydrogen:  # hydrogen atom not used for stereo coding
+            self.fix_stereo()
+
+    def delete_bond(self, n, m):
+        """
+        Disconnect atoms.
+
+        For Thiele forms of molecule causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+        """
+        super().delete_bond(n, m)
+        self._conformers.clear()  # clean conformers. need full recalculation for new system
+
+        self._calc_implicit(n)
+        self._calc_implicit(m)
+
+        if self._atoms[n].atomic_number != 1 and self._atoms[m].atomic_number != 1:
+            self.fix_stereo()
+
+    def remap(self, mapping: Dict[int, int], *, copy: bool = False) -> 'MoleculeContainer':
+        if len(mapping) != len(set(mapping.values())) or \
+                not (self._atoms.keys() - mapping.keys()).isdisjoint(mapping.values()):
+            raise ValueError('mapping overlap')
+
+        mg = mapping.get
+        sp = self._plane
+        sc = self._charges
+        sr = self._radicals
+        shg = self._hydrogens
+
+        if copy:
+            h = self.__class__()
+            h._MoleculeContainer__name = self.__name
+            if self.__meta is not None:
+                h._MoleculeContainer__meta = self.__meta.copy()
+            hb = h._bonds
+            ha = h._atoms
+            hc = h._charges
+            hr = h._radicals
+            hp = h._plane
+            hhg = h._hydrogens
+            hcf = h._conformers
+            has = h._atoms_stereo
+            hal = h._allenes_stereo
+            hcs = h._cis_trans_stereo
+            hm = h._parsed_mapping
+
+            for n, atom in self._atoms.items():
+                m = mg(n, n)
+                atom = atom.copy()
+                ha[m] = atom
+                atom._attach_to_graph(h, m)
+
+            # deep copy of bonds
+            for n, m_bond in self._bonds.items():
+                n = mg(n, n)
+                hb[n] = hbn = {}
+                for m, bond in m_bond.items():
+                    m = mg(m, m)
+                    if m in hb:  # bond partially exists. need back-connection.
+                        hbn[m] = hb[m][n]
+                    else:
+                        hbn[m] = bond.copy()
+        else:
+            hb = {}
+            ha = {}
+            hc = {}
+            hr = {}
+            hp = {}
+            hhg = {}
+            hcf = []
+            has = {}
+            hal = {}
+            hcs = {}
+            hm = {}
+            for n, atom in self._atoms.items():
+                m = mg(n, n)
+                ha[m] = atom
+                atom._change_map(m)  # change mapping number
+
+            for n, m_bond in self._bonds.items():
+                hb[mg(n, n)] = {mg(m, m): b for m, b in m_bond.items()}
+
+        for n in self._atoms:
+            m = mg(n, n)
+            hc[m] = sc[n]
+            hr[m] = sr[n]
+            hp[m] = sp[n]
+            hhg[m] = shg[n]
+
+        hcf.extend({mg(n, n): x for n, x in c.items()} for c in self._conformers)
+        for n, m in self._parsed_mapping.items():
+            hm[mg(n, n)] = m
+        for n, stereo in self._atoms_stereo.items():
+            has[mg(n, n)] = stereo
+        for n, stereo in self._allenes_stereo.items():
+            hal[mg(n, n)] = stereo
+        for (n, m), stereo in self._cis_trans_stereo.items():
+            hcs[(mg(n, n), mg(m, m))] = stereo
+
+        if copy:
+            return h
+
+        self._atoms = ha
+        self._bonds = hb
+        self._charges = hc
+        self._radicals = hr
+        self._plane = hp
+        self._hydrogens = hhg
+        self._conformers = hcf
+        self._atoms_stereo = has
+        self._allenes_stereo = hal
+        self._cis_trans_stereo = hcs
+        self._parsed_mapping = hm
+        self.flush_cache()
+        return self
+
+    def copy(self) -> 'MoleculeContainer':
+        copy = super().copy()
+        copy._MoleculeContainer__name = self.__name
+        if self.__meta is None:
+            copy._MoleculeContainer__meta = None
+        else:
+            copy._MoleculeContainer__meta = self.__meta.copy()
+        copy._hydrogens = self._hydrogens.copy()
+        copy._parsed_mapping = self._parsed_mapping.copy()
+        copy._conformers = [c.copy() for c in self._conformers]
+        copy._atoms_stereo = self._atoms_stereo.copy()
+        copy._allenes_stereo = self._allenes_stereo.copy()
+        copy._cis_trans_stereo = self._cis_trans_stereo.copy()
+        return copy
+
+    def union(self, other: 'MoleculeContainer', *, remap=False) -> 'MoleculeContainer':
+        """
+        :param remap: if atoms has collisions then remap other graph atoms else raise exception.
+        """
+        if not isinstance(other, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        elif self._atoms.keys() & other._atoms.keys():
+            if remap:
+                other = other.remap({n: i for i, n in enumerate(other, start=max(self._atoms) + 1)}, copy=True)
+            else:
+                raise MappingError('mapping of graphs is not disjoint')
+        u = super().union(other)
+        u._MoleculeContainer__name = u._MoleculeContainer__meta = None
+        u._conformers.clear()
+        u._hydrogens.update(other._hydrogens)
+        u._parsed_mapping.update(other._parsed_mapping)
+        u._atoms_stereo.update(other._atoms_stereo)
+        u._allenes_stereo.update(other._allenes_stereo)
+        u._cis_trans_stereo.update(other._cis_trans_stereo)
+        return u
+
+    def substructure(self, atoms: Iterable[int], *, as_query: bool = False, recalculate_hydrogens=True,
+                     skip_neighbors_marks=False, skip_hybridizations_marks=False, skip_hydrogens_marks=False,
+                     skip_rings_sizes_marks=False,) -> Union['MoleculeContainer', 'query.QueryContainer']:
+        """
+        Create substructure containing atoms from atoms list.
+
+        For Thiele forms of molecule In Molecule substructure causes invalidation of internal state.
+        Implicit hydrogens marks will not be set if atoms in aromatic rings.
+        Call `kekule()` and `thiele()` in sequence to fix marks.
+
+        :param atoms: list of atoms numbers of substructure
+        :param as_query: return Query object based on graph substructure
+        :param recalculate_hydrogens: calculate implicit H count in substructure
+        :param skip_neighbors_marks: Don't set neighbors count marks on substructured queries
+        :param skip_hybridizations_marks: Don't set hybridizations marks on substructured queries
+        :param skip_hydrogens_marks: Don't set hydrogens count marks on substructured queries
+        :param skip_rings_sizes_marks: Don't set rings_sizes marks on substructured queries
+        """
+        if not atoms:
+            raise ValueError('empty atoms list not allowed')
+        if set(atoms) - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        atoms = tuple(n for n in self._atoms if n in atoms)  # save original order
+        if as_query:
+            atom_type = QueryElement
+            bond_type = QueryBond
+            sub = object.__new__(query.QueryContainer)
+        else:
+            atom_type = Element
+            bond_type = Bond
+            sub = object.__new__(self.__class__)
+            sub._MoleculeContainer__name = sub._MoleculeContainer__meta = None
+
+        sa = self._atoms
+        sb = self._bonds
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+
+        sub._charges = {n: sc[n] for n in atoms}
+        sub._radicals = {n: sr[n] for n in atoms}
+        sub._plane = {n: sp[n] for n in atoms}
+
+        sub._atoms = ca = {}
+        for n in atoms:
+            ca[n] = atom = atom_type.from_atom(sa[n])
+            atom._attach_to_graph(sub, n)
+
+        sub._bonds = cb = {}
+        for n in atoms:
+            cb[n] = cbn = {}
+            for m, bond in sb[n].items():
+                if m in cb:  # bond partially exists. need back-connection.
+                    cbn[m] = cb[m][n]
+                elif m in atoms:
+                    cbn[m] = bond_type.from_bond(bond)
+
+        if as_query:
+            lost = {n for n, a in sa.items() if a.atomic_number != 1} - set(atoms)  # atoms not in substructure
+            not_skin = {n for n in atoms if lost.isdisjoint(sb[n])}
+            sub._atoms_stereo = {n: s for n, s in self._atoms_stereo.items() if n in not_skin}
+            sub._allenes_stereo = {n: s for n, s in self._allenes_stereo.items()
+                                   if not_skin.issuperset(self._stereo_allenes_paths[n]) and
+                                      not_skin.issuperset(x for x in self._stereo_allenes[n] if x)}
+            sub._cis_trans_stereo = {nm: s for nm, s in self._cis_trans_stereo.items()
+                                     if not_skin.issuperset(self._stereo_cis_trans_paths[nm]) and
+                                        not_skin.issuperset(x for x in self._stereo_cis_trans[nm] if x)}
+
+            sub._heteroatoms = {n: () for n in atoms}
+
+            if skip_hybridizations_marks:
+                sub._hybridizations = {n: () for n in atoms}
+            else:
+                sh = self.hybridization
+                sub._hybridizations = {n: (sh(n),) for n in atoms}
+            if skip_neighbors_marks:
+                sub._neighbors = {n: () for n in atoms}
+            else:
+                sn = self.neighbors
+                sub._neighbors = {n: (sn(n),) for n in atoms}
+            if skip_hydrogens_marks:
+                sub._hydrogens = {n: () for n in atoms}
+            else:
+                shg = self._hydrogens
+                sub._hydrogens = {n: () if shg[n] is None else (shg[n],) for n in atoms}
+            if skip_rings_sizes_marks:
+                sub._rings_sizes = {n: () for n in atoms}
+            else:
+                rs = self.atoms_rings_sizes
+                sub._rings_sizes = {n: rs.get(n, ()) for n in atoms}
+        else:
+            sub._conformers = [{n: c[n] for n in atoms} for c in self._conformers]
+
+            if recalculate_hydrogens:
+                sub._hydrogens = {}
+                for n in atoms:
+                    sub._calc_implicit(n)
+            else:
+                hg = self._hydrogens
+                sub._hydrogens = {n: hg[n] for n in atoms}
+
+            sub._parsed_mapping = {n: m for n, m in self._parsed_mapping.items() if n in atoms}
+
+            # fix_stereo will repair data
+            sub._atoms_stereo = self._atoms_stereo.copy()
+            sub._allenes_stereo = self._allenes_stereo.copy()
+            sub._cis_trans_stereo = self._cis_trans_stereo.copy()
+            sub.fix_stereo()
+        return sub
+
+    def augmented_substructure(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> 'MoleculeContainer':
+        """
+        Create substructure containing atoms and their neighbors
+
+        :param atoms: list of core atoms in graph
+        :param deep: number of bonds between atoms and neighbors
+        """
+        return self.substructure(self._augmented_substructure(atoms, deep)[-1], **kwargs)
+
+    def augmented_substructures(self, atoms: Iterable[int], deep: int = 1, **kwargs) -> List['MoleculeContainer']:
+        """
+        Create list of substructures containing atoms and their neighbors
+
+        :param atoms: list of core atoms in graph
+        :param deep: number of bonds between atoms and neighbors
+        :return: list of graphs containing atoms, atoms + first circle, atoms + 1st + 2nd,
+            etc up to deep or while new nodes available
+        """
+        return [self.substructure(a, **kwargs) for a in self._augmented_substructure(atoms, deep)]
+
+    def split(self) -> List['MoleculeContainer']:
+        """
+        Split disconnected structure to connected substructures
+        """
+        return [self.substructure(c, recalculate_hydrogens=False) for c in self.connected_components]
+
+    def compose(self, other: 'MoleculeContainer') -> 'cgr.CGRContainer':
+        """
+        Compose 2 graphs to CGR.
+        """
+        if not isinstance(other, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        sa = self._atoms
+        sc = self._charges
+        sr = self._radicals
+        sp = self._plane
+        sb = self._bonds
+
+        bonds = []
+        adj = defaultdict(lambda: defaultdict(lambda: [None, None]))
+
+        oa = other._atoms
+        oc = other._charges
+        or_ = other._radicals
+        op = other._plane
+        ob = other._bonds
+
+        common = sa.keys() & oa.keys()
+
+        h = cgr.CGRContainer()
+        ha = h._atoms
+        hb = h._bonds
+        hc = h._charges
+        hpc = h._p_charges
+        hr = h._radicals
+        hpr = h._p_radicals
+        hp = h._plane
+
+        for n in sa.keys() - common:  # cleavage atoms
+            hc[n] = hpc[n] = sc[n]
+            hr[n] = hpr[n] = sr[n]
+            hp[n] = sp[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(sa[n])
+            a._attach_to_graph(h, n)
+
+            for m, bond in sb[n].items():
+                if m not in ha:
+                    if m in common:  # bond to common atoms is broken bond
+                        bond = DynamicBond(bond.order, None)
+                    else:
+                        bond = DynamicBond(bond.order, bond.order)
+                    bonds.append((n, m, bond))
+        for n in oa.keys() - common:  # coupling atoms
+            hc[n] = hpc[n] = oc[n]
+            hr[n] = hpr[n] = or_[n]
+            hp[n] = op[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(oa[n])
+            a._attach_to_graph(h, n)
+
+            for m, bond in ob[n].items():
+                if m not in ha:
+                    if m in common:  # bond to common atoms is formed bond
+                        bond = DynamicBond(None, bond.order)
+                    else:
+                        bond = DynamicBond(bond.order, bond.order)
+                    bonds.append((n, m, bond))
+        for n in common:
+            an = adj[n]
+            for m, bond in sb[n].items():
+                if m in common:
+                    an[m][0] = bond.order
+            for m, bond in ob[n].items():
+                if m in common:
+                    an[m][1] = bond.order
+        for n in common:
+            san = sa[n]
+            if san.atomic_number != oa[n].atomic_number or san.isotope != oa[n].isotope:
+                raise MappingError(f'atoms with number {{{n}}} not equal')
+
+            hc[n] = sc[n]
+            hpc[n] = oc[n]
+            hr[n] = sr[n]
+            hpr[n] = or_[n]
+            hp[n] = sp[n]
+            hb[n] = {}
+            ha[n] = a = DynamicElement.from_atom(san)
+            a._attach_to_graph(h, n)
+
+            for m, (o1, o2) in adj[n].items():
+                if m not in ha:
+                    bonds.append((n, m, DynamicBond(o1, o2)))
+
+        for n, m, bond in bonds:
+            hb[n][m] = hb[m][n] = bond
+        return h
+
+    def get_fast_mapping(self, other: 'MoleculeContainer') -> Optional[Dict[int, int]]:
+        """
+        Get self to other fast (suboptimal) structure mapping.
+        Only one possible atoms mapping returned.
+        Effective only for big molecules.
+        """
+        if isinstance(other, MoleculeContainer):
+            if len(self) != len(other):
+                return
+            so = self.smiles_atoms_order
+            oo = other.smiles_atoms_order
+            if self != other:
+                return
+            return dict(zip(so, oo))
+        raise TypeError('MoleculeContainer expected')
+
+    def get_mapping(self, other: 'MoleculeContainer', /, **kwargs):
+        if isinstance(other, MoleculeContainer):
+            return super().get_mapping(other, **kwargs)
+        raise TypeError('MoleculeContainer expected')
+
+    def pack(self, *, compressed=True) -> bytes:
+        """
+        Pack into compressed bytes.
+        Note:
+            * Less than 4096 atoms supported. Atoms mapping should be in range 1-4095.
+            * Implicit hydrogens count should be in range 0-6 or unspecified.
+            * Isotope shift should be in range -15 - 15 relatively mdl.common_isotopes
+            * Atoms neighbors should be in range 0-15
+
+        Format specification:
+        Big endian bytes order
+        8 bit - empty byte for future extending
+        12 bit - number of atoms
+        12 bit - cis/trans stereo block size
+        Atom block 9 bytes (repeated):
+        12 bit - atom number
+        4 bit - number of neighbors
+        2 bit tetrahedron sign (00 - not stereo, 10 or 11 - has stereo)
+        2 bit - allene sign
+        5 bit - isotope (00000 - not specified, over = isotope - common_isotope + 16)
+        7 bit - atomic number (<=118)
+        32 bit - XY float16 coordinates
+        3 bit - hydrogens (0-7). Note: 7 == None
+        4 bit - charge (charge + 4. possible range -4 - 4)
+        1 bit - radical state
+        Connection table: flatten list of neighbors. neighbors count stored in atom block.
+        For example CC(=O)O - {1: [2], 2: [1, 3, 4], 3: [2], 4: [2]} >> [2, 1, 3, 4, 2, 2].
+        Repeated block (equal to bonds count).
+        24 bit - paired 12 bit numbers.
+        Bonds order block (repeated):
+        16 bit - 5 bonds grouped (3 bit each). 1 bit unused. Zero padding used than bonds count not proportional to 5.
+        Cis/trans data block (repeated):
+        24 bit - atoms pair
+        7 bit - zero padding. in future can be used for extra bond-level stereo, like atropoisomers.
+        1 bit - sign
+
+        :param compressed: return zlib-compressed pack.
+        """
+        bonds = self._bonds
+        if max(bonds) > 4095:
+            raise ValueError('Big molecules not supported')
+        if any(len(x) > 15 for x in bonds.values()):
+            raise ValueError('To many neighbors not supported')
+        from ..files._mdl.mol import common_isotopes
+
+        plane = self._plane
+        charges = self._charges
+        radicals = self._radicals
+        hydrogens = self._hydrogens
+        atoms_stereo = self._atoms_stereo
+        allenes_stereo = self._allenes_stereo
+        cis_trans_stereo = self._cis_trans_stereo
+
+        data = bytearray(4 +  # extension byte + atoms count + cis/trans bit
+                         9 * self.atoms_count +  # atoms data
+                         3 * self.bonds_count +  # connection table
+                         2 * ceil(self.bonds_count / 5) +  # bonds order
+                         4 * len(cis_trans_stereo))
+        pack_into('>HB', data, 1, (self.atoms_count << 4) | (len(cis_trans_stereo) >> 8), len(cis_trans_stereo) & 0xff)
+        shift = 4
+
+        neighbors = []
+        bonds_pack = []
+        seen = set()
+        hold = []
+        for o, (n, a) in enumerate(self._atoms.items()):
+            bs = bonds[n]
+            neighbors.extend(bs)
+            seen.add(n)
+            for m, b in bs.items():
+                if m not in seen:
+                    bonds_pack.append(b.order - 1)  # 8 - 4 bit, but 7 - 3 bit
+
+            # 3 bit - hydrogens (0-7) | 4 bit - charge | 1 bit - radical
+            hcr = (charges[n] + 4) << 1
+            if radicals[n]:
+                hcr |= 1
+            if (h := hydrogens[n]) is None:
+                hcr |= 224
+            else:
+                hcr |= h << 5
+
+            # 2 bit tetrahedron sign | 2 bit - allene sign | 5 bit - isotope | 7 bit - atomic number (<=118)
+            sia = a.atomic_number
+            if a.isotope:
+                sia |= (a.isotope - common_isotopes[a.atomic_symbol] + 16) << 7
+
+            if n in atoms_stereo:
+                if atoms_stereo[n]:
+                    sia |= 0xc000
+                else:
+                    sia |= 0x8000
+            if n in allenes_stereo:
+                if allenes_stereo[n]:
+                    sia |= 0x3000
+                else:
+                    sia |= 0x2000
+
+            hold.append((shift + 9 * o, (n << 4) | len(bs), sia, *plane[n], hcr))
+
+        shift += 9 * self.atoms_count + 3 * self.bonds_count - 4
+        ngb = iter(reversed(neighbors))
+        for o, (n2, n1) in enumerate(zip_longest(ngb, ngb)):
+            # 12 bit + 12 bit
+            pack_into('>I', data, shift - 3 * o, (n1 << 12) | n2)
+
+        # pack after connection table for preventing override!
+        for x in hold:
+            pack_into('>2H2eB', data, *x)
+
+        # 16 bit - 5 bonds packing. 1 bit empty.
+        shift += 4
+        bp = iter(bonds_pack)
+        for o, (b1, b2, b3, b4, b5) in enumerate(zip_longest(bp, bp, bp, bp, bp, fillvalue=0)):
+            pack_into('>H', data, shift + 2 * o, (b1 << 12) | (b2 << 9) | (b3 << 6) | (b4 << 3) | b5)
+
+        shift += 2 * ceil(self.bonds_count / 5)
+        for o, ((n, m), s) in enumerate(cis_trans_stereo.items()):
+            pack_into('>I', data, shift + 4 * o, (n << 20) | (m << 8) | s)
+
+        if compressed:
+            return compress(bytes(data), 9)
+        return bytes(data)
+
+    @classmethod
+    def unpack(cls, data: bytes, /, *, compressed=True, _return_pack_length=False) -> 'MoleculeContainer':
+        """
+        Unpack from compressed bytes.
+
+        :param compressed: decompress data before processing.
+        """
+        try:  # windows? ;)
+            from ._unpack import unpack
+        except ImportError:
+            return cls.pure_unpack(data, compressed=compressed, _return_pack_length=_return_pack_length)
+        if compressed:
+            data = decompress(data)
+        if data[0] != 0:
+            raise ValueError('invalid pack header')
+
+        (mapping, atom_numbers, isotopes, charges, radicals, hydrogens, plane, bonds,
+         atoms_stereo, allenes_stereo, cis_trans_stereo, pack_length) = unpack(data)
+
+        mol = object.__new__(cls)
+        mol._bonds = bonds
+        mol._plane = plane
+        mol._charges = charges
+        mol._radicals = radicals
+        mol._hydrogens = hydrogens
+        mol._atoms_stereo = atoms_stereo
+        mol._allenes_stereo = allenes_stereo
+        mol._cis_trans_stereo = cis_trans_stereo
+
+        mol._conformers = []
+        mol._parsed_mapping = {}
+        mol._MoleculeContainer__meta = None
+        mol._MoleculeContainer__name = None
+        mol._atoms = atoms = {}
+
+        for n, a, i in zip(mapping, atom_numbers, isotopes):
+            atoms[n] = a = object.__new__(Element.from_atomic_number(a))
+            a._Core__isotope = i
+            a._graph = ref(mol)
+            a._map = n
+        if _return_pack_length:
+            return mol, pack_length
+        return mol
+
+    @classmethod
+    def pure_unpack(cls, data: bytes, /, *, compressed=True, _return_pack_length=False) -> 'MoleculeContainer':
+        """
+        Unpack from compressed bytes. Python implementation.
+        """
+        from ..files._mdl.mol import common_isotopes
+        if compressed:
+            data = memoryview(decompress(data))
+        elif not isinstance(data, memoryview):
+            data = memoryview(data)
+        if data[0] != 0:
+            raise ValueError('invalid pack header')
+
+        mol = cls()
+        atoms = mol._atoms
+        bonds = mol._bonds
+        plane = mol._plane
+        charges = mol._charges
+        radicals = mol._radicals
+        hydrogens = mol._hydrogens
+        atoms_stereo = mol._atoms_stereo
+        allenes_stereo = mol._allenes_stereo
+        cis_trans_stereo = mol._cis_trans_stereo
+
+        neighbors = {}
+        acs = int.from_bytes(data[1:4], 'big')
+        shift = 4
+        for o in range(acs >> 12):
+            nn, sia, x, y, hcr = unpack_from('>2H2eB', data, shift + 9 * o)
+            n = nn >> 4
+            neighbors[n] = nn & 0x0f
+            # stereo
+            s = sia >> 14
+            if s:
+                atoms_stereo[n] = s == 3
+            s = (sia >> 12) & 3
+            if s:
+                allenes_stereo[n] = s == 3
+
+            # atoms
+            a = Element.from_atomic_number(sia & 0x7f)
+            ai = (sia >> 7) & 0x1f
+            if ai:
+                ai += common_isotopes[a.__name__] - 16
+            else:
+                ai = None
+            atoms[n] = a = a(ai)
+            a._attach_to_graph(mol, n)
+
+            charges[n] = ((hcr >> 1) & 0x0f) - 4
+            radicals[n] = bool(hcr & 0x01)
+            hydrogens[n] = None if (h := hcr >> 5) == 7 else h
+            plane[n] = (x, y)
+
+        bc = sum(neighbors.values()) // 2
+        shift += 9 * len(neighbors) - 1
+        connections = []
+        for o in range(bc):
+            nn = unpack_from('>I', data, shift + 3 * o)[0]
+            connections.append((nn >> 12) & 0x0fff)
+            connections.append(nn & 0x0fff)
+
+        shift += 1 + 3 * bc
+        orders = []
+        for o in range(ceil(bc / 5)):
+            bb = unpack_from('>H', data, shift + 2 * o)[0]
+            orders.append(((bb >> 12) & 0x07) + 1)
+            orders.append(((bb >> 9) & 0x07) + 1)
+            orders.append(((bb >> 6) & 0x07) + 1)
+            orders.append(((bb >> 3) & 0x07) + 1)
+            orders.append((bb & 0x07) + 1)
+        orders = orders[:bc]  # skip padding
+
+        con = iter(connections)
+        ords = iter(orders)
+        for n, ms in neighbors.items():
+            bonds[n] = cbn = {}
+            for _ in range(ms):
+                m = next(con)
+                if m in bonds:  # bond partially exists. need back-connection.
+                    cbn[m] = bonds[m][n]
+                else:
+                    cbn[m] = Bond(next(ords))
+
+        shift += 2 * ceil(bc / 5)
+        for o in range(acs & 0x0fff):  # cis/trans
+            ct = unpack_from('>I', data, shift + 4 * o)[0]
+            cis_trans_stereo[(ct >> 20, (ct >> 8) & 0x0fff)] = ct & 0x01
+        if _return_pack_length:
+            return mol, shift + (acs & 0x0fff) * 4
+        return mol
+
+    def _augmented_substructure(self, atoms: Iterable[int], deep: int):
+        atoms = set(atoms)
+        bonds = self._bonds
+        if atoms - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        nodes = [atoms]
+        for _ in range(deep):
+            n = {y for x in nodes[-1] for y in bonds[x]} | nodes[-1]
+            if n in nodes:
+                break
+            nodes.append(n)
+        return nodes
+
+    @cached_property
+    def _screen_fingerprint(self) -> Dict[int, Set[int]]:
+        """
+        Fingerprint of available linear fragments with set of mapped atoms.
+        Required for isomorphism tests filtering speedup.
+        Parameters can be modified globally in `MoleculeContainer._fingerprint_config`.
+        """
+        if self._fingerprint_config:
+            return {hash(k): {x for x in v for x in x} for k, v in self._fragments(**self._fingerprint_config).items()}
+        return {}
+
+    @cached_args_method
+    def _component_fingerprint(self, component):
+        """
+        Fingerprint of specific component.
+        """
+        scope = set(self.connected_components[component])
+        return {k: v & scope for k, v in self._screen_fingerprint.items() if not v.isdisjoint(scope)}
+
+    @cached_property
+    def _cython_compiled_structure(self):
+        # long I:
+        # bond: single, double, triple, aromatic, special = 5 bit
+        # atom: H-Ce: 58 bit
+        # transfer bit
+
+        # long II:
+        # atom Pr-Og: 60 bit
+        # hybridizations: 1-4 = 4 bit
+
+        # long III:
+        # isotope: not specified, isotope - common_isotope = -8 - +8 = 18 bit
+        # is_radical: 2 bit
+        # charge: -4 - +4: 9 bit
+        # implicit_hydrogens: 0-4 = 5 bit
+        # neighbors: 0-14 = 15 bit
+        # heteroatoms: 0-14 = 15 bit
+
+        # long IV:
+        # ring_sizes: not-in-ring bit, 3-atom ring, 4-...., 65-atom ring
+        from ..files._mdl.mol import common_isotopes
+
+        charges = self._charges
+        radicals = self._radicals
+        hydrogens = self._hydrogens
+        neighbors = self.neighbors
+        heteroatoms = self.heteroatoms
+        rings_sizes = self.atoms_rings_sizes
+        hybridization = self.hybridization
+
+        mapping = {}
+        numbers = []
+        bits1 = []
+        bits2 = []
+        bits3 = []
+        bits4 = []
+        for i, (n, a) in enumerate(self._atoms.items()):
+            mapping[n] = i
+            numbers.append(n)
+            v2 = 1 << (hybridization(n) - 1)
+            if (an := a.atomic_number) > 58:
+                v1 = 1  # transfer bit
+                v2 |= 1 << (122 - an)
+            else:
+                v1 = 1 << (59 - an)
+
+            if a.isotope:
+                v3 = 1 << (a.isotope - common_isotopes[a.atomic_symbol] + 54)
+                if radicals[n]:
+                    v3 |= 0x200000000000
+                else:
+                    v3 |= 0x100000000000
+            elif radicals[n]:
+                v3 = 0x8000200000000000
+            else:
+                v3 = 0x8000100000000000
+
+            v3 |= 1 << (charges[n] + 39)
+            v3 |= 1 << ((hydrogens[n] or 0) + 30)
+            v3 |= 1 << (neighbors(n) + 15)
+            v3 |= 1 << heteroatoms(n)
+
+            if n in rings_sizes:
+                v4 = 0
+                for r in rings_sizes[n]:
+                    if r > 65:  # big rings not supported
+                        continue
+                    v4 |= 1 << (65 - r)
+                if not v4:  # only 65+ rings. set as rings-free.
+                    v4 = 0x8000000000000000
+            else:  # not in rings
+                v4 = 0x8000000000000000
+
+            bits1.append(v1)
+            bits2.append(v2)
+            bits3.append(v3)
+            bits4.append(v4)
+
+        o_from = [0] * len(mapping)
+        o_to = [0] * len(mapping)
+        indices = [0] * self.bonds_count * 2
+        bonds = [0] * self.bonds_count * 2
+        start = 0
+        for n, ms in self._bonds.items():
+            i = mapping[n]
+            o_from[i] = start
+            for j, (m, b) in enumerate(ms.items(), start):
+                indices[j] = x = mapping[m]
+                v = bits1[x]
+                o = b.order
+                if o == 1:
+                    v |= 0x0800000000000000
+                elif o == 4:
+                    v |= 0x4000000000000000
+                elif o == 2:
+                    v |= 0x1000000000000000
+                elif o == 3:
+                    v |= 0x2000000000000000
+                else:
+                    v |= 0x8000000000000000
+                bonds[j] = v
+            start += len(ms)
+            o_to[i] = start
+
+        return (array('L', numbers), array('Q', bits1), array('Q', bits2), array('Q', bits3), array('Q', bits4),
+                array('Q', bonds), array('I', o_from), array('I', o_to), array('I', indices))
+
+    def _calc_implicit(self, n: int):
+        atoms = self._atoms
+        atom = atoms[n]
+        if atom.atomic_number != 1:
+            charge: int = self._charges[n]
+            is_radical = self._radicals[n]
+            explicit_sum = 0
+            explicit_dict = defaultdict(int)
+            for m, bond in self._bonds[n].items():
+                order = bond.order
+                if order == 4:  # aromatic rings not supported
+                    self._hydrogens[n] = None
+                    return
+                elif order != 8:  # any bond used for complexes
+                    explicit_sum += order
+                    explicit_dict[(order, atoms[m].atomic_number)] += 1
+            try:
+                rules = atom.valence_rules(charge, is_radical, explicit_sum)
+            except ValenceError:
+                self._hydrogens[n] = None
+                return
+            for s, d, h in rules:
+                if s.issubset(explicit_dict) and all(explicit_dict[k] >= c for k, c in d.items()):
+                    self._hydrogens[n] = h
+                    return
+        self._hydrogens[n] = 0
+
+    def __int__(self):
+        """
+        Total charge of molecule
+        """
+        return self.molecular_charge
+
+    def __float__(self):
+        return self.molecular_mass
+
+    def __xor__(self, other):
+        """
+        G ^ H is CGR generation
+        """
+        return self.compose(other)
+
+    def __and__(self, other: Iterable[int]):
+        """
+        Substructure of graph with given nodes.
+        """
+        return self.substructure(other)
+
+    def __sub__(self, other: Iterable[int]):
+        """
+        Given nodes excluded substructure of graph.
+        """
+        atoms = set(other)
+        if atoms - self._atoms.keys():
+            raise ValueError('invalid atom numbers')
+        atoms = self._atoms.keys() - atoms
+        if atoms:
+            return self.substructure(atoms)
+        raise ValueError('full substitution not allowed')
+
+    def __enter__(self):
+        """
+        Transaction of changes. Keep current state for restoring on errors.
+        """
+        atoms = {}
+        for n, atom in self._atoms.items():
+            atom = atom.copy()
+            atoms[n] = atom
+            atom._attach_to_graph(self, n)
+
+        bonds = {}
+        for n, m_bond in self._bonds.items():
+            bonds[n] = cbn = {}
+            for m, bond in m_bond.items():
+                if m in bonds:  # bond partially exists. need back-connection.
+                    cbn[m] = bonds[m][n]
+                else:
+                    cbn[m] = bond.copy()
+        self._backup = {'atoms': atoms, 'bonds': bonds, 'parsed_mapping': self._parsed_mapping.copy(),
+                        'plane': self._plane.copy(), 'charges': self._charges.copy(), 'radicals': self._radicals.copy(),
+                        'hydrogens': self._hydrogens.copy(), 'conformers': [x.copy() for x in self._conformers],
+                        'atoms_stereo': self._atoms_stereo.copy(), 'allenes_stereo': self._allenes_stereo.copy(),
+                        'cis_trans_stereo': self._cis_trans_stereo.copy()}
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        if exc_type:  # restore state
+            backup = self._backup
+            self._atoms = backup['atoms']
+            self._bonds = backup['bonds']
+            self._parsed_mapping = backup['parsed_mapping']
+            self._plane = backup['plane']
+            self._charges = backup['charges']
+            self._radicals = backup['radicals']
+            self._hydrogens = backup['hydrogens']
+            self._conformers = backup['conformers']
+            self._atoms_stereo = backup['atoms_stereo']
+            self._allenes_stereo = backup['allenes_stereo']
+            self._cis_trans_stereo = backup['cis_trans_stereo']
+            self.flush_cache()
+        del self._backup
+
+    def __getstate__(self):
+        return {'conformers': self._conformers, 'hydrogens': self._hydrogens, 'atoms_stereo': self._atoms_stereo,
+                'allenes_stereo': self._allenes_stereo, 'cis_trans_stereo': self._cis_trans_stereo,
+                'parsed_mapping': self._parsed_mapping, 'meta': self.__meta, 'name': self.__name,
+                **super().__getstate__()}
+
+    def __setstate__(self, state):
+        super().__setstate__(state)
+        self._conformers = state['conformers']
+        self._atoms_stereo = state['atoms_stereo']
+        self._allenes_stereo = state['allenes_stereo']
+        self._cis_trans_stereo = state['cis_trans_stereo']
+        self._hydrogens = state['hydrogens']
+        self._parsed_mapping = state['parsed_mapping']
+        self.__meta = state['meta']
+        self.__name = state['name']
+
+    _fingerprint_config = {'min_radius': 2, 'max_radius': 4}  # set empty for disable screening
+
+
+__all__ = ['MoleculeContainer']
```

### Comparing `chython-1.67/chython/containers/reaction.py` & `chython-1.8/chython/containers/reaction.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,334 +1,285 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from CachedMethods import cached_method
-from functools import reduce
-from hashlib import sha512
-from itertools import chain
-from math import ceil
-from operator import itemgetter, or_
-from typing import Dict, Iterable, Iterator, Optional, Tuple, List
-from zlib import compress, decompress
-from .cgr import CGRContainer
-from .molecule import MoleculeContainer
-from ..algorithms.calculate2d import Calculate2DReaction
-from ..algorithms.depict import DepictReaction
-from ..algorithms.mapping import Mapping
-from ..algorithms.standardize import StandardizeReaction
-
-
-class ReactionContainer(StandardizeReaction, Mapping, Calculate2DReaction, DepictReaction):
-    """
-    Reaction storage. Contains reactants, products and reagents lists.
-
-    Reaction storage hashable and comparable. based on reaction unique signature (SMILES).
-    """
-    __slots__ = ('__reactants', '__products', '__reagents', '__meta', '__name', '_arrow', '_signs', '__dict__')
-    __class_cache__ = {}
-
-    def __init__(self, reactants: Iterable[MoleculeContainer] = (), products: Iterable[MoleculeContainer] = (),
-                 reagents: Iterable[MoleculeContainer] = (), meta: Optional[Dict] = None, name: Optional[str] = None):
-        """
-        New reaction object creation
-
-        :param reactants: list of MoleculeContainers in left side of reaction
-        :param products: right side of reaction. see reactants
-        :param reagents: middle side of reaction: solvents, catalysts, etc. see reactants
-        :param meta: dictionary of metadata. like DTYPE-DATUM in RDF
-
-        """
-        reactants = tuple(reactants)
-        products = tuple(products)
-        reagents = tuple(reagents)
-        if not reactants and not products and not reagents:
-            raise ValueError('At least one graph object required')
-        elif not all(isinstance(x, MoleculeContainer) for x in chain(reactants, products, reagents)):
-            raise TypeError(f'MoleculeContainers expected')
-
-        self.__reactants = reactants
-        self.__products = products
-        self.__reagents = reagents
-        if meta is None:
-            self.__meta = None
-        else:
-            self.__meta = dict(meta)
-        if name is None:
-            self.__name = None
-        else:
-            self.name = name
-        self._arrow = None
-        self._signs = None
-
-    @property
-    def reactants(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__reactants
-
-    @property
-    def reagents(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__reagents
-
-    @property
-    def products(self) -> Tuple[MoleculeContainer, ...]:
-        return self.__products
-
-    def molecules(self) -> Iterator[MoleculeContainer]:
-        """
-        Iterator of all reaction molecules
-        """
-        return chain(self.__reactants, self.__reagents, self.__products)
-
-    @property
-    def meta(self) -> Dict:
-        """
-        Dictionary of metadata.
-        Like DTYPE-DATUM in RDF
-        """
-        if self.__meta is None:
-            self.__meta = {}  # lazy
-        return self.__meta
-
-    @property
-    def name(self) -> str:
-        return self.__name or ''
-
-    @name.setter
-    def name(self, name: str):
-        if not isinstance(name, str):
-            raise TypeError('name should be string up to 80 symbols')
-        self.__name = name
-
-    def copy(self) -> 'ReactionContainer':
-        """
-        Get copy of object
-        """
-        copy = object.__new__(self.__class__)
-        copy._ReactionContainer__reactants = tuple(x.copy() for x in self.__reactants)
-        copy._ReactionContainer__products = tuple(x.copy() for x in self.__products)
-        copy._ReactionContainer__reagents = tuple(x.copy() for x in self.__reagents)
-        copy._ReactionContainer__name = self.__name
-        if self.__meta is None:
-            copy._ReactionContainer__meta = None
-        else:
-            copy._ReactionContainer__meta = self.__meta.copy()
-        copy._arrow = self._arrow
-        copy._signs = self._signs
-        return copy
-
-    @cached_method
-    def compose(self) -> CGRContainer:
-        """
-        Get CGR of reaction
-
-        Reagents will be presented as unchanged molecules
-        :return: CGRContainer
-        """
-        rr = self.__reagents + self.__reactants
-        if rr:
-            r = reduce(or_, rr)
-        else:
-            r = MoleculeContainer()
-        if self.__products:
-            p = reduce(or_, self.__products)
-        else:
-            p = MoleculeContainer()
-        return r ^ p
-
-    def flush_cache(self):
-        self.__dict__.clear()
-        for m in self.molecules():
-            m.flush_cache()
-
-    def pack(self, *, compressed=True, check=True):
-        """
-        Pack into compressed bytes.
-
-        Note:
-            * Same restrictions as in molecules pack.
-            * reactants, reagents nad products should contain less than 256 molecules.
-
-        Format specification:
-        Big endian bytes order
-        8 bit - header byte = 0x01 (current format specification)
-        8 bit - reactants count
-        8 bit - reagents count
-        8 bit - products count
-        x bit - concatenated molecules packs
-
-        :param compressed: return zlib-compressed pack.
-        :param check: check molecules for format restrictions.
-        """
-        data = b''.join((bytearray((1, len(self.__reactants), len(self.__reagents), len(self.__products))),
-                         *(m.pack(compressed=False, check=check) for m in self.molecules())))
-        if compressed:
-            return compress(data, 9)
-        return data
-
-    @classmethod
-    def pack_len(cls, data: bytes, /, *, compressed=True) -> Tuple[List[int], List[int], List[int]]:
-        """
-        Returns reactants, reagents, products molecules atoms count in reaction pack.
-        """
-        if compressed:
-            data = decompress(data)
-        data = memoryview(data)
-        if data[0] != 1:
-            raise ValueError('invalid pack header')
-        reactants, reagents, products = data[1], data[2], data[3]
-
-        v = data[4]  # mol pack version
-        shift = 5  # RH+RC+RC+PC+MH
-        molecules = []
-        for _ in range(reactants + reagents + products - 1):
-            acs = int.from_bytes(data[shift: shift + 3], 'big')
-            neighbors = 0
-            ac = acs >> 12
-            shift += 4  # AC+CC+AN
-            for _ in range(ac):
-                neighbors += data[shift] & 0x0f
-                shift += 9
-            neighbors //= 2
-            if v == 2:
-                shift += 3 * neighbors + ceil(neighbors * 3 / 8) + (acs & 0x0fff) * 4
-            elif v == 0:
-                shift += 3 * neighbors + ceil(neighbors / 5) * 2 + (acs & 0x0fff) * 4
-            molecules.append(ac)
-        if reactants or reagents or products:
-            molecules.append(int.from_bytes(data[shift: shift + 3], 'big') >> 12)
-        return molecules[:reactants], molecules[reactants: -products], molecules[-products:]
-
-    @classmethod
-    def unpack(cls, data: bytes, /, *, compressed=True) -> 'ReactionContainer':
-        """
-        Unpack from compressed bytes.
-
-        :param compressed: decompress data before processing.
-        """
-        if compressed:
-            data = decompress(data)
-        data = memoryview(data)
-        if data[0] != 1:
-            raise ValueError('invalid pack header')
-
-        reactants, reagents, products = data[1], data[2], data[3]
-        molecules = []
-        shift = 4
-        for _ in range(reactants + reagents + products):
-            m, pl = MoleculeContainer.unpack(data[shift:], compressed=False, _return_pack_length=True)
-            molecules.append(m)
-            shift += pl
-        return cls(molecules[:reactants], molecules[-products:], molecules[reactants: -products])
-
-    def __invert__(self) -> CGRContainer:
-        """
-        Get CGR of reaction
-        """
-        return self.compose()
-
-    def __eq__(self, other):
-        return isinstance(other, ReactionContainer) and str(self) == str(other)
-
-    @cached_method
-    def __hash__(self):
-        return hash(str(self))
-
-    @cached_method
-    def __bytes__(self):
-        return sha512(str(self).encode()).digest()
-
-    def __bool__(self):
-        """
-        Exists both reactants and products
-        """
-        return bool(self.__reactants and self.__products)
-
-    @cached_method
-    def __str__(self):
-        return format(self)
-
-    def __format__(self, format_spec):
-        """
-        :param format_spec:
-            !c - Keep nested containers order.
-            a - Generate asymmetric closures.
-            !s - Disable stereo marks.
-            A - Use aromatic bonds instead aromatic atoms.
-            m - Set atom mapping.
-            r - Generate random-ordered smiles.
-            h - Show implicit hydrogens.
-            !b - Disable bonds tokens.
-            !x - Disable CXSMILES extension.
-            !z - Disable charge representation.
-        """
-        sig = []
-        count = 0
-        contract = []
-        orders = []
-
-        for ml in (self.__reactants, self.__reagents, self.__products):
-            mso = [(m, *m.__format__(format_spec, _return_order=True)) for m in ml]
-            if not format_spec or '!c' not in format_spec:
-                mso.sort(key=itemgetter(1))
-
-            ss = []
-            for m, s, o in mso:
-                if m.connected_components_count > 1:
-                    contract.append([str(x + count) for x in range(m.connected_components_count)])
-                    count += m.connected_components_count
-                else:
-                    count += 1
-
-                orders.append((m, o))
-                ss.append(s)
-            sig.append('.'.join(ss))
-
-        if not format_spec or '!x' not in format_spec:
-            cx = []
-            if r := ','.join(str(n) for n, (m, a) in enumerate((m, a) for m, o in orders for a in o) if m._radicals[a]):
-                cx.append(f'^1:{r}')
-            if contract:
-                cx.append(f"f:{','.join('.'.join(x) for x in contract)}")
-            if cx:
-                return f"{'>'.join(sig)} |{','.join(cx)}|"
-        return '>'.join(sig)
-
-    @cached_method
-    def __len__(self):
-        return len(self.__reactants) + len(self.__products) + len(self.__reagents)
-
-    def __getstate__(self):
-        state = {'reactants': self.__reactants, 'products': self.__products, 'reagents': self.__reagents,
-                 'meta': self.__meta, 'name': self.__name, 'arrow': self._arrow, 'signs': self._signs}
-        from chython import pickle_cache
-
-        if pickle_cache:
-            state['cache'] = self.__dict__
-        return state
-
-    def __setstate__(self, state):
-        self.__reactants = state['reactants']
-        self.__products = state['products']
-        self.__reagents = state['reagents']
-        self.__meta = state['meta']
-        self.__name = state['name']
-        self._arrow = state['arrow']
-        self._signs = state['signs']
-        if 'cache' in state:
-            self.__dict__.update(state['cache'])
-
-
-__all__ = ['ReactionContainer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from CachedMethods import cached_method
+from functools import reduce
+from hashlib import sha512
+from itertools import chain
+from math import ceil
+from operator import or_
+from typing import Dict, Iterable, Iterator, Optional, Tuple
+from zlib import compress, decompress
+from .cgr import CGRContainer
+from .molecule import MoleculeContainer
+from ..algorithms.calculate2d import Calculate2DReaction
+from ..algorithms.depict import DepictReaction
+from ..algorithms.standardize import StandardizeReaction
+
+
+class ReactionContainer(StandardizeReaction, Calculate2DReaction, DepictReaction):
+    """
+    Reaction storage. Contains reactants, products and reagents lists.
+
+    Reaction storage hashable and comparable. based on reaction unique signature (SMILES).
+    """
+    __slots__ = ('__reactants', '__products', '__reagents', '__meta', '__name', '_arrow', '_signs', '__dict__')
+    __class_cache__ = {}
+
+    def __init__(self, reactants: Iterable[MoleculeContainer] = (), products: Iterable[MoleculeContainer] = (),
+                 reagents: Iterable[MoleculeContainer] = (), meta: Optional[Dict] = None, name: Optional[str] = None):
+        """
+        New reaction object creation
+
+        :param reactants: list of MoleculeContainers in left side of reaction
+        :param products: right side of reaction. see reactants
+        :param reagents: middle side of reaction: solvents, catalysts, etc. see reactants
+        :param meta: dictionary of metadata. like DTYPE-DATUM in RDF
+
+        """
+        reactants = tuple(reactants)
+        products = tuple(products)
+        reagents = tuple(reagents)
+        if not reactants and not products and not reagents:
+            raise ValueError('At least one graph object required')
+        elif not all(isinstance(x, MoleculeContainer) for x in chain(reactants, products, reagents)):
+            raise TypeError(f'MoleculeContainers expected')
+
+        self.__reactants = reactants
+        self.__products = products
+        self.__reagents = reagents
+        if meta is None:
+            self.__meta = None
+        else:
+            self.__meta = dict(meta)
+        if name is None:
+            self.__name = None
+        else:
+            self.name = name
+        self._arrow = None
+        self._signs = None
+
+    @property
+    def reactants(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__reactants
+
+    @property
+    def reagents(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__reagents
+
+    @property
+    def products(self) -> Tuple[MoleculeContainer, ...]:
+        return self.__products
+
+    def molecules(self) -> Iterator[MoleculeContainer]:
+        """
+        Iterator of all reaction molecules
+        """
+        return chain(self.__reactants, self.__reagents, self.__products)
+
+    @property
+    def meta(self) -> Dict:
+        """
+        Dictionary of metadata.
+        Like DTYPE-DATUM in RDF
+        """
+        if self.__meta is None:
+            self.__meta = {}  # lazy
+        return self.__meta
+
+    @property
+    def name(self) -> str:
+        return self.__name or ''
+
+    @name.setter
+    def name(self, name: str):
+        if not isinstance(name, str):
+            raise TypeError('name should be string up to 80 symbols')
+        self.__name = name
+
+    def copy(self) -> 'ReactionContainer':
+        """
+        Get copy of object
+        """
+        copy = object.__new__(self.__class__)
+        copy._ReactionContainer__reactants = tuple(x.copy() for x in self.__reactants)
+        copy._ReactionContainer__products = tuple(x.copy() for x in self.__products)
+        copy._ReactionContainer__reagents = tuple(x.copy() for x in self.__reagents)
+        copy._ReactionContainer__meta = self.__meta.copy()
+        copy._ReactionContainer__name = self.__name
+        copy._arrow = self._arrow
+        copy._signs = self._signs
+        return copy
+
+    @cached_method
+    def compose(self) -> CGRContainer:
+        """
+        Get CGR of reaction
+
+        Reagents will be presented as unchanged molecules
+        :return: CGRContainer
+        """
+        rr = self.__reagents + self.__reactants
+        if rr:
+            r = reduce(or_, rr)
+        else:
+            r = MoleculeContainer()
+        if self.__products:
+            p = reduce(or_, self.__products)
+        else:
+            p = MoleculeContainer()
+        return r ^ p
+
+    @classmethod
+    def from_cgr(cls, cgr: CGRContainer) -> 'ReactionContainer':
+        """
+        Decompose CGR into reaction
+        """
+        if not isinstance(cgr, CGRContainer):
+            raise TypeError('CGR expected')
+        r, p = ~cgr
+        return ReactionContainer(r, p)
+
+    def flush_cache(self):
+        self.__dict__.clear()
+        for m in self.molecules():
+            m.flush_cache()
+
+    def pack(self, *, compressed=True):
+        """
+        Pack into compressed bytes.
+
+        Note:
+            * Same restrictions as in molecules pack.
+            * reactants, reagents nad products should contain less than 257 molecules.
+
+        Format specification:
+        Big endian bytes order
+        8 bit - header byte = 0x01. Extending possible
+        8 bit - reactants count
+        8 bit - reagents count
+        8 bit - products count
+        x bit - concatenated molecules packs
+
+        :param compressed: return zlib-compressed pack.
+        """
+        data = b''.join((bytearray((1, len(self.__reactants), len(self.__reagents), len(self.__products))),
+                         *(m.pack(compressed=False) for m in self.molecules())))
+        if compressed:
+            return compress(data, 9)
+        return data
+
+    @classmethod
+    def unpack(cls, data: bytes, /, *, compressed=True) -> 'ReactionContainer':
+        """
+        Unpack from compressed bytes.
+
+        :param compressed: decompress data before processing.
+        """
+        if compressed:
+            data = decompress(data)
+        data = memoryview(data)
+        if data[0] != 1:
+            raise ValueError('invalid pack header')
+
+        reactants, reagents, products = data[1], data[2], data[3]
+        molecules = []
+        shift = 4
+        for i in range(reactants + reagents + products):
+            m, pl = MoleculeContainer.unpack(data[shift:], compressed=False, _return_pack_length=True)
+            molecules.append(m)
+            shift += pl
+        return cls(molecules[:reactants], molecules[-products:], molecules[reactants: -products])
+
+    def __invert__(self) -> CGRContainer:
+        """
+        Get CGR of reaction
+        """
+        return self.compose()
+
+    def __eq__(self, other):
+        return isinstance(other, ReactionContainer) and str(self) == str(other)
+
+    @cached_method
+    def __hash__(self):
+        return hash(str(self))
+
+    @cached_method
+    def __bytes__(self):
+        return sha512(str(self).encode()).digest()
+
+    def __bool__(self):
+        """
+        Exists both reactants and products
+        """
+        return bool(self.__reactants and self.__products)
+
+    @cached_method
+    def __str__(self):
+        return format(self)
+
+    def __format__(self, format_spec):
+        """
+        :param format_spec: see specification of nested containers.
+            !c - Keep nested containers order
+            !C - skip cxsmiles fragments contract
+        """
+        sig = []
+        count = 0
+        contract = []
+        for ml in (self.__reactants, self.__reagents, self.__products):
+            if not format_spec or '!c' not in format_spec:
+                ml = sorted(ml, key=str)
+            for m in ml:
+                if m.connected_components_count > 1:
+                    contract.append([str(x + count) for x in range(m.connected_components_count)])
+                    count += m.connected_components_count
+                else:
+                    count += 1
+            if format_spec:
+                sig.append('.'.join(format(x, format_spec) for x in ml))
+            else:
+                sig.append('.'.join(str(x) for x in ml))
+        if (not format_spec or '!C' not in format_spec) and contract:
+            return f"{'>'.join(sig)} |f:{','.join('.'.join(x) for x in contract)}|"
+        return '>'.join(sig)
+
+    @cached_method
+    def __len__(self):
+        return len(self.__reactants) + len(self.__products) + len(self.__reagents)
+
+    def __getstate__(self):
+        state = {'reactants': self.__reactants, 'products': self.__products, 'reagents': self.__reagents,
+                 'meta': self.__meta, 'name': self.__name, 'arrow': self._arrow, 'signs': self._signs}
+        import chython
+        if chython.pickle_cache:
+            state['cache'] = self.__dict__
+        return state
+
+    def __setstate__(self, state):
+        self.__reactants = state['reactants']
+        self.__products = state['products']
+        self.__reagents = state['reagents']
+        self.__meta = state['meta']
+        self.__name = state['name']
+        self._arrow = state['arrow']
+        self._signs = state['signs']
+        if 'cache' in state:
+            self.__dict__.update(state['cache'])
+
+
+__all__ = ['ReactionContainer']
```

### Comparing `chython-1.67/chython/files/MRVrw.py` & `chython-1.8/chython/files/MRVrw.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,507 +1,463 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2017-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from collections import defaultdict
-from io import StringIO, BytesIO, TextIOWrapper, BufferedIOBase, BufferedReader
-from itertools import count, islice, chain
-from lxml.etree import iterparse, QName, tostring
-from pathlib import Path
-from typing import Union, List, Iterator, Dict, Optional
-from ._convert import create_molecule, create_reaction
-from ._mapping import postprocess_parsed_molecule, postprocess_parsed_reaction
-from ._mdl import postprocess_molecule
-from ..containers import MoleculeContainer, ReactionContainer
-from ..exceptions import EmptyMolecule, EmptyReaction
-
-
-organic_set = {'B', 'C', 'N', 'O', 'P', 'S', 'Se', 'F', 'Cl', 'Br', 'I'}
-bond_map = {8: '1" queryType="Any', 4: 'A', 1: '1', 2: '2', 3: '3',
-            'Any': 8, 'any': 8, 'A': 4, 'a': 4, '1': 1, '2': 2, '3': 3}
-
-
-def xml_dict(parent_element, stop_list=None):
-    stop_list = set() if stop_list is None else set(stop_list)
-    out = {}
-    for x, y in parent_element.items():
-        y = y.strip()
-        if y:
-            x = '@%s' % x.strip()
-            out[x] = y
-
-    text = []
-    if len(parent_element):
-        elements_grouped = defaultdict(list)
-        for element in parent_element:
-            name = QName(element).localname
-            if name in stop_list:
-                text.append(tostring(element, encoding=str, with_tail=False))
-            else:
-                elements_grouped[name].append(element)
-
-            if element.tail:
-                t = element.tail.strip()
-                if t:
-                    text.append(t)
-
-        for element_tag, element_group in elements_grouped.items():
-            if len(element_group) == 1:
-                out[element_tag] = xml_dict(element_group[0], stop_list)
-            else:
-                out[element_tag] = [xml_dict(x, stop_list) for x in element_group]
-
-    if parent_element.text:
-        t = parent_element.text.strip()
-        if t:
-            text.insert(0, t)
-    if text:
-        out['$'] = ''.join(text)
-
-    return out
-
-
-class MRVRead:
-    """
-    ChemAxon MRV files reader. works similar to opened file object. support `with` context manager.
-    on initialization accept opened in binary mode file, string path to file,
-    pathlib.Path object or another binary buffered reader object
-    """
-    molecule_cls = MoleculeContainer
-    reaction_cls = ReactionContainer
-
-    def __init__(self, file, *, ignore: bool = True, remap: bool = False,
-                 calc_cis_trans: bool = False, ignore_stereo: bool = False, ignore_bad_isotopes: bool = False):
-        """
-        :param ignore: Skip some checks of data or try to fix some errors.
-        :param remap: Remap atom numbers started from one.
-        :param calc_cis_trans: Calculate cis/trans marks from 2d coordinates.
-        :param ignore_stereo: Ignore stereo data.
-        :param ignore_bad_isotopes: reset invalid isotope mark to non-isotopic.
-        """
-        if isinstance(file, str):
-            self.__file = open(file, 'rb')
-            self.__is_buffer = False
-        elif isinstance(file, Path):
-            self.__file = file.open('rb')
-            self.__is_buffer = False
-        elif isinstance(file, (BytesIO, BufferedReader, BufferedIOBase)):
-            self.__file = file
-            self.__is_buffer = True
-        else:
-            raise TypeError('invalid file. BytesIO, BufferedReader and BufferedIOBase subclasses expected')
-        self.__ignore = ignore
-        self.__remap = remap
-        self.__calc_cis_trans = calc_cis_trans
-        self.__ignore_stereo = ignore_stereo
-        self.__ignore_bad_isotopes = ignore_bad_isotopes
-        self.__tell = 0
-        self.__xml = iterparse(self.__file, tag='{*}MChemicalStruct')
-        self.__buffer = None
-
-    def read(self, amount: Optional[int] = None) -> List[Union[ReactionContainer, MoleculeContainer]]:
-        """
-        Parse whole file
-
-        :param amount: number of records to read
-        """
-        if amount:
-            return list(islice(iter(self), amount))
-        return list(iter(self))
-
-    def read_structure(self, *, current: bool = True):
-        """
-        Read Reaction or Molecule container.
-
-        :param current: return current structure if already parsed, otherwise read next
-        """
-        data = self._read_block(current=current)
-        meta = self.read_metadata()
-        log = []
-
-        if 'molecule' in data and isinstance(data['molecule'], dict):
-            data = data['molecule']
-            tmp = parse_molecule(data)
-            postprocess_parsed_molecule(tmp, remap=self.__remap, ignore=self.__ignore)
-            mol = create_molecule(tmp, ignore_bad_isotopes=self.__ignore_bad_isotopes, _cls=self.molecule_cls)
-            postprocess_molecule(mol, tmp, ignore=self.__ignore, ignore_stereo=self.__ignore_stereo,
-                                 calc_cis_trans=self.__calc_cis_trans)
-            if meta:
-                mol.meta.update(meta)
-            return mol
-        elif 'reaction' in data and isinstance(data['reaction'], dict):
-            data = data['reaction']
-            tmp = {'reactants': [], 'products': [], 'reagents': [],
-                   'meta': None, 'log': log, 'title': data.get('@title')}
-
-            n = 0
-            for tag, group in (('reactantList', 'reactants'), ('productList', 'products'), ('agentList', 'reagents')):
-                if tag in data and 'molecule' in data[tag]:
-                    molecule = data[tag]['molecule']
-                    if isinstance(molecule, dict):
-                        molecule = (molecule,)
-                    for m in molecule:
-                        n += 1
-                        try:
-                            tmp[group].append(parse_molecule(m))
-                        except ValueError as e:
-                            if isinstance(e, EmptyMolecule):
-                                log.append(f'ignored empty molecule {n}')
-                            elif self.__ignore:
-                                log.append(f'ignored molecule {n} with {e}')
-                            else:
-                                raise
-
-            if not tmp['reactants'] and not tmp['products'] and not tmp['reagents']:
-                raise EmptyReaction
-
-            postprocess_parsed_reaction(tmp, remap=self.__remap, ignore=self.__ignore)
-            rxn = create_reaction(tmp, ignore_bad_isotopes=self.__ignore_bad_isotopes, _m_cls=self.molecule_cls,
-                                  _r_cls=self.reaction_cls)
-            for mol, tmp in zip(rxn.molecules(), chain(tmp['reactants'], tmp['reagents'], tmp['products'])):
-                postprocess_molecule(mol, tmp, ignore=self.__ignore, ignore_stereo=self.__ignore_stereo,
-                                     calc_cis_trans=self.__calc_cis_trans)
-            if meta:
-                rxn.meta.update(meta)
-            return rxn
-        else:
-            raise ValueError('reaction or molecule expected')
-
-    def read_metadata(self, *, current: bool = True) -> Dict[str, str]:
-        """
-        Read metadata block
-        """
-        data = self._read_block(current=current)
-        if 'molecule' in data and isinstance(data['molecule'], dict):
-            data = data['molecule']
-        elif 'reaction' in data and isinstance(data['reaction'], dict):
-            data = data['reaction']
-        else:
-            raise ValueError('reaction or molecule expected')
-
-        if 'propertyList' in data and 'property' in data['propertyList']:
-            data = data['propertyList']['property']
-            meta = {}
-            if isinstance(data, dict):
-                key = data['@title']
-                val = data['scalar']['$'].strip()
-                if key and val:
-                    meta[key] = val
-                else:
-                    meta['chython_unparsed_metadata'] = [data]
-            else:
-                for x in data:
-                    key = x['@title']
-                    val = x['scalar']['$'].strip()
-                    if key and val:
-                        meta[key] = val
-                    else:
-                        if 'chython_unparsed_metadata' not in meta:
-                            meta['chython_unparsed_metadata'] = []
-                        meta['chython_unparsed_metadata'].append(x)
-        else:
-            return {}
-
-    def close(self, force: bool = False):
-        """
-        Close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self.__is_buffer or force:
-            self.__file.close()
-
-    def tell(self):
-        """
-        Number of records processed from the original file
-        """
-        return self.__tell
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
-        while True:
-            try:
-                yield self.read_structure(current=False)
-            except ValueError:
-                pass
-            except EOFError:
-                return
-
-    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
-        return next(iter(self))
-
-    def _read_block(self, *, current: bool = True) -> dict:
-        if not current or not self.__buffer:
-            self.__buffer = None
-            try:
-                e = next(self.__xml)[1]
-            except StopIteration:
-                raise EOFError
-            self.__buffer = xml_dict(e)
-            self.__tell += 1
-            e.clear()
-        return self.__buffer
-
-
-def parse_molecule(data):
-    atoms, bonds, stereo = [], [], []
-    log = []
-    hydrogens = {}
-    atom_map = {}
-    if 'atom' in data['atomArray']:
-        da = data['atomArray']['atom']
-        if isinstance(da, dict):
-            da = (da,)
-        for n, atom in enumerate(da):
-            atom_map[atom['@id']] = n
-            atoms.append({'element': atom['@elementType'],
-                          'isotope': int(atom['@isotope']) if '@isotope' in atom else None,
-                          'charge': int(atom.get('@formalCharge', 0)),
-                          'is_radical': '@radical' in atom,
-                          'mapping': int(atom.get('@mrvMap', 0))})
-            if '@z3' in atom:
-                atoms[-1].update(x=float(atom['@x3']), y=float(atom['@y3']), z=float(atom['@z3']))
-            else:
-                atoms[-1].update(x=float(atom['@x2']) / 2, y=float(atom['@y2']) / 2, z=0.)
-            if '@mrvQueryProps' in atom:
-                raise ValueError('queries unsupported')
-            if '@hydrogenCount' in atom:
-                hydrogens[n] = int(atom['@hydrogenCount'])
-    else:
-        atom = data['atomArray']
-        for n, (_id, e) in enumerate(zip(atom['@atomID'].split(), atom['@elementType'].split())):
-            atom_map[_id] = n
-            atoms.append({'element': e, 'charge': 0, 'mapping': 0, 'isotope': None, 'is_radical': False})
-        if '@z3' in atom:
-            for a, x, y, z in zip(atoms, atom['@x3'].split(), atom['@y3'].split(), atom['@z3'].split()):
-                a['x'] = float(x)
-                a['y'] = float(y)
-                a['z'] = float(z)
-        else:
-            for a, x, y in zip(atoms, atom['@x2'].split(), atom['@y2'].split()):
-                a['x'] = float(x) / 2
-                a['y'] = float(y) / 2
-                a['z'] = 0.
-        if '@isotope' in atom:
-            for a, x in zip(atoms, atom['@isotope'].split()):
-                if x != '0':
-                    a['isotope'] = int(x)
-        if '@formalCharge' in atom:
-            for a, x in zip(atoms, atom['@formalCharge'].split()):
-                if x != '0':
-                    a['charge'] = int(x)
-        if '@mrvMap' in atom:
-            for a, x in zip(atoms, atom['@mrvMap'].split()):
-                if x != '0':
-                    a['mapping'] = int(x)
-        if '@radical' in atom:
-            for a, x in zip(atoms, atom['@radical'].split()):
-                if x != '0':
-                    a['is_radical'] = True
-        if '@mrvQueryProps' in atom:
-            raise ValueError('queries unsupported')
-    if not atoms:
-        raise EmptyMolecule
-
-    if 'bond' in data['bondArray']:
-        db = data['bondArray']['bond']
-        if isinstance(db, dict):
-            db = (db,)
-        for bond in db:
-            order = bond_map[bond['@queryType' if '@queryType' in bond else '@order']]
-            a1, a2 = bond['@atomRefs2'].split()
-            if 'bondStereo' in bond:
-                if '$' in bond['bondStereo']:
-                    s = bond['bondStereo']['$']
-                    if s == 'H':
-                        stereo.append((atom_map[a1], atom_map[a2], -1))
-                    elif s == 'W':
-                        stereo.append((atom_map[a1], atom_map[a2], 1))
-                    else:
-                        log.append('invalid or unsupported stereo')
-                else:
-                    log.append('incorrect bondStereo tag')
-            bonds.append((atom_map[a1], atom_map[a2], order))
-
-    return {'atoms': atoms, 'bonds': bonds, 'stereo': stereo, 'hydrogens': hydrogens,
-            'meta': None, 'title': data.get('@title'), 'log': log}
-
-
-class MRVWrite:
-    """
-    ChemAxon MRV files writer. works similar to opened for writing file object. support `with` context manager.
-    on initialization accept opened for writing in text mode file, string path to file,
-    pathlib.Path object or another buffered writer object
-    """
-    def __init__(self, file, mapping: bool = True):
-        """
-        :param mapping: write atom mapping.
-        """
-        if isinstance(file, str):
-            self.__file = open(file, 'w')
-            self.__is_buffer = False
-        elif isinstance(file, Path):
-            self.__file = file.open('w')
-            self.__is_buffer = False
-        elif isinstance(file, (TextIOWrapper, StringIO)):
-            self.__file = file
-            self.__is_buffer = True
-        else:
-            raise TypeError('invalid file. '
-                            'TextIOWrapper, StringIO, BytesIO, BufferedReader and BufferedIOBase subclasses possible')
-        self.__writable = True
-        self.__finalized = False
-        self.__mapping = mapping
-
-    def close(self, force=False):
-        """
-        Write close tag of MRV file and close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self.__finalized:
-            self.__file.write('</cml>\n')
-            self.__finalized = True
-        if self.__writable:
-            self.write = self.__write_closed
-            self.__writable = False
-
-        if not self.__is_buffer or force:
-            self.__file.close()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    @staticmethod
-    def __write_closed(_):
-        raise ValueError('I/O operation on closed writer')
-
-    def write(self, data: Union[ReactionContainer, MoleculeContainer]):
-        """
-        Write single molecule or reaction into file
-        """
-        self.__file.write('<cml>\n')
-        self.__write(data)
-        self.write = self.__write
-
-    def __write(self, data):
-        file = self.__file
-        file.write('<MDocument><MChemicalStruct>')
-        if isinstance(data, ReactionContainer):
-            if not data._arrow:
-                data.fix_positions()
-            if data.name:
-                file.write(f'<reaction title="{data.name}">')
-            else:
-                file.write('<reaction>')
-
-            if data.meta:
-                file.write('<propertyList>')
-                for k, v in data.meta.items():
-                    if isinstance(v, str):
-                        v = f'<![CDATA[{v}]]>'
-                    file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
-                file.write('</propertyList>')
-
-            c = count(1)
-            for i, j in ((data.reactants, 'reactantList'), (data.reagents, 'agentList'),
-                         (data.products, 'productList')):
-                if not i:
-                    continue
-                file.write(f'<{j}>')
-                for n, m in zip(c, i):
-                    if m.name:
-                        file.write(f'<molecule title="{m.name}" molID="m{n}">')
-                    else:
-                        file.write(f'<molecule molID="m{n}">')
-
-                    self.__write_molecule(m)
-                    file.write('</molecule>')
-                file.write(f'</{j}>')
-
-            file.write(f'<arrow type="DEFAULT" x1="{data._arrow[0] * 2:.4f}" y1="0" '
-                       f'x2="{data._arrow[1] * 2:.4f}" y2="0"/></reaction>')
-        elif not isinstance(data, MoleculeContainer):
-            raise TypeError('MoleculeContainer expected')
-        else:
-            if data.name:
-                file.write(f'<molecule title="{data.name}">')
-            else:
-                file.write('<molecule>')
-            if data.meta:
-                file.write('<propertyList>')
-                for k, v in data.meta.items():
-                    if isinstance(v, str):
-                        v = f'<![CDATA[{v}]]>'
-                    file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
-                file.write('</propertyList>')
-
-            self.__write_molecule(data)
-            file.write('</molecule>')
-        file.write('</MChemicalStruct></MDocument>\n')
-
-    def __write_molecule(self, g):
-        gp = g._plane
-        gc = g._charges
-        gr = g._radicals
-        bg = g._bonds
-        hg = g._hydrogens
-        hb = g.hybridization
-        mapping = self.__mapping
-
-        file = self.__file
-        file.write('<atomArray>')
-        for n, atom in g._atoms.items():
-            x, y = gp[n]
-            ih = hg[n]
-            file.write(f'<atom id="a{n}" elementType="{atom.atomic_symbol}" x2="{x * 2:.4f}" y2="{y * 2:.4f}"')
-            if mapping:
-                file.write(f' mrvMap="{n}"')
-            if gc[n]:
-                file.write(f' formalCharge="{gc[n]}"')
-            if gr[n]:
-                file.write(' radical="monovalent"')
-            if atom.isotope:
-                file.write(f' isotope="{atom.isotope}"')
-            if ih and (atom.atomic_symbol not in organic_set or hb(n) == 4 and atom.atomic_number in (5, 7, 15)):
-                file.write(f' hydrogenCount="{ih}"')
-            file.write('/>')
-        file.write('</atomArray>')
-
-        file.write('<bondArray>')
-        wedge = defaultdict(set)
-        n = 0  # empty wedge trick
-        for n, (i, j, s) in enumerate(g._wedge_map, start=1):
-            file.write(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bg[i][j].order]}">'
-                       f'<bondStereo>{s == 1 and "W" or "H"}</bondStereo></bond>')
-            wedge[i].add(j)
-            wedge[j].add(i)
-        for i, j, bond in g.bonds():
-            if j not in wedge[i]:
-                n += 1
-                file.write(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bond.order]}"/>')
-        file.write('</bondArray>')
-
-
-__all__ = ['MRVRead', 'MRVWrite']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2017-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from collections import defaultdict, namedtuple
+from io import StringIO, BytesIO, TextIOWrapper, BufferedIOBase, BufferedReader
+from itertools import count
+from lxml.etree import iterparse, QName, tostring
+from pathlib import Path
+from traceback import format_exc
+from typing import Union, List, Iterator
+from ._mdl import MDLStereo
+from ..containers import MoleculeContainer, ReactionContainer
+from ..exceptions import EmptyMolecule
+
+
+parse_error = namedtuple('MRVParseError', ('number', 'json', 'log', 'meta'))
+organic_set = {'B', 'C', 'N', 'O', 'P', 'S', 'Se', 'F', 'Cl', 'Br', 'I'}
+bond_map = {8: '1" queryType="Any', 4: 'A', 1: '1', 2: '2', 3: '3',
+            'Any': 8, 'any': 8, 'A': 4, 'a': 4, '1': 1, '2': 2, '3': 3}
+
+
+def xml_dict(parent_element, stop_list=None):
+    stop_list = set() if stop_list is None else set(stop_list)
+    out = {}
+    for x, y in parent_element.items():
+        y = y.strip()
+        if y:
+            x = '@%s' % x.strip()
+            out[x] = y
+
+    text = []
+    if len(parent_element):
+        elements_grouped = defaultdict(list)
+        for element in parent_element:
+            name = QName(element).localname
+            if name in stop_list:
+                text.append(tostring(element, encoding=str, with_tail=False))
+            else:
+                elements_grouped[name].append(element)
+
+            if element.tail:
+                t = element.tail.strip()
+                if t:
+                    text.append(t)
+
+        for element_tag, element_group in elements_grouped.items():
+            if len(element_group) == 1:
+                out[element_tag] = xml_dict(element_group[0], stop_list)
+            else:
+                out[element_tag] = [xml_dict(x, stop_list) for x in element_group]
+
+    if parent_element.text:
+        t = parent_element.text.strip()
+        if t:
+            text.insert(0, t)
+    if text:
+        out['$'] = ''.join(text)
+
+    return out
+
+
+class MRVRead(MDLStereo):
+    """
+    ChemAxon MRV files reader. works similar to opened file object. support `with` context manager.
+    on initialization accept opened in binary mode file, string path to file,
+    pathlib.Path object or another binary buffered reader object
+    """
+    def __init__(self, file, **kwargs):
+        """
+        :param ignore: Skip some checks of data or try to fix some errors.
+        :param remap: Remap atom numbers started from one.
+        :param store_log: Store parser log if exists messages to `.meta` by key `ParserLog`.
+        :param calc_cis_trans: Calculate cis/trans marks from 2d coordinates.
+        :param ignore_stereo: Ignore stereo data.
+        """
+        if isinstance(file, str):
+            self.__file = open(file, 'rb')
+            self.__is_buffer = False
+        elif isinstance(file, Path):
+            self.__file = file.open('rb')
+            self.__is_buffer = False
+        elif isinstance(file, (BytesIO, BufferedReader, BufferedIOBase)):
+            self.__file = file
+            self.__is_buffer = True
+        else:
+            raise TypeError('invalid file. BytesIO, BufferedReader and BufferedIOBase subclasses possible')
+        super().__init__(**kwargs)
+        self._data = self.__reader()
+
+    def close(self, force=False):
+        """
+        close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self.__is_buffer or force:
+            self.__file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    def read(self) -> List[Union[ReactionContainer, MoleculeContainer]]:
+        """
+        parse whole file
+
+        :return: list of parsed molecules or reactions
+        """
+        return list(iter(self))
+
+    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
+        return (x for x in self._data if not isinstance(x, parse_error))
+
+    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
+        return next(iter(self))
+
+    def __reader(self) -> Iterator[Union[ReactionContainer, MoleculeContainer, parse_error]]:
+        for n, (_, element) in enumerate(iterparse(self.__file, tag='{*}MChemicalStruct')):
+            parsed = xml_dict(element)
+            element.clear()
+            if 'molecule' in parsed and isinstance(parsed['molecule'], dict):
+                parsed = parsed['molecule']
+                if 'propertyList' in parsed and 'property' in parsed['propertyList']:
+                    meta = self.__parse_property(parsed['propertyList']['property'])
+                else:
+                    meta = {}
+
+                try:
+                    record = self.__parse_molecule(parsed)
+                except (KeyError, ValueError):
+                    self._info(f'record consist errors:\n{format_exc()}')
+                    yield parse_error(n, parsed, self._format_log(), meta)
+                else:
+                    record['meta'].update(meta)
+                    try:
+                        container = self._convert_molecule(record)
+                    except ValueError:
+                        self._info(f'record consist errors:\n{format_exc()}')
+                        yield parse_error(n, parsed, self._format_log(), meta)
+                    else:
+                        yield container
+            elif 'reaction' in parsed and isinstance(parsed['reaction'], dict):
+                parsed = parsed['reaction']
+                if 'propertyList' in parsed and 'property' in parsed['propertyList']:
+                    meta = self.__parse_property(parsed['propertyList']['property'])
+                else:
+                    meta = {}
+
+                try:
+                    record = self.__parse_reaction(parsed)
+                except (KeyError, ValueError):
+                    self._info(f'record consist errors:\n{format_exc()}')
+                    yield parse_error(n, parsed, self._format_log(), meta)
+                else:
+                    record['meta'] = meta
+                    try:
+                        container = self._convert_reaction(record)
+                    except ValueError:
+                        self._info(f'record consist errors:\n{format_exc()}')
+                        yield parse_error(n, parsed, self._format_log(), meta)
+                    else:
+                        yield container
+            else:
+                self._info('invalid MDocument')
+                yield parse_error(n, parsed, self._format_log(), {})
+
+    def __parse_reaction(self, data):
+        reaction = {'reactants': [], 'products': [], 'reagents': []}
+        title = data.get('@title')
+        if title:
+            reaction['title'] = title
+        for tag, group in (('reactantList', 'reactants'), ('productList', 'products'), ('agentList', 'reagents')):
+            if tag in data and 'molecule' in data[tag]:
+                molecule = data[tag]['molecule']
+                if isinstance(molecule, dict):
+                    molecule = (molecule,)
+                for m in molecule:
+                    try:
+                        reaction[group].append(self.__parse_molecule(m))
+                    except EmptyMolecule:
+                        if not self._ignore:
+                            raise
+                        self._info('empty molecule ignored')
+        return reaction
+
+    def __parse_property(self, data):
+        meta = {}
+        if isinstance(data, dict):
+            key = data['@title']
+            val = data['scalar']['$'].strip()
+            if key and val:
+                meta[key] = val
+            else:
+                self._info(f'invalid metadata entry: {data}')
+        else:
+            for x in data:
+                key = x['@title']
+                val = x['scalar']['$'].strip()
+                if key and val:
+                    meta[key] = val
+                else:
+                    self._info(f'invalid metadata entry: {x}')
+        return meta
+
+    def __parse_molecule(self, data):
+        atoms, bonds, stereo = [], [], []
+        hydrogens = {}
+        atom_map = {}
+        if 'atom' in data['atomArray']:
+            da = data['atomArray']['atom']
+            if isinstance(da, dict):
+                da = (da,)
+            for n, atom in enumerate(da):
+                atom_map[atom['@id']] = n
+                atoms.append({'element': atom['@elementType'],
+                              'isotope': int(atom['@isotope']) if '@isotope' in atom else None,
+                              'charge': int(atom.get('@formalCharge', 0)),
+                              'is_radical': '@radical' in atom,
+                              'mapping': int(atom.get('@mrvMap', 0))})
+                if '@z3' in atom:
+                    atoms[-1].update(x=float(atom['@x3']), y=float(atom['@y3']), z=float(atom['@z3']))
+                else:
+                    atoms[-1].update(x=float(atom['@x2']) / 2, y=float(atom['@y2']) / 2, z=0.)
+                if '@mrvQueryProps' in atom:
+                    raise ValueError('queries unsupported')
+                if '@hydrogenCount' in atom:
+                    hydrogens[n] = int(atom['@hydrogenCount'])
+        else:
+            atom = data['atomArray']
+            for n, (_id, e) in enumerate(zip(atom['@atomID'].split(), atom['@elementType'].split())):
+                atom_map[_id] = n
+                atoms.append({'element': e, 'charge': 0, 'mapping': 0, 'isotope': None, 'is_radical': False})
+            if '@z3' in atom:
+                for a, x, y, z in zip(atoms, atom['@x3'].split(), atom['@y3'].split(), atom['@z3'].split()):
+                    a['x'] = float(x)
+                    a['y'] = float(y)
+                    a['z'] = float(z)
+            else:
+                for a, x, y in zip(atoms, atom['@x2'].split(), atom['@y2'].split()):
+                    a['x'] = float(x) / 2
+                    a['y'] = float(y) / 2
+                    a['z'] = 0.
+            if '@isotope' in atom:
+                for a, x in zip(atoms, atom['@isotope'].split()):
+                    if x != '0':
+                        a['isotope'] = int(x)
+            if '@formalCharge' in atom:
+                for a, x in zip(atoms, atom['@formalCharge'].split()):
+                    if x != '0':
+                        a['charge'] = int(x)
+            if '@mrvMap' in atom:
+                for a, x in zip(atoms, atom['@mrvMap'].split()):
+                    if x != '0':
+                        a['mapping'] = int(x)
+            if '@radical' in atom:
+                for a, x in zip(atoms, atom['@radical'].split()):
+                    if x != '0':
+                        a['is_radical'] = True
+            if '@mrvQueryProps' in atom:
+                raise ValueError('queries unsupported')
+        if not atoms:
+            raise EmptyMolecule
+
+        if 'bond' in data['bondArray']:
+            db = data['bondArray']['bond']
+            if isinstance(db, dict):
+                db = (db,)
+            for bond in db:
+                order = bond_map[bond['@queryType' if '@queryType' in bond else '@order']]
+                a1, a2 = bond['@atomRefs2'].split()
+                if 'bondStereo' in bond:
+                    if '$' in bond['bondStereo']:
+                        s = bond['bondStereo']['$']
+                        if s == 'H':
+                            stereo.append((atom_map[a1], atom_map[a2], -1))
+                        elif s == 'W':
+                            stereo.append((atom_map[a1], atom_map[a2], 1))
+                        else:
+                            self._info('invalid or unsupported stereo')
+                    else:
+                        self._info('incorrect bondStereo tag')
+                bonds.append((atom_map[a1], atom_map[a2], order))
+
+        mol = {'atoms': atoms, 'bonds': bonds, 'stereo': stereo, 'meta': {}, 'hydrogens': hydrogens}
+        if '@title' in data:
+            mol['title'] = data['@title']
+        return mol
+
+
+class MRVWrite:
+    """
+    ChemAxon MRV files writer. works similar to opened for writing file object. support `with` context manager.
+    on initialization accept opened for writing in text mode file, string path to file,
+    pathlib.Path object or another buffered writer object
+    """
+    def __init__(self, file):
+        if isinstance(file, str):
+            self._file = open(file, 'w')
+            self._is_buffer = False
+        elif isinstance(file, Path):
+            self._file = file.open('w')
+            self._is_buffer = False
+        elif isinstance(file, (TextIOWrapper, StringIO)):
+            self._file = file
+            self._is_buffer = True
+        else:
+            raise TypeError('invalid file. '
+                            'TextIOWrapper, StringIO, BytesIO, BufferedReader and BufferedIOBase subclasses possible')
+        self.__writable = True
+
+    def close(self, force=False):
+        """
+        write close tag of MRV file and close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self.__finalized:
+            self._file.write('</cml>\n')
+            self.__finalized = True
+        if self.__writable:
+            self.write = self.__write_closed
+            self.__writable = False
+
+        if not self._is_buffer or force:
+            self._file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    @staticmethod
+    def __write_closed(_):
+        raise ValueError('I/O operation on closed writer')
+
+    def write(self, data: Union[ReactionContainer, MoleculeContainer]):
+        """
+        write single molecule or reaction into file
+        """
+        self._file.write('<cml>\n')
+        self.__write(data)
+        self.write = self.__write
+
+    def __write(self, data):
+        if isinstance(data, ReactionContainer):
+            buffer = ['<MDocument><MChemicalStruct>']
+            if not data._arrow:
+                data.fix_positions()
+
+            if data.name:
+                buffer.append(f'<reaction title="{data.name}">')
+            else:
+                buffer.append('<reaction>')
+
+            if data.meta:
+                buffer.append('<propertyList>')
+                for k, v in data.meta.items():
+                    if isinstance(v, str):
+                        v = f'<![CDATA[{v}]]>'
+                    buffer.append(f'<property title="{k}"><scalar>{v}</scalar></property>')
+                buffer.append('</propertyList>')
+            c = count(1)
+            for i, j in ((data.reactants, 'reactantList'), (data.products, 'productList'),
+                         (data.reagents, 'agentList')):
+                if not i:
+                    continue
+                buffer.append(f'<{j}>')
+                for n, m in zip(c, i):
+                    if m.name:
+                        buffer.append(f'<molecule title="{m.name}" molID="m{n}">')
+                    else:
+                        buffer.append(f'<molecule molID="m{n}">')
+                    buffer.append(self.__convert_structure(m))
+                    buffer.append('</molecule>')
+                buffer.append(f'</{j}>')
+
+            buffer.append(f'<arrow type="DEFAULT" x1="{data._arrow[0] * 2:.4f}" y1="0" '
+                          f'x2="{data._arrow[1] * 2:.4f}" y2="0"/>')
+            buffer.append('</reaction>')
+            self._file.writelines(buffer)
+        elif not isinstance(data, MoleculeContainer):
+            raise TypeError('MoleculeContainer expected')
+        else:
+            m = self.__convert_structure(data)
+            self._file.write('<MDocument><MChemicalStruct>')
+
+            if data.name:
+                self._file.write(f'<molecule title="{data.name}">')
+            else:
+                self._file.write('<molecule>')
+
+            if data.meta:
+                self._file.write('<propertyList>')
+                for k, v in data.meta.items():
+                    if isinstance(v, str):
+                        v = f'<![CDATA[{v}]]>'
+                    self._file.write(f'<property title="{k}"><scalar>{v}</scalar></property>')
+                self._file.write('</propertyList>')
+            self._file.write(m)
+            self._file.write('</molecule>')
+        self._file.write('</MChemicalStruct></MDocument>\n')
+
+    @staticmethod
+    def __convert_structure(g):
+        gp = g._plane
+        gc = g._charges
+        gr = g._radicals
+        bg = g._bonds
+        hg = g._hydrogens
+        hb = g.hybridization
+
+        out = ['<atomArray>']
+        for n, atom in g._atoms.items():
+            x, y = gp[n]
+            ih = hg[n]
+            out.append(f'<atom id="a{n}" elementType="{atom.atomic_symbol}" '
+                       f'x2="{x * 2:.4f}" y2="{y * 2:.4f}" mrvMap="{n}"')
+            if gc[n]:
+                out.append(f' formalCharge="{gc[n]}"')
+            if gr[n]:
+                out.append(' radical="monovalent"')
+            if atom.isotope:
+                out.append(f' isotope="{atom.isotope}"')
+            if ih and (atom.atomic_symbol not in organic_set or hb(n) == 4 and atom.atomic_number in (5, 7, 15)):
+                out.append(f' hydrogenCount="{ih}"')
+            out.append('/>')
+        out.append('</atomArray>')
+
+        out.append('<bondArray>')
+        wedge = defaultdict(set)
+        for n, (i, j, s) in enumerate(g._wedge_map, start=1):
+            out.append(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bg[i][j].order]}">'
+                       f'<bondStereo>{s == 1 and "W" or "H"}</bondStereo></bond>')
+            wedge[i].add(j)
+            wedge[j].add(i)
+        for n, (i, j, bond) in enumerate(g.bonds(), start=len(out)):
+            if j not in wedge[i]:
+                out.append(f'<bond id="b{n}" atomRefs2="a{i} a{j}" order="{bond_map[bond.order]}"/>')
+        out.append('</bondArray>')
+        return ''.join(out)
+
+    __finalized = False
+
+
+__all__ = ['MRVRead', 'MRVWrite']
```

### Comparing `chython-1.67/chython/files/__init__.py` & `chython-1.8/chython/files/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,29 +1,30 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .daylight import *
-from .inchi import *
-from .MRVrw import *
-from .PDBrw import *
-from .RDFrw import *
-from .SDFrw import *
-from .xyz import *
-
-
-__all__ = ['smiles', 'smarts', 'mdl_mol', 'mdl_rxn', 'xyz', 'xyz_file', 'inchi']
-__all__.extend(x for x in locals() if x.endswith(('Read', 'Write')))
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .INCHIrw import *
+from .MRVrw import *
+from .PDBrw import *
+from .RDFrw import *
+from .SDFrw import *
+from .SMILESrw import *
+from .XYZrw import *
+from ._mdl import parse_error
+
+
+__all__ = [x for x in locals() if x.endswith(('Read', 'Write'))]
+__all__.append('mdl_mol')
```

### Comparing `chython-1.67/chython/files/_mdl/read.py` & `chython-1.8/chython/files/_mdl/read.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,225 +1,190 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2021-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABCMeta, abstractmethod
-from base64 import urlsafe_b64encode
-from fileinput import FileInput
-from io import StringIO, TextIOWrapper
-from itertools import islice
-from os.path import abspath, join
-from pathlib import Path
-from pickle import load, UnpicklingError
-from sys import platform
-from tempfile import gettempdir
-from typing import Union, Iterator, List, Dict, Optional
-from ...containers import ReactionContainer, MoleculeContainer
-
-
-class MDLReadMeta(ABCMeta):
-    def __call__(cls, *args, **kwargs):
-        if kwargs.get('indexable'):
-            _cls = type(cls.__name__, (cls,), {'__len__': lambda x: len(x._shifts), '__module__': cls.__module__})
-            obj = object.__new__(_cls)  # noqa
-        else:
-            obj = object.__new__(cls)  # noqa
-        obj.__init__(*args, **kwargs)
-        return obj
-
-
-class MDLRead(metaclass=MDLReadMeta):
-    def __init__(self, file, buffer_size=1000, indexable=False, ignore=True, remap=False, ignore_bad_isotopes=False,
-                 ignore_stereo=False, calc_cis_trans=False):
-        if isinstance(file, str):
-            self._file = open(file)
-            self._is_buffer = False
-        elif isinstance(file, Path):
-            self._file = file.open()
-            self._is_buffer = False
-        elif isinstance(file, (TextIOWrapper, StringIO, FileInput)):
-            self._file = file
-            self._is_buffer = True
-        else:
-            raise TypeError('invalid file. TextIOWrapper, StringIO or FileInput subclasses or path to file expected')
-        self._shifts = None
-        self._tell = 0
-        self._buffer_size = buffer_size
-        self._buffer = None
-        self._ignore = ignore
-        self._remap = remap
-        self._ignore_bad_isotopes = ignore_bad_isotopes
-        self._ignore_stereo = ignore_stereo
-        self._calc_cis_trans = calc_cis_trans
-        if indexable:
-            self._load_cache()
-
-    def read(self, amount: Optional[int] = None) -> List[Union[ReactionContainer, MoleculeContainer]]:
-        """
-        Parse whole file
-
-        :param amount: number of records to read
-        """
-        if amount:
-            return list(islice(iter(self), amount))
-        return list(iter(self))
-
-    @abstractmethod
-    def read_structure(self, *, current: bool = True):
-        """
-        Read Reaction or Molecule container.
-
-        :param current: return current structure if already parsed, otherwise read next
-        """
-
-    @abstractmethod
-    def read_metadata(self, *, current: bool = True) -> Dict[str, str]:
-        """
-        Read metadata block
-        """
-
-    def close(self, force: bool = False):
-        """
-        Close opened file
-
-        :param force: force closing of externally opened file or buffer
-        """
-        if not self._is_buffer or force:
-            self._file.close()
-
-    def tell(self):
-        """
-        Number of records processed from the original file
-        """
-        return self._tell
-
-    def seek(self, offset):
-        """
-        Shift to a given record number
-        """
-        if self._shifts:
-            if 0 <= offset < len(self._shifts):
-                self._tell = offset
-                self._buffer = None
-                self._file.seek(self._shifts[offset])
-            else:
-                raise IndexError('invalid offset')
-        else:
-            raise NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
-
-    @abstractmethod
-    def reset_index(self):
-        """
-        Create (rewrite) indexation table. Implemented only for object that
-        is a real file (the path to the file is specified) because the external grep utility is used.
-        """
-
-    def read_block(self, *, current: bool = True) -> str:
-        """
-        Read full record block with metadata
-        """
-        return ''.join(self._read_block(current=current))
-
-    @abstractmethod
-    def _read_block(self, *, current: bool = True) -> List[str]:
-        """
-        Read full record block with metadata
-        """
-
-    def _load_cache(self):
-        """
-        Load existing cache or create new. Working only for UNIX-like systems and local files (not buffers).
-        """
-        if platform == 'win32' or self._is_buffer:
-            return
-        try:
-            with open(self._cache_path, 'rb') as f:
-                self._shifts = load(f)
-        except FileNotFoundError:  # cache not found
-            self.reset_index()
-        except IsADirectoryError as e:
-            raise IsADirectoryError(f'Please delete {self._cache_path} directory') from e
-        except (UnpicklingError, EOFError) as e:  # invalid file. ask user to check it.
-            raise UnpicklingError(f'Invalid cache file {self._cache_path}. Please delete it') from e
-
-    @property
-    def _cache_path(self):
-        return abspath(join(gettempdir(), 'chython_' + urlsafe_b64encode(abspath(self._file.name).encode()).decode()))
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, _type, value, traceback):
-        self.close()
-
-    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
-        while True:
-            try:
-                yield self.read_structure(current=False)
-            except ValueError:
-                pass
-            except EOFError:
-                return
-
-    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
-        return next(iter(self))
-
-    def __getitem__(self, item) -> Union[ReactionContainer, MoleculeContainer,
-                                         List[Union[ReactionContainer, MoleculeContainer]]]:
-        """
-        Getting the item by index from the original file,
-        For slices records with errors skipped.
-        """
-        if self._shifts:
-            _len = len(self._shifts)
-            if isinstance(item, int):
-                if item >= _len or item < -_len:
-                    raise IndexError('List index out of range')
-                if item < 0:
-                    item += _len
-                self.seek(item)
-                return self.read_structure()
-            elif isinstance(item, slice):
-                start, stop, step = item.indices(_len)
-                if start == stop:
-                    return []
-                if step == 1:
-                    self.seek(start)
-                    records = []
-                    for _ in range(start, stop):
-                        try:
-                            records.append(self.read_structure(current=False))
-                        except EOFError:
-                            break
-                        except ValueError:
-                            pass
-                else:
-                    records = []
-                    for index in range(start, stop, step):
-                        self.seek(index)
-                        try:
-                            records.append(self.read_structure())
-                        except EOFError:
-                            break
-                        except ValueError:
-                            pass
-                return records
-            else:
-                raise TypeError('Indices must be integers or slices')
-        raise NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
-
-
-__all__ = ['MDLRead']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from base64 import urlsafe_b64encode
+from fileinput import FileInput
+from io import StringIO, TextIOWrapper
+from itertools import islice
+from os.path import abspath, join
+from pathlib import Path
+from pickle import dump, load, UnpicklingError
+from sys import platform
+from tempfile import gettempdir
+from typing import Union, Iterator, List
+from .parser import parse_error
+from .stereo import MDLStereo
+from ...containers import ReactionContainer, MoleculeContainer
+
+
+class MDLReadMeta(type):
+    def __call__(cls, *args, **kwargs):
+        if kwargs.get('indexable'):
+            _cls = type(cls.__name__, (cls,), {'__len__': lambda x: len(x._shifts) - 1, '__module__': cls.__module__})
+            obj = object.__new__(_cls)
+        else:
+            obj = object.__new__(cls)
+        obj.__init__(*args, **kwargs)
+        return obj
+
+
+class MDLRead(MDLStereo, metaclass=MDLReadMeta):
+    def __init__(self, file, **kwargs):
+        if isinstance(file, str):
+            self._file = open(file)
+            self._is_buffer = False
+        elif isinstance(file, Path):
+            self._file = file.open()
+            self._is_buffer = False
+        elif isinstance(file, (TextIOWrapper, StringIO, FileInput)):
+            self._file = file
+            self._is_buffer = True
+        else:
+            raise TypeError('invalid file. TextIOWrapper, StringIO subclasses possible')
+        super().__init__(**kwargs)
+
+    def close(self, force=False):
+        """
+        Close opened file
+
+        :param force: force closing of externally opened file or buffer
+        """
+        if not self._is_buffer or force:
+            self._file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, _type, value, traceback):
+        self.close()
+
+    def _load_cache(self):
+        """
+        Load existing cache or create new. Working only for UNIX-like systems and local files (not buffers).
+        """
+        if platform == 'win32' or self._is_buffer:
+            return
+        try:
+            with open(self.__cache_path, 'rb') as f:
+                self._shifts = load(f)
+        except FileNotFoundError:  # cache not found
+            self.reset_index()
+        except IsADirectoryError as e:
+            raise IsADirectoryError(f'Please delete {self.__cache_path} directory') from e
+        except (UnpicklingError, EOFError) as e:  # invalid file. ask user to check it.
+            raise UnpicklingError(f'Invalid cache file {self.__cache_path}. Please delete it') from e
+
+    def reset_index(self):
+        """
+        Create (rewrite) indexation table. Implemented only for object that
+        is a real file (the path to the file is specified) because the external grep utility is used.
+        """
+        if platform != 'win32' and not self._is_buffer:
+            self._shifts = self._get_shifts(self._file.name)
+            with open(self.__cache_path, 'wb') as f:
+                dump(self._shifts, f)
+        else:
+            raise self._implement_error
+
+    @property
+    def __cache_path(self):
+        return abspath(join(gettempdir(), 'chython_' + urlsafe_b64encode(abspath(self._file.name).encode()).decode()))
+
+    def read(self) -> List[Union[ReactionContainer, MoleculeContainer]]:
+        """
+        Parse whole file
+
+        :return: list of parsed molecules
+        """
+        return list(iter(self))
+
+    def __iter__(self) -> Iterator[Union[ReactionContainer, MoleculeContainer]]:
+        return (x for x in self._data if not isinstance(x, parse_error))
+
+    def __next__(self) -> Union[ReactionContainer, MoleculeContainer]:
+        return next(iter(self))
+
+    def __getitem__(self, item) -> Union[ReactionContainer, MoleculeContainer, parse_error]:
+        """
+        Getting the item by index from the original file,
+        For slices records with errors skipped.
+        For indexed access records with errors returned as error container.
+        :return: [Molecule, Reaction]Container or list of [Molecule, Reaction]Containers
+        """
+        if self._shifts:
+            _len = len(self._shifts) - 1
+            if isinstance(item, int):
+                if item >= _len or item < -_len:
+                    raise IndexError('List index out of range')
+                if item < 0:
+                    item += _len
+                self.seek(item)
+                return next(self._data)
+            elif isinstance(item, slice):
+                start, stop, step = item.indices(_len)
+                if start == stop:
+                    return []
+                if step == 1:
+                    self.seek(start)
+                    records = [x for x in islice(self._data, stop - start) if not isinstance(x, parse_error)]
+                else:
+                    records = []
+                    for index in range(start, stop, step):
+                        self.seek(index)
+                        record = next(self._data)
+                        if not isinstance(record, parse_error):
+                            records.append(record)
+                return records
+            else:
+                raise TypeError('Indices must be integers or slices')
+        raise self._implement_error
+
+    def read_text(self, item):
+        """
+        Read record block as text
+        """
+        if self._shifts:
+            if not isinstance(item, int):
+                raise TypeError('int required')
+            _len = len(self._shifts) - 1
+            if item >= _len or item < -_len:
+                raise IndexError('List index out of range')
+            if item < 0:
+                item += _len
+            start = self._shifts[item]
+            end = self._shifts[item + 1]
+            current = self._file.tell()
+            self._file.seek(start)
+            data = self._file.read(end - start)
+            self._file.seek(current)
+            return data
+        raise self._implement_error
+
+    def _prepare_meta(self, meta):
+        new_meta = {}
+        for k, v in meta.items():
+            if v:
+                new_meta[k] = '\n'.join(v)
+            else:
+                self._info(f'invalid metadata entry: {k}: {v}')
+        return new_meta
+
+    _shifts = None
+    _implement_error = NotImplementedError('Indexable supported in unix-like o.s. and for files stored on disk')
+
+
+__all__ = ['MDLRead']
```

### Comparing `chython-1.67/chython/files/_mdl/stereo.py` & `chython-1.8/chython/files/_mdl/stereo.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,95 +1,79 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from ...exceptions import NotChiral, IsChiral, ValenceError
-
-
-def postprocess_molecule(molecule, data, *, ignore=True, ignore_stereo=False, calc_cis_trans=False,
-                         keep_implicit=False):
-    mapping = data['mapping']
-    hydrogens = molecule._hydrogens
-    hyb = molecule.hybridization
-
-    implicit_mismatch = {}
-    if 'chython_parsing_log' in molecule.meta:
-        log = molecule.meta['chython_parsing_log']
-    else:
-        log = []
-
-    for n, h in data['hydrogens'].items():
-        n = mapping[n]
-        if keep_implicit:  # override any calculated hydrogens count.
-            hydrogens[n] = h
-        if (hc := hydrogens[n]) is None:  # aromatic rings or valence errors
-            if hyb(n) == 4:  # this is aromatic rings. just store given H count.
-                hydrogens[n] = h
-        elif hc != h:
-            if hyb(n) == 4:
-                if ignore:
-                    implicit_mismatch[n] = h
-                    log.append(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-                else:
-                    raise ValueError(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-            elif molecule._check_implicit(n, h):  # set another possible implicit state. probably Al, P
-                hydrogens[n] = h
-            elif ignore:  # just ignore it
-                implicit_mismatch[n] = h
-                log.append(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-            else:
-                raise ValueError(f'implicit hydrogen count ({h}) mismatch with calculated on atom {n}')
-
-    if implicit_mismatch:
-        molecule.meta['chython_implicit_mismatch'] = implicit_mismatch
-    if log and 'chython_parsing_log' not in molecule.meta:
-        molecule.meta['chython_parsing_log'] = log
-    if ignore_stereo:
-        return
-
-    if calc_cis_trans:
-        molecule.calculate_cis_trans_from_2d()
-
-    stereo = [(mapping[n], mapping[m], s) for n, m, s in data['stereo']]
-    while stereo:
-        fail_stereo = []
-        old_stereo = len(stereo)
-        for n, m, s in stereo:
-            try:
-                molecule.add_wedge(n, m, s, clean_cache=False)
-            except NotChiral:
-                fail_stereo.append((n, m, s))
-            except IsChiral:
-                pass
-            except ValenceError:
-                log.append('structure has errors, stereo data skipped')
-                molecule.flush_cache()
-                break
-        else:
-            stereo = fail_stereo
-            if len(stereo) == old_stereo:
-                break
-            molecule.flush_stereo_cache()
-            if calc_cis_trans:
-                molecule.calculate_cis_trans_from_2d(clean_cache=False)
-            continue
-        break
-
-    if log and 'chython_parsing_log' not in molecule.meta:
-        molecule.meta['chython_parsing_log'] = log
-
-
-__all__ = ['postprocess_molecule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .parser import Parser
+from ...exceptions import NotChiral, IsChiral, ValenceError
+
+
+class MDLStereo(Parser):
+    def __init__(self, calc_cis_trans=False, ignore_stereo=False, **kwargs):
+        super().__init__(**kwargs)
+        self.__calc_cis_trans = calc_cis_trans
+        self.__ignore_stereo = ignore_stereo
+
+    def _create_molecule(self, data, mapping):
+        mol = super()._create_molecule(data, mapping)
+        hydrogens = mol._hydrogens
+        for n, h in data['hydrogens'].items():
+            n = mapping[n]
+            hc = hydrogens[n]
+            if hc is None:  # aromatic rings or valence errors. just store given H count.
+                hydrogens[n] = h
+            elif hc != h:  # H count mismatch. try radical state of atom.
+                if self._ignore:
+                    hydrogens[n] = h  # set parsed hydrogens count
+                    self._info(f'implicit hydrogen count ({h}) mismatch with '
+                               f'calculated ({hc}) on atom {n}. calculated count replaced.')
+                else:
+                    raise ValueError(f'implicit hydrogen count ({h}) mismatch with '
+                                     f'calculated ({hc}) on atom {n}.')
+
+        if self.__ignore_stereo:
+            return mol
+
+        if self.__calc_cis_trans:
+            mol.calculate_cis_trans_from_2d()
+
+        stereo = [(mapping[n], mapping[m], s) for n, m, s in data['stereo']]
+        while stereo:
+            fail_stereo = []
+            old_stereo = len(stereo)
+            for n, m, s in stereo:
+                try:
+                    mol.add_wedge(n, m, s, clean_cache=False)
+                except NotChiral:
+                    fail_stereo.append((n, m, s))
+                except IsChiral:
+                    pass
+                except ValenceError:
+                    self._info('structure has errors, stereo data skipped')
+                    mol.flush_cache()
+                    break
+            else:
+                stereo = fail_stereo
+                if len(stereo) == old_stereo:
+                    break
+                mol.flush_stereo_cache()
+                if self.__calc_cis_trans:
+                    mol.calculate_cis_trans_from_2d(clean_cache=False)
+                continue
+            break
+        return mol
+
+
+__all__ = ['MDLStereo']
```

### Comparing `chython-1.67/chython/periodictable/__init__.py` & `chython-1.8/chython/periodictable/__init__.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABCMeta
-from .element import *
-from .groups import *
-from .periods import *
-from .groupI import *
-from .groupII import *
-from .groupIII import *
-from .groupIV import *
-from .groupV import *
-from .groupVI import *
-from .groupVII import *
-from .groupVIII import *
-from .groupIX import *
-from .groupX import *
-from .groupXI import *
-from .groupXII import *
-from .groupXIII import *
-from .groupXIV import *
-from .groupXV import *
-from .groupXVI import *
-from .groupXVII import *
-from .groupXVIII import *
-
-modules = {v.__name__: v for k, v in globals().items() if k.startswith('group') and k != 'groups'}
-elements = {k: v for k, v in globals().items() if isinstance(v, ABCMeta) and k != 'Element' and issubclass(v, Element)}
-
-__all__ = ['Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'ListElement', 'AnyMetal']
-__all__.extend(k for k in globals() if k.startswith('Group'))
-__all__.extend(k for k in globals() if k.startswith('Period'))
-__all__.extend(elements)
-
-
-for _class in (DynamicElement, QueryElement):
-    for k, v in elements.items():
-        name = f'{_class.__name__[:-7]}{k}'
-        globals()[name] = cls = type(name, (_class, *v.__mro__[-3:-1]),
-                                     {'__module__': v.__module__, '__slots__': (), 'atomic_number': v.atomic_number,
-                                      'atomic_radius': v.atomic_radius})
-        setattr(modules[v.__module__], name, cls)
-        modules[v.__module__].__all__.append(name)
-        __all__.append(name)
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2018-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABCMeta
+from .element import *
+from .groups import *
+from .periods import *
+from .groupI import *
+from .groupII import *
+from .groupIII import *
+from .groupIV import *
+from .groupV import *
+from .groupVI import *
+from .groupVII import *
+from .groupVIII import *
+from .groupIX import *
+from .groupX import *
+from .groupXI import *
+from .groupXII import *
+from .groupXIII import *
+from .groupXIV import *
+from .groupXV import *
+from .groupXVI import *
+from .groupXVII import *
+from .groupXVIII import *
+
+modules = {v.__name__: v for k, v in globals().items() if k.startswith('group') and k != 'groups'}
+elements = {k: v for k, v in globals().items() if isinstance(v, ABCMeta) and k != 'Element' and issubclass(v, Element)}
+
+__all__ = ['Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'ListElement', 'AnyMetal']
+__all__.extend(k for k in globals() if k.startswith('Group'))
+__all__.extend(k for k in globals() if k.startswith('Period'))
+__all__.extend(elements)
+
+
+for _class in (DynamicElement, QueryElement):
+    for k, v in elements.items():
+        name = f'{_class.__name__[:-7]}{k}'
+        globals()[name] = cls = type(name, (_class, *v.__mro__[-3:-1]),
+                                     {'__module__': v.__module__, '__slots__': (), 'atomic_number': v.atomic_number,
+                                      'atomic_radius': v.atomic_radius})
+        setattr(modules[v.__module__], name, cls)
+        modules[v.__module__].__all__.append(name)
+        __all__.append(name)
```

### Comparing `chython-1.67/chython/periodictable/element/__init__.py` & `chython-1.8/chython/periodictable/element/__init__.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .core import *
-from .element import *
-from .query import *
-from .dynamic import *
-
-
-__all__ = ['Core', 'Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .core import *
+from .element import *
+from .query import *
+from .dynamic import *
+
+
+__all__ = ['Core', 'Element', 'DynamicElement', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
```

### Comparing `chython-1.67/chython/periodictable/element/dynamic.py` & `chython-1.8/chython/periodictable/element/dynamic.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC
-from typing import Type, Union
-from .core import Core
-from .element import Element
-from ...exceptions import IsNotConnectedAtom
-
-
-class DynamicElement(Core, ABC):
-    __slots__ = ('__p_charge', '__p_is_radical')
-
-    @property
-    def atomic_symbol(self) -> str:
-        return self.__class__.__name__[7:]
-
-    @classmethod
-    def from_symbol(cls, symbol: str) -> Type['DynamicElement']:
-        """
-        get DynamicElement class by its symbol
-        """
-        try:
-            element = next(x for x in DynamicElement.__subclasses__() if x.__name__ == f'Dynamic{symbol}')
-        except StopIteration:
-            raise ValueError(f'DynamicElement with symbol "{symbol}" not found')
-        return element
-
-    @classmethod
-    def from_atomic_number(cls, number: int) -> Type['DynamicElement']:
-        """
-        get DynamicElement class by its number
-        """
-        try:
-            element = next(x for x in DynamicElement.__subclasses__() if x.atomic_number.fget(None) == number)
-        except StopIteration:
-            raise ValueError(f'DynamicElement with number "{number}" not found')
-        return element
-
-    @classmethod
-    def from_atom(cls, atom: Union['Element', 'DynamicElement']) -> 'DynamicElement':
-        """
-        get DynamicElement object from Element object or copy of DynamicElement object
-        """
-        if isinstance(atom, Element):
-            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
-        elif not isinstance(atom, DynamicElement):
-            raise TypeError('Element or DynamicElement expected')
-        return atom.copy()
-
-    @property
-    def p_charge(self) -> int:
-        try:
-            return self._graph()._p_charges[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def p_is_radical(self) -> bool:
-        try:
-            return self._graph()._p_radicals[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    def __eq__(self, other):
-        """
-        compare attached to molecules dynamic elements
-        """
-        return isinstance(other, DynamicElement) and self.atomic_number == other.atomic_number and \
-            self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical and \
-            self.p_charge == other.p_charge and self.p_is_radical == other.p_is_radical
-
-    def __hash__(self):
-        return hash((self.isotope or 0, self.atomic_number, self.charge, self.p_charge,
-                     self.is_radical, self.p_is_radical))
-
-    @property
-    def is_dynamic(self) -> bool:
-        """
-        Atom has dynamic features
-        """
-        return self.charge != self.p_charge or self.is_radical != self.p_is_radical
-
-
-__all__ = ['DynamicElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC
+from typing import Type, Union
+from .core import Core
+from .element import Element
+from ...exceptions import IsNotConnectedAtom
+
+
+class DynamicElement(Core, ABC):
+    __slots__ = ('__p_charge', '__p_is_radical')
+
+    @property
+    def atomic_symbol(self) -> str:
+        return self.__class__.__name__[7:]
+
+    @classmethod
+    def from_symbol(cls, symbol: str) -> Type['DynamicElement']:
+        """
+        get DynamicElement class by its symbol
+        """
+        try:
+            element = next(x for x in DynamicElement.__subclasses__() if x.__name__ == f'Dynamic{symbol}')
+        except StopIteration:
+            raise ValueError(f'DynamicElement with symbol "{symbol}" not found')
+        return element
+
+    @classmethod
+    def from_atomic_number(cls, number: int) -> Type['DynamicElement']:
+        """
+        get DynamicElement class by its number
+        """
+        try:
+            element = next(x for x in DynamicElement.__subclasses__() if x.atomic_number.fget(None) == number)
+        except StopIteration:
+            raise ValueError(f'DynamicElement with number "{number}" not found')
+        return element
+
+    @classmethod
+    def from_atom(cls, atom: Union['Element', 'DynamicElement']) -> 'DynamicElement':
+        """
+        get DynamicElement object from Element object or copy of DynamicElement object
+        """
+        if isinstance(atom, Element):
+            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
+        elif not isinstance(atom, DynamicElement):
+            raise TypeError('Element or DynamicElement expected')
+        return atom.copy()
+
+    @property
+    def p_charge(self) -> int:
+        try:
+            return self._graph()._p_charges[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @property
+    def p_is_radical(self) -> bool:
+        try:
+            return self._graph()._p_radicals[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    def __eq__(self, other):
+        """
+        compare attached to molecules dynamic elements
+        """
+        return isinstance(other, DynamicElement) and self.atomic_number == other.atomic_number and \
+            self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical and \
+            self.p_charge == other.p_charge and self.p_is_radical == other.p_is_radical
+
+    def __hash__(self):
+        return hash((self.isotope or 0, self.atomic_number, self.charge, self.p_charge,
+                     self.is_radical, self.p_is_radical))
+
+    @property
+    def is_dynamic(self) -> bool:
+        """
+        Atom has dynamic features
+        """
+        return self.charge != self.p_charge or self.is_radical != self.p_is_radical
+
+
+__all__ = ['DynamicElement']
```

### Comparing `chython-1.67/chython/periodictable/element/query.py` & `chython-1.8/chython/periodictable/element/query.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,318 +1,394 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2021 Dmitrij Zanadvornykh <zandmitrij@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from abc import ABC
-from typing import Tuple, Type, List, Union
-from .core import Core
-from .element import Element
-from ...exceptions import IsNotConnectedAtom
-
-
-_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'B', 'C', 'N', 'O',
-              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
-
-
-class Query(Core, ABC):
-    __slots__ = ()
-
-    @property
-    def neighbors(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._neighbors[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def hybridization(self):
-        try:
-            return self._graph()._hybridizations[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def heteroatoms(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._heteroatoms[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-    @property
-    def ring_sizes(self) -> Tuple[int, ...]:
-        """
-        Atom rings sizes.
-        """
-        try:
-            return self._graph()._rings_sizes[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-        except KeyError:
-            return ()
-
-    @property
-    def implicit_hydrogens(self) -> Tuple[int, ...]:
-        try:
-            return self._graph()._hydrogens[self._n]
-        except AttributeError:
-            raise IsNotConnectedAtom
-
-
-class QueryElement(Query, ABC):
-    __slots__ = ()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return self.__class__.__name__[5:]
-
-    @classmethod
-    def from_symbol(cls, symbol: str) -> Type[Union['QueryElement', 'AnyElement', 'AnyMetal']]:
-        """
-        get Element class by its symbol
-        """
-        if symbol == 'A':
-            return AnyElement
-        elif symbol == 'M':
-            return AnyMetal
-        try:
-            element = next(x for x in QueryElement.__subclasses__() if x.__name__ == f'Query{symbol}')
-        except StopIteration:
-            raise ValueError(f'QueryElement with symbol "{symbol}" not found')
-        return element
-
-    @classmethod
-    def from_atomic_number(cls, number: int) -> Type['QueryElement']:
-        """
-        get Element class by its number
-        """
-        try:
-            element = next(x for x in QueryElement.__subclasses__() if x.atomic_number.fget(None) == number)
-        except StopIteration:
-            raise ValueError(f'QueryElement with number "{number}" not found')
-        return element
-
-    @classmethod
-    def from_atom(cls, atom: Union['Element', 'Query']) -> 'Query':
-        """
-        get QueryElement or AnyElement object from Element object or copy of QueryElement or AnyElement
-        """
-        if isinstance(atom, Element):
-            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
-        elif not isinstance(atom, Query):
-            raise TypeError('Element or Query expected')
-        return atom.copy()
-
-    def __eq__(self, other):
-        """
-        compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if self.atomic_number == other.atomic_number and self.charge == other.charge and \
-                    self.is_radical == other.is_radical:
-                if self.isotope and self.isotope != other.isotope:
-                    return False
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, QueryElement) and self.atomic_number == other.atomic_number and \
-                self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            # equal query element has equal query marks
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.isotope or 0, self.atomic_number, self.charge, self.is_radical, self.neighbors,
-                     self.hybridization, self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
-
-
-class AnyElement(Query):
-    __slots__ = ()
-
-    def __init__(self, *args, **kwargs):
-        super().__init__()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return 'A'
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def __eq__(self, other):
-        """
-        Compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if self.charge == other.charge and self.is_radical == other.is_radical:
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, AnyMetal):
-            return False
-        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.charge, self.is_radical, self.neighbors, self.hybridization, self.ring_sizes,
-                     self.implicit_hydrogens, self.heteroatoms))
-
-
-class AnyMetal(Query):
-    """
-    Charge and radical ignored any metal. Rings, hydrogens and heteroatoms count also ignored.
-
-    Class designed for d-elements matching in standardization.
-    """
-    def __init__(self, *args, **kwargs):
-        super().__init__()
-
-    @property
-    def atomic_symbol(self) -> str:
-        return 'M'
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def __eq__(self, other):
-        if isinstance(other, Element):
-            if other.atomic_symbol not in _inorganic:
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                return True
-        elif isinstance(other, AnyMetal) and self.neighbors == other.neighbors \
-                and self.hybridization == other.hybridization:
-            return True
-        return False
-
-    def __hash__(self):
-        return hash((self.neighbors, self.hybridization))
-
-
-class ListElement(Query):
-    __slots__ = ('_elements', '_numbers')
-
-    def __init__(self, elements: List[str], *args, **kwargs):
-        """
-        Elements list
-        """
-        super().__init__()
-        self._elements = tuple(elements)
-        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__() if x.__name__ in elements)
-
-    @property
-    def atomic_symbol(self) -> str:
-        return ','.join(self._elements)
-
-    @property
-    def atomic_number(self) -> int:
-        return 0
-
-    def copy(self):
-        copy = super().copy()
-        copy._elements = self._elements
-        copy._numbers = self._numbers
-        return copy
-
-    def __eq__(self, other):
-        """
-        Compare attached to molecules elements and query elements
-        """
-        if isinstance(other, Element):
-            if other.atomic_number in self._numbers:
-                if self.charge != other.charge or self.is_radical != other.is_radical:
-                    return False
-                if self.neighbors and other.neighbors not in self.neighbors:
-                    return False
-                if self.hybridization and other.hybridization not in self.hybridization:
-                    return False
-                if self.ring_sizes:
-                    if self.ring_sizes[0]:
-                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
-                            return False
-                    elif other.ring_sizes:  # not in ring expected
-                        return False
-                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
-                    return False
-                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
-                    return False
-                return True
-        elif isinstance(other, (AnyElement, AnyMetal)):
-            return False
-        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
-                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
-                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
-                and self.heteroatoms == other.heteroatoms:
-            if isinstance(other, ListElement):
-                return self._numbers == other._numbers
-            return other.atomic_number in self._numbers
-        return False
-
-    def __hash__(self):
-        return hash((self._numbers, self.charge, self.is_radical, self.neighbors, self.hybridization,
-                     self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
-
-    def __getstate__(self):
-        state = super().__getstate__()
-        state['elements'] = self._elements
-        return state
-
-    def __setstate__(self, state):
-        self._elements = state['elements']
-        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__()
-                              if x.__name__ in state['elements'])
-        super().__setstate__(state)
-
-    def __repr__(self):
-        return f'{self.__class__.__name__}([{",".join(self._elements)}])'
-
-
-__all__ = ['Query', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2021 Dmitrij Zanadvornykh <zandmitrij@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from abc import ABC
+from typing import Tuple, Type, List, Union
+from .core import Core
+from .element import Element
+from ...exceptions import IsNotConnectedAtom
+
+
+_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'B', 'C', 'N', 'O',
+              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
+
+
+class Query(Core, ABC):
+    __slots__ = ()
+
+    @Core.charge.setter
+    def charge(self, charge):
+        if not isinstance(charge, int):
+            raise TypeError('formal charge should be int in range [-4, 4]')
+        elif charge > 4 or charge < -4:
+            raise ValueError('formal charge should be in range [-4, 4]')
+        try:
+            g = self._graph()
+            g._charges[self._map] = charge
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @Core.is_radical.setter
+    def is_radical(self, is_radical):
+        if not isinstance(is_radical, bool):
+            raise TypeError('bool expected')
+        try:
+            g = self._graph()
+            g._radicals[self._map] = is_radical
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def neighbors(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._neighbors[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @property
+    def hybridization(self):
+        try:
+            return self._graph()._hybridizations[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @neighbors.setter
+    def neighbors(self, neighbors):
+        try:
+            g = self._graph()
+            g._neighbors[self._map] = g._validate_neighbors(neighbors)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @hybridization.setter
+    def hybridization(self, hybridization):
+        try:
+            g = self._graph()
+            g._hybridizations[self._map] = g._validate_hybridization(hybridization)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def heteroatoms(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._heteroatoms[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @heteroatoms.setter
+    def heteroatoms(self, heteroatoms):
+        try:
+            g = self._graph()
+            g._heteroatoms[self._map] = g._validate_neighbors(heteroatoms)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def ring_sizes(self) -> Tuple[int, ...]:
+        """
+        Atom rings sizes.
+        """
+        try:
+            return self._graph()._rings_sizes[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+        except KeyError:
+            return ()
+
+    @ring_sizes.setter
+    def ring_sizes(self, ring_sizes):
+        try:
+            g = self._graph()
+            g._rings_sizes[self._map] = g._validate_rings(ring_sizes)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+    @property
+    def implicit_hydrogens(self) -> Tuple[int, ...]:
+        try:
+            return self._graph()._hydrogens[self._map]
+        except AttributeError:
+            raise IsNotConnectedAtom
+
+    @implicit_hydrogens.setter
+    def implicit_hydrogens(self, implicit_hydrogens):
+        try:
+            g = self._graph()
+            g._hydrogens[self._map] = g._validate_neighbors(implicit_hydrogens)
+        except AttributeError:
+            raise IsNotConnectedAtom
+        else:
+            g.flush_cache()
+
+
+class QueryElement(Query, ABC):
+    __slots__ = ()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return self.__class__.__name__[5:]
+
+    @classmethod
+    def from_symbol(cls, symbol: str) -> Type[Union['QueryElement', 'AnyElement', 'AnyMetal']]:
+        """
+        get Element class by its symbol
+        """
+        if symbol == 'A':
+            return AnyElement
+        elif symbol == 'M':
+            return AnyMetal
+        try:
+            element = next(x for x in QueryElement.__subclasses__() if x.__name__ == f'Query{symbol}')
+        except StopIteration:
+            raise ValueError(f'QueryElement with symbol "{symbol}" not found')
+        return element
+
+    @classmethod
+    def from_atomic_number(cls, number: int) -> Type['QueryElement']:
+        """
+        get Element class by its number
+        """
+        try:
+            element = next(x for x in QueryElement.__subclasses__() if x.atomic_number.fget(None) == number)
+        except StopIteration:
+            raise ValueError(f'QueryElement with number "{number}" not found')
+        return element
+
+    @classmethod
+    def from_atom(cls, atom: Union['Element', 'Query']) -> 'Query':
+        """
+        get QueryElement or AnyElement object from Element object or copy of QueryElement or AnyElement
+        """
+        if isinstance(atom, Element):
+            return cls.from_atomic_number(atom.atomic_number)(atom.isotope)
+        elif not isinstance(atom, Query):
+            raise TypeError('Element or Query expected')
+        return atom.copy()
+
+    def __eq__(self, other):
+        """
+        compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if self.atomic_number == other.atomic_number and self.charge == other.charge and \
+                    self.is_radical == other.is_radical:
+                if self.isotope and self.isotope != other.isotope:
+                    return False
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, QueryElement) and self.atomic_number == other.atomic_number and \
+                self.isotope == other.isotope and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            # equal query element has equal query marks
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.isotope or 0, self.atomic_number, self.charge, self.is_radical, self.neighbors,
+                     self.hybridization, self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
+
+
+class AnyElement(Query):
+    __slots__ = ()
+
+    def __init__(self, *args, **kwargs):
+        super().__init__()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return 'A'
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def __eq__(self, other):
+        """
+        Compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if self.charge == other.charge and self.is_radical == other.is_radical:
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, AnyMetal):
+            return False
+        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.charge, self.is_radical, self.neighbors, self.hybridization, self.ring_sizes,
+                     self.implicit_hydrogens, self.heteroatoms))
+
+
+class AnyMetal(Query):
+    """
+    Charge and radical ignored any metal. Rings, hydrogens and heteroatoms count also ignored.
+
+    Class designed for d-elements matching in standardization.
+    """
+    def __init__(self, *args, **kwargs):
+        super().__init__()
+
+    @property
+    def atomic_symbol(self) -> str:
+        return 'M'
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def __eq__(self, other):
+        if isinstance(other, Element):
+            if other.atomic_symbol not in _inorganic:
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                return True
+        elif isinstance(other, AnyMetal) and self.neighbors == other.neighbors \
+                and self.hybridization == other.hybridization:
+            return True
+        return False
+
+    def __hash__(self):
+        return hash((self.neighbors, self.hybridization))
+
+
+class ListElement(Query):
+    __slots__ = ('_elements', '_numbers')
+
+    def __init__(self, elements: List[str], *args, **kwargs):
+        """
+        Elements list
+        """
+        super().__init__()
+        self._elements = tuple(elements)
+        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__() if x.__name__ in elements)
+
+    @property
+    def atomic_symbol(self) -> str:
+        return ','.join(self._elements)
+
+    @property
+    def atomic_number(self) -> int:
+        return 0
+
+    def copy(self):
+        copy = super().copy()
+        copy._elements = self._elements
+        copy._numbers = self._numbers
+        return copy
+
+    def __eq__(self, other):
+        """
+        Compare attached to molecules elements and query elements
+        """
+        if isinstance(other, Element):
+            if other.atomic_number in self._numbers:
+                if self.charge != other.charge or self.is_radical != other.is_radical:
+                    return False
+                if self.neighbors and other.neighbors not in self.neighbors:
+                    return False
+                if self.hybridization and other.hybridization not in self.hybridization:
+                    return False
+                if self.ring_sizes:
+                    if self.ring_sizes[0]:
+                        if set(self.ring_sizes).isdisjoint(other.ring_sizes):
+                            return False
+                    elif other.ring_sizes:  # not in ring expected
+                        return False
+                if self.implicit_hydrogens and other.implicit_hydrogens not in self.implicit_hydrogens:
+                    return False
+                if self.heteroatoms and other.heteroatoms not in self.heteroatoms:
+                    return False
+                return True
+        elif isinstance(other, (AnyElement, AnyMetal)):
+            return False
+        elif isinstance(other, Query) and self.charge == other.charge and self.is_radical == other.is_radical \
+                and self.neighbors == other.neighbors and self.hybridization == other.hybridization \
+                and self.ring_sizes == other.ring_sizes and self.implicit_hydrogens == other.implicit_hydrogens \
+                and self.heteroatoms == other.heteroatoms:
+            if isinstance(other, ListElement):
+                return self._numbers == other._numbers
+            return other.atomic_number in self._numbers
+        return False
+
+    def __hash__(self):
+        return hash((self._numbers, self.charge, self.is_radical, self.neighbors, self.hybridization,
+                     self.ring_sizes, self.implicit_hydrogens, self.heteroatoms))
+
+    def __getstate__(self):
+        state = super().__getstate__()
+        state['elements'] = self._elements
+        return state
+
+    def __setstate__(self, state):
+        self._elements = state['elements']
+        self._numbers = tuple(x.atomic_number.fget(None) for x in Element.__subclasses__()
+                              if x.__name__ in state['elements'])
+        super().__setstate__(state)
+
+    def __repr__(self):
+        return f'{self.__class__.__name__}([{",".join(self._elements)}])'
+
+
+__all__ = ['Query', 'QueryElement', 'AnyElement', 'AnyMetal', 'ListElement']
```

### Comparing `chython-1.67/chython/periodictable/groupI.py` & `chython-1.8/chython/periodictable/groupXIII.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,220 +1,205 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupI
-from .periods import *
-
-
-class H(Element, PeriodI, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 1
-
-    @property
-    def isotopes_distribution(self):
-        return {1: 0.999885, 2: 0.000115, 3: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {1: 1.007825, 2: 2.014102, 3: 3.016049}
-
-    @property
-    def _common_valences(self):
-        return 1,
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()), (0, True, 0, ()), (-1, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 0.53
-
-
-class Li(Element, PeriodII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 3
-
-    @property
-    def isotopes_distribution(self):
-        return {6: 0.0759, 7: 0.9241}
-
-    @property
-    def isotopes_masses(self):
-        return {6: 6.015122, 7: 7.016004}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 167
-
-
-class Na(Element, PeriodIII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 11
-
-    @property
-    def isotopes_distribution(self):
-        return {22: 0., 23: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {22: 21.994437, 23: 22.98977}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.9
-
-
-class K(Element, PeriodIV, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 19
-
-    @property
-    def isotopes_distribution(self):
-        return {39: 0.932581, 40: 0.000117, 41: 0.067302, 42: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {39: 38.963707, 40: 39.963999, 41: 40.961826, 42: 41.962402}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.43
-
-
-class Rb(Element, PeriodV, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 37
-
-    @property
-    def isotopes_distribution(self):
-        return {82: 0., 85: 0.7217, 87: 0.2783}
-
-    @property
-    def isotopes_masses(self):
-        return {82: 81.918209, 85: 84.911789, 87: 86.909183}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.65
-
-
-class Cs(Element, PeriodVI, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 55
-
-    @property
-    def isotopes_distribution(self):
-        return {131: 0., 133: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {131: 130.905464, 133: 132.905447}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.98
-
-
-class Fr(Element, PeriodVII, GroupI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 87
-
-    @property
-    def isotopes_distribution(self):
-        return {223: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {223: 223.019736}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return (1, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.98  # unknown, taken radius of previous element in group
-
-
-__all__ = ['H', 'Li', 'Na', 'K', 'Rb', 'Cs', 'Fr']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXIII
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class B(Element, PeriodII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 5
+
+    @property
+    def isotopes_distribution(self):
+        return {10: 0.199, 11: 0.801}
+
+    @property
+    def isotopes_masses(self):
+        return {10: 10.012937, 11: 11.009305}
+
+    @property
+    def _common_valences(self):
+        return 3,
+
+    @property
+    def _valences_exceptions(self):
+        return (-1, False, 4, ()),
+
+    @property
+    def atomic_radius(self):
+        return .87
+
+
+class Al(Element, PeriodIII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 13
+
+    @property
+    def isotopes_distribution(self):
+        return {27: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {27: 26.981538}
+
+    @property
+    def _common_valences(self):
+        return 0,  # 3 omitted. added to exceptions
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (2, False, 1, ()), (1, False, 2, ()), (0, False, 3, ()), (-1, False, 4, ()),
+                (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.18
+
+
+class Ga(Element, PeriodIV, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 31
+
+    @property
+    def isotopes_distribution(self):
+        return {67: 0., 69: 0.60108, 71: 0.39892}
+
+    @property
+    def isotopes_masses(self):
+        return {67: 66.928202, 69: 68.925581, 71: 70.924705}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
+                (-1, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'), (1, 'H'))),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (-1, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (-1, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.36
+
+
+class In(Element, PeriodV, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 49
+
+    @property
+    def isotopes_distribution(self):
+        return {111: 0., 113: 0.0429, 115: 0.9571}
+
+    @property
+    def isotopes_masses(self):
+        return {111: 110.905103, 113: 112.904061, 115: 114.903878}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
+                (0, False, 0, ((1, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 1.56
+
+
+class Tl(Element, PeriodVI, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 81
+
+    @property
+    def isotopes_distribution(self):
+        return {203: 0.29524, 205: 0.70476}
+
+    @property
+    def isotopes_masses(self):
+        return {203: 202.972329, 205: 204.974412}
+
+    @property
+    def _common_valences(self):
+        return 0, 1
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ()), (3, False, 0, ()),
+                (-3, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (1, False, 0, ((1, 'C'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.56
+
+
+class Nh(Element, PeriodVII, GroupXIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 113
+
+    @property
+    def isotopes_distribution(self):
+        return {286: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {286: 286.182555}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.56  # unknown, taken radius of previous element in group
+
+
+__all__ = ['B', 'Al', 'Ga', 'In', 'Tl', 'Nh']
```

### Comparing `chython-1.67/chython/periodictable/groupII.py` & `chython-1.8/chython/periodictable/groupXV.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,199 +1,214 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupII
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Be(Element, PeriodII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 4
-
-    @property
-    def isotopes_distribution(self):
-        return {9: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {9: 9.012182}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.12
-
-
-class Mg(Element, PeriodIII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 12
-
-    @property
-    def isotopes_distribution(self):
-        return {24: 0.7899, 25: 0.1, 26: 0.1101}
-
-    @property
-    def isotopes_masses(self):
-        return {24: 23.985042, 25: 24.985837, 26: 25.982593}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((2, False, 0, ()),
-                (1, False, 0, ((1, 'C'),)),
-                (1, False, 0, ((1, 'O'),)),
-                (1, False, 0, ((1, 'Br'),)),
-                (1, False, 0, ((1, 'Cl'),)))
-
-    @property
-    def atomic_radius(self):
-        return 1.45
-
-
-class Ca(Element, PeriodIV, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 20
-
-    @property
-    def isotopes_distribution(self):
-        return {40: 0.96941, 42: 0.00647, 43: 0.00135, 44: 0.02086, 45: 0., 46: 4e-05, 47: 0., 48: 0.00187}
-
-    @property
-    def isotopes_masses(self):
-        return {40: 39.962591, 42: 41.958618, 43: 42.958767, 44: 43.955481, 45: 44.956186, 46: 45.953693, 47: 46.954541,
-                48: 47.952534}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 1.94
-
-
-class Sr(Element, PeriodV, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 38
-
-    @property
-    def isotopes_distribution(self):
-        return {84: 0.0056, 85: 0., 86: 0.0986, 87: 0.07, 88: 0.8258, 89: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {84: 83.913425, 85: 84.912933, 86: 85.909262, 87: 86.908879, 88: 87.905614, 89: 88.907451}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.19
-
-
-class Ba(Element, PeriodVI, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 56
-
-    @property
-    def isotopes_distribution(self):
-        return {130: 0.00106, 132: 0.00101, 134: 0.02417, 135: 0.06592, 136: 0.07854, 137: 0.11232, 138: 0.71698}
-
-    @property
-    def isotopes_masses(self):
-        return {130: 129.90631, 132: 131.905056, 134: 133.904503, 135: 134.905683, 136: 135.90457, 137: 136.905821,
-                138: 137.905241}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.53
-
-
-class Ra(Element, PeriodVII, GroupII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 88
-
-    @property
-    def isotopes_distribution(self):
-        return {223: 0., 226: 1.0, 228: 0., 233: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {223: 223.018502, 226: 226.025410, 228: 228.031070, 233: 233.048065}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.53  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Be', 'Mg', 'Ca', 'Sr', 'Ba', 'Ra']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXV
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class N(Element, PeriodII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 7
+
+    @property
+    def isotopes_distribution(self):
+        return {14: 0.99632, 15: 0.00368}
+
+    @property
+    def isotopes_masses(self):
+        return {14: 14.003074, 15: 15.000109}
+
+    @property
+    def _common_valences(self):
+        return 3,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 2, ()), (1, False, 4, ()),
+                (0, True, 2, ()))  # *NO, etc
+
+    @property
+    def atomic_radius(self):
+        return .56
+
+
+class P(Element, PeriodIII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 15
+
+    @property
+    def isotopes_distribution(self):
+        return {31: 1.0, 32: 0., 33: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {31: 30.973762, 32: 31.973908, 33: 32.971726}
+
+    @property
+    def _common_valences(self):
+        return 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 2, ()), (1, False, 4, ()),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return .98
+
+
+class As(Element, PeriodIV, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 33
+
+    @property
+    def isotopes_distribution(self):
+        return {75: 1.0, 76: 0., 77: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {75: 74.921596, 76: 75.922394, 77: 76.920647}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return (1, False, 4, ()),
+
+    @property
+    def atomic_radius(self):
+        return 1.14
+
+
+class Sb(Element, PeriodV, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 51
+
+    @property
+    def isotopes_distribution(self):
+        return {121: 0.5721, 123: 0.4279}
+
+    @property
+    def isotopes_masses(self):
+        return {121: 120.903818, 123: 122.904216}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 4, ()),
+                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.33
+
+
+class Bi(Element, PeriodVI, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 83
+
+    @property
+    def isotopes_distribution(self):
+        return {207: 0., 209: 1.0, 210: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {207: 206.978471, 209: 208.980383, 210: 209.984120}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'),)),
+                (0, False, 0, ((1, 'Br'),)),
+
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'S'), (1, 'S'))),
+                (0, False, 0, ((2, 'S'),)),
+                (0, False, 0, ((1, 'Se'), (1, 'Se'))),
+                (0, False, 0, ((2, 'Se'),)),
+
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.43
+
+
+class Mc(Element, PeriodVII, GroupXV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 115
+
+    @property
+    def isotopes_distribution(self):
+        return {289: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {289: 289.0}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.43  # unknown, taken radius of previous element in group
+
+
+__all__ = ['N', 'P', 'As', 'Sb', 'Bi', 'Mc']
```

### Comparing `chython-1.67/chython/periodictable/groupIII.py` & `chython-1.8/chython/periodictable/groupIII.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,1026 +1,1026 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupIII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Sc(Element, PeriodIV, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 21
-
-    @property
-    def isotopes_distribution(self):
-        return {44: 0., 45: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {44: 43.959403, 45: 44.955910}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()), (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F')))
-
-    @property
-    def atomic_radius(self):
-        return 1.84
-
-
-class Y(Element, PeriodV, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 39
-
-    @property
-    def isotopes_distribution(self):
-        return {86: 0., 89: 1.0, 90: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {86: 85.914886, 89: 88.905848, 90: 89.907152}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.12
-
-
-class La(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 57
-
-    @property
-    def isotopes_distribution(self):
-        return {138: 0.0009, 139: 0.9991}
-
-    @property
-    def isotopes_masses(self):
-        return {138: 137.907107, 139: 138.906348}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.12  # unknown, taken radius of previous element in group
-
-
-class Ce(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 58
-
-    @property
-    def isotopes_distribution(self):
-        return {136: 0.00185, 138: 0.00251, 140: 0.8845, 142: 0.11114}
-
-    @property
-    def isotopes_masses(self):
-        return {136: 135.90714, 138: 137.905986, 140: 139.905434, 142: 141.90924}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.12  # unknown, taken radius of previous element in group
-
-
-class Pr(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 59
-
-    @property
-    def isotopes_distribution(self):
-        return {141: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {141: 140.907648}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.47
-
-
-class Nd(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 60
-
-    @property
-    def isotopes_distribution(self):
-        return {142: 0.272, 143: 0.122, 144: 0.238, 145: 0.083, 146: 0.172, 148: 0.057, 150: 0.056}
-
-    @property
-    def isotopes_masses(self):
-        return {142: 141.907719, 143: 142.90981, 144: 143.910083, 145: 144.912569, 146: 145.913112, 148: 147.916889,
-                150: 149.920887}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'),)),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.06
-
-
-class Pm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 61
-
-    @property
-    def isotopes_distribution(self):
-        return {145: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {145: 144.912749}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.05
-
-
-class Sm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 62
-
-    @property
-    def isotopes_distribution(self):
-        return {144: 0.0307, 145: 0., 147: 0.1499, 148: 0.1124, 149: 0.1382, 150: 0.0738, 152: 0.2675, 153: 0.,
-                154: 0.2275}
-
-    @property
-    def isotopes_masses(self):
-        return {144: 143.911995, 145: 144.913410, 147: 146.914893, 148: 147.914818, 149: 148.917180, 150: 149.917271,
-                152: 151.919728, 153: 152.922097, 154: 153.922205}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.38
-
-
-class Eu(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 63
-
-    @property
-    def isotopes_distribution(self):
-        return {151: 0.4781, 152: 0., 153: 0.5219}
-
-    @property
-    def isotopes_masses(self):
-        return {151: 150.919846, 152: 151.921744, 153: 152.921226}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.31
-
-
-class Gd(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 64
-
-    @property
-    def isotopes_distribution(self):
-        return {152: 0.002, 153: 0., 154: 0.0218, 155: 0.148, 156: 0.2047, 157: 0.1565, 158: 0.2484, 160: 0.2186}
-
-    @property
-    def isotopes_masses(self):
-        return {152: 151.919788, 153: 152.921750, 154: 153.920862, 155: 154.922619, 156: 155.922120, 157: 156.923957,
-                158: 157.924101, 160: 159.927051}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.33
-
-
-class Tb(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 65
-
-    @property
-    def isotopes_distribution(self):
-        return {159: 1.0, 160: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {159: 158.925343, 160: 159.927168}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.25
-
-
-class Dy(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 66
-
-    @property
-    def isotopes_distribution(self):
-        return {156: 0.0006, 158: 0.001, 160: 0.0234, 161: 0.1891, 162: 0.2551, 163: 0.249, 164: 0.2818}
-
-    @property
-    def isotopes_masses(self):
-        return {156: 155.924278, 158: 157.924405, 160: 159.925194, 161: 160.92693, 162: 161.926795, 163: 162.928728,
-                164: 163.929171}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.28
-
-
-class Ho(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 67
-
-    @property
-    def isotopes_distribution(self):
-        return {165: 1.0, 166: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {165: 164.930319, 166: 165.932284}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.26
-
-
-class Er(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 68
-
-    @property
-    def isotopes_distribution(self):
-        return {162: 0.0014, 164: 0.0161, 166: 0.3361, 167: 0.2293, 168: 0.2678, 170: 0.1493}
-
-    @property
-    def isotopes_masses(self):
-        return {162: 161.928775, 164: 163.929197, 166: 165.93029, 167: 166.932045, 168: 167.932368, 170: 169.93546}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.26
-
-
-class Tm(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 69
-
-    @property
-    def isotopes_distribution(self):
-        return {169: 1.0, 170: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {169: 168.934211, 170: 169.935801}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.22
-
-
-class Yb(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 70
-
-    @property
-    def isotopes_distribution(self):
-        return {168: 0.0013, 169: 0., 170: 0.0304, 171: 0.1428, 172: 0.2183, 173: 0.1613, 174: 0.3183, 176: 0.1276}
-
-    @property
-    def isotopes_masses(self):
-        return {168: 167.933894, 169: 168.935190, 170: 169.934759, 171: 170.936322, 172: 171.936378, 173: 172.938207,
-                174: 173.938858, 176: 175.942568}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'F'), (1, 'Br'))),
-                (0, False, 0, ((1, 'F'), (1, 'I'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.22
-
-
-class Lu(Element, PeriodVI, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 71
-
-    @property
-    def isotopes_distribution(self):
-        return {175: 0.9741, 176: 0.0259, 177: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {175: 174.940768, 176: 175.942682, 177: 176.943758}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17
-
-
-class Ac(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 89
-
-    @property
-    def isotopes_distribution(self):
-        return {225: 0., 227: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {225: 225.023230, 227: 227.027752}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Th(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 90
-
-    @property
-    def isotopes_distribution(self):
-        return {227: 0., 232: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {227: 227.027704, 232: 232.038050}
-
-    @property
-    def _common_valences(self):
-        return 0, 4
-
-    @property
-    def _valences_exceptions(self):
-        return ((4, False, 0, ()),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Pa(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 91
-
-    @property
-    def isotopes_distribution(self):
-        return {231: 1.0, 233: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {231: 231.035879, 233: 233.040247}
-
-    @property
-    def _common_valences(self):
-        return 0, 4, 5
-
-    @property
-    def _valences_exceptions(self):
-        return ((4, False, 0, ()),
-                (0, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'))),
-                (0, False, 0, ((2, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class U(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 92
-
-    @property
-    def isotopes_distribution(self):
-        return {234: 5.5e-05, 235: 0.0072, 238: 0.992745}
-
-    @property
-    def isotopes_masses(self):
-        return {234: 234.040946, 235: 235.043923, 238: 238.050783}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4, 5, 6
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (2, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Np(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 93
-
-    @property
-    def isotopes_distribution(self):
-        return {237: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {237: 237.048173}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4, 5, 6, 7
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (1, False, 0, ((2, 'O'), (2, 'O'))),
-                (2, False, 0, ((2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Pu(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 94
-
-    @property
-    def isotopes_distribution(self):
-        return {239: 1.0, 242: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {239: 239.052163, 242: 242.058743}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4, 5, 6
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()), (4, False, 0, ()),
-                (1, False, 0, ((2, 'O'), (2, 'O'))),
-                (2, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'Se'), )),
-                (0, False, 0, ((2, 'S'),)),
-                (0, False, 0, ((2, 'Te'),)),
-                (0, False, 0, ((2, 'O'),)),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'H'), (1, 'H'))))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Am(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 95
-
-    @property
-    def isotopes_distribution(self):
-        return {241: 1.0, 243: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {241: 241.056829, 243: 243.061380}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Cm(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 96
-
-    @property
-    def isotopes_distribution(self):
-        return {243: 0., 244: 1.0, 248: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {243: 243.061389, 244: 244.062753, 248: 248.072349}
-
-    @property
-    def _common_valences(self):
-        return 0, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'H'), (1, 'H')))
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Bk(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 97
-
-    @property
-    def isotopes_distribution(self):
-        return {249: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {249: 249.074987}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()), (4, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Cf(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 98
-
-    @property
-    def isotopes_distribution(self):
-        return {249: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {249: 249.074854}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3, 4
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Es(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 99
-
-    @property
-    def isotopes_distribution(self):
-        return {252: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {252: 252.08298}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Fm(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 100
-
-    @property
-    def isotopes_distribution(self):
-        return {257: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {257: 257.095106}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Md(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 101
-
-    @property
-    def isotopes_distribution(self):
-        return {258: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {258: 258.098431}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class No(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 102
-
-    @property
-    def isotopes_distribution(self):
-        return {259: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {259: 259.10103}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-class Lr(Element, PeriodVII, GroupIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 103
-
-    @property
-    def isotopes_distribution(self):
-        return {266: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {266: 266.11983}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (3, False, 0, ()),
-
-    @property
-    def atomic_radius(self):
-        return 2.17  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Sc', 'Y',
-           'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
-           'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupIII
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Sc(Element, PeriodIV, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 21
+
+    @property
+    def isotopes_distribution(self):
+        return {44: 0., 45: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {44: 43.959403, 45: 44.955910}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()), (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F')))
+
+    @property
+    def atomic_radius(self):
+        return 1.84
+
+
+class Y(Element, PeriodV, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 39
+
+    @property
+    def isotopes_distribution(self):
+        return {86: 0., 89: 1.0, 90: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {86: 85.914886, 89: 88.905848, 90: 89.907152}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.12
+
+
+class La(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 57
+
+    @property
+    def isotopes_distribution(self):
+        return {138: 0.0009, 139: 0.9991}
+
+    @property
+    def isotopes_masses(self):
+        return {138: 137.907107, 139: 138.906348}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.12  # unknown, taken radius of previous element in group
+
+
+class Ce(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 58
+
+    @property
+    def isotopes_distribution(self):
+        return {136: 0.00185, 138: 0.00251, 140: 0.8845, 142: 0.11114}
+
+    @property
+    def isotopes_masses(self):
+        return {136: 135.90714, 138: 137.905986, 140: 139.905434, 142: 141.90924}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.12  # unknown, taken radius of previous element in group
+
+
+class Pr(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 59
+
+    @property
+    def isotopes_distribution(self):
+        return {141: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {141: 140.907648}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.47
+
+
+class Nd(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 60
+
+    @property
+    def isotopes_distribution(self):
+        return {142: 0.272, 143: 0.122, 144: 0.238, 145: 0.083, 146: 0.172, 148: 0.057, 150: 0.056}
+
+    @property
+    def isotopes_masses(self):
+        return {142: 141.907719, 143: 142.90981, 144: 143.910083, 145: 144.912569, 146: 145.913112, 148: 147.916889,
+                150: 149.920887}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'),)),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.06
+
+
+class Pm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 61
+
+    @property
+    def isotopes_distribution(self):
+        return {145: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {145: 144.912749}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.05
+
+
+class Sm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 62
+
+    @property
+    def isotopes_distribution(self):
+        return {144: 0.0307, 145: 0., 147: 0.1499, 148: 0.1124, 149: 0.1382, 150: 0.0738, 152: 0.2675, 153: 0.,
+                154: 0.2275}
+
+    @property
+    def isotopes_masses(self):
+        return {144: 143.911995, 145: 144.913410, 147: 146.914893, 148: 147.914818, 149: 148.917180, 150: 149.917271,
+                152: 151.919728, 153: 152.922097, 154: 153.922205}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.38
+
+
+class Eu(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 63
+
+    @property
+    def isotopes_distribution(self):
+        return {151: 0.4781, 152: 0., 153: 0.5219}
+
+    @property
+    def isotopes_masses(self):
+        return {151: 150.919846, 152: 151.921744, 153: 152.921226}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.31
+
+
+class Gd(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 64
+
+    @property
+    def isotopes_distribution(self):
+        return {152: 0.002, 153: 0., 154: 0.0218, 155: 0.148, 156: 0.2047, 157: 0.1565, 158: 0.2484, 160: 0.2186}
+
+    @property
+    def isotopes_masses(self):
+        return {152: 151.919788, 153: 152.921750, 154: 153.920862, 155: 154.922619, 156: 155.922120, 157: 156.923957,
+                158: 157.924101, 160: 159.927051}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.33
+
+
+class Tb(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 65
+
+    @property
+    def isotopes_distribution(self):
+        return {159: 1.0, 160: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {159: 158.925343, 160: 159.927168}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.25
+
+
+class Dy(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 66
+
+    @property
+    def isotopes_distribution(self):
+        return {156: 0.0006, 158: 0.001, 160: 0.0234, 161: 0.1891, 162: 0.2551, 163: 0.249, 164: 0.2818}
+
+    @property
+    def isotopes_masses(self):
+        return {156: 155.924278, 158: 157.924405, 160: 159.925194, 161: 160.92693, 162: 161.926795, 163: 162.928728,
+                164: 163.929171}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.28
+
+
+class Ho(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 67
+
+    @property
+    def isotopes_distribution(self):
+        return {165: 1.0, 166: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {165: 164.930319, 166: 165.932284}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.26
+
+
+class Er(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 68
+
+    @property
+    def isotopes_distribution(self):
+        return {162: 0.0014, 164: 0.0161, 166: 0.3361, 167: 0.2293, 168: 0.2678, 170: 0.1493}
+
+    @property
+    def isotopes_masses(self):
+        return {162: 161.928775, 164: 163.929197, 166: 165.93029, 167: 166.932045, 168: 167.932368, 170: 169.93546}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.26
+
+
+class Tm(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 69
+
+    @property
+    def isotopes_distribution(self):
+        return {169: 1.0, 170: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {169: 168.934211, 170: 169.935801}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.22
+
+
+class Yb(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 70
+
+    @property
+    def isotopes_distribution(self):
+        return {168: 0.0013, 169: 0., 170: 0.0304, 171: 0.1428, 172: 0.2183, 173: 0.1613, 174: 0.3183, 176: 0.1276}
+
+    @property
+    def isotopes_masses(self):
+        return {168: 167.933894, 169: 168.935190, 170: 169.934759, 171: 170.936322, 172: 171.936378, 173: 172.938207,
+                174: 173.938858, 176: 175.942568}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()),
+                (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'F'), (1, 'Br'))),
+                (0, False, 0, ((1, 'F'), (1, 'I'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.22
+
+
+class Lu(Element, PeriodVI, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 71
+
+    @property
+    def isotopes_distribution(self):
+        return {175: 0.9741, 176: 0.0259, 177: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {175: 174.940768, 176: 175.942682, 177: 176.943758}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17
+
+
+class Ac(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 89
+
+    @property
+    def isotopes_distribution(self):
+        return {225: 0., 227: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {225: 225.023230, 227: 227.027752}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Th(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 90
+
+    @property
+    def isotopes_distribution(self):
+        return {227: 0., 232: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {227: 227.027704, 232: 232.038050}
+
+    @property
+    def _common_valences(self):
+        return 0, 4
+
+    @property
+    def _valences_exceptions(self):
+        return ((4, False, 0, ()),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Pa(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 91
+
+    @property
+    def isotopes_distribution(self):
+        return {231: 1.0, 233: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {231: 231.035879, 233: 233.040247}
+
+    @property
+    def _common_valences(self):
+        return 0, 4, 5
+
+    @property
+    def _valences_exceptions(self):
+        return ((4, False, 0, ()),
+                (0, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'))),
+                (0, False, 0, ((2, 'O'),)))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class U(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 92
+
+    @property
+    def isotopes_distribution(self):
+        return {234: 5.5e-05, 235: 0.0072, 238: 0.992745}
+
+    @property
+    def isotopes_masses(self):
+        return {234: 234.040946, 235: 235.043923, 238: 238.050783}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4, 5, 6
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (2, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Np(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 93
+
+    @property
+    def isotopes_distribution(self):
+        return {237: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {237: 237.048173}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4, 5, 6, 7
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (1, False, 0, ((2, 'O'), (2, 'O'))),
+                (2, False, 0, ((2, 'O'), (2, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Pu(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 94
+
+    @property
+    def isotopes_distribution(self):
+        return {239: 1.0, 242: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {239: 239.052163, 242: 242.058743}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4, 5, 6
+
+    @property
+    def _valences_exceptions(self):
+        return ((3, False, 0, ()), (4, False, 0, ()),
+                (1, False, 0, ((2, 'O'), (2, 'O'))),
+                (2, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'Se'), )),
+                (0, False, 0, ((2, 'S'),)),
+                (0, False, 0, ((2, 'Te'),)),
+                (0, False, 0, ((2, 'O'),)),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'H'), (1, 'H'))))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Am(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 95
+
+    @property
+    def isotopes_distribution(self):
+        return {241: 1.0, 243: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {241: 241.056829, 243: 243.061380}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Cm(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 96
+
+    @property
+    def isotopes_distribution(self):
+        return {243: 0., 244: 1.0, 248: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {243: 243.061389, 244: 244.062753, 248: 248.072349}
+
+    @property
+    def _common_valences(self):
+        return 0, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'H'), (1, 'H')))
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Bk(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 97
+
+    @property
+    def isotopes_distribution(self):
+        return {249: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {249: 249.074987}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()), (4, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Cf(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 98
+
+    @property
+    def isotopes_distribution(self):
+        return {249: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {249: 249.074854}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3, 4
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Es(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 99
+
+    @property
+    def isotopes_distribution(self):
+        return {252: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {252: 252.08298}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Fm(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 100
+
+    @property
+    def isotopes_distribution(self):
+        return {257: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {257: 257.095106}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Md(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 101
+
+    @property
+    def isotopes_distribution(self):
+        return {258: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {258: 258.098431}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class No(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 102
+
+    @property
+    def isotopes_distribution(self):
+        return {259: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {259: 259.10103}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (2, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+class Lr(Element, PeriodVII, GroupIII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 103
+
+    @property
+    def isotopes_distribution(self):
+        return {266: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {266: 266.11983}
+
+    @property
+    def _common_valences(self):
+        return 0, 3
+
+    @property
+    def _valences_exceptions(self):
+        return (3, False, 0, ()),
+
+    @property
+    def atomic_radius(self):
+        return 2.17  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Sc', 'Y',
+           'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
+           'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr']
```

### Comparing `chython-1.67/chython/periodictable/groupVII.py` & `chython-1.8/chython/periodictable/groupXI.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,146 +1,146 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupVII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Mn(Element, PeriodIV, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 25
-
-    @property
-    def isotopes_distribution(self):
-        return {52: 0., 55: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {52: 51.945566, 55: 54.938050}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((2, False, 0, ()), (3, False, 0, ()),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'),)),  # MnO
-                (0, False, 0, ((2, 'O'), (1, 'O'))),  # Mn2O3
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),  # MnO2
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),  # [MnO4]2-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'))))  # [MnO4]-
-
-    @property
-    def atomic_radius(self):
-        return 1.61
-
-
-class Tc(Element, PeriodV, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 43
-
-    @property
-    def isotopes_distribution(self):
-        return {98: 0., 99: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {98: 97.907216, 99: 98.906255}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'))),  # TcO2
-                (0, False, 0, ((2, 'S'), (2, 'S'))))  # TcS2
-
-    @property
-    def atomic_radius(self):
-        return 1.83
-
-
-class Re(Element, PeriodVI, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 75
-
-    @property
-    def isotopes_distribution(self):
-        return {185: 0.374, 186: 0., 187: 0.626, 188: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {185: 184.952956, 186: 185.954986, 187: 186.955751, 188: 187.958114}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.88
-
-
-class Bh(Element, PeriodVII, GroupVII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 107
-
-    @property
-    def isotopes_distribution(self):
-        return {270: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {270: 270.133363}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.88  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Mn', 'Tc', 'Re', 'Bh']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXI
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Cu(Element, PeriodIV, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 29
+
+    @property
+    def isotopes_distribution(self):
+        return {63: 0.6917, 64: 0., 65: 0.3083, 67: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {63: 62.929601, 64: 63.929764, 65: 64.927794, 67: 66.927730}
+
+    @property
+    def _common_valences(self):
+        return 0, 1, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'))),  # CuCl2^-
+                (-3, False, 0, ((1, 'S'), (1, 'S'))))  # CuS2^3- - это характерный комплекс для одновалентной меди
+
+    @property
+    def atomic_radius(self):
+        return 1.45
+
+
+class Ag(Element, PeriodV, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 47
+
+    @property
+    def isotopes_distribution(self):
+        return {107: 0.51839, 109: 0.48161, 110: 0., 111: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {107: 106.905093, 109: 108.904756, 110: 109.906107, 111: 110.905291}
+
+    @property
+    def _common_valences(self):
+        return 0, 1
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 0, ((1, 'Cl'), (1, 'Cl'))),  # AgCl2^1-
+                (-1, False, 0, ((1, 'O'), (1, 'O'))),  # Ag(OH)2^1-
+                (-1, False, 0, ((1, 'S'), (1, 'S'))),  # AgS2^1-
+                (-1, False, 0, ((1, 'C'), (1, 'C'))),  # Ag(CN)2^1-
+                (1, False, 0, ()))
+
+    @property
+    def atomic_radius(self):
+        return 1.65
+
+
+class Au(Element, PeriodVI, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 79
+
+    @property
+    def isotopes_distribution(self):
+        return {195: 0., 197: 1.0, 198: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {195: 194.965035, 197: 196.966552, 198: 197.968244}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.74
+
+
+class Rg(Element, PeriodVII, GroupXI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 111
+
+    @property
+    def isotopes_distribution(self):
+        return {282: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {282: 282.169127}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.74  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Cu', 'Ag', 'Au', 'Rg']
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `chython-1.67/chython/periodictable/groupVIII.py` & `chython-1.8/chython/periodictable/groupVII.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,145 +1,146 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupVIII
-from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class Fe(Element, PeriodIV, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 26
-
-    @property
-    def isotopes_distribution(self):
-        return {54: 0.05845, 55: 0., 56: 0.91754, 57: 0.02119, 58: 0.00282, 59: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {54: 53.939615, 55: 54.938293, 56: 55.934942, 57: 56.935399, 58: 57.933281, 59: 58.934876}
-
-    @property
-    def _common_valences(self):
-        return 0, 2, 3
-
-    @property
-    def _valences_exceptions(self):
-        return (2, False, 0, ()), (3, False, 0, ())
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Ru(Element, PeriodV, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 44
-
-    @property
-    def isotopes_distribution(self):
-        return {96: 0.0554, 98: 0.0187, 99: 0.1276, 100: 0.126, 101: 0.1706, 102: 0.3155, 104: 0.1862, 106: 0.}
-
-    @property
-    def isotopes_masses(self):
-        return {96: 95.907598, 98: 97.905287, 99: 98.905939, 100: 99.90422, 101: 100.905582, 102: 101.904349,
-                104: 103.90543, 106: 105.907329}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),  # RuO4
-                (0, False, 0, ((1, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),  # [RuO4]-
-                (0, False, 0, ((2, 'C'), (1, 'Cl'), (1, 'Cl'))),  # Grubbs
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))))  # Hoveyda–Grubbs
-
-    @property
-    def atomic_radius(self):
-        return 1.78
-
-
-class Os(Element, PeriodVI, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 76
-
-    @property
-    def isotopes_distribution(self):
-        return {184: 0.0002, 186: 0.0159, 187: 0.0196, 188: 0.1324, 189: 0.1615, 190: 0.2626, 191: 0., 192: 0.4078}
-
-    @property
-    def isotopes_masses(self):
-        return {184: 183.952491, 186: 185.953838, 187: 186.955748, 188: 187.955836, 189: 188.958145, 190: 189.958445,
-                191: 190.960930, 192: 191.961479}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.85
-
-
-class Hs(Element, PeriodVII, GroupVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 108
-
-    @property
-    def isotopes_distribution(self):
-        return {240: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {270: 270.134293}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.85  # unknown, taken radius of previous element in group
-
-
-__all__ = ['Fe', 'Ru', 'Os', 'Hs']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Alexander Nikanshin <17071996sasha@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupVII
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Mn(Element, PeriodIV, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 25
+
+    @property
+    def isotopes_distribution(self):
+        return {52: 0., 55: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {52: 51.945566, 55: 54.938050}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'),)),  # MnO
+                (0, False, 0, ((2, 'O'), (1, 'O'))),  # Mn2O3
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),  # MnO2
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),  # [MnO4]2-
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'O'))))  # [MnO4]-
+
+    @property
+    def atomic_radius(self):
+        return 1.61
+
+
+class Tc(Element, PeriodV, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 43
+
+    @property
+    def isotopes_distribution(self):
+        return {98: 0., 99: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {98: 97.907216, 99: 98.906255}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'))),  # TcO2
+                (0, False, 0, ((2, 'S'), (2, 'S'))))  # TcS2
+
+    @property
+    def atomic_radius(self):
+        return 1.83
+
+
+class Re(Element, PeriodVI, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 75
+
+    @property
+    def isotopes_distribution(self):
+        return {185: 0.374, 186: 0., 187: 0.626, 188: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {185: 184.952956, 186: 185.954986, 187: 186.955751, 188: 187.958114}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.88
+
+
+class Bh(Element, PeriodVII, GroupVII):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 107
+
+    @property
+    def isotopes_distribution(self):
+        return {270: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {270: 270.133363}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.88  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Mn', 'Tc', 'Re', 'Bh']
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `chython-1.67/chython/periodictable/groupXIII.py` & `chython-1.8/chython/periodictable/groupVI.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,207 +1,167 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXIII
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class B(Element, PeriodII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 5
-
-    @property
-    def isotopes_distribution(self):
-        return {10: 0.199, 11: 0.801}
-
-    @property
-    def isotopes_masses(self):
-        return {10: 10.012937, 11: 11.009305}
-
-    @property
-    def _common_valences(self):
-        return 3,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 4, ()), (0, False, 0, ()),
-                (0, True, 2, ()))  # radical OGB-dataset
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Al(Element, PeriodIII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 13
-
-    @property
-    def isotopes_distribution(self):
-        return {27: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {27: 26.981538}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (2, False, 1, ()), (1, False, 2, ()), (0, False, 3, ()), (-1, False, 4, ()),  # accept [AlHx]
-                (-3, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.18
-
-
-class Ga(Element, PeriodIV, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 31
-
-    @property
-    def isotopes_distribution(self):
-        return {67: 0., 68: 0., 69: 0.60108, 71: 0.39892}
-
-    @property
-    def isotopes_masses(self):
-        return {67: 66.928202, 68: 67.927980, 69: 68.925581, 71: 70.924705}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
-                (-1, False, 0, ((1, 'H'), (1, 'H'), (1, 'H'), (1, 'H'))),
-                (-1, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (-1, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (-1, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (-1, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.36
-
-
-class In(Element, PeriodV, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 49
-
-    @property
-    def isotopes_distribution(self):
-        return {111: 0., 113: 0.0429, 115: 0.9571}
-
-    @property
-    def isotopes_masses(self):
-        return {111: 110.905103, 113: 112.904061, 115: 114.903878}
-
-    @property
-    def _common_valences(self):
-        return 0, 3
-
-    @property
-    def _valences_exceptions(self):
-        return ((3, False, 0, ()),
-                (0, False, 0, ((1, 'Cl'),)), (0, False, 0, ((1, 'Br'),)), (0, False, 0, ((1, 'I'),)),
-                (0, False, 0, ((1, 'O'),)))
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Tl(Element, PeriodVI, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 81
-
-    @property
-    def isotopes_distribution(self):
-        return {203: 0.29524, 205: 0.70476}
-
-    @property
-    def isotopes_masses(self):
-        return {203: 202.972329, 205: 204.974412}
-
-    @property
-    def _common_valences(self):
-        return 0, 1
-
-    @property
-    def _valences_exceptions(self):
-        return ((1, False, 0, ()), (3, False, 0, ()),
-                (-3, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.56
-
-
-class Nh(Element, PeriodVII, GroupXIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 113
-
-    @property
-    def isotopes_distribution(self):
-        return {286: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {286: 286.182555}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.56  # unknown, taken radius of previous element in group
-
-
-__all__ = ['B', 'Al', 'Ga', 'In', 'Tl', 'Nh']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupVI
+from .periods import PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class Cr(Element, PeriodIV, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 24
+
+    @property
+    def isotopes_distribution(self):
+        return {50: 0.04345, 51: 0., 52: 0.83789, 53: 0.09501, 54: 0.02365}
+
+    @property
+    def isotopes_masses(self):
+        return {50: 49.946050, 51: 50.944767, 52: 51.940512, 53: 52.940654, 54: 53.938885}
+
+    @property
+    def _common_valences(self):
+        return 0, 2, 3
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()), (3, False, 0, ()),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),  # CrO2
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),  # CrF4
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),  # CrC4
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.66
+
+
+class Mo(Element, PeriodV, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 42
+
+    @property
+    def isotopes_distribution(self):
+        return {92: 0.1484, 94: 0.0925, 95: 0.1592, 96: 0.1668, 97: 0.0955, 98: 0.2413, 99: 0., 100: 0.0963}
+
+    @property
+    def isotopes_masses(self):
+        return {92: 91.906810, 94: 93.905088, 95: 94.905841, 96: 95.904679, 97: 96.906021, 98: 97.905408, 99: 98.907712,
+                100: 99.907477}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'S'), (2, 'S'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.90
+
+
+class W(Element, PeriodVI, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 74
+
+    @property
+    def isotopes_distribution(self):
+        return {180: 0.0012, 182: 0.265, 183: 0.1431, 184: 0.3064, 186: 0.2843}
+
+    @property
+    def isotopes_masses(self):
+        return {180: 179.946706, 182: 181.948206, 183: 182.950224, 184: 183.950933, 186: 185.954362}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.93
+
+
+class Sg(Element, PeriodVII, GroupVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 106
+
+    @property
+    def isotopes_distribution(self):
+        return {269: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {269: 269.128634}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.93  # unknown, taken radius of previous element in group
+
+
+__all__ = ['Cr', 'Mo', 'W', 'Sg']
```

### Comparing `chython-1.67/chython/periodictable/groupXVI.py` & `chython-1.8/chython/periodictable/groupXVI.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,400 +1,358 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXVI
-from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
-
-
-class O(Element, PeriodII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 8
-
-    @property
-    def isotopes_distribution(self):
-        return {15: 0., 16: 0.99757, 17: 0.00038, 18: 0.00205}
-
-    @property
-    def isotopes_masses(self):
-        return {15: 15.003065, 16: 15.994915, 17: 16.999132, 18: 17.99916}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return (-1, False, 1, ()), (-2, False, 0, ()), (0, True, 1, ()), (1, False, 3, ())
-
-    @property
-    def atomic_radius(self):
-        return .48
-
-
-class S(Element, PeriodIII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 16
-
-    @property
-    def isotopes_distribution(self):
-        return {32: 0.9493, 33: 0.0076, 34: 0.0429, 35: 0., 36: 0.0002}
-
-    @property
-    def isotopes_masses(self):
-        return {32: 31.972071, 33: 32.971458, 34: 33.967867, 35: 34.969032, 36: 35.967081}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 1, ()), (-2, False, 0, ()),  # anions
-                (0, True, 1, ()), (0, True, 3, ()),  # radical OGB-dataset
-                (0, False, 0, ()),  # elemental
-
-                (1, False, 0, ((2, 'C'), (1, 'C'))),
-                (1, False, 0, ((2, 'C'), (1, 'S'))),
-                (1, False, 0, ((2, 'N'), (1, 'C'))),
-
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'B'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'))),
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'N'))),
-
-                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'))),
-                (0, False, 0, ((2, 'N'), (2, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'))),
-                (0, False, 0, ((2, 'C'), (2, 'C'))),
-                (0, False, 0, ((2, 'C'), (2, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'S'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'Br'), (1, 'Br'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'S'), (1, 'S'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'P'))),
-
-                (0, False, 0, ((2, 'N'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'O'))),
-                (0, False, 0, ((2, 'N'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'S'))),
-                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'S'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'N'))),
-                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'S'))),
-
-                (0, False, 0, ((1, 'N'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-
-                (0, False, 0, ((1, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((1, 'O'), (1, 'N'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'N'), (1, 'N'))),
-
-                (0, False, 0, ((1, 'S'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'C'))),
-
-                # sulfat derivatives
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'I'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'S'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Br'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'I'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'F'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'F'))),
-
-                (0, False, 0, ((2, 'N'), (2, 'N'), (1, 'C'), (1, 'C'))),
-
-                # aci forms of tautomers
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'N'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'N'))),
-
-                (0, False, 0, ((2, 'N'), (2, 'C'), (1, 'C'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'O'))),  # [S2O3]2-
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'C'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'S'), (2, 'S'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))))
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Se(Element, PeriodIV, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 34
-
-    @property
-    def isotopes_distribution(self):
-        return {73: 0., 74: 0.0089, 75: 0., 76: 0.0937, 77: 0.0763, 78: 0.2377, 80: 0.4961, 82: 0.0873}
-
-    @property
-    def isotopes_masses(self):
-        return {73: 72.926765, 74: 73.922477, 75: 74.922523, 76: 75.919214, 77: 76.919915, 78: 77.917310, 80: 79.916522,
-                82: 81.916700}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((-1, False, 1, ()), (-2, False, 0, ()),
-                (0, False, 0, ()),  # elemental
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (1, False, 0, ((1, 'C'), (2, 'C'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'S'), (2, 'S'))),
-                (0, False, 0, ((2, 'N'), (2, 'N'))),
-
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-
-                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
-
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'O'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'O'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.03
-
-
-class Te(Element, PeriodV, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 52
-
-    @property
-    def isotopes_distribution(self):
-        return {120: 0.0009, 122: 0.0255, 123: 0.0089, 124: 0.0474, 125: 0.0707, 126: 0.1884, 128: 0.3174, 130: 0.3408}
-
-    @property
-    def isotopes_masses(self):
-        return {120: 119.90402, 122: 121.903047, 123: 122.904273, 124: 123.90282, 125: 124.904425, 126: 125.903306,
-                128: 127.904461, 130: 129.906223}
-
-    @property
-    def _common_valences(self):
-        return 2,
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ()),  # elemental,
-                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
-                (-1, False, 0, ((1, 'C'), (1, 'O'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (1, False, 0, ((1, 'C'), (2, 'C'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
-                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))),
-                (0, False, 0, ((1, 'C'), (1, 'O'), (1, 'Cl'), (1, 'Cl'))),
-
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'Cl'), (1, 'Cl'))),
-
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.23
-
-
-class Po(Element, PeriodVI, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 84
-
-    @property
-    def isotopes_distribution(self):
-        return {210: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {210: 209.982874}
-
-    @property
-    def _common_valences(self):
-        return 0, 2
-
-    @property
-    def _valences_exceptions(self):
-        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'))),
-                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
-                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
-                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.35
-
-
-class Lv(Element, PeriodVII, GroupXVI):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 116
-
-    @property
-    def isotopes_distribution(self):
-        return {293: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {293: 293.204555}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.35  # unknown, taken radius of previous element in group
-
-
-__all__ = ['O', 'S', 'Se', 'Te', 'Po', 'Lv']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXVI
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class O(Element, PeriodII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 8
+
+    @property
+    def isotopes_distribution(self):
+        return {16: 0.99757, 17: 0.00038, 18: 0.00205}
+
+    @property
+    def isotopes_masses(self):
+        return {16: 15.994915, 17: 16.999132, 18: 17.99916}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return (-1, False, 1, ()), (-2, False, 0, ()), (0, True, 1, ()), (1, False, 3, ())
+
+    @property
+    def atomic_radius(self):
+        return .48
+
+
+class S(Element, PeriodIII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 16
+
+    @property
+    def isotopes_distribution(self):
+        return {32: 0.9493, 33: 0.0076, 34: 0.0429, 35: 0., 36: 0.0002}
+
+    @property
+    def isotopes_masses(self):
+        return {32: 31.972071, 33: 32.971458, 34: 33.967867, 35: 34.969032, 36: 35.967081}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 1, ()), (-2, False, 0, ()),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'B'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (1, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'))),
+                (0, False, 0, ((2, 'N'), (2, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'))),
+                (0, False, 0, ((2, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'C'), (2, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'N'), (1, 'S'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'Br'), (1, 'Br'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'P'))),
+
+                (0, False, 0, ((2, 'N'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'N'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'N'), (1, 'N'), (1, 'O'))),
+                (0, False, 0, ((2, 'N'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'C'), (1, 'C'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'S'))),
+                (0, False, 0, ((2, 'C'), (1, 'S'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'C'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'N'))),
+                (0, False, 0, ((2, 'S'), (1, 'C'), (1, 'S'))),
+
+                (0, False, 0, ((1, 'N'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+                (0, False, 0, ((1, 'O'), (1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((1, 'O'), (1, 'N'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'Cl'), (1, 'Cl'))),
+
+                (0, False, 0, ((1, 'S'), (1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'C'))),
+
+                # sulfat derivatives
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'I'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'N'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'S'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'Br'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'I'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'F'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'F'))),
+
+                (0, False, 0, ((2, 'N'), (2, 'N'), (1, 'C'), (1, 'C'))),
+
+                # aci forms of tautomers
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'N'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'C'), (1, 'N'), (1, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'O'))),  # [S2O3]2-
+                (0, False, 0, ((2, 'O'), (2, 'S'), (1, 'O'), (1, 'C'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return .87
+
+
+class Se(Element, PeriodIV, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 34
+
+    @property
+    def isotopes_distribution(self):
+        return {73: 0., 74: 0.0089, 75: 0., 76: 0.0937, 77: 0.0763, 78: 0.2377, 80: 0.4961, 82: 0.0873}
+
+    @property
+    def isotopes_masses(self):
+        return {73: 72.926765, 74: 73.922477, 75: 74.922523, 76: 75.919214, 77: 76.919915, 78: 77.917310, 80: 79.916522,
+                82: 81.916700}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((-1, False, 1, ()),
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'S'), (2, 'S'))),
+                (0, False, 0, ((2, 'N'), (2, 'N'))),
+
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'N'), (1, 'C'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.03
+
+
+class Te(Element, PeriodV, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 52
+
+    @property
+    def isotopes_distribution(self):
+        return {120: 0.0009, 122: 0.0255, 123: 0.0089, 124: 0.0474, 125: 0.0707, 126: 0.1884, 128: 0.3174, 130: 0.3408}
+
+    @property
+    def isotopes_masses(self):
+        return {120: 119.90402, 122: 121.903047, 123: 122.904273, 124: 123.90282, 125: 124.904425, 126: 125.903306,
+                128: 127.904461, 130: 129.906223}
+
+    @property
+    def _common_valences(self):
+        return 2,
+
+    @property
+    def _valences_exceptions(self):
+        return ((1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (1, False, 0, ((1, 'C'), (2, 'C'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'C'))),
+                (0, False, 0, ((2, 'O'), (1, 'C'), (1, 'C'))),
+                (0, False, 0, ((1, 'C'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.23
+
+
+class Po(Element, PeriodVI, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 84
+
+    @property
+    def isotopes_distribution(self):
+        return {210: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {210: 209.982874}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'Br'), (1, 'Br'), (1, 'Br'), (1, 'Br'))),
+                (0, False, 0, ((1, 'I'), (1, 'I'), (1, 'I'), (1, 'I'))),
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.35
+
+
+class Lv(Element, PeriodVII, GroupXVI):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 116
+
+    @property
+    def isotopes_distribution(self):
+        return {293: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {293: 293.204555}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.35  # unknown, taken radius of previous element in group
+
+
+__all__ = ['O', 'S', 'Se', 'Te', 'Po', 'Lv']
```

### Comparing `chython-1.67/chython/periodictable/groupXVIII.py` & `chython-1.8/chython/periodictable/groupXIV.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,232 +1,213 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Tagir Akhmetshin <tagirshin@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from .element import Element
-from .groups import GroupXVIII
-from .periods import *
-
-
-class He(Element, PeriodI, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 2
-
-    @property
-    def isotopes_distribution(self):
-        return {3: 1e-06, 4: 0.999999}
-
-    @property
-    def isotopes_masses(self):
-        return {3: 3.016029, 4: 4.002603}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .31
-
-
-class Ne(Element, PeriodII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 10
-
-    @property
-    def isotopes_distribution(self):
-        return {20: 0.9048, 21: 0.0027, 22: 0.0925}
-
-    @property
-    def isotopes_masses(self):
-        return {20: 19.99244, 21: 20.993847, 22: 21.991386}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .38
-
-
-class Ar(Element, PeriodIII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 18
-
-    @property
-    def isotopes_distribution(self):
-        return {36: 0.003365, 38: 0.000632, 40: 0.996003}
-
-    @property
-    def isotopes_masses(self):
-        return {36: 35.967546, 38: 37.962732, 40: 39.962383}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .71
-
-
-class Kr(Element, PeriodIV, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 36
-
-    @property
-    def isotopes_distribution(self):
-        return {78: 0.0035, 80: 0.0228, 81: 0., 82: 0.1158, 83: 0.1149, 84: 0.57, 86: 0.173}
-
-    @property
-    def isotopes_masses(self):
-        return {78: 77.920386, 80: 79.916378, 81: 80.916592, 82: 81.913485, 83: 82.914136, 84: 83.911507, 86: 85.91061}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return .87
-
-
-class Xe(Element, PeriodV, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 54
-
-    @property
-    def isotopes_distribution(self):
-        return {124: 0.0009, 126: 0.0009, 127: 0., 128: 0.0192, 129: 0.2644, 130: 0.0408, 131: 0.2118, 132: 0.2689,
-                133: 0., 134: 0.1044, 136: 0.0887}
-
-    @property
-    def isotopes_masses(self):
-        return {124: 123.905896, 126: 125.904269, 127: 126.905184, 128: 127.90353, 129: 128.904779, 130: 129.903508,
-                131: 130.905082, 132: 131.904155, 133: 132.905911, 134: 133.905394, 136: 135.90722}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        # XeF2, XeF4, XeF6, XeO3, XeO4, XeO2F2, XeOF4, XeO3F2, [XeO6]4-
-        return ((0, False, 0, ((1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (2, 'O'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((2, 'O'), (2, 'O'), (2, 'O'), (1, 'F'), (1, 'F'))),
-                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (2, 'O'), (2, 'O'))))
-
-    @property
-    def atomic_radius(self):
-        return 1.08
-
-
-class Rn(Element, PeriodVI, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 86
-
-    @property
-    def isotopes_distribution(self):
-        return {222: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {222: 222.017578}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return (0, False, 0, ((1, 'F'), (1, 'F'))), (1, False, 0, ((1, 'F'),))
-
-    @property
-    def atomic_radius(self):
-        return 1.2
-
-
-class Og(Element, PeriodVII, GroupXVIII):
-    __slots__ = ()
-
-    @property
-    def atomic_number(self):
-        return 118
-
-    @property
-    def isotopes_distribution(self):
-        return {294: 1.0}
-
-    @property
-    def isotopes_masses(self):
-        return {294: 294.0}
-
-    @property
-    def _common_valences(self):
-        return 0,
-
-    @property
-    def _valences_exceptions(self):
-        return ()
-
-    @property
-    def atomic_radius(self):
-        return 1.2  # unknown, taken radius of previous element in group
-
-
-__all__ = ['He', 'Ne', 'Ar', 'Kr', 'Xe', 'Rn', 'Og']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Dayana Bashirova <dayana.bashirova@yandex.ru>
+#  Copyright 2019 Tansu Nasyrova <tansu.nasyrova@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from .element import Element
+from .groups import GroupXIV
+from .periods import PeriodII, PeriodIII, PeriodIV, PeriodV, PeriodVI, PeriodVII
+
+
+class C(Element, PeriodII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 6
+
+    @property
+    def isotopes_distribution(self):
+        return {12: 0.9893, 13: 0.0107, 14: 0.0}
+
+    @property
+    def isotopes_masses(self):
+        return {12: 12.0, 13: 13.003355, 14: 14.003242}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (0, True, 3, ()), (1, False, 3, ()), (-1, False, 3, ())
+
+    @property
+    def atomic_radius(self):
+        return .67
+
+
+class Si(Element, PeriodIII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 14
+
+    @property
+    def isotopes_distribution(self):
+        return {28: 0.922297, 29: 0.046832, 30: 0.030872}
+
+    @property
+    def isotopes_masses(self):
+        return {28: 27.976927, 29: 28.976495, 30: 29.97377}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (-2, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+    @property
+    def atomic_radius(self):
+        return 1.11
+
+
+class Ge(Element, PeriodIV, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 32
+
+    @property
+    def isotopes_distribution(self):
+        return {70: 0.2084, 72: 0.2754, 73: 0.0773, 74: 0.3628, 76: 0.0761}
+
+    @property
+    def isotopes_masses(self):
+        return {70: 69.92425, 72: 71.922076, 73: 72.923459, 74: 73.921178, 76: 75.921403}
+
+    @property
+    def _common_valences(self):
+        return 4,
+
+    @property
+    def _valences_exceptions(self):
+        return (-2, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+
+    @property
+    def atomic_radius(self):
+        return 1.25
+
+
+class Sn(Element, PeriodV, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 50
+
+    @property
+    def isotopes_distribution(self):
+        return {112: 0.0097, 113: 0., 114: 0.0066, 115: 0.0034, 116: 0.1454, 117: 0.0768, 118: 0.2422, 119: 0.0859,
+                120: 0.3258, 122: 0.0463, 124: 0.0579}
+
+    @property
+    def isotopes_masses(self):
+        return {112: 111.904821, 113: 112.905171, 114: 113.902782, 115: 114.903346, 116: 115.901744, 117: 116.902954,
+                118: 117.901606, 119: 118.903309, 120: 119.902197, 122: 121.903440, 124: 123.905275}
+
+    @property
+    def _common_valences(self):
+        return 0, 4
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (0, False, 0, ((2, 'O'),)), (0, False, 0, ((1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'S'),)),
+
+                (1, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'))),
+                (0, False, 1, ((1, 'C'), (1, 'C'), (1, 'C'))),
+
+                (-2, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.45
+
+
+class Pb(Element, PeriodVI, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 82
+
+    @property
+    def isotopes_distribution(self):
+        return {204: 0.014, 206: 0.241, 207: 0.221, 208: 0.524, 210: 0.}
+
+    @property
+    def isotopes_masses(self):
+        return {204: 203.973029, 206: 205.974449, 207: 206.975881, 208: 207.976636, 210: 209.984189}
+
+    @property
+    def _common_valences(self):
+        return 0, 2
+
+    @property
+    def _valences_exceptions(self):
+        return ((2, False, 0, ()),
+                (-2, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (-2, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((2, 'O'), (2, 'O'))),
+                (0, False, 0, ((1, 'O'), (1, 'O'), (1, 'O'), (1, 'O'))),
+                (0, False, 0, ((2, 'O'), (1, 'O'), (1, 'O'))),
+
+                (0, False, 0, ((1, 'F'), (1, 'F'), (1, 'F'), (1, 'F'))),
+                (0, False, 0, ((1, 'Cl'), (1, 'Cl'), (1, 'Cl'), (1, 'Cl'))),
+                (0, False, 0, ((1, 'C'), (1, 'C'), (1, 'C'), (1, 'C'))))
+
+    @property
+    def atomic_radius(self):
+        return 1.54
+
+
+class Fl(Element, PeriodVII, GroupXIV):
+    __slots__ = ()
+
+    @property
+    def atomic_number(self):
+        return 114
+
+    @property
+    def isotopes_distribution(self):
+        return {289: 1.0}
+
+    @property
+    def isotopes_masses(self):
+        return {289: 289.190444}
+
+    @property
+    def _common_valences(self):
+        return 0,
+
+    @property
+    def _valences_exceptions(self):
+        return ()
+
+    @property
+    def atomic_radius(self):
+        return 1.54  # unknown, taken radius of previous element in group
+
+
+__all__ = ['C', 'Si', 'Ge', 'Sn', 'Pb', 'Fl']
```

### Comparing `chython-1.67/chython/reactor/transformer.py` & `chython-1.8/chython/reactor/transformer.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2019 Adelia Fatykhova <adelik21979@gmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from typing import Union
-from .base import BaseReactor
-from ..containers import QueryContainer, MoleculeContainer
-
-
-class Transformer(BaseReactor):
-    """
-    Editor for molecules.
-    generates modified molecules from input molecule using template.
-    Transformer calling returns generator of all possible replacements.
-    """
-    def __init__(self, pattern: QueryContainer, replacement: Union[MoleculeContainer, QueryContainer],
-                 delete_atoms: bool = True, automorphism_filter: bool = True, fix_aromatic_rings: bool = True,
-                 fix_tautomers: bool = True):
-        """
-        :param pattern: Search pattern.
-        :param replacement: Resulted structure.
-        :param delete_atoms: If True atoms exists in reactants but not exists in products will be removed.
-        :param fix_aromatic_rings: Proceed kekule and thiele on products.
-        :param fix_tautomers: See `thiele()` docs.
-        :param automorphism_filter: Skip matches to same atoms.
-        """
-        if not isinstance(pattern, QueryContainer) or not isinstance(replacement, (MoleculeContainer, QueryContainer)):
-            raise TypeError('invalid params')
-
-        self.pattern = pattern
-        self.replacement = replacement
-        self.__automorphism_filter = automorphism_filter
-        super().__init__({n for n, h in pattern._masked.items() if not h}, replacement, delete_atoms,
-                         fix_aromatic_rings, fix_tautomers)
-
-    def __call__(self, structure: MoleculeContainer):
-        if not isinstance(structure, MoleculeContainer):
-            raise TypeError('only Molecules possible')
-
-        for mapping in self.pattern.get_mapping(structure, automorphism_filter=self.__automorphism_filter):
-            yield from self._patcher(structure, mapping)
-
-
-__all__ = ['Transformer']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2019 Adelia Fatykhova <adelik21979@gmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from typing import Union
+from .base import BaseReactor
+from ..containers import QueryContainer, MoleculeContainer
+
+
+class Transformer(BaseReactor):
+    """
+    Editor for molecules.
+    generates modified molecules from input molecule using template.
+    Transformer calling returns generator of all possible replacements.
+    """
+    def __init__(self, pattern: QueryContainer, replacement: Union[MoleculeContainer, QueryContainer],
+                 delete_atoms: bool = True):
+        """
+        :param pattern: search pattern
+        :param replacement: atoms and bonds replacement
+        :param delete_atoms: if True atoms exists in pattern but not exists in replacement will be removed
+        """
+        if not isinstance(pattern, QueryContainer) or not isinstance(replacement, (MoleculeContainer, QueryContainer)):
+            raise TypeError('invalid params')
+
+        self.__pattern = pattern
+        super().__init__(pattern, replacement, delete_atoms)
+
+    def __call__(self, structure: MoleculeContainer, automorphism_filter: bool = True):
+        if not isinstance(structure, MoleculeContainer):
+            raise TypeError('only Molecules possible')
+
+        for mapping in self.__pattern.get_mapping(structure, automorphism_filter=automorphism_filter):
+            yield self._patcher(structure, mapping)
+
+    def __getstate__(self):
+        return {'pattern': self.__pattern, **super().__getstate__()}
+
+    def __setstate__(self, state):
+        self.__pattern = state['pattern']
+        super().__setstate__(state)
+
+
+__all__ = ['Transformer']
```

### Comparing `chython-1.67/chython/utils/functional_groups.py` & `chython-1.8/chython/utils/functional_groups.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  Copyright 2020 Dinar Batyrshin <batyrshin-dinar@mail.ru>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-
-
-def functional_groups(molecule, limit):
-    """
-    Generate all connected atom groups up to limit atoms.
-
-    :param molecule: MoleculeContainer
-    :param limit: chain length
-    :return: list of molecule functional groups
-    """
-    bonds = molecule._bonds
-
-    if limit < 1:
-        raise ValueError('limit should be >= 1')
-
-    response = []
-    groups = set()
-    stack = [([a], list(n)) for a, n in bonds.items()]
-    while stack:
-        aug, nei = stack.pop(0)
-        for x in nei:
-            augx = (*aug, x)
-            if augx not in groups:
-                groups.add(augx)
-                response.append(molecule.substructure(augx, as_query=True))
-                nt = nei.copy()
-                nt.remove(x)
-                nt.extend(list(bonds[x]))
-                if len(augx) < limit:
-                    stack.append((augx, nt))
-    return response
-
-
-__all__ = ['functional_groups']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2020, 2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  Copyright 2020 Dinar Batyrshin <batyrshin-dinar@mail.ru>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+
+
+def functional_groups(molecule, limit):
+    """
+    Generate all connected atom groups up to limit atoms.
+
+    :param molecule: MoleculeContainer
+    :param limit: chain length
+    :return: list of molecule functional groups
+    """
+    bonds = molecule._bonds
+
+    if limit < 1:
+        raise ValueError('limit should be >= 1')
+
+    response = []
+    groups = set()
+    stack = [([a], list(n)) for a, n in bonds.items()]
+    while stack:
+        aug, nei = stack.pop(0)
+        for x in nei:
+            augx = (*aug, x)
+            if augx not in groups:
+                groups.add(augx)
+                response.append(molecule.substructure(augx, as_query=True))
+                nt = nei.copy()
+                nt.remove(x)
+                nt.extend(list(bonds[x]))
+                if len(augx) < limit:
+                    stack.append((augx, nt))
+    return response
+
+
+__all__ = ['functional_groups']
```

### Comparing `chython-1.67/chython/utils/rdkit.py` & `chython-1.8/chython/utils/rdkit.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,189 +1,179 @@
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2019-2022 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from rdkit.Chem import AssignStereochemistry, Atom, BondStereo, BondType, ChiralType, Conformer, RWMol, SanitizeMol
-from ..containers import MoleculeContainer
-from ..exceptions import IsChiral, NotChiral, ValenceError
-from ..periodictable import Element
-
-
-def from_rdkit_molecule(data):
-    """
-    RDKit molecule object to MoleculeContainer converter
-    """
-    mol = MoleculeContainer()
-    parsed_mapping = mol._parsed_mapping
-    mol_conformers = mol._conformers
-    bonds = mol._bonds
-
-    atoms, mapping = [], []
-    tetrahedron_stereo = []
-    for a in data.GetAtoms():
-        e = Element.from_symbol(a.GetSymbol())
-        isotope = a.GetIsotope()
-        if isotope:
-            e = e(isotope)
-        else:
-            e = e()
-        atom = {'atom': e, 'charge': a.GetFormalCharge()}
-
-        radical = a.GetNumRadicalElectrons()
-        if radical:
-            atom['is_radical'] = True
-
-        atoms.append(atom)
-        mapping.append(a.GetAtomMapNum())
-        tetrahedron_stereo.append(a.GetChiralTag())
-
-    conformers = []
-    c = data.GetConformers()
-    if c:
-        for atom, (x, y, _) in zip(atoms, c[0].GetPositions()):
-            atom['xy'] = (x, y)
-        for c in c:
-            if c.Is3D():
-                conformers.append(c.GetPositions())
-
-    new_map = []
-    for a, n in zip(atoms, mapping):
-        a = mol.add_atom(**a)
-        new_map.append(a)
-        parsed_mapping[a] = n
-
-    stereo = []
-    for b in data.GetBonds():
-        n, m = new_map[b.GetBeginAtomIdx()], new_map[b.GetEndAtomIdx()]
-        mol.add_bond(n, m, _rdkit_bond_map[b.GetBondType()])
-        s = b.GetStereo()
-        if s == _cis:
-            nn, nm = b.GetStereoAtoms()
-            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], True))
-        elif s == _trans:
-            nn, nm = b.GetStereoAtoms()
-            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], False))
-
-    for n, s in zip(new_map, tetrahedron_stereo):
-        if s == _chiral_cw:
-            env = bonds[n]
-            env = [x for x in new_map if x in env]
-            stereo.append((mol.add_atom_stereo, n, env, False))
-        elif s == _chiral_ccw:
-            env = bonds[n]
-            env = [x for x in new_map if x in env]
-            stereo.append((mol.add_atom_stereo, n, env, True))
-
-    while stereo:
-        fail_stereo = []
-        old_stereo = len(stereo)
-        for f, *args in stereo:
-            try:
-                f(*args, clean_cache=False)
-            except NotChiral:
-                fail_stereo.append((f, *args))
-            except IsChiral:
-                pass
-            except ValenceError:
-                mol.flush_cache()
-                break
-        else:
-            stereo = fail_stereo
-            if len(stereo) == old_stereo:
-                break
-            mol.flush_stereo_cache()
-            continue
-        break
-
-    for c in conformers:
-        mol_conformers.append({k: tuple(v) for k, v in zip(new_map, c)})
-    return mol
-
-
-def to_rdkit_molecule(data: MoleculeContainer, *, keep_mapping=True):
-    """
-    MoleculeContainer to RDKit molecule object converter.
-
-    :param keep_mapping: set atom numbers.
-
-    Note: implicit hydrogens data omitted.
-    """
-    mol = RWMol()
-    mapping = {}
-    atoms = data._atoms
-    bonds = data._bonds
-
-    for n, a in data.atoms():
-        ra = Atom(a.atomic_number)
-        if keep_mapping:
-            ra.SetAtomMapNum(n)
-        if a.charge:
-            ra.SetFormalCharge(a.charge)
-        if a.isotope:
-            ra.SetIsotope(a.isotope)
-        if a.is_radical:
-            ra.SetNumRadicalElectrons(1)
-        mapping[n] = mol.AddAtom(ra)
-
-    for n, m, b in data.bonds():
-        if atoms[n].atomic_symbol not in _inorganic:
-            n, m = m, n  # fix direction of dative bond
-        mol.AddBond(mapping[n], mapping[m], _bond_map[b.order])
-
-    for n in data._atoms_stereo:
-        ra = mol.GetAtomWithIdx(mapping[n])
-        env = bonds[n]
-        s = data._translate_tetrahedron_sign(n, [x for x in mapping if x in env])
-        ra.SetChiralTag(_chiral_ccw if s else _chiral_cw)
-
-    for nm, s in data._cis_trans_stereo.items():
-        n, m = nm
-        if m in bonds[n]:  # cumulenes unsupported
-            nn, nm, *_ = data._stereo_cis_trans[nm]
-            b = mol.GetBondBetweenAtoms(mapping[n], mapping[m])
-            b.SetStereoAtoms(mapping[nn], mapping[nm])
-            b.SetStereo(_cis if s else _trans)
-
-    conf = Conformer()
-    for n, a in data.atoms():
-        conf.SetAtomPosition(mapping[n], (a.x, a.y, 0))
-    conf.Set3D(False)
-    mol.AddConformer(conf, assignId=True)
-
-    for c in data._conformers:
-        conf = Conformer()
-        for n, xyz in c.items():
-            conf.SetAtomPosition(mapping[n], xyz)
-        mol.AddConformer(conf, assignId=True)
-
-    SanitizeMol(mol)
-    AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
-    return mol
-
-
-_rdkit_bond_map = {BondType.SINGLE: 1, BondType.DOUBLE: 2, BondType.TRIPLE: 3, BondType.AROMATIC: 4, BondType.ZERO: 8,
-                   BondType.UNSPECIFIED: 8, BondType.DATIVE: 8}
-_bond_map = {1: BondType.SINGLE, 2: BondType.DOUBLE, 3: BondType.TRIPLE, 4: BondType.AROMATIC, 8: BondType.DATIVE}
-
-_chiral_cw = ChiralType.CHI_TETRAHEDRAL_CW
-_chiral_ccw = ChiralType.CHI_TETRAHEDRAL_CCW
-_trans = BondStereo.STEREOE
-_cis = BondStereo.STEREOZ
-_inorganic = {'He', 'Ne', 'Ar', 'Kr', 'Xe', 'F', 'Cl', 'Br', 'I', 'C', 'N', 'O',
-              'H', 'Si', 'P', 'S', 'Se', 'Ge', 'As', 'Sb', 'Te'}
-
-
-__all__ = ['from_rdkit_molecule', 'to_rdkit_molecule']
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2019-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from rdkit.Chem import AssignStereochemistry, Atom, BondStereo, BondType, ChiralType, Conformer, RWMol, SanitizeMol
+from ..containers import MoleculeContainer
+from ..exceptions import IsChiral, NotChiral, ValenceError
+from ..periodictable import Element
+
+
+def from_rdkit_molecule(data):
+    """
+    RDKit molecule object to MoleculeContainer converter
+    """
+    mol = MoleculeContainer()
+    parsed_mapping = mol._parsed_mapping
+    mol_conformers = mol._conformers
+    bonds = mol._bonds
+
+    atoms, mapping = [], []
+    tetrahedron_stereo = []
+    for a in data.GetAtoms():
+        e = Element.from_symbol(a.GetSymbol())
+        isotope = a.GetIsotope()
+        if isotope:
+            e = e(isotope)
+        else:
+            e = e()
+        atom = {'atom': e, 'charge': a.GetFormalCharge()}
+
+        radical = a.GetNumRadicalElectrons()
+        if radical:
+            atom['is_radical'] = True
+
+        atoms.append(atom)
+        mapping.append(a.GetAtomMapNum())
+        tetrahedron_stereo.append(a.GetChiralTag())
+
+    conformers = []
+    c = data.GetConformers()
+    if c:
+        for atom, (x, y, _) in zip(atoms, c[0].GetPositions()):
+            atom['xy'] = (x, y)
+        for c in c:
+            if c.Is3D():
+                conformers.append(c.GetPositions())
+
+    new_map = []
+    for a, n in zip(atoms, mapping):
+        a = mol.add_atom(**a)
+        new_map.append(a)
+        parsed_mapping[a] = n
+
+    stereo = []
+    for b in data.GetBonds():
+        n, m = new_map[b.GetBeginAtomIdx()], new_map[b.GetEndAtomIdx()]
+        mol.add_bond(n, m, _rdkit_bond_map[b.GetBondType()])
+        s = b.GetStereo()
+        if s == _cis:
+            nn, nm = b.GetStereoAtoms()
+            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], True))
+        elif s == _trans:
+            nn, nm = b.GetStereoAtoms()
+            stereo.append((mol.add_cis_trans_stereo, n, m, new_map[nn], new_map[nm], False))
+
+    for n, s in zip(new_map, tetrahedron_stereo):
+        if s == _chiral_cw:
+            env = bonds[n]
+            env = [x for x in new_map if x in env]
+            stereo.append((mol.add_atom_stereo, n, env, False))
+        elif s == _chiral_ccw:
+            env = bonds[n]
+            env = [x for x in new_map if x in env]
+            stereo.append((mol.add_atom_stereo, n, env, True))
+
+    while stereo:
+        fail_stereo = []
+        old_stereo = len(stereo)
+        for f, *args in stereo:
+            try:
+                f(*args, clean_cache=False)
+            except NotChiral:
+                fail_stereo.append((f, *args))
+            except IsChiral:
+                pass
+            except ValenceError:
+                mol.flush_cache()
+                break
+        else:
+            stereo = fail_stereo
+            if len(stereo) == old_stereo:
+                break
+            mol.flush_stereo_cache()
+            continue
+        break
+
+    for c in conformers:
+        mol_conformers.append({k: tuple(v) for k, v in zip(new_map, c)})
+    return mol
+
+
+def to_rdkit_molecule(data: MoleculeContainer):
+    """
+    MoleculeContainer to RDKit molecule object converter.
+
+    Note: implicit hydrogens data omitted.
+    """
+    mol = RWMol()
+    mapping = {}
+    bonds = data._bonds
+
+    for n, a in data.atoms():
+        ra = Atom(a.atomic_number)
+        ra.SetAtomMapNum(n)
+        if a.charge:
+            ra.SetFormalCharge(a.charge)
+        if a.isotope:
+            ra.SetIsotope(a.isotope)
+        if a.is_radical:
+            ra.SetNumRadicalElectrons(1)
+        mapping[n] = mol.AddAtom(ra)
+
+    for n, m, b in data.bonds():
+        mol.AddBond(mapping[n], mapping[m], _bond_map[b.order])
+
+    for n in data._atoms_stereo:
+        ra = mol.GetAtomWithIdx(mapping[n])
+        env = bonds[n]
+        s = data._translate_tetrahedron_sign(n, [x for x in mapping if x in env])
+        ra.SetChiralTag(_chiral_ccw if s else _chiral_cw)
+
+    for nm, s in data._cis_trans_stereo.items():
+        n, m = nm
+        if m in bonds[n]:  # cumulenes unsupported
+            nn, nm, *_ = data._stereo_cis_trans[nm]
+            b = mol.GetBondBetweenAtoms(mapping[n], mapping[m])
+            b.SetStereoAtoms(mapping[nn], mapping[nm])
+            b.SetStereo(_cis if s else _trans)
+
+    conf = Conformer()
+    for n, a in data.atoms():
+        conf.SetAtomPosition(mapping[n], (a.x, a.y, 0))
+    conf.Set3D(False)
+    mol.AddConformer(conf, assignId=True)
+
+    for c in data._conformers:
+        conf = Conformer()
+        for n, xyz in c.items():
+            conf.SetAtomPosition(mapping[n], xyz)
+        mol.AddConformer(conf, assignId=True)
+
+    SanitizeMol(mol)
+    AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
+    return mol
+
+
+_rdkit_bond_map = {BondType.SINGLE: 1, BondType.DOUBLE: 2, BondType.TRIPLE: 3, BondType.AROMATIC: 4}
+_bond_map = {1: BondType.SINGLE, 2: BondType.DOUBLE, 3: BondType.TRIPLE, 4: BondType.AROMATIC}
+
+_chiral_cw = ChiralType.CHI_TETRAHEDRAL_CW
+_chiral_ccw = ChiralType.CHI_TETRAHEDRAL_CCW
+_trans = BondStereo.STEREOE
+_cis = BondStereo.STEREOZ
+
+__all__ = ['from_rdkit_molecule', 'to_rdkit_molecule']
```

### Comparing `chython-1.67/setup.py` & `chython-1.8/setup.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
-#  Copyright 2014-2023 Ramil Nugmanov <nougmanoff@protonmail.com>
-#  This file is part of chython.
-#
-#  chython is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU Lesser General Public License as published by
-#  the Free Software Foundation; either version 3 of the License, or
-#  (at your option) any later version.
-#
-#  This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#  GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public License
-#  along with this program; if not, see <https://www.gnu.org/licenses/>.
-#
-from distutils.command.sdist import sdist
-from distutils.command.build import build
-from distutils.util import get_platform
-from importlib.util import find_spec
-from pathlib import Path
-from setuptools import setup, Extension, find_packages
-
-
-class _sdist(sdist):
-    def finalize_options(self):
-        super().finalize_options()
-        self.distribution.data_files.append(('lib', ['INCHI/libinchi.so',
-                                                     'INCHI/libinchi.dll', 'INCHI/libinchi.dynlib']))
-
-
-cmd_class = {'sdist': _sdist}
-
-
-if find_spec('wheel'):
-    from wheel.bdist_wheel import bdist_wheel
-
-    class _bdist_wheel(bdist_wheel):
-        def finalize_options(self):
-            super().finalize_options()
-            self.root_is_pure = False
-            platform = get_platform()
-            if platform == 'win-amd64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dll']))
-            elif platform == 'linux-x86_64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.so']))
-            elif platform == 'macosx-11-x86_64':
-                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dynlib']))
-
-    cmd_class['bdist_wheel'] = _bdist_wheel
-
-
-if find_spec('cython'):
-    class _build(build):
-        def finalize_options(self):
-            super().finalize_options()
-            from Cython.Build import cythonize
-            self.distribution.ext_modules = cythonize(self.distribution.ext_modules, language_level=3)
-
-    cmd_class['build'] = _build
-
-
-setup(
-    name='chython',
-    version='1.67',
-    packages=find_packages(),
-    url='https://github.com/chython/chython',
-    license='LGPLv3',
-    author='Dr. Ramil Nugmanov',
-    author_email='nougmanoff@protonmail.com',
-    python_requires='>=3.8',
-    cmdclass=cmd_class,
-    ext_modules=[Extension('chython.algorithms._isomorphism', ['chython/algorithms/_isomorphism.pyx'],
-                           extra_compile_args=['-O3']),
-                 Extension('chython.containers._unpack', ['chython/containers/_unpack.pyx'],
-                           extra_compile_args=['-O3']),
-                 Extension('chython.containers._pack', ['chython/containers/_pack.pyx'], extra_compile_args=['-O3']),
-                 Extension('chython.containers._cpack', ['chython/containers/_cpack.pyx'], extra_compile_args=['-O3']),
-                 Extension('chython.files._xyz', ['chython/files/_xyz.pyx'], extra_compile_args=['-O3'])],
-    setup_requires=['wheel', 'cython'],
-    install_requires=['CachedMethods>=0.1.4,<0.2', 'lazy-object-proxy>=1.6', 'lxml>=4.1', 'py-mini-racer>=0.4.0',
-                      'numpy>=1.18'],
-    extras_require={'pytest': ['pytest'], 'mapping': ['chytorch-rxnmap>=1.4']},
-    package_data={'chython.algorithms': ['_isomorphism.pyx'], 'chython.algorithms.calculate2d': ['clean2d.js'],
-                  'chython.containers': ['_pack.pyx', '_unpack.pyx', '_cpack.pyx'], 'chython.files': ['_xyz.pyx']},
-    data_files=[],
-    zip_safe=False,
-    long_description=(Path(__file__).parent / 'README.rst').read_text('utf8'),
-    classifiers=['Environment :: Plugins',
-                 'Intended Audience :: Science/Research',
-                 'License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)',
-                 'Operating System :: OS Independent',
-                 'Programming Language :: Python',
-                 'Programming Language :: Python :: 3 :: Only',
-                 'Programming Language :: Python :: 3.8',
-                 'Topic :: Scientific/Engineering',
-                 'Topic :: Scientific/Engineering :: Chemistry',
-                 'Topic :: Scientific/Engineering :: Information Analysis',
-                 'Topic :: Software Development',
-                 'Topic :: Software Development :: Libraries',
-                 'Topic :: Software Development :: Libraries :: Python Modules']
-)
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+#  Copyright 2014-2021 Ramil Nugmanov <nougmanoff@protonmail.com>
+#  This file is part of chython.
+#
+#  chython is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU Lesser General Public License for more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+from distutils.command.sdist import sdist
+from distutils.command.build import build
+from distutils.util import get_platform
+from importlib.util import find_spec
+from pathlib import Path
+from setuptools import setup, Extension, find_packages
+
+
+class _sdist(sdist):
+    def finalize_options(self):
+        super().finalize_options()
+        self.distribution.data_files.append(('lib', ['INCHI/libinchi.so',
+                                                     'INCHI/libinchi.dll', 'INCHI/libinchi.dynlib']))
+
+
+cmd_class = {'sdist': _sdist}
+
+
+if find_spec('wheel'):
+    from wheel.bdist_wheel import bdist_wheel
+
+    class _bdist_wheel(bdist_wheel):
+        def finalize_options(self):
+            super().finalize_options()
+            self.root_is_pure = False
+            platform = get_platform()
+            if platform == 'win-amd64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dll']))
+            elif platform == 'linux-x86_64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.so']))
+            elif platform == 'macosx-11-x86_64':
+                self.distribution.data_files.append(('lib', ['INCHI/libinchi.dynlib']))
+
+    cmd_class['bdist_wheel'] = _bdist_wheel
+
+
+if find_spec('cython'):
+    class _build(build):
+        def finalize_options(self):
+            super().finalize_options()
+            from Cython.Build import cythonize
+            self.distribution.ext_modules = cythonize(self.distribution.ext_modules, language_level=3)
+
+    cmd_class['build'] = _build
+
+
+setup(
+    name='chython',
+    version='1.8',
+    packages=find_packages(),
+    url='https://github.com/chython/chython',
+    license='LGPLv3',
+    author='Dr. Ramil Nugmanov',
+    author_email='nougmanoff@protonmail.com',
+    python_requires='>=3.8',
+    cmdclass=cmd_class,
+    ext_modules=[Extension('chython.containers._unpack', ['chython/containers/_unpack.pyx'],
+                           extra_compile_args=['-O3']),
+                 Extension('chython.algorithms._isomorphism', ['chython/algorithms/_isomorphism.pyx'],
+                           extra_compile_args=['-O3'])],
+    setup_requires=['wheel', 'cython'],
+    install_requires=['CachedMethods>=0.1.4,<0.2', 'lazy_object_proxy>=1.6', 'lxml>=4.1', 'py-mini-racer>=0.4.0',
+                      'numpy>=1.18', 'numba>=0.50'],
+    extras_require={'pytest': ['pytest']},
+    package_data={'chython.algorithms': ['_isomorphism.pyx'], 'chython.algorithms.calculate2d': ['clean2d.js'],
+                  'chython.containers': ['_unpack.pyx']},
+    data_files=[],
+    zip_safe=False,
+    long_description=(Path(__file__).parent / 'README.rst').read_text('utf8'),
+    classifiers=['Environment :: Plugins',
+                 'Intended Audience :: Science/Research',
+                 'License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)',
+                 'Operating System :: OS Independent',
+                 'Programming Language :: Python',
+                 'Programming Language :: Python :: 3 :: Only',
+                 'Programming Language :: Python :: 3.8',
+                 'Topic :: Scientific/Engineering',
+                 'Topic :: Scientific/Engineering :: Chemistry',
+                 'Topic :: Scientific/Engineering :: Information Analysis',
+                 'Topic :: Software Development',
+                 'Topic :: Software Development :: Libraries',
+                 'Topic :: Software Development :: Libraries :: Python Modules'],
+    command_options={'build_sphinx': {'source_dir': ('setup.py', 'doc'),
+                                      'build_dir':  ('setup.py', 'build/doc'),
+                                      'all_files': ('setup.py', True)}}
+)
```

