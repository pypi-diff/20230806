# Comparing `tmp/Omnicon_DDSDocGen-2.2.1-2-py3-none-any.whl.zip` & `tmp/Omnicon_DDSDocGen-3.0.1-3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,26 @@
-Zip file size: 51179 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat     2039 b- defN 23-Mar-08 19:39 Omnicon_DDSDocGen/DocGenInterface.py
--rw-rw-rw-  2.0 fat    35135 b- defN 23-Jun-20 19:19 Omnicon_DDSDocGen/DocGenLogic.py
--rw-rw-rw-  2.0 fat    10756 b- defN 23-Mar-10 19:10 Omnicon_DDSDocGen/DocxGen.py
--rw-rw-rw-  2.0 fat      884 b- defN 23-Mar-08 19:45 Omnicon_DDSDocGen/ErrorListHandler.py
--rw-rw-rw-  2.0 fat    12992 b- defN 23-Mar-08 19:45 Omnicon_DDSDocGen/LatexGen.py
--rw-rw-rw-  2.0 fat     3707 b- defN 23-Jun-16 14:03 Omnicon_DDSDocGen/Logger.py
--rw-rw-rw-  2.0 fat     3628 b- defN 23-Jun-20 18:45 Omnicon_DDSDocGen/Omnicon_DDSDocGen.py
--rw-rw-rw-  2.0 fat     1581 b- defN 23-Mar-14 12:44 Omnicon_DDSDocGen/PdfGen.py
--rw-rw-rw-  2.0 fat    38422 b- defN 23-Mar-08 19:45 Omnicon_DDSDocGen/SingleChapterGenerator.py
--rw-rw-rw-  2.0 fat    21970 b- defN 23-Mar-13 18:50 Omnicon_DDSDocGen/Template.docx
--rw-rw-rw-  2.0 fat      636 b- defN 23-Mar-08 19:39 Omnicon_DDSDocGen/Utils.py
--rw-rw-rw-  2.0 fat      574 b- defN 23-Jun-20 12:25 Omnicon_DDSDocGen/__init__.py
--rw-rw-rw-  2.0 fat     7437 b- defN 23-Jun-20 19:20 Omnicon_DDSDocGen-2.2.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-20 19:20 Omnicon_DDSDocGen-2.2.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       18 b- defN 23-Jun-20 19:20 Omnicon_DDSDocGen-2.2.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1407 b- defN 23-Jun-20 19:20 Omnicon_DDSDocGen-2.2.1.dist-info/RECORD
-16 files, 141278 bytes uncompressed, 48839 bytes compressed:  65.4%
+Zip file size: 79638 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat    24884 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/ComparisonModule.py
+-rw-rw-rw-  2.0 fat    32791 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/DocCompareLogic.py
+-rw-rw-rw-  2.0 fat     2820 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/DocGenInterface.py
+-rw-rw-rw-  2.0 fat    36214 b- defN 23-Aug-06 07:54 Omnicon_DDSDocGen/DocGenLogic.py
+-rw-rw-rw-  2.0 fat    10861 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/DocumentHandler.py
+-rw-rw-rw-  2.0 fat    21497 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/DocxGen.py
+-rw-rw-rw-  2.0 fat      884 b- defN 23-Jul-24 16:43 Omnicon_DDSDocGen/ErrorListHandler.py
+-rw-rw-rw-  2.0 fat    11500 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/GeneralFunctions.py
+-rw-rw-rw-  2.0 fat    12992 b- defN 23-Jul-24 16:43 Omnicon_DDSDocGen/LatexGen.py
+-rw-rw-rw-  2.0 fat     4473 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/Logger.py
+-rw-rw-rw-  2.0 fat     2420 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/OmniconEngineHandler.py
+-rw-rw-rw-  2.0 fat     9370 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/Omnicon_DDSDocGen.py
+-rw-rw-rw-  2.0 fat     3236 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/PdfGen.py
+-rw-rw-rw-  2.0 fat      819 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/SharedEnums.py
+-rw-rw-rw-  2.0 fat    41882 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/SingleChapterGenerator.py
+-rw-rw-rw-  2.0 fat    23764 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/Template.docx
+-rw-rw-rw-  2.0 fat      636 b- defN 23-Jul-24 16:43 Omnicon_DDSDocGen/Utils.py
+-rw-rw-rw-  2.0 fat      807 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/__init__.py
+-rw-rw-rw-  2.0 fat     4164 b- defN 23-Aug-06 07:48 Omnicon_DDSDocGen/comp.py
+-rw-rw-rw-  2.0 fat     1148 b- defN 23-Aug-06 08:17 Omnicon_DDSDocGen-3.0.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat    14839 b- defN 23-Aug-06 08:17 Omnicon_DDSDocGen-3.0.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Aug-06 08:17 Omnicon_DDSDocGen-3.0.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       18 b- defN 23-Aug-06 08:17 Omnicon_DDSDocGen-3.0.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2152 b- defN 23-Aug-06 08:17 Omnicon_DDSDocGen-3.0.1.dist-info/RECORD
+24 files, 264263 bytes uncompressed, 76120 bytes compressed:  71.2%
```

## zipnote {}

```diff
@@ -1,49 +1,73 @@
+Filename: Omnicon_DDSDocGen/ComparisonModule.py
+Comment: 
+
+Filename: Omnicon_DDSDocGen/DocCompareLogic.py
+Comment: 
+
 Filename: Omnicon_DDSDocGen/DocGenInterface.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/DocGenLogic.py
 Comment: 
 
+Filename: Omnicon_DDSDocGen/DocumentHandler.py
+Comment: 
+
 Filename: Omnicon_DDSDocGen/DocxGen.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/ErrorListHandler.py
 Comment: 
 
+Filename: Omnicon_DDSDocGen/GeneralFunctions.py
+Comment: 
+
 Filename: Omnicon_DDSDocGen/LatexGen.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/Logger.py
 Comment: 
 
+Filename: Omnicon_DDSDocGen/OmniconEngineHandler.py
+Comment: 
+
 Filename: Omnicon_DDSDocGen/Omnicon_DDSDocGen.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/PdfGen.py
 Comment: 
 
+Filename: Omnicon_DDSDocGen/SharedEnums.py
+Comment: 
+
 Filename: Omnicon_DDSDocGen/SingleChapterGenerator.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/Template.docx
 Comment: 
 
 Filename: Omnicon_DDSDocGen/Utils.py
 Comment: 
 
 Filename: Omnicon_DDSDocGen/__init__.py
 Comment: 
 
-Filename: Omnicon_DDSDocGen-2.2.1.dist-info/METADATA
+Filename: Omnicon_DDSDocGen/comp.py
+Comment: 
+
+Filename: Omnicon_DDSDocGen-3.0.1.dist-info/LICENSE
+Comment: 
+
+Filename: Omnicon_DDSDocGen-3.0.1.dist-info/METADATA
 Comment: 
 
-Filename: Omnicon_DDSDocGen-2.2.1.dist-info/WHEEL
+Filename: Omnicon_DDSDocGen-3.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: Omnicon_DDSDocGen-2.2.1.dist-info/top_level.txt
+Filename: Omnicon_DDSDocGen-3.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: Omnicon_DDSDocGen-2.2.1.dist-info/RECORD
+Filename: Omnicon_DDSDocGen-3.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Omnicon_DDSDocGen/DocGenInterface.py

```diff
@@ -5,18 +5,29 @@
 """
 Abstract Base class for defining mutual I/F to be implemented for Doc generation
 in various platforms for various formats
 """
 
 
 class DocGenInterface(ABC):
-    def __init__(self, title: str, version: str, time: str):
-        self.title = title
-        self.version = version
-        self.time = time
+    def __init__(self, title: str, new_version: str,  time: str, origin_version: str,
+                        origin_dds_types_files: list = None,
+                        new_dds_types_files: list = None,
+                        origin_dds_topics_types_mapping: str = "",
+                        new_dds_topics_types_mapping: str = ""):
+        """
+        This class allows creating one of two documents; an ICD (created by docGen) and a comparison document (created
+        by DocCompare). The difference is in the title page; the version in the ICD is added on its on, but in the
+        comparison document both versions are displayed in a table along with the files/folders used by each version
+
+        IMPORTANT:
+        WHEN origin_version COMES EMPTY , WE KNOW IT'S AN ICD, and new_version IS USED AS THE VERSION.
+        WHEN origin_version IS NOT EMPTY, WE KNOW IT'S A COMPARISON DOCUMENT.
+
+        """
 
     """
      This function creates a single chapter in the ICD. When a topic-to-types XML was was given by the user,
      a chapter is created for each topic. When  the user did not provide such XML file, a chapter is created for
      each non-nested type.
      :param topic: A string that contains the topic name. NOTE: When the user doesn't provide the topic-to-type XML.
                    This parameter will contain an empty string ('').
```

## Omnicon_DDSDocGen/DocGenLogic.py

```diff
@@ -1,16 +1,19 @@
 import inspect
+import math
 import shutil
 import tempfile
 import time
 import types
 from asyncio import sleep
 from datetime import datetime
 from typing import Dict, Any, List, Union, Tuple, Callable
 
+from .DocumentHandler import DocumentHandler
+from .comp import CompElement
 from . import Utils
 from Omnicon_GenericDDSEngine_Py import Omnicon_GenericDDSEngine_Py as Omnicon
 import os
 
 import xml.etree.ElementTree as ET
 
 from .ErrorListHandler import ErrorListHandler, LogLevel
@@ -68,32 +71,32 @@
     current_union_enum_vector: List[Any]
     level_of_Discriminator: int
     union_label_to_userComment_dictionary: Dict[str, str]
     name_of_previous_element: str
     is_all_types_ok: bool
     levels_skipped: List[int]
 
-    def __init__(self, logging_verbosity, progress_callback_function) -> None:
+    def __init__(self, progress_callback_function) -> None:
         # :param logging_verbosity: The requested level of logging. Could be either 'CRITICAL','ERROR','WARNING',
         #                         'INFO' or 'DEBUG'. NOTE: This parameter is optional; Default is 'INFO'.
 
         self.check_progress_callback_function_signature(progress_callback_function)
         self.update_external_progress_callback_function = progress_callback_function
 
         self.single_chapter_generator = None
 
-        self.logger = Logger.init_logger(__name__, logging_verbosity)
+        self.logger = Logger.add_logger(__name__)
 
         self.check_artifacts_integrity()
 
-        self.header_titles = ("Hierarchy", "Field", "Type", "Description/Metadata")
+        self.table_header_titles = ("Hierarchy", "Field", "Type", "Description/Metadata")
         # Create an automatic dictionary to link between indexes and column-titles
         self.titles_to_indexes = {}
         index = 0
-        for title in self.header_titles:
+        for title in self.table_header_titles:
             self.titles_to_indexes.update({title: index})
             index += 1
 
         self.basic_types = [
             "ENUMERATION", "BOOLEAN", "UINT_8", "INT_16", "UINT_16", "INT_32", "UINT_32", "INT_64", "UINT_64",
             "FLOAT_32", "FLOAT_64", "FLOAT_128", "CHAR_8", "CHAR_16", "CHAR_32"]
 
@@ -201,20 +204,22 @@
         # A flag that holds TRUE (when at least one chapter (type) was written. False when no chapter was written):
         is_at_least_one_type_ok: bool = False
         # Run the introspection for each data type:
         iteration_number: int = 1
         num_of_chapters: int = len(DDSTopicToTypeXMLMapping.keys())
         self.calculate_total_work_for_progress_bar(num_of_chapters)
 
+        self.structured_doc_data = {}
+
         for topic, DDS_type in DDSTopicToTypeXMLMapping.items():
-            self.update_progress_bar(iteration_number, DDS_type)
+            self.update_progress_bar_parse(iteration_number, DDS_type)
             iteration_number += 1
             # Generate a new chapter for that topic / type:
             try:
-                self.single_chapter_generator.generate_single_chapter(topic, DDS_type)
+                self.structured_doc_data[topic] = self.single_chapter_generator.generate_single_chapter(topic, DDS_type)
             except Exception as e:
                 self.logger.error(Exception, e)
                 # Signal that there is an issue with one of the types.
                 error_message: str = 'Failed to parse topic' + topic + ' . Error : ' + str(e)
                 self.logger.error(error_message)
                 ErrorListHandler.add_entry(LogLevel.ERROR, error_message)
                 self.is_all_types_ok = False
@@ -241,56 +246,48 @@
     def calculate_total_work_for_progress_bar(self, num_of_chapters):
         """
         This function determines the numbers that would be used to calculate the progress (for the progress bar)
         :param num_of_chapters: The total number of chapters from the given XML
         :return:
         """
         self.num_of_chapters = num_of_chapters
-        self.work_per_format = num_of_chapters +  int(num_of_chapters / 5)
-        self.total_steps = self.total_num_of_formats * self.work_per_format
+        steps_for_parsing = self.num_of_chapters
+        steps_for_writing = self.total_num_of_formats * num_of_chapters
+        steps_for_saving = self.total_num_of_formats
 
-    def update_progress_bar(self, iteration_number: int, DDS_type: str):
-        """
-        This function updates the progress bar by calling the function provided by the user, taking into
-        consideration the total num of  formats required by the user, the current iteration within the format currently
-         under work, and adding 10% to the total work required for file saving overhead.
-        :param iteration_number: The iteration number - where are we in terms of progress
-        :param DDS_type: A string that says which DDS type is parsed now
-        :return: None
-        """
+        self.total_steps = steps_for_parsing + steps_for_writing +steps_for_saving
+
+    def update_progress_bar(self, current_step: int, info: str):
         if self.update_external_progress_callback_function is not None:
             if self.is_progress_bar_func_ok:
-                current_step = iteration_number + (self.work_per_format * (self.current_format_num -1))
-                info = f"{ErrorListHandler.get_current_module().lower()}: Parsing {DDS_type}"
                 try:
                     self.update_external_progress_callback_function(self.total_steps, current_step, info)
                 except Exception:
                     self.is_progress_bar_func_ok = False
                     warning_text = f"There seems to be a problem with the provided progress bar callback function. " \
                                    f"Please refer to README.md for the required progress bar function."
                     ErrorListHandler.add_entry(LogLevel.WARNING, warning_text)
 
-    def update_progress_save(self):
-        """
-        This function updates the progress bar by calling the function provided by the user, letting him know now we
-        are saving a file and that might take a while.
-        :return: None
-        """
-        current_step = (self.current_format_num - 1) * self.work_per_format + self.num_of_chapters
-        info = f"{ErrorListHandler.get_current_module().lower()}: Saving to disk. Might take a while..."
+    def update_progress_bar_parse(self, iteration_number: int, DDS_type: str):
+        current_step = iteration_number
+        info = f"{ErrorListHandler.get_current_module().lower()}: Parsing {DDS_type}"
+        self.update_progress_bar(current_step, info)
+
+    def update_progress_bar_write(self, iteration_number: int, DDS_type: str, progress_factor, is_save=False):
+        steps_for_parsing = self.num_of_chapters
+        # progress_factor tells us how many formats were previously written
+        steps_for_previous_writes = iteration_number + progress_factor * self.num_of_chapters
+
+        current_step = steps_for_parsing + steps_for_previous_writes
+        info = f"{ErrorListHandler.get_current_module().lower()}: {DDS_type}"
+        if is_save:
+            info = f"{ErrorListHandler.get_current_module().lower()}: Saving"
 
-        if self.update_external_progress_callback_function is not None:
-            if self.is_progress_bar_func_ok:
-                try:
-                    self.update_external_progress_callback_function(self.total_steps, current_step, info)
-                except Exception:
-                    self.is_progress_bar_func_ok = False
-                    warning_text = f"There seems to be a problem with the provided progress bar callback function. " \
-                                   f"Please refer to README.md for the required progress bar function."
-                    ErrorListHandler.add_entry(LogLevel.WARNING, warning_text)
+        self.latest_step = current_step
+        self.update_progress_bar(current_step, info)
 
     def update_progress_end(self):
         if self.update_external_progress_callback_function is not None:
             if self.is_progress_bar_func_ok:
                 try:
                     state_txt = f"DocGen operation is completed."
                     self.update_external_progress_callback_function(1, 1, state_txt)
@@ -320,21 +317,24 @@
             raise Exception("Error! Invalid DDS type files!")
         # A flag that holds TRUE (when at least one chapter (type) was written. False when no chapter was written):
         is_at_least_one_type_ok: bool = False
         iteration_number: int = 1
         num_of_chapters: int = len(DDS_type_list)
         self.calculate_total_work_for_progress_bar(num_of_chapters)
 
+        self.structured_doc_data = {}
+
         for DDS_type in DDS_type_list:
-            self.update_progress_bar(iteration_number, DDS_type.fullName)
+            self.update_progress_bar_parse(iteration_number, DDS_type.fullName)
             iteration_number += 1
             if DDS_type.isNested is False:
                 # Add a chapter only when the type is not a nested one:
                 try:
-                    self.single_chapter_generator.generate_single_chapter("", DDS_type.fullName)
+                    self.structured_doc_data[DDS_type.fullName] = \
+                        self.single_chapter_generator.generate_single_chapter("", DDS_type.fullName)
                 except Exception as err:
                     # Signal that there is an issue with one of the types.
                     list_of_errors.append(err)
                     self.is_all_types_ok = False
                 else:
                     # When writing a chapter went well
                     is_at_least_one_type_ok = True
@@ -511,15 +511,15 @@
                       f"Please check you have writing permissions at requested target folder."
             self.logger.error(message, exc_info=True)
             raise Exception(message)
 
     def check_artifacts_integrity(self):
         self.logger.debug("check_artifacts_integrity")
         # print(get_hash_of_template())
-        if not get_hash_of_template() == '40a39dba625aee2b572b862c2cefad23':
+        if not get_hash_of_template() == '7d6d8c09b081bfe18fbae885f53967e5':
             self.logger.fatal("DocGen resource 'Template.Docx' was modified. Cannot start DocGen.")
             raise Exception("FATAL: DocGen resource 'Template.Docx' was modified. Cannot start DocGen.")
 
     def run_engine_and_generate_ICD(self,
                                     dds_types_files: list,
                                     dds_topics_types_mapping: str,
                                     output_file_name: str,
@@ -538,19 +538,31 @@
         now: datetime = datetime.now()
         date_time_string: str = now.strftime("%d/%m/%Y %H:%M:%S")
 
         # Two variables to know which status to give the user at the end.
         is_at_least_one_file_created = False
         is_at_least_one_file_error = False
 
+        self.single_chapter_generator = \
+            SingleChapterGenerator.SingleChapterGenerator(self.engine)
+        # See whether the ICD is to be based on topics or on types:
+        if dds_topics_types_mapping != "":
+            # When the user provided a topic-to-types xml, a topic-based ICD is to be created:
+            # (generate_topic_based_icd returns a list of all topics that could not be processed)
+            self.generate_topic_based_icd(
+                dds_topics_types_mapping, order_alphabetically)
+        else:
+            # When the user did NOT provide a topic-to-type XML:
+            self.generate_type_based_ICD(order_alphabetically)
+
         # Create an ICD of each requested type of output file
         for i, output_format in enumerate(output_formats):
             self.current_format_num = i + 1
             # Update the errors list handler which format is about to be worked on
-            ErrorListHandler.update_current_module_name(output_format)
+            ErrorListHandler.update_current_module_name(f"Writing {output_format}")
 
             # Create a temporary directory to save some temporary files
             with tempfile.TemporaryDirectory() as temp_folder:
                 try:
                     # Check if the requested file is open
                     if Utils.is_output_file_open(output_file_name, output_folder, output_format):
                         # When the output file is open:
@@ -563,78 +575,99 @@
 
                     # Switch 'output format' to lower case:
                     output_format = output_format.lower()
 
                     if output_format == 'docx':
                         # Case where the requested type is docx
                         self.doc_generator = DocxGen(title=title,
-                                                     version=version,
+                                                     new_version=version,
                                                      time=date_time_string)
                     elif output_format == 'pdf':
                         # Case where the requested type is pdf
                         self.doc_generator = PdfGen(title=title,
-                                                    version=version,
+                                                    new_version=version,
                                                     time=date_time_string)
 
                     # TODO the following comment is for use when we want to use the latex:
                     # elif output_format.lower() == 'tex':
                     #     self.doc_generator = LatexDocGen(title=title, version=version, time=date_time_string)
 
                     else:
                         # When an invalid type was requested, send warning and continue to the nextformat:
                         warning_message = f"Requested output format '{output_format}' is unsupported at this point."
                         self.logger.warning(warning_message)
                         ErrorListHandler.add_entry(LogLevel.ERROR, warning_message)
                         continue
 
-                    self.single_chapter_generator = SingleChapterGenerator.SingleChapterGenerator(self.engine,
-                                                                                                  self.doc_generator)
-                    # See whether the ICD is to be based on topics or on types:
-                    if dds_topics_types_mapping != "":
-                        # When the user provided a topic-to-types xml, a topic-based ICD is to be created:
-                        # (generate_topic_based_icd returns a list of all topics that could not be processed)
-                        self.generate_topic_based_icd(
-                            dds_topics_types_mapping, order_alphabetically)
-                    else:
-                        # When the user did NOT provide a topic-to-type XML:
-                        self.generate_type_based_ICD(order_alphabetically)
-
-                    # update the progress bar and the state (format_save phase)
-                    self.update_progress_save()
-                    # Finalize and save doc
-                    self.doc_generator.finalize_doc()
-                    self.doc_generator.generate_doc(output_file_name, temp_folder)
-                    self.save_file_to_requested_folder(output_file_name, output_folder, temp_folder, output_format)
+                    # self.create_doc_from_structured_doc_data()
+                    doc_handler = DocumentHandler(
+                        document=self.doc_generator,
+                        table_header_titles=self.table_header_titles,
+                        update_progress_bar=self.update_progress_bar_write)
+
+                    doc_handler.create_ICD_from_structured_doc_data(
+                        structured_doc_data=self.structured_doc_data,
+                        output_file_name=output_file_name,
+                        output_folder=output_folder,
+                        temp_folder=temp_folder,
+                        output_format=output_format,
+                        progress_factor=i)
+
+                    # # Finalize and save doc
+                    # self.doc_generator.finalize_doc()
+                    # self.doc_generator.generate_doc(output_file_name, temp_folder)
+                    # self.save_file_to_requested_folder(output_file_name, output_folder, temp_folder, output_format)
 
                     is_at_least_one_file_created = True
 
                 except Exception as err:
                     ErrorListHandler.add_entry(LogLevel.ERROR, str(err))
                     self.logger.error(str(err), exc_info=True)
 
         self.shutdown_engine()
+        self.structured_doc_data.clear()
         self.update_progress_end()
         time.sleep(0.5)
 
         ErrorListHandler.update_current_module_name("general")
         if is_at_least_one_file_created == False:
             warning_message = "There was an issue creating the files. Please refer to the log for more information."
             self.logger.error(warning_message)
-            # ErrorListHandler.add_entry(LogLevel.ERROR, warning_message)
+            ErrorListHandler.add_entry(LogLevel.ERROR, warning_message)
 
             raise Exception(warning_message)
 
         elif is_at_least_one_file_error:
             msg = "There was an issue with some of the requested files. " \
                   "Please refer to the log for more information."
             self.logger.warning(msg)
             ErrorListHandler.add_entry(LogLevel.WARNING, msg)
 
             # Clear the temporary directory
 
+    def reconstruct_chapter_header_from_structured_doc_data(self, chapter_name: str, root_element: CompElement):
+        type_name = root_element.field_name
+        element = root_element.introspection_element
+        type_kind_name = root_element.type_kind_name
+        topic_level_comment = root_element.user_comment
+        self.current_table = \
+            self.single_chapter_generator.create_new_chapter_with_table(
+                chapter_name, type_name, element, topic_level_comment)
+
+    def recursive_doc_reconstruction(self, element: CompElement):
+        # Finally - add the extra row to the document
+
+        for son_element in element.sons_list:
+            row_data_list = son_element.retrieve_row_data_list()
+            self.doc_generator.add_table_row(self.current_table, row_data_list)
+            self.recursive_doc_reconstruction(son_element)
+    def create_doc_from_structured_doc_data(self):
+        for chapter_name, root_element in self.structured_doc_data.items():
+            self.reconstruct_chapter_header_from_structured_doc_data(chapter_name, root_element)
+            self.recursive_doc_reconstruction(root_element)
     """
     ############################################   MAIN   ############################################
     """
 
     def run_doc_gen(self,
                           dds_types_files: list,
                           dds_topics_types_mapping: str = "",
@@ -686,13 +719,13 @@
                                             order_alphabetically,
                                             output_folder,
                                             output_formats)
 
             is_document_generated = True
 
         except Exception as err:
-            self.logger.error(err, exc_info=True)
+            # self.logger.error(err, exc_info=True)
             ErrorListHandler.add_entry(LogLevel.ERROR,err)
             self.shutdown_engine()
 
 
-        return (is_document_generated, ErrorListHandler.get_error_list())
+        return (is_document_generated, ErrorListHandler.get_error_list())
```

## Omnicon_DDSDocGen/DocxGen.py

```diff
@@ -1,44 +1,88 @@
 import inspect
 import os
 import shutil
+from typing import List
 
 import docx
+from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_PARAGRAPH_ALIGNMENT
+from docx.oxml.ns import qn, nsdecls
+from docx.oxml import CT_R, OxmlElement, parse_xml
 import win32com.client
 from docx.enum.table import WD_TABLE_ALIGNMENT
+from docx.shared import RGBColor, Inches, Pt
 
-from .DocGenInterface import DocGenInterface
-from docx.oxml.ns import qn
-from docx.oxml import CT_R, OxmlElement
+from .SharedEnums import ChangeStatusEnum
+from . import DocGenInterface
 
 from . import Logger
 
 from docx.table import Table
 from docx.text.paragraph import Paragraph
 
 
-class DocxGen(DocGenInterface):
+class DocxGen(DocGenInterface.DocGenInterface):
 
-    def __init__(self, title: str, version: str, time: str):
-        super().__init__(title, version, time)
+    def __init__(self, title: str, new_version: str,  time: str, origin_version: str = "",
+                        origin_dds_types_files: list = None,
+                        new_dds_types_files: list = None,
+                        origin_dds_topics_types_mapping: str = "",
+                        new_dds_topics_types_mapping: str = "",
+                        is_compare_by_name: bool = False,
+                        is_ignore_id: bool = False,
+                        is_summary_report=False):
+        """
+        This class allows creating one of two documents; an ICD (created by docGen) and a comparison document (created
+        by DocCompare). The difference is in the title page; the version in the ICD is added on its on, but in the
+        comparison document both versions are displayed in a table along with the files/folders used by each version
+
+        IMPORTANT:
+        WHEN origin_version COMES EMPTY , WE KNOW IT'S AN ICD, and new_version IS USED AS THE VERSION.
+        WHEN origin_version IS NOT EMPTY, WE KNOW IT'S A COMPARISON DOCUMENT.
+
+        """
+        super().__init__(title=title,
+                         new_version=new_version,
+                         time=time,
+                         origin_version=origin_version,
+                         origin_dds_types_files=origin_dds_types_files,
+                         new_dds_types_files=new_dds_types_files,
+                         origin_dds_topics_types_mapping=origin_dds_topics_types_mapping,
+                         new_dds_topics_types_mapping=new_dds_topics_types_mapping)
         self.logger = Logger.add_logger(__name__)
 
+        self.approx_width = Inches(len('Hierarchy') * 0.09)  # approximating each of 12pt font chars to around 0.09 Inch
+
         # Create a new '.docx' file based on the styling info from the template
         self.document = None
         self.doc_template_path = DocxGen.get_doc_template_path()
         if not self.doc_template_path:
             self.logger.fatal("Template.docx wasn't found. Cannot create doc")
             raise Exception("Template.docx wasn't found. Cannot create doc")
         else:
             self.logger.debug("doc template path at " + self.doc_template_path)
             self.document = docx.Document(self.doc_template_path)
 
         # Clear the document
         self.document._body.clear_content()
-        self.add_doc_title_page()
+        self.add_doc_title_page(title=title,
+                         new_version=new_version,
+                         time=time,
+                         origin_version=origin_version,
+                         origin_dds_types_files=origin_dds_types_files,
+                         new_dds_types_files=new_dds_types_files,
+                         origin_dds_topics_types_mapping=origin_dds_topics_types_mapping,
+                         new_dds_topics_types_mapping=new_dds_topics_types_mapping,
+                         is_compare_by_name=is_compare_by_name,
+                         is_ignore_id=is_ignore_id)
+
+        if origin_version != "":
+            # When this is a comparison document, add the color legend table
+            self.add_color_legend_table()
+
         self.add_toc_page()
 
     @staticmethod
     def get_doc_template_path() -> str:
         doc_name = "Template.docx"
         local_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), doc_name)
         cwd_path = os.path.join(os.path.join(os.getcwd(), doc_name))
@@ -50,28 +94,146 @@
             # https://importlib-resources.readthedocs.io/en/latest/using.html
             from importlib_resources import files
             whl_path = files('').joinpath(doc_name)
             if whl_path.is_file():
                 return str(whl_path)
         return None
 
-    def add_doc_title_page(self):
+    @staticmethod
+    def prepare_type_files_text_for_versions_table(type_files_list: List[str]):
+        result = ""
+        for type_file in type_files_list:
+            result += type_file + "\n"
+
+        if result.endswith("\n"):
+            result = result[:-1]
+
+        return result
+
+    def add_version_info(self, origin_or_new_text: str, version: str, dds_types_files: list, dds_topic_file: str):
+
+        paragraph = self.document.add_paragraph(f'{origin_or_new_text} - {version}', style='Version_style')
+
+        paragraph = self.document.add_paragraph('DDS Type Files', style='List Paragraph')
+        paragraph.paragraph_format.left_indent = Inches(0.5)
+
+        # Add sub-bullets
+        for sub_item in dds_types_files:
+            sub_p = self.document.add_paragraph(f'{sub_item}', style='empty_bullet_2')
+            sub_p.paragraph_format.left_indent = Inches(1)
+
+        paragraph = self.document.add_paragraph(f'DDS Topic File: {dds_topic_file}', style='List Paragraph')
+        paragraph.paragraph_format.left_indent = Inches(0.5)
+
+    def add_color_legend_table(self):
+        # Add a page break
+        self.document.add_page_break()
+
+        # Add a few blank lines to push the table down
+        for _ in range(5):  # adjust this number as needed
+            self.document.add_paragraph()
+
+        # Add a table with 5 rows and 1 column with 'Table Grid' style for gridlines
+        table = self.document.add_table(rows=5, cols=1, style='Table Grid')
+
+        # Center the table horizontally
+        table.alignment = WD_TABLE_ALIGNMENT.CENTER
+
+        # Set the cell text for each row
+        texts = ['Color Legend', 'No background color means there is no change',
+                 'GREEN background means the field was ADDED',
+                 'YELLOW background means field was MODIFIED',
+                 'RED background means field was DELETED']
+
+        # Set cell width
+        for row in table.rows:
+            for cell in row.cells:
+                cell.width = Inches(5.0)  # set the width
+
+        # Set cell colors
+        color_mapping = [None, ChangeStatusEnum.NO_CHANGE, ChangeStatusEnum.ADDED,
+                         ChangeStatusEnum.CHANGED, ChangeStatusEnum.DELETED]
+
+        for i in range(5):
+            paragraph = table.cell(i, 0).paragraphs[0]
+            run = paragraph.add_run(texts[i])
+            run.font.size = Pt(14)  # set font size to 14
+            paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  # center text horizontally
+            # Set background color if color_mapping is not None
+            if color_mapping[i] is not None:
+                color_xml = ChangeStatusEnum.get_background_color(color_mapping[i])
+                if color_xml is not None:
+                    paragraph._p.get_or_add_pPr().append(color_xml)
+
+    def add_doc_title_page(self, title: str, new_version: str,  time: str, origin_version: str,
+                        origin_dds_types_files: list = None,
+                        new_dds_types_files: list = None,
+                        origin_dds_topics_types_mapping: str = "",
+                        new_dds_topics_types_mapping: str = "",
+                        is_compare_by_name: bool = False,
+                        is_ignore_id: bool = False,
+                        is_summary_report=False):
         """
         This function adds a title page, with creation time, including header & footer,
         to be appended as a preamble section.
+        This function  has two types of title page: one for an ICD (created by docGen) and one for a comparison document
+        (created by DocCompare). The difference is that the version in the ICD is added on its own, but in the
+        comparison document both versions are displayed in a table along with the files/folders used by each version
+
+        IMPORTANT:
+        WHEN origin_version COMES EMPTY , WE KNOW IT'S AN ICD, and new_version IS USED AS THE VERSION.
+        WHEN origin_version IS NOT EMPTY, WE KNOW IT'S A COMPARISON DOCUMENT.
+
         """
         self.logger.debug(self.add_doc_title_page.__name__)
+
         # Add the title:
-        self.document.add_heading(self.title, 0)
+        self.document.add_heading(title, 0)
+        if origin_version == "":
+            # When this is an ICD - add the versions. (if it's not, the versions will be added below the creation time)
+            par: Paragraph = self.document.add_paragraph('Version ' + origin_version)
+            par.style = self.document.styles['version']
 
-        par: Paragraph = self.document.add_paragraph('Version ' + self.version)
-        par.style = self.document.styles['version']
-        par: Paragraph = self.document.add_paragraph('Generated on ' + self.time)
+        par: Paragraph = self.document.add_paragraph('Generated on ' + time)
         par.style = self.document.styles['Subtitle']
 
+        if origin_version != "":
+            # When this is A COMPARISON DOCUMENT, add report type and compasison method:
+
+            report_type = "Complete"
+            if not is_summary_report:
+                report_type = "Summary"
+            # create an empty paragraph with no style
+            par: Paragraph = self.document.add_paragraph()
+            # add the first part of the text with the desired style
+            par.add_run('Document Type', style='bold_underline_14')
+            # add the rest of the text with no style
+            run  = par.add_run(f': {report_type} Report')
+            run.font.size = Pt(14)
+
+            # Tell the user if we are comparing by id or by name (and if we're ignoring the ID)
+            comparison_type = "ID"
+            if not is_compare_by_name:
+                comparison_type = "Name"
+            ignore_id_text = ""
+            if is_ignore_id and is_compare_by_name:
+                ignore_id_text = " (Ignoring IDs)"
+            # create an empty paragraph with no style
+            par: Paragraph = self.document.add_paragraph()
+            # add the first part of the text with the desired style
+            par.add_run('Comparison Type', style='bold_underline_14')
+            # add the rest of the text with no style
+            run  = par.add_run(f': {comparison_type} base{ignore_id_text}')
+            run.font.size = Pt(14)
+
+        # Add version info
+        if origin_version != "":
+            self.add_version_info("Origin", origin_version, origin_dds_types_files, origin_dds_topics_types_mapping)
+            self.add_version_info("New", new_version, new_dds_types_files, new_dds_topics_types_mapping)
+
     def add_toc_page(self):
         """
         This function adds a table of contents with hyperlink.
         """
         self.logger.debug(self.add_toc_page.__name__)
         self.add_new_page()
         # https://stackoverflow.com/questions/18595864/python-create-a-table-of-contents-with-python-docx-lxml
@@ -94,39 +256,60 @@
 
         r_element = run._r
         r_element.append(fldChar)
         r_element.append(instrText)
         r_element.append(fldChar2)
         r_element.append(fldChar4)
 
-    def add_chapter(self, section_title, sub_section_title=""):
+    def add_chapter(self, section_title, parent_change_status=ChangeStatusEnum.NO_CHANGE, level=1):
         """
         This function adds a new chapter, on a new page.
         :param section_title: section name.
-        :param sub_section_title: sub section name.
+        :param parent_change_status: The status of changes made to the parent item.
         """
         self.logger.debug(self.add_chapter.__name__)
-        self.document.add_heading(section_title, 1)
 
-        if sub_section_title != "":
-            sub_section_par = self.document.add_paragraph()
-            sub_section_par.add_run('Type').underline = True
-            sub_section_par.add_run(": " + sub_section_title)
+        # Since the only change in chapter level could be in the description, do not allow the heading get yellow bg
+        if parent_change_status == ChangeStatusEnum.CHANGED or level == 2:
+            parent_change_status = ChangeStatusEnum.NO_CHANGE
+
+        # Add section heading with background color according to the change status
+        color_xml = ChangeStatusEnum.get_background_color(parent_change_status)
+        heading = self.document.add_heading(level=level)
+        run = heading.add_run(section_title)
+
+        if color_xml is not None:
+            heading._p.get_or_add_pPr().append(color_xml)
+
+    def add_type_to_chapter(self, dds_type, parent_change_status=ChangeStatusEnum.NO_CHANGE):
+        # Since the only change in chapter level could be in the description, do not allow the heading get yellow bg
+        if parent_change_status == ChangeStatusEnum.CHANGED:
+            parent_change_status = ChangeStatusEnum.NO_CHANGE
+
+        color_xml = ChangeStatusEnum.get_background_color(parent_change_status)
+        sub_section_par = self.document.add_paragraph()
+        sub_section_par.add_run('Type').underline = True
+        sub_section_par.add_run(": " + dds_type)
+        if color_xml is not None:
+            sub_section_par._p.get_or_add_pPr().append(color_xml)
 
     @staticmethod
     def set_repeat_table_header(row):
         """ set repeat table row on every new page
         """
         tr = row._tr
         trPr = tr.get_or_add_trPr()
         tblHeader = OxmlElement('w:tblHeader')
         tblHeader.set(qn('w:val'), "true")
         trPr.append(tblHeader)
         return row
 
+    def add_paragraph(self, paragraph_text):
+        paragraph = self.document.add_paragraph(paragraph_text, style='Version_style')
+
     def add_table_header(self, listOfTitles, bLongHeader=True, color="grey"):
         """
         This function creates a table, and adds a table header with the titles.
 
         :param listOfTitles: the titles of the columns at the table header.
         :param bLongHeader: not in use, inherited from base class. May be needed in
                             other implementation environments. Defaults to True.
@@ -138,28 +321,37 @@
         table.style = self.document.styles['Table Grid']
         table.alignment = WD_TABLE_ALIGNMENT.LEFT
 
         table_header_cells = table.rows[0].cells
         for i, title in enumerate(listOfTitles):
             table_header_cells[i].text = title
             table_header_cells[i].paragraphs[0].runs[0].font.bold = True
+            if i == 0:  # If this is the first cell
+                table_header_cells[i].width = self.approx_width  # Set the width
         DocxGen.set_repeat_table_header(table.rows[0])
+
         return table
 
-    def add_table_row(self, theTable, cells_text, align='c'):  # align=centered
+    def add_table_row(self, theTable, cells_text, align='c', change_status=ChangeStatusEnum.NO_CHANGE):  # align=centered
         """
         This function adds a row for a table.
         :param theTable: the table object.
         :param cells_text: the data for the columns - as text.
         :param align:  alignment - centered (not in use here)
+        :param bg_color: the background color for the row. Options are: ChangeStatusEnum.NO_CHANGE, ChangeStatusEnum.DELETED, ChangeStatusEnum.ADDED, ChangeStatusEnum.CHANGED, ChangeStatusEnum.TBD
         """
         self.logger.debug(self.add_table_row.__name__)
         row_cells = theTable.add_row().cells
         for i, cell_content in enumerate(cells_text):
             row_cells[i].text += cell_content
+            color_xml = ChangeStatusEnum.get_background_color(change_status)
+            if color_xml is not None:
+                row_cells[i]._tc.get_or_add_tcPr().append(color_xml)
+            if i == 0:  # If this is the first cell
+                row_cells[i].width = self.approx_width  # Set the width
 
         if cells_text[0] == "":
             # When this element is on the basic level of the type, write the name in bold.
             row_cells[1].paragraphs[0].runs[0].font.bold = True
 
     def add_new_page(self):
         """
@@ -171,22 +363,31 @@
     def add_section(self):
         """
         This function adds a new section. Not implemented.
         """
         self.logger.debug(self.add_section.__name__)
         pass
 
-    def add_description(self, descr):
+    def add_description(self, descr, parent_change_status=ChangeStatusEnum.NO_CHANGE):
         """
-        This function adds a description (within a new section/subsection)..
+        This function adds a description (within a new section/subsection).
+        :param descr: The description text to add.
+        :param parent_change_status: The status of changes made to the parent item.
         """
         self.logger.debug(self.add_description.__name__)
+
+        # Add description with background color according to the change status
+        color_xml = ChangeStatusEnum.get_background_color(parent_change_status)
         description = self.document.add_paragraph()
-        description.add_run('Description').underline = True
-        description.add_run(": " + descr)
+        run = description.add_run('Description')
+        run.underline = True
+        run = description.add_run(": " + descr)
+        if color_xml is not None:
+            description._p.get_or_add_pPr().append(color_xml)
+
         self.add_new_line()
 
     def add_new_line(self):
         """
         This function adds a new line.
         """
         self.logger.debug(self.add_new_line.__name__)
```

## Omnicon_DDSDocGen/Logger.py

```diff
@@ -7,15 +7,15 @@
 # from logging.handlers import TimedRotatingFileHandler
 #
 # log_file_name = f"myapp-{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.log"
 
 # fh = logging.FileHandler('DocGen' + '.log', mode='w')
 
 
-class LoggerWriter:
+class LoggerFakeWriter:
     """
     Fake file-like stream object that redirects writes to a logger instance.
     due to docx2pdf https://stackoverflow.com/questions/74787311/error-with-docx2pdf-after-compiling-using-pyinstaller
     """
     def __init__(self, logfct):
         self.logfct = logfct
         self.buf = []
@@ -29,14 +29,40 @@
         # else:
         #     self.buf.append(msg)
 
     def flush(self):
         pass
 
 
+class LoggerWriter:
+    """
+    Fake file-like stream object that redirects writes to a logger instance.
+    due to docx2pdf https://stackoverflow.com/questions/74787311/error-with-docx2pdf-after-compiling-using-pyinstaller
+    """
+    def __init__(self, logfct):
+        self.logfct = logfct
+        self.buf = []
+
+    def write(self, msg):
+        # print(msg)
+        red_start = "\033[91m"
+        reset = "\033[0m"
+        print(f"{red_start}{msg}{reset}", file=sys.stdout)
+
+        # pass
+        # if msg.endswith('\n'):
+        #     self.buf.append(msg.rstrip('\n'))
+        #     self.logfct(''.join(self.buf))
+        #     self.buf = []
+        # else:
+        #     self.buf.append(msg)
+
+    def flush(self):
+        pass
+
 
 def parse_logging_level(verbosity: str):
     # Check if input is a string:
     if type(verbosity) != str:
         # When not a string, print warning message and choose the default INFO
         error_message: str = f"[WARNING]: Invalid input! Parameter <logging_verbosity> '{verbosity}' is: " \
                              f"{type(verbosity)}. Should be of class 'string'.\nUsing the default verbosity 'INFO'."
```

## Omnicon_DDSDocGen/Omnicon_DDSDocGen.py

```diff
@@ -1,28 +1,33 @@
 from typing import Any, Callable, List
+
+from . import DocCompareLogic, Logger
 from . import DocGenLogic
 
 
 class DDSDocGen():
     def __init__(self, logging_verbosity: str = "WARNING",
                           progress_callback_function: Callable[[], Any] = None) -> None:
         """
         :param logging_verbosity: The requested level of logging. Could be either 'CRITICAL','ERROR','WARNING',
                                 'INFO' or 'DEBUG'. NOTE: This parameter is optional; Default is 'INFO'.
         """
+        self.logger = Logger.init_logger(__name__, logging_verbosity)
         progress_function = progress_callback_function
         if progress_callback_function is None:
            progress_function = self.__my_progress_callback_function
 
-        self.__document_generator = DocGenLogic.DocumentGenerator(logging_verbosity, progress_function)
+        self.__document_generator = DocGenLogic.DocumentGenerator(progress_function)
+        self.__document_comparator = DocCompareLogic.DocCompareLogic(progress_function)
 
     @staticmethod
     def __my_progress_callback_function(total_steps: int, current_step: int, info: str):
         percentage = (current_step / total_steps) * 100
-        print(f"{int(percentage)}% complete, {info}")
+        percentage_to_print = "{:.1f}".format(percentage)
+        print(f"{percentage_to_print}% complete, {info}")
 
 
     def generate_document(self,
                           dds_types_files: list,
                           dds_topics_types_mapping: str = "",
                           output_file_name: str = "ICD",
                           title: str = "ICD",
@@ -60,7 +65,93 @@
             output_file_name=output_file_name,
             title=title,
             version=version,
             order_alphabetically=order_alphabetically,
             output_folder=output_folder,
             output_formats=output_formats
         )
+
+    def determine_comparison_method(self, comparison_method: str)-> bool:
+        # Returning True if comparing by name, False if comapring by id
+        if comparison_method.lower() == "id":
+            return False
+        elif comparison_method.lower() == "name":
+            return True
+
+        else:
+            raise Exception("Comparison method parameter is invalid. Please use either 'name' or 'id'")
+
+    def determine_report_type(self, report_type: str)-> bool:
+        # Returning True if comparing by name, False if comapring by id
+        if report_type.lower() == "summary":
+            return True
+        elif report_type.lower() == "complete" or report_type.lower() == "full":
+            return True
+
+        else:
+            raise Exception("Report type parameter is invalid. Please use either 'complete' or 'summary'")
+
+    def generate_comparison_document(self,
+                          origin_dds_types_files: list,
+                          new_dds_types_files: list,
+                          origin_dds_topics_types_mapping: str = "",
+                          new_dds_topics_types_mapping: str = "",
+                          output_file_name: str = "Comparison",
+                          title: str = "Comparison",
+                          origin_version: str = "v1",
+                          new_version: str = "v2",
+                          order_alphabetically: bool = True,
+                          output_folder: str = "",
+                          output_formats=None,
+                          ignore_id: bool = False,
+                          comparison_method: str = "name",
+                          document_type: str = "complete") -> (bool, List[str]):
+        """
+        Start the doc comparison process.
+        :param origin_dds_types_files: A list of DDS XML type files or folders of the original date model.
+        :param new_dds_types_files: A list of DDS XML type files or folders of the revised data model.
+        :param origin_dds_topics_types_mapping: (string) An XML file that contains a DDS topic to type mapping of the
+                                                original date model. NOTE: This parameter is optional; In case mapping
+                                                is not provided, a type-based comparison will be generated.
+        :param new_dds_topics_types_mapping: (string) An XML file that contains a DDS topic to type mapping of the
+                                              revised date model. NOTE: This parameter is optional; In case mapping
+                                              is not provided, a type-based comparison will be generated.
+        :param output_file_name: (string) The user's file name of choice. NOTE: This parameter is optional.
+                                  Default: "ICD".
+        :param title: (string) The title/heading  of the document. This string will be added to the first page of the
+                               document. NOTE: This parameter is optional; Default is "ICD"
+        :param origin_version: The origin document's version number - This string will be added to a table at the top
+                        page of the comparison document.
+                        NOTE: This parameter is optional; Default is "v1".
+        :param new_version: The new document's version number - This string will be added to a table at the top
+                        page of the comparison document.
+                        NOTE: This parameter is optional; Default is "v2".
+        :param order_alphabetically: Whether to order to generated document topics/types alphabetically or according to
+                                    the loaded files order
+        :param output_folder: (string) The user's output folder of choice. NOTE: This parameter is optional;
+                              Default is current working directory.
+        :param output_formats: A list of desired output formats as strings. for example: ["docx", "pdf"]
+        :param ignore_id: (bool) determines if the ID is to be compared AT ALL.
+        :param comparison_method: (str) Either 'name' (for name based comparison) or 'id' (for id based comparison).
+        :param document_type: (str) Either 'complete' (for a full document which includes all the fields in topics that
+                                have changes in them) or 'summary' (for a report that show only the changes).
+
+
+        :return: tuple of (bool, list). bool: True upon success. list: list of errors that happened along the way
+        """
+        self.__document_comparator.is_ignore_id = ignore_id
+        self.__document_comparator.is_compare_by_name = self.determine_comparison_method(comparison_method)
+        self.__document_comparator.is_summary_report = self.determine_report_type(document_type)
+
+        return self.__document_comparator.run_doc_compare(
+            origin_dds_types_files=origin_dds_types_files,
+            new_dds_types_files=new_dds_types_files,
+            origin_dds_topics_types_mapping=origin_dds_topics_types_mapping,
+            new_dds_topics_types_mapping=new_dds_topics_types_mapping,
+            output_file_name=output_file_name,
+            title=title,
+            origin_version=origin_version,
+            new_version=new_version,
+            order_alphabetically=order_alphabetically,
+            output_folder=output_folder,
+            output_formats=output_formats
+        )
```

## Omnicon_DDSDocGen/PdfGen.py

```diff
@@ -1,24 +1,52 @@
 import os
 import sys
 import logging
 from . import Logger
 import docx2pdf
 # due to https://stackoverflow.com/questions/74787311/error-with-docx2pdf-after-compiling-using-pyinstaller
-logger = Logger.add_logger()
-sys.stderr = Logger.LoggerWriter(logger.error)
+# logger = Logger.add_logger("__name__")
+# sys.stderr = Logger.LoggerFakeWriter(logger.error)
+# sys.stderr = Logger.LoggerWriter(logger.error)
+
+
 from .DocxGen import DocxGen
 import pythoncom
 
 class PdfGen(DocxGen):
-    def __init__(self, title: str, version: str, time: str):
-        super().__init__(title, version, time)
+    def __init__(self, title: str, new_version: str,  time: str, origin_version: str = "",
+                        origin_dds_types_files: list = None,
+                        new_dds_types_files: list = None,
+                        origin_dds_topics_types_mapping: str = "",
+                        new_dds_topics_types_mapping: str = ""):
+        """
+        This class allows creating one of two documents; an ICD (created by docGen) and a comparison document (created
+        by DocCompare). The difference is in the title page; the version in the ICD is added on its on, but in the
+        comparison document both versions are displayed in a table along with the files/folders used by each version
+
+        IMPORTANT:
+        WHEN origin_version COMES EMPTY , WE KNOW IT'S AN ICD, and new_version IS USED AS THE VERSION.
+        WHEN origin_version IS NOT EMPTY, WE KNOW IT'S A COMPARISON DOCUMENT.
+
+        """
+        super().__init__(title=title,
+                         new_version=new_version,
+                         time=time,
+                         origin_version=origin_version,
+                         origin_dds_types_files=origin_dds_types_files,
+                         new_dds_types_files=new_dds_types_files,
+                         origin_dds_topics_types_mapping=origin_dds_topics_types_mapping,
+                         new_dds_topics_types_mapping=new_dds_topics_types_mapping)
         self.logger = Logger.add_logger(__name__)
 
     def generate_doc(self, output_file_name: str, temp_folder: str)->str:
+        # TODO if there is an issue while using at UI then revert the following 2 lines
+        logger = Logger.add_logger("__name__")
+        sys.stderr = Logger.LoggerFakeWriter(logger.error)
+
         self.logger.debug(self.generate_doc.__name__)
         # Create the docx using DocxGen
         super().generate_doc(output_file_name, temp_folder)
 
         temp_docx_file_name = f'{output_file_name}.docx'
         temp_docx_path = os.path.join(temp_folder, temp_docx_file_name)
         temp_pdf_file_name = f'{output_file_name}.pdf'
@@ -32,7 +60,10 @@
             docx2pdf.convert(temp_docx_path, temp_pdf_path, keep_active=True)
 
             self.logger.info(f"File saved successfully into '{temp_pdf_path}'")
 
         except Exception as err:
 
             self.logger.error(f"Could not save '{temp_pdf_path}'.", exc_info=True)
+
+        sys.stderr = Logger.LoggerWriter(logger.error)
+
```

## Omnicon_DDSDocGen/SingleChapterGenerator.py

```diff
@@ -1,27 +1,22 @@
-import enum
-import logging
-from typing import Dict, Any
 
-from . import Logger
+from typing import Dict, Any
 
+from Omnicon_GenericDDSEngine_Py import Element
 
-class ColumnNumbersEnum(enum.IntEnum):
-    HIERARCHY_COLUMN_NUM = 0
-    FIELD_COLUMN_NUM = 1
-    TYPE_COLUMN_NUM = 2
-    DESCRIPTION_COLUMN_NUM = 3
+from .comp import CompElement, ColumnNumbersEnum
+from . import Logger
 
 
 class SingleChapterGenerator:
-    def __init__(self, engine, document):
+    def __init__(self, engine):
         self.current_table = None
         self.logger = Logger.add_logger(__name__)
         self.engine = engine
-        self.document = document
+        # self.document = document
 
         self.header_titles = ("Hierarchy", "Field", "Type", "Description/Metadata")
 
         self.basic_types = [
             "ENUMERATION", "BOOLEAN", "UINT_8", "INT_16", "UINT_16", "INT_32", "UINT_32", "INT_64", "UINT_64",
             "FLOAT_32", "FLOAT_64", "FLOAT_128", "CHAR_8", "CHAR_16", "CHAR_32"]
 
@@ -98,15 +93,15 @@
 
     @staticmethod
     def remove_carriage_return_notation(user_comment_to_replace: str) -> str:
         """
         This function removes the carriage return ("\n") notation (if exist) from a string.
         """
         if user_comment_to_replace != "":
-           user_comment_to_replace = user_comment_to_replace.replace('\r','')
+            user_comment_to_replace = user_comment_to_replace.replace('\r', '')
 
         return user_comment_to_replace
 
     @staticmethod
     def append_xml_metadata(user_comment_to_replace: str, element, is_key_allowed: bool) -> str:
         """
         This function adds min, max, default and unit XML notations to the user comment
@@ -148,15 +143,15 @@
         Return: if "unbounded" length (2147483647) - returns "-1"; else return the actual length.
         """
         if length == 2147483647:
             return -1
         return length
 
     @staticmethod
-    def write_special_data_of_enumeration(element, row_data_list):
+    def write_special_data_of_enumeration(element: Element, row_data_list: list, comp_element: CompElement):
         """"
         This function Handles the Enumeration type elements and exports the appropriate data to the ICD document.
         :param element: The introspection element that represent the enum element.
         :Param element - The current element from the introspection
         :param row_data_list: the table row data that this function writes into
         :return: None
         """
@@ -176,20 +171,23 @@
             # Write the  new enum in a new line:
             lineDescription += f"\n{enumElement.name} = {str(enumElement.value)}"
             if enumElement.isDefault:
                 lineDescription += " : Default "
             if enumElement.userComment != "":
                 lineDescription += f" ({enumElement.userComment})"
 
+            comp_element.add_enum_element_to_list(
+                enumElement.name, enumElement.value, enumElement.userComment, enumElement.isDefault)
+
             i = i + 1
 
         row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] = lineDescription
 
     @staticmethod
-    def write_union_enumeration_of_discriminator(element, row_data_list):
+    def write_union_enumeration_of_discriminator(element, row_data_list, comp_element):
         """"
         This function writes all Enumeration options of union elements and exports the appropriate data to
         the ICD document.
         Parameter1: element - The current element from the introspection
         Parameter2: row_cells - The row of the table this function writes into.
         """
         # First see if a new line is in order:
@@ -215,27 +213,32 @@
                     union_enum_comments_dictionary[enum_member.value] = enum_member.userComment
 
             # Now write the information we just gathered into the table:
             for key, value in union_enum_dictionary.items():
 
                 row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] += f"\n{value} = {str(key)}"
 
+                comp_element.add_enum_element_to_list(value, key, union_enum_comments_dictionary[key], False)
+
                 if union_enum_comments_dictionary[key] != "":
                     row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] += \
                         f" ({union_enum_comments_dictionary[key]})"
         else:
             # When it is not an enum based union (when based on numbers)
             is_first_instance = True
 
             for item in element.unionMembersInfo:
+                # Add a nameless enum element (which means it is not an enum, just a number)
+                comp_element.add_enum_element_to_list("",item.label , "", False)
                 if is_first_instance is True:
                     is_first_instance = False
                     row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] += str(item.label)
                 else:
                     row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] += ", " + str(item.label)
+        comp_element.add_data_to_comp_element(row_data_list)
 
     def determine_topic_level_comment(self, element_list: list) -> str:
         """
         This function returns the only the topic's type comment. This operation is required when the topic's type
         inherits from other types, in which case the other type's comments override the topic's comment.
         :param element_list: list of elements that describe the introspection structure
         :return: A string.
@@ -255,30 +258,37 @@
         :param type_name: the type to introspect.
         :return:
         """
         self.logger.debug(self.generate_single_chapter.__name__)
         # Get the introspection product, a list of elements that hold information about every field  within a given type
         element_list: list = self.get_introspection_list(type_name)
 
+        root_element = CompElement()
+
         # Get the combined topic level comments:
         topic_level_comment = self.determine_topic_level_comment(element_list)
         # Go over the elements: ('enumerate' just puts the element_index of the iteration into i)
         for element_index, element in enumerate(element_list):
             if element.level == 1:
                 # When a chapter has not yet been created - create one
-                self.create_new_chapter_with_table(topic_name, type_name, element, topic_level_comment)
+                # self.create_new_chapter_with_table(topic_name, type_name, element, topic_level_comment)
+                root_element.field_name = type_name
+                root_element.introspection_element = element
+                root_element.type_kind_name = self.type_rename_dictionary[element.typeKindName]
+                root_element.user_comment = topic_level_comment
 
                 # Nothing to do really in the first level, which is the level that holds the type itself.
                 self.logger.debug(f"Passing level 1 of {element.name}")
 
             if element.level == 2:
                 # When this element is a direct son of the introspected type: see which type it is and act accordingly.
-                self.handle_element_types(element_index, element_list, element.level, is_key_allowed=True)
+                self.handle_element_types(element_index, element_list, element.level, is_key_allowed=True, father_comp_element=root_element)
 
         self.logger.info(f"Finished introspecting topic {topic_name} with type {type_name}")
+        return root_element
 
     def get_introspection_list(self, type_name: str) -> list:
         """
         This function does the actual introspection and returns the element list
         :param type_name: The type we want to introspect and inspect.
         :return: the introspection product: element list
         """
@@ -290,15 +300,16 @@
         if introspected_type is None:
             error_message: str = f"Could not find '{type_name}' in provided files!"
             self.logger.warning(error_message)
             raise Exception(error_message)
 
         return introspected_type.structure
 
-    def recursive_type_introspect(self, type_name: str, real_level: int, is_key_allowed: bool):
+    def recursive_type_introspect(
+            self, type_name: str, real_level: int, is_key_allowed: bool, father_comp_element: CompElement):
         """
         This function introspects a given type and goes over its elements ONLY AT THE SECOND LEVEL, which is the level
         of the type's 'sons'.
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
         maintains the true level trough out the recursive operation.
         :param type_name: The type we want to introspect and inspect.
         :param is_key_allowed: Specifies whether the elements at higher levels (directly above this one) have
@@ -317,15 +328,15 @@
             current_level = real_level + element.level
             if element.level == 1:
                 # Nothing to do really in the first level, which is the level that holds the type itself.
                 self.logger.debug(f"Passing level 1 of {element.name}")
 
             if element.level == 2:
                 # When this element is a direct son of the introspected type: see which type it is and act accordingly.
-                self.handle_element_types(element_index, element_list, current_level, is_key_allowed)
+                self.handle_element_types(element_index, element_list, current_level, is_key_allowed, father_comp_element)
 
     def create_new_chapter_with_table(self, topic: str, dds_type: str, element: Any, topic_level_comment: str) -> None:
         """
         This function adds a new heading (i.e. chapter) and a new table to the ICD.
         :param topic_level_comment: The comment to add to add above the table.
         :param topic: A string that contains the topic name. NOTE: When the user doesn't provide the topic-to-type XML.
                       This parameter will contain an empty string ('').
@@ -351,25 +362,26 @@
         self.document.add_description(topic_level_comment)
         #
         # if element.parentDataTypeName != "":
         #     self.document.add_new_line(self.modify_user_comment_to_icd_needs(element))
 
         # Create the table
         self.current_table = self.document.add_table_header(self.header_titles)
+        return self.current_table
 
     def create_row_data_list(self, element, real_level, is_key_allowed):
         self.logger.debug(self.create_row_data_list.__name__)
         hierarchy: str = self.generate_hierarchy_notation(real_level)
         field: str = element.name
         type_notation: str = self.generate_type_notation(element)
         description_and_metadata = self.modify_user_comment_to_icd_needs(element, is_key_allowed)
 
         return [hierarchy, field, type_notation, description_and_metadata]
 
-    def handle_element_types(self, element_index, element_list, real_level, is_key_allowed):
+    def handle_element_types(self, element_index, element_list, real_level, is_key_allowed, father_comp_element):
         """
         This function gets element list and an index (which gives a specific element, hence the 'handle element' part
         of this function's name) and adds takes action according to the element's type.
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
                             maintains the true level trough out the recursive operation.
         :param element_list: The introspection product, a list of elements that hold information about every field
                              within a given type.
@@ -384,51 +396,51 @@
         if element.name == 'discriminator' and len(element.unionMembersInfo) > 0:
             # When the element is a union discriminator, it' already in the table - so don't do a thing.
             return
 
         # See if we need to add an extra row that describes which union it is:
         if len(element.unionLabels) > 0:
             # When the current element is a part of a union - need to add the discriminator number row:
-            self.add_extra_row_for_union_option_element(element, real_level)
+            self.add_extra_row_for_union_option_element(element, real_level, father_comp_element)
 
         row_data_list = self.create_row_data_list(element, real_level, is_key_allowed)
         # Find out whether this element's descendants will be allowed to show the 'key' notation:
         is_key_allowed: bool = element.isKey
 
         # Then See if it's a number:
         if element.typeKindName in self.numerical_types:
-            self.handle_regular_primitive_element(element, row_data_list)
+            self.handle_regular_primitive_element(element, row_data_list, father_comp_element)
 
         # See if it's a char:
         elif element.typeKindName in self.char_types:
-            self.handle_regular_primitive_element(element, row_data_list)
+            self.handle_regular_primitive_element(element, row_data_list, father_comp_element)
 
         # See if it's a string:
         elif element.typeKindName in self.string_types:
-            self.handle_string_element(element, row_data_list)
+            self.handle_string_element(element, row_data_list, father_comp_element)
 
         # See if it's a bool:
         elif element.typeKindName == 'BOOLEAN':
-            self.handle_regular_primitive_element(element, row_data_list)
+            self.handle_regular_primitive_element(element, row_data_list, father_comp_element)
 
         # See if it's an enum:
         elif element.typeKindName == 'ENUMERATION':
-            self.handle_enum_element(element, row_data_list)
+            self.handle_enum_element(element, row_data_list, father_comp_element)
 
         # See if it's a char:
         elif element.typeKindName == 'STRUCTURE':
-            self.handle_struct_element(element, row_data_list, real_level, is_key_allowed)
+            self.handle_struct_element(element, row_data_list, real_level, is_key_allowed, father_comp_element)
 
         # See if it's an array:
         elif element.typeKindName == 'ARRAY' or element.typeKindName == 'SEQUENCE':
-            self.handle_collection_element(element_index, element_list, row_data_list, real_level, is_key_allowed)
+            self.handle_collection_element(element_index, element_list, row_data_list, real_level, is_key_allowed, father_comp_element)
         #
         # See if it's a union:
         elif element.typeKindName == 'UNION':
-            self.handle_union_element(element_index, element_list, row_data_list, real_level, is_key_allowed)
+            self.handle_union_element(element_index, element_list, row_data_list, real_level, is_key_allowed, father_comp_element)
 
         else:
             self.logger.debug(f"Unsorted: {element.name}")
 
     def modify_topic_level_comment_to_icd_needs(self, comment):
         """
         This function prepares the topic level comment for the ICD: replaces special chars and remove the comment
@@ -450,14 +462,15 @@
                                'key' notation in them.
         :return: A comment, ready to be added
         """
         self.logger.debug(self.modify_user_comment_to_icd_needs.__name__)
         user_comment: str = self.replace_special_xml_chars_in_user_comment(element.userComment)
         user_comment = self.remove_comment_notation(user_comment)
         user_comment = self.remove_carriage_return_notation(user_comment)
+        # TODO see if required
         user_comment = self.append_xml_metadata(user_comment, element, is_key_allowed)
         return user_comment.rstrip()
 
     def generate_type_notation(self, element):
         self.logger.debug(self.generate_type_notation.__name__)
         type_text: str
         if (element.typeKindName == "ARRAY") or (element.typeKindName == "SEQUENCE"):
@@ -473,50 +486,67 @@
         else:
             # Write into "Type" column (If the name is in the dictionary, use it. if not, use the original name):
             type_text = \
                 self.type_rename_dictionary.get(element.typeKindName, element.typeKindName)
 
         return type_text
 
-    def handle_regular_primitive_element(self, element, row_data_list):
+    def handle_regular_primitive_element(self, element, row_data_list, father_comp_element):
         """
         Adds a regular element row to the document
         :param row_data_list: the table row data that this function writes into
         :param element: The introspection element that represent the numerical element. This element holds a lot of
                         valuable information about the numerical element
         :return: None
         """
         self.logger.debug(f"Handling {element.name}")
-        self.document.add_table_row(self.current_table, row_data_list)
 
-    def handle_string_element(self, element, row_data_list):
+        new_son_comp_element = CompElement(element)
+        father_comp_element.sons_list.append(new_son_comp_element)
+        new_son_comp_element.add_data_to_comp_element(row_data_list)
+
+        # create_doc_from_structured_doc_data
+
+    def handle_string_element(self, element, row_data_list, father_comp_element):
         """
         Adds a string element to the table.
         :param row_data_list: the table row data that this function writes into
         :param element: The introspection element that represent the char element. This element holds a lot of valuable
                         information about the element
         :return: None
         """
         self.logger.debug(f"Handling {element.name}")
         row_data_list[ColumnNumbersEnum.TYPE_COLUMN_NUM] += \
             f"<{str((SingleChapterGenerator.get_sequence_or_string_length_value(element.length)))}>"
 
-        self.document.add_table_row(self.current_table, row_data_list)
+        new_son_comp_element = CompElement(element)
+        father_comp_element.sons_list.append(new_son_comp_element)
+        new_son_comp_element.add_data_to_comp_element(row_data_list)
+
+        # create_doc_from_structured_doc_data
 
-    def handle_enum_element(self, element, row_data_list):
+    def handle_enum_element(self, element, row_data_list, father_comp_element):
         """
         Adds A number (either 0 or a random number, depends on the 'is_random' parameter)
         into the given local_dict. A string is used because this is for the JSON form of injecting messages.
         :param element: The introspection element that represent the enum element.
         :param row_data_list: the table row data that this function writes into
         :return:
         """
         self.logger.debug(f"Handling {element.name}")
-        self.write_special_data_of_enumeration(element, row_data_list)
-        self.document.add_table_row(self.current_table, row_data_list)
+
+
+        new_son_comp_element = CompElement(element)
+        # Adding user comment BEFORE enum data is added
+        new_son_comp_element.user_comment = row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM]
+        father_comp_element.sons_list.append(new_son_comp_element)
+
+        self.write_special_data_of_enumeration(element, row_data_list, new_son_comp_element)
+        new_son_comp_element.add_data_to_comp_element(row_data_list)
+        # create_doc_from_structured_doc_data
 
     def write_special_data_of_collection(self, element, row_data_list):
         """"
         This function adds the data special to collection type elements (arrays and sequences) to the
         row_data_list which will be inserted to the ICD.
         Param: element - The current element from the introspection
         :param element: The introspection element that represent the enum element.
@@ -539,34 +569,40 @@
 
         if element.contentTypeKindName not in self.basic_types:
             type_column_text += \
                 f" of {self.type_rename_dictionary.get(element.contentTypeKindName, element.contentTypeKindName)}"
 
         row_data_list[ColumnNumbersEnum.TYPE_COLUMN_NUM] = type_column_text
 
-    def handle_struct_element(self, element, row_data_list, real_level, is_key_allowed):
+    def handle_struct_element(self, element, row_data_list, real_level, is_key_allowed, father_comp_element):
         """
 
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
                             maintains the true level trough out the recursive operation.
         :param element: The introspection element that represent the struct element.
         :param row_data_list: the table row data that this function writes into
         :param is_key_allowed: Specifies whether the elements at higher levels (directly above this one) have
                                'key' notation in them.
         :return: None
         """
         self.logger.debug(f"Handling {element.name}")
 
-        self.document.add_table_row(self.current_table, row_data_list)
-        self.recursive_type_introspect(element.dataTypeName, real_level - 1, is_key_allowed)  # See explanation below:
-        # we send rel_level-1 because levels start at 1 and  we calculate real_level + element.level.  Since
+
+        new_son_comp_element = CompElement(element)
+        father_comp_element.sons_list.append(new_son_comp_element)
+        new_son_comp_element.add_data_to_comp_element(row_data_list)
+
+        # create_doc_from_structured_doc_data# See explanation below:
+        # We're about to send rel_level-1 because levels start at 1 and  we calculate real_level + element.level.  Since
         # level 1 of the next introspection is the current real level, then the real level would be increased
         # for no  reason.
+        self.recursive_type_introspect(element.dataTypeName, real_level - 1, is_key_allowed, new_son_comp_element)
 
-    def handle_collection_element(self, element_index, element_list, row_data_list, real_level, is_key_allowed):
+    def handle_collection_element(
+            self, element_index, element_list, row_data_list, real_level, is_key_allowed, father_comp_element):
         """
         This function is called when the current element is a collection element, i.e. array/sequence.
         :param element_index: Index of current element
         :param element_list: The list of elements (the product of introspection structure)
         :param row_data_list: The table row data
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
                             maintains the true level trough out the recursive operation.
@@ -575,37 +611,48 @@
         :return: None
         """
         self.logger.debug(self.handle_collection_element.__name__)
         element = element_list[element_index]
         self.write_special_data_of_collection(element, row_data_list)
         #
         if element.contentTypeKindName in self.string_types:
+
+            new_son_comp_element = CompElement(element)
+            new_son_comp_element.add_data_to_comp_element(row_data_list)
+            father_comp_element.sons_list.append(new_son_comp_element)
+
             # Add the current line:
-            self.document.add_table_row(self.current_table, row_data_list)
+            # create_doc_from_structured_doc_data
             # Then add a line for the string element
             row_data_list = self.create_row_data_list(element_list[element_index + 1], real_level + 1, is_key_allowed)
-            self.handle_string_element(element_list[element_index + 1], row_data_list)
+            self.handle_string_element(element_list[element_index + 1], row_data_list, new_son_comp_element)
         #
         elif element.contentTypeKindName == 'ENUMERATION':
-            self.handle_enum_element(element_list[element_index + 1], row_data_list)
+            self.handle_enum_element(element_list[element_index + 1], row_data_list, father_comp_element)
 
         elif element.contentTypeKindName == 'UNION':
-            self.handle_union_element(element_index + 1, element_list, row_data_list, real_level, is_key_allowed)
+            self.handle_union_element(element_index + 1, element_list, row_data_list, real_level, is_key_allowed, father_comp_element)
 
         elif element.contentTypeKindName == 'STRUCTURE':
-               self.handle_struct_element(element_list[element_index + 1], row_data_list, real_level, is_key_allowed)
+               self.handle_struct_element(element_list[element_index + 1], row_data_list, real_level, is_key_allowed, father_comp_element)
 
         # If the element's content is none of the above, it is either a primitive or a collection;
         # In both cases the table row need to be added here
         else:
-            self.document.add_table_row(self.current_table, row_data_list)
+            new_son_comp_element = CompElement(element)
+            new_son_comp_element.add_data_to_comp_element(row_data_list)
+            father_comp_element.sons_list.append(new_son_comp_element)
+
+            # create_doc_from_structured_doc_data
+            # Make
+            father_comp_element = new_son_comp_element
 
         
         if element.contentTypeKindName == 'ARRAY' or element.contentTypeKindName == 'SEQUENCE':
-            self.handle_element_types(element_index + 1, element_list, real_level + 1, is_key_allowed)
+            self.handle_element_types(element_index + 1, element_list, real_level + 1, is_key_allowed, father_comp_element)
 
 
         # else:
         #     self.logger.debug(f"Unsorted ARR: {element.name}")
 
     def create_row_data_list_for_union_option_row(self, real_level):
         """
@@ -613,15 +660,15 @@
         union option it is) needs to be added. This function creates the relevant row data
         :param real_level: The true level of the element. Since we do recursive introspection, this is the parameter
                            that maintains the true level trough out the recursive operation.
         :return:
         """
         self.logger.debug(self.create_row_data_list_for_union_option_row.__name__)
         hierarchy: str = self.generate_hierarchy_notation(real_level) + "(D)"
-        field: str = "Discriminator = "
+        field: str = "discriminator = "
         type_notation: str = "-"
         description_and_metadata = ""
 
         return [hierarchy, field, type_notation, description_and_metadata]
 
     def map_enum_members_vector_to_enum_value_vs_index(self) -> Dict[int, str]:
         """
@@ -635,27 +682,34 @@
         if self.current_union_enum_vector is not None:
             for i in range(len(self.current_union_enum_vector)):
                 names_vs_index_of_enumMembers_vector[self.current_union_enum_vector[i].value] = \
                     self.current_union_enum_vector[i].name
 
         return names_vs_index_of_enumMembers_vector
 
-    def add_extra_row_for_union_option_element(self, element, real_level):
+
+    def add_extra_row_for_union_option_element(self, element, real_level, father_comp_element):
         """
         The current ICD format does not describe which union option the current element belongs to. For that reason,
         this function creates an additional table row to display the union option this element belongs to.
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
                             maintains the true level trough out the recursive operation.
         :param element: The introspection element that represent the struct element.
         :return:
         """
         self.logger.debug(self.add_extra_row_for_union_option_element.__name__)
+
+        # Not adding an element here: this is a ghost table row created for the user to understand more about the union.
+        new_son = CompElement()
+        father_comp_element.sons_list.append(new_son)
+
         # Creating custom row_data for this row
         row_data_list = self.create_row_data_list_for_union_option_row(real_level)
 
+
         # Create a list to help us make sure there are no duplicate descriptions.
         description_list = []
         # Map the current_union_enum_vector to name vs index
         enum_member_map = self.map_enum_members_vector_to_enum_value_vs_index()
         # Add the union labels to the "field" column:
         i = 0
         for union_label in element.unionLabels:
@@ -680,58 +734,70 @@
             else:
                 row_data_list[ColumnNumbersEnum.FIELD_COLUMN_NUM] += str(union_label)
             # At any case, add the description here:
             row_data_list[ColumnNumbersEnum.DESCRIPTION_COLUMN_NUM] += description
 
             i = i + 1
 
+        #TODO TEST!!!!!
+        new_son.add_data_to_comp_element(row_data_list)
+
         # Finally - add the extra row to the document
-        self.document.add_table_row(self.current_table, row_data_list)
+        # create_doc_from_structured_doc_data
 
-    def handle_discriminator_element(self, element, real_level):
+    def handle_discriminator_element(self, element, real_level, father_comp_element):
         """
         This function creates and adds the discriminator table row.
         :param element: The introspection element that represent the discriminator element.
         :param real_level: The true level of the discriminator. Since we do recursive introspection, this is the
                             parameter that maintains the true level trough out the recursive operation.
         :return: None
         """
         self.logger.debug(self.handle_discriminator_element.__name__)
         row_data_list = self.create_row_data_list(element, real_level, False)
 
-        self.write_union_enumeration_of_discriminator(element, row_data_list)
+        new_son_comp_element = CompElement(element, is_discriminator=True)
+        father_comp_element.sons_list.append(new_son_comp_element)
+
+        self.write_union_enumeration_of_discriminator(element, row_data_list, new_son_comp_element)
 
         self.union_label_to_userComment_dictionary = \
             self.create_union_label_to_user_comment_dictionary(element.unionMembersInfo)
 
         if element.typeKindName == "ENUMERATION":
             self.current_union_enum_vector = element.enumMembers
         else:
             self.current_union_enum_vector = None
 
-        self.document.add_table_row(self.current_table, row_data_list)
+        # create_doc_from_structured_doc_data
 
-    def handle_union_element(self, element_index, element_list, row_data_list, real_level, is_key_allowed):
+    def handle_union_element(
+            self, element_index, element_list, row_data_list, real_level, is_key_allowed, father_comp_element):
         """
         This function handles the case wherer the current element is a union element.
         :param element_index: Index of current element
         :param element_list: The list of elements (the product of introspection structure)
         :param row_data_list: The table row data
         :param real_level: The true level of the type. Since we do recursive introspection, this is the parameter that
                             maintains the true level trough out the recursive operation.
         :param is_key_allowed: Specifies whether the elements at higher levels (directly above this one) have
                                'key' notation in them.
         :return: None
         """
-        self.logger.debug(self.handle_discriminator_element.__name__)
+        self.logger.debug(self.handle_union_element.__name__)
         element = element_list[element_index]
         self.logger.debug(f"Handling {element.name}")
-        self.document.add_table_row(self.current_table, row_data_list)
+
+        new_son_comp_element = CompElement(element)
+        father_comp_element.sons_list.append(new_son_comp_element)
+        new_son_comp_element.add_data_to_comp_element(row_data_list)
+
+        # create_doc_from_structured_doc_data
         # Handle the discriminator row:
-        self.handle_discriminator_element(element_list[element_index + 1], real_level + 1)
+        self.handle_discriminator_element(element_list[element_index + 1], real_level + 1, new_son_comp_element)
 
-        self.recursive_type_introspect(element.dataTypeName, real_level - 1, is_key_allowed)  # See explanation below:
+        self.recursive_type_introspect(element.dataTypeName, real_level - 1, is_key_allowed, new_son_comp_element)  # See explanation below:
         # we send rel_level-1 because levels start at 1 and  we calculate real_level + element.level.  Since
         # level 1 of the next introspection is the current real level, then the real level would be increased
         # for no  reason.
 
         self.union_label_to_userComment_dictionary.clear()
```

## Omnicon_DDSDocGen/Template.docx

### docx2txt

```diff
@@ -1,11 +1,14 @@
 Delete this page 
 Version v1.0
 Subtitle
 Example Heading 1
+Example Heading 2	
+
+Example bold underline 14 Style: Example bold_14
 
 Example
 
 
 
 
 
@@ -23,9 +26,13 @@
 
 
 
 
 
 
 Normal styling.
+Example Heading 2
+
+ Bullet 1	
+Emmpty bullet 2
```

## Omnicon_DDSDocGen/__init__.py

```diff
@@ -3,13 +3,18 @@
 import sys
 from .Omnicon_DDSDocGen import *
 
 sys.path.append(os.path.dirname(os.path.realpath(__file__)))
 from Omnicon_DDSDocGen import Logger
 from Omnicon_DDSDocGen import Utils
 from Omnicon_DDSDocGen import DocGenLogic
+from Omnicon_DDSDocGen import GeneralFunctions
+from Omnicon_DDSDocGen import DocumentHandler
+from Omnicon_DDSDocGen import DocCompareLogic
 from Omnicon_DDSDocGen.DocGenInterface import DocGenInterface
 from Omnicon_DDSDocGen import SingleChapterGenerator
 from Omnicon_DDSDocGen import PdfGen
 from Omnicon_DDSDocGen import DocxGen
 from Omnicon_DDSDocGen import DocGenInterface
 from Omnicon_DDSDocGen import ErrorListHandler
+from Omnicon_DDSDocGen import SharedEnums
+from Omnicon_DDSDocGen import ComparisonModule
```

## Comparing `Omnicon_DDSDocGen-2.2.1.dist-info/RECORD` & `Omnicon_DDSDocGen-3.0.1.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,24 @@
-Omnicon_DDSDocGen/DocGenInterface.py,sha256=xoSvfv3Qu2pRtKGUJduuBAw07qqLP8Tf8sVYU8oxs0Y,2039
-Omnicon_DDSDocGen/DocGenLogic.py,sha256=6S5BsldvCiUZQShfedq64BjgCgY9-e0RfKJvTIBW4KA,35135
-Omnicon_DDSDocGen/DocxGen.py,sha256=GIdv9jRilyd1vNaTh19CixO6_eIfHinLW8BYXXDJFNE,10756
+Omnicon_DDSDocGen/ComparisonModule.py,sha256=cmxAn5FQn1UMdZYu8S8ZBbVu452-d8rP5AZJPf0v57g,24884
+Omnicon_DDSDocGen/DocCompareLogic.py,sha256=8tawG6Divl3kLMajxwmn2Q6qRzvcDoUtnAGg-FmYRVU,32791
+Omnicon_DDSDocGen/DocGenInterface.py,sha256=Dh1kBNHr9yhYFeN2gVQOEDJfZDnUyI3qoRdfkont130,2820
+Omnicon_DDSDocGen/DocGenLogic.py,sha256=5CAcJVyYC5qomtEGlGieqN8ZZQs6UANAmV4zMI8S8zY,36214
+Omnicon_DDSDocGen/DocumentHandler.py,sha256=WaqwoVUU1DUd49hd5fSbHVucOLoucDrlDqreZUVFlkI,10861
+Omnicon_DDSDocGen/DocxGen.py,sha256=A099CaSZ2PaApDxDU-reftJLq6oah-eRx4kLDRbypBA,21497
 Omnicon_DDSDocGen/ErrorListHandler.py,sha256=1cOO2UOBmURPBUSvIqNYYMsPeReFtZXOqt1gk5MFwEs,884
+Omnicon_DDSDocGen/GeneralFunctions.py,sha256=rcwopXFfQOOKXNO6XItTL0I5ZNgkkKGPot_WJsIecKk,11500
 Omnicon_DDSDocGen/LatexGen.py,sha256=wqO62A1pK8-CXZox201ddZPQXplwS1hX0Q3ljp2w1As,12992
-Omnicon_DDSDocGen/Logger.py,sha256=mxd7uJEn_A-gmqbjcdEmn-YSmGzN4ebQsAUv6rDhbcU,3707
-Omnicon_DDSDocGen/Omnicon_DDSDocGen.py,sha256=8EENwWPSX3b_1pBCvWUrDNNg4eYiOdhAzzAbheh1ycA,3628
-Omnicon_DDSDocGen/PdfGen.py,sha256=uSAA1ZoXCypNr4PZt-XaQQttopFCaKJDnkF9oX-k_Wk,1581
-Omnicon_DDSDocGen/SingleChapterGenerator.py,sha256=f4_aE11WRtHZowFNV_On1uT-V-mXOSRN0bW_4fwdb1E,38422
-Omnicon_DDSDocGen/Template.docx,sha256=-8AyVDLVArS6ihcf5eW0p21aF5QZ5DuSjouGsb1Lu9E,21970
+Omnicon_DDSDocGen/Logger.py,sha256=mBF6wCAzkQ8AX-nb3e1Ak9sUi1RMwgSqjLqhDe0qYxM,4473
+Omnicon_DDSDocGen/OmniconEngineHandler.py,sha256=mwdU3XF3CG2lkZLS5kr-kQIWNlAgGXKVDbYXKni7IlQ,2420
+Omnicon_DDSDocGen/Omnicon_DDSDocGen.py,sha256=hsHi51upfbQN9gQGgtQlMZZWS2jK6aFW8HMmaS4tMrM,9370
+Omnicon_DDSDocGen/PdfGen.py,sha256=PNSKAY63rUvSW8AQ4I6FmZSGeIJOzeUSB1Ygg8M79Nw,3236
+Omnicon_DDSDocGen/SharedEnums.py,sha256=kQgAjuyiAxj2KPKDu9mSbZELxyG528FSROAUr4rFMFk,819
+Omnicon_DDSDocGen/SingleChapterGenerator.py,sha256=2euy4WAMpESG7lXj-gEOC9dwKOgWMMfeSiPnRqGqFC4,41882
+Omnicon_DDSDocGen/Template.docx,sha256=GAilFz59H52x_hWsGWE0LQibjpkik5692Bz3uNZS0lg,23764
 Omnicon_DDSDocGen/Utils.py,sha256=O7Uq8Nw6GZ1oopXnezATL2IYVLY-PRO4csdgCVTsH4I,636
-Omnicon_DDSDocGen/__init__.py,sha256=lTBdtMUD01scXcIuz0_gRdxKQvXGzPKg9cvLi5XmV6g,574
-Omnicon_DDSDocGen-2.2.1.dist-info/METADATA,sha256=JPLWUyLzllJ7JHUKQuKRXc3IxeU-yHLXWRK-LiVuewI,7437
-Omnicon_DDSDocGen-2.2.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-Omnicon_DDSDocGen-2.2.1.dist-info/top_level.txt,sha256=N_T3f3SrPcjZY7yTpuuUAzmhBoNgEvwOuwqKxGZFXEI,18
-Omnicon_DDSDocGen-2.2.1.dist-info/RECORD,,
+Omnicon_DDSDocGen/__init__.py,sha256=_EjedQVl_0sIgkxdNIrtn_d-rqwdoGOUFoUOrhq2Ot8,807
+Omnicon_DDSDocGen/comp.py,sha256=H6JjTV-Z6eMDXJaJVpJV9xvVvkkUhkNB8UWT6G2H_-U,4164
+Omnicon_DDSDocGen-3.0.1.dist-info/LICENSE,sha256=XSIwLWa6oB7ZrV1lbbzYgj5AAYxve0v6oGjWdGkvvRw,1148
+Omnicon_DDSDocGen-3.0.1.dist-info/METADATA,sha256=L_EGgP1ldsKXxeO96DrAsJs4K6MwZTATTLJQdobN_bc,14839
+Omnicon_DDSDocGen-3.0.1.dist-info/WHEEL,sha256=5sUXSg9e4bi7lTLOHcm6QEYwO5TIF1TNbTSVFVjcJcc,92
+Omnicon_DDSDocGen-3.0.1.dist-info/top_level.txt,sha256=N_T3f3SrPcjZY7yTpuuUAzmhBoNgEvwOuwqKxGZFXEI,18
+Omnicon_DDSDocGen-3.0.1.dist-info/RECORD,,
```

